<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2023/01/07/%E5%9B%BE/"/>
    <url>/2023/01/07/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>边和边之间关系通过矩阵数组来保存关系</p><ul><li>邻接矩阵适合稠密图(复杂的顶点关系)</li><li>邻接矩阵可以O（1）判断顶点的连接关系</li><li>不适合查看一个顶点连接的所有边O(N)</li></ul><blockquote><p>A,B之间相连所以matrix[A][B]&#x3D;1</p></blockquote><p><img src="https://img-blog.csdnimg.cn/88d2d8b0862a4bff8617a3671423a26c.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">W</span>, W MAX_W = INT32_MAX, <span class="hljs-type">bool</span> Direct = <span class="hljs-literal">false</span>&gt;<br>    <span class="hljs-keyword">class</span> Graph<br>    &#123;<br>        <span class="hljs-keyword">typedef</span> Graph&lt;V, W, MAX_W, Direct&gt; Self;<br><br>    <span class="hljs-keyword">private</span>:<br>        vector&lt;V&gt; _vertex;         <span class="hljs-comment">// 保存顶点</span><br>        map&lt;V, <span class="hljs-type">int</span>&gt; _indexmap;     <span class="hljs-comment">// 顶点映射下标的关系</span><br>        vector&lt;vector&lt;W&gt;&gt; _matrix; <span class="hljs-comment">// 邻接矩阵来保存边的数据，邻接矩阵适合稠密的关系图</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 图的创建</span><br>        <span class="hljs-comment">// 1.IO输入</span><br>        <span class="hljs-comment">// 2.图结构写到文件中</span><br>        <span class="hljs-comment">// 3. 手动添加边</span><br>        <span class="hljs-built_in">Graph</span>() = <span class="hljs-keyword">default</span>;<br>        <span class="hljs-built_in">Graph</span>(<span class="hljs-type">const</span> V *a, <span class="hljs-type">size_t</span> n)<br>        &#123;<br>            _vertex.<span class="hljs-built_in">reserve</span>(n);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            &#123;<br>                _vertex.<span class="hljs-built_in">push_back</span>(a[i]);<br>                _indexmap[a[i]] = i;<br>            &#125;<br>            _matrix.<span class="hljs-built_in">resize</span>(n);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            &#123;<br>                _matrix[i].<span class="hljs-built_in">resize</span>(n, MAX_W);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 获得顶点的下标</span><br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetVertexIndex</span><span class="hljs-params">(<span class="hljs-type">const</span> V &amp;v)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">auto</span> it = _indexmap.<span class="hljs-built_in">find</span>(v);<br>            <span class="hljs-keyword">if</span> (it != _indexmap.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> it-&gt;second;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 防止编译器的优化</span><br>            &#125;<br>        &#125;<br>               <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> V &amp;src, <span class="hljs-type">const</span> V &amp;dst, <span class="hljs-type">const</span> W &amp;w)</span> <span class="hljs-comment">// 添加边</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">// 添加边</span><br>            <span class="hljs-type">size_t</span> srci = <span class="hljs-built_in">GetVertexIndex</span>(src);<br>            <span class="hljs-type">size_t</span> dsti = <span class="hljs-built_in">GetVertexIndex</span>(dst);<br><br>            _matrix[srci][dsti] = w;<br>            <span class="hljs-keyword">if</span> (Direct == <span class="hljs-literal">false</span>)<br>            &#123;<br>                <span class="hljs-comment">// 无相图，两边都要添加</span><br>                _matrix[dsti][srci] = w;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表：使用数组表示顶点的集合，使用链表来表示边的关系<br>类似<code>hashtable</code></p><ol><li>适合稀疏的图（顶点之间关系比较简单）</li><li>方便查找一个节点的所有边</li><li>不适合判断两个节点之间是否相连</li></ol><p><img src="https://img-blog.csdnimg.cn/5e30fb75161446ca91bb1c6ebcd6957d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/69f47257906f46159a16aa6b1ce22798.jpg" alt="在这里插入图片描述"></p><blockquote><p>添加边关系：通过src顶点找到对应的数组，进行<code>头插元素</code>来进行<code>添加边</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">W</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    W _w;<br>    <span class="hljs-type">int</span> _dsti; <span class="hljs-comment">// 目标点连接的下标</span><br>    Edge&lt;W&gt; *_next;<br><br>    <span class="hljs-built_in">Edge</span>(W w, <span class="hljs-type">int</span> dsti)<br>        : _w(w), _dsti(dsti), _next(<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">W</span>, <span class="hljs-type">bool</span> Direct = <span class="hljs-literal">false</span>&gt;<br><span class="hljs-keyword">class</span> Graph<br>&#123;<br>    <span class="hljs-keyword">typedef</span> Table::Edge&lt;W&gt; Edge;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;V&gt; _vertex;     <span class="hljs-comment">// 保存顶点</span><br>    map&lt;V, <span class="hljs-type">int</span>&gt; _indexmap; <span class="hljs-comment">// 顶点映射下标的关系</span><br>    vector&lt;Edge *&gt; _table; <span class="hljs-comment">// 邻接表来保存边的数据，邻接矩阵适合稀疏的关系图,类似哈希</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 图的创建</span><br>    <span class="hljs-comment">// 1.IO输入</span><br>    <span class="hljs-comment">// 2.图结构写到文件中</span><br>    <span class="hljs-comment">// 3. 手动添加边</span><br>    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">const</span> V *a, <span class="hljs-type">size_t</span> n)<br>    &#123;<br>        _vertex.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            _vertex.<span class="hljs-built_in">push_back</span>(a[i]);<br>            _indexmap[a[i]] = i;<br>        &#125;<br><br>        _table.<span class="hljs-built_in">resize</span>(n, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-comment">// 获得顶点的下标</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetVertexIndex</span><span class="hljs-params">(<span class="hljs-type">const</span> V &amp;v)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = _indexmap.<span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">if</span> (it != _indexmap.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> it-&gt;second;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;顶点不存在&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 防止编译器的优化</span><br>        &#125;<br>    &#125;<br>            <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> V &amp;src, <span class="hljs-type">const</span> V &amp;dst, <span class="hljs-type">const</span> W &amp;w)</span> <span class="hljs-comment">// 添加边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 添加边</span><br>        <span class="hljs-type">size_t</span> srci = <span class="hljs-built_in">GetVertexIndex</span>(src);<br>        <span class="hljs-type">size_t</span> dsti = <span class="hljs-built_in">GetVertexIndex</span>(dst);<br>        Edge *eg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Edge</span>(w, dsti); <span class="hljs-comment">// 头插</span><br>        eg-&gt;_next = _table[srci];<br>        _table[srci] = eg;<br>        <span class="hljs-comment">// 如果是一个无相图</span><br>        <span class="hljs-keyword">if</span> (Direct == <span class="hljs-literal">false</span>)<br>        &#123;<br>            Edge *eg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Edge</span>(w, srci); <span class="hljs-comment">// 头插</span><br>            eg-&gt;_next = _table[dsti];<br>            _table[dsti] = eg;<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><blockquote><p>DFS:深度优先搜索：先往深处遍历，深处遍历完了再回溯，查看上层未边俩的元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b38319a780054ca3aeb20991bfd6b55a.png" alt="在这里插入图片描述"></p><blockquote><p>使用一个<code>visited</code>数组,来标记元素访问与否,用递归来进行遍历</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> _DFS(<span class="hljs-type">size_t</span> srci, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visited)<br>&#123;<br>    visited[srci] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; srci &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; _vertex[srci] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _vertex.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_matrix[srci][i] != MAX_W &amp;&amp; visited[i] == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-comment">// 没有被访问过</span><br>            _DFS(i, visited);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">const</span> V &amp;src)</span> <span class="hljs-comment">// 深度遍历，</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> srci = <span class="hljs-built_in">GetVertexIndex</span>(src);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(_vertex.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    _DFS(srci, visited);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><blockquote><p>BFS：广度优先搜索，一层一层的遍历元素,直到遍历到最后一层的元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/e7b100c60d254ef384d887aeff7a59aa.png" alt=" "></p><p><strong>思路</strong></p><blockquote><p>使用一个<strong>队列</strong>和一个<strong>visited数组</strong>,元素入队列的时候，标记他对应的visited数组&#x3D;true，元素出队列的时候，代入他连接的未入队列的所有节点,直到队列为空，遍历结束</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 确认两个点是否相连</span><br><span class="hljs-comment">// 遍历都是遍历顶点而不是遍历边</span><br><span class="hljs-comment">// 图的遍历，深搜：优先往深走</span><br><span class="hljs-comment">//         广搜：类似层序遍历</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">const</span> V &amp;src)</span> <span class="hljs-comment">// 深度优先搜索</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> srci = <span class="hljs-built_in">GetVertexIndex</span>(src);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 队列进行搜索</span><br>    q.<span class="hljs-built_in">push</span>(srci);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(_vertex.size(), <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 标记数组，入队列的时候就进行标记</span><br>    visited[srci] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> levelsize = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; levelsize; i++) <span class="hljs-comment">// 控制层序遍历</span><br>        &#123;<br>            <span class="hljs-type">int</span> front = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 获得对头的所有的链接的元素</span><br>            cout &lt;&lt; front &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; _vertex[front] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _vertex.<span class="hljs-built_in">size</span>(); i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (_matrix[front][i] != MAX_W)<br>                &#123;<br>                    <span class="hljs-comment">// 入队列</span><br>                    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 没被访问过，就要入队列</span><br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// 检查是否被标记了</span><br>                        visited[i] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        levelsize = q.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>构成最小生成树的原则</p><ol><li>只能使用图中的边来构成最小生成树</li><li>只能使用n-1条边来连接图中的n个顶点</li><li>选用的n-1边不能构成回路</li></ol><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><blockquote><p>全局贪心的方法，每次在全局查找最小的边，同时判断这个边连接的两个顶点是否会形成环，如果不会形成环，就添加到最小生成树中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">size_t</span> _srci;<br>    <span class="hljs-type">size_t</span> _dsti;<br>    W _w;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">size_t</span> srci, <span class="hljs-type">size_t</span> dsti, W w)<br>        : _srci(srci), _dsti(dsti), _w(w)<br>    &#123;<br>    &#125;<br>    <span class="hljs-comment">// 我们要重新弄一下比较函数</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Edge &amp;e) <span class="hljs-type">const</span> <span class="hljs-comment">// 重载一下&gt;函数</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> _w &gt; e._w;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Kruskal 是每次都选出最小的边，然后保证选出的边不会成环即可，在全局选择最小</span><br><span class="hljs-function">W <span class="hljs-title">Kruskal</span><span class="hljs-params">(Self &amp;mintree)</span> <span class="hljs-comment">// 计算最小生成树</span></span><br><span class="hljs-function"></span>&#123;<br>    mintree._vertex = _vertex;<br>    mintree._indexmap = _indexmap;<br>    mintree._matrix.<span class="hljs-built_in">resize</span>(_vertex.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _vertex.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        mintree._matrix[i].<span class="hljs-built_in">resize</span>(_vertex.<span class="hljs-built_in">size</span>(), MAX_W);<br>    &#125;<br><br>    priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq; <span class="hljs-comment">// 建立一个小堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _vertex.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; _vertex.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; _matrix[i][j] != MAX_W) <span class="hljs-comment">// 无相图，只要走一半即可</span><br>            &#123;<br>                <span class="hljs-comment">// 合法</span><br>                <span class="hljs-function">Edge <span class="hljs-title">e</span><span class="hljs-params">(i, j, _matrix[i][j])</span></span>;<br>                pq.<span class="hljs-built_in">push</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 依次选出最小的边，然后依次添加就可以了</span><br>    <span class="hljs-comment">// n个顶点，选出n-1条边</span><br>    W total = <span class="hljs-built_in">W</span>();<br>    <span class="hljs-type">int</span> n = _vertex.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">ufs2::UnionFindSet <span class="hljs-title">ufs</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 使用并查集来判断选中的点是否形成了一个环路</span><br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        Edge min = pq.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 最顶部的就是最小的边</span><br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (!ufs.<span class="hljs-built_in">Inset</span>(min._dsti, min._srci))<br>        &#123;<br>            <span class="hljs-comment">// 这两个点不在一个集合，说明这两个点可以添加，连接起来</span><br>            cout &lt;&lt; _vertex[min._dsti] &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _vertex[min._srci] &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; min._w &lt;&lt; endl;<br>            mintree.<span class="hljs-built_in">AddEdge</span>(_vertex[min._srci], _vertex[min._dsti], min._w);<br>            ufs.<span class="hljs-built_in">Union</span>(min._dsti, min._srci);<br>            ++size;<br>            total += min._w;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (size == n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 成功选出了n-1条边</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 可能出现走完没有选出的情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">W</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><blockquote><p>局部贪心的方法，通过已经进入最小生成树的顶点和未进入最小生成树的顶点中，查找最小的边</p></blockquote><blockquote><p>通过优先级队列来记录所有已经进入树中延伸出去的所有边，每次查找里面最小的边，找到了判断是否已经在树中，如果已经在了，说明成环了，就继续，没有成环就添加入树中，同时把该顶点未添加到树中的所有边添加入队列中，进行下一次遍历</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Prim算法计算最小生成树算法</span><br> <span class="hljs-comment">// 在已经连接点的集合和未连接点的集合中选出最小的边顶点，</span><br> <span class="hljs-comment">// 局部贪心</span><br> <span class="hljs-function">W <span class="hljs-title">Prim</span><span class="hljs-params">(Self &amp;mintree, <span class="hljs-type">const</span> V &amp;src)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">int</span> n = _vertex.<span class="hljs-built_in">size</span>();<br>     <span class="hljs-type">int</span> srci = <span class="hljs-built_in">GetVertexIndex</span>(src);<br>     mintree._vertex = _vertex;<br>     mintree._indexmap = _indexmap;<br>     mintree._matrix.<span class="hljs-built_in">resize</span>(_vertex.<span class="hljs-built_in">size</span>());<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _vertex.<span class="hljs-built_in">size</span>(); i++)<br>     &#123;<br>         mintree._matrix[i].<span class="hljs-built_in">resize</span>(_vertex.<span class="hljs-built_in">size</span>(), MAX_W);<br>     &#125;<br>     <span class="hljs-comment">//</span><br>     <span class="hljs-comment">// set&lt;int&gt; X; // 两个集合</span><br>     <span class="hljs-comment">// set&lt;int&gt; Y;</span><br>     <span class="hljs-comment">// X.insert(srci); // 先存进去一个起点</span><br>     <span class="hljs-comment">// for (size_t i = 0; i &lt; n; i++)</span><br>     <span class="hljs-comment">// &#123;</span><br>     <span class="hljs-comment">//     if (i != srci)</span><br>     <span class="hljs-comment">//     &#123;</span><br>     <span class="hljs-comment">//         Y.insert(i); // Y集合不存起点</span><br>     <span class="hljs-comment">//     &#125;</span><br>     <span class="hljs-comment">// &#125;</span><br><br>     <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">X</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>     <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Y</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>;<br>     X[srci] = <span class="hljs-literal">true</span>;<br>     Y[srci] = <span class="hljs-literal">false</span>;<br><br>     <span class="hljs-comment">// 从X到Y集合中，连接的边选出最小的边</span><br>     priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; minq; <span class="hljs-comment">// 选出最小边</span><br>     <span class="hljs-comment">// 先把srci连接的边添加到队列中</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (_matrix[srci][i] != MAX_W)<br>         &#123;<br>             <span class="hljs-comment">// 合法的边</span><br>             minq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Edge</span>(srci, i, _matrix[srci][i]));<br>         &#125;<br>     &#125;<br>     <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>     W total = <span class="hljs-built_in">W</span>();<br>     <span class="hljs-keyword">while</span> (!minq.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         Edge min = minq.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 选出最小的边</span><br>         minq.<span class="hljs-built_in">pop</span>();<br>         <span class="hljs-keyword">if</span> (X[min._dsti]) <span class="hljs-comment">// 如果选出的边都在X集合，或者都在Y集合就成环了</span><br>         &#123;<br>             <span class="hljs-comment">// 都为true，说明就成环了，起点一定是在X集合中的</span><br>             <span class="hljs-comment">// 成环了</span><br>             <span class="hljs-keyword">continue</span>;<br>         &#125;<br>         mintree.<span class="hljs-built_in">AddEdge</span>(_vertex[min._srci], _vertex[min._dsti], min._w);<br>         <span class="hljs-comment">// X.insert(min._dsti); // X集合添加一个元素</span><br>         <span class="hljs-comment">// Y.erase(min._dsti);  // Y集合减少这个元素</span><br>         X[min._dsti] = <span class="hljs-literal">true</span>;<br>         Y[min._dsti] = <span class="hljs-literal">false</span>;<br>         size++;<br>         total += min._w;<br>         <span class="hljs-keyword">if</span> (size == n - <span class="hljs-number">1</span>)<br>         &#123;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>         <span class="hljs-comment">// 把新添加进来的所有边都过一遍，</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (_matrix[min._dsti][i] != MAX_W &amp;&amp; Y[i]) <span class="hljs-comment">// 新添加到队列里面，要保证添加的点并不已经在集合中了</span><br>             &#123;<br>                 <span class="hljs-comment">// 目标点要在Y集合</span><br>                 <span class="hljs-comment">//  合法的边</span><br>                 minq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Edge</span>(min._dsti, i, _matrix[min._dsti][i]));<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (size == n - <span class="hljs-number">1</span>)<br>     &#123;<br>         <span class="hljs-comment">// 成功选出了n-1条边</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-keyword">return</span> total;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>         <span class="hljs-comment">// 可能出现走完没有选出的情况</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">W</span>();<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><blockquote><p>在带权有相图G中的某个顶点出发，找到通往另一个顶点的最短路径，最短也就是路径的权值总和最短</p></blockquote><h2 id="Djkstra"><a href="#Djkstra" class="headerlink" title="Djkstra"></a>Djkstra</h2><p>单源最短路径:一个源顶点到每个顶点之间的最短路径</p><blockquote><p>如源顶点为S，图中的顶点有A，B，C，D<br>计算S-D,S-B,S-A,S-C这些路径的最短路径</p></blockquote><blockquote><p>使用一个dist数组来记录最小路径，ppath来记录自己的父亲是谁<br>从一个已经确定最小路径进行查找他延伸出去的边，进行更性这些顶点的路径最小值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 打印最短路径的算法</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">const</span> V &amp;src, vector&lt;W&gt; &amp;dist, vector&lt;<span class="hljs-type">int</span>&gt; &amp;pPath)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-type">size_t</span> srci = <span class="hljs-built_in">GetVertexIndex</span>(src);<br>     <span class="hljs-type">size_t</span> n = _vertex.<span class="hljs-built_in">size</span>();<br>     dist.<span class="hljs-built_in">resize</span>(n, MAX_W); <span class="hljs-comment">// 一开始这个距离就初始化给一个最大值</span><br>     pPath.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">-1</span>);   <span class="hljs-comment">// 父路径</span><br><br>     <span class="hljs-comment">// 自己到自己的距离就设置为0即可</span><br>     dist[srci] = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// 自己的父亲路径就是自己</span><br>     pPath[srci] = srci;<br>     <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 已经确定最短路径的顶点集合</span><br><br>     <span class="hljs-comment">// 如果所有的点都被更新一遍了，就结束了,需要更新n次</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>     &#123;<br>         <span class="hljs-comment">// 去选最短路径的顶点来进行更新</span><br>         <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>         W min = MAX_W; <span class="hljs-comment">// 最小的权值</span><br><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-literal">false</span> &amp;&amp; dist[i] &lt; min) <span class="hljs-comment">// dist[i]已经被操作了，已经小于min了，但是他还不是已经确定的了的点</span><br>             &#123;<br>                 u = i;         <span class="hljs-comment">// u保存哪一个需要接下来进行被操作</span><br>                 min = dist[i]; <span class="hljs-comment">// 保存此时的最小值</span><br>             &#125;<br>         &#125;<br>         s[u] = <span class="hljs-literal">true</span>;<br>         <span class="hljs-comment">// 进行松弛操作</span><br>         <span class="hljs-comment">// 更新u链接的顶点v，就可以更新</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> v = <span class="hljs-number">0</span>; v &lt; n; v++)<br>         &#123;<br>             <span class="hljs-comment">//保证v这个点没有更新过</span><br>             <br>             <span class="hljs-keyword">if</span> (s[v]==<span class="hljs-literal">false</span>&amp;&amp;_matrix[u][v] != MAX_W &amp;&amp; dist[u] + _matrix[u][v] &lt; dist[v]) <span class="hljs-comment">// 记录u链接除去的所有边</span><br>             &#123;<br>                 <span class="hljs-comment">// 如果此时链接出去的点小于原来记录 的值，那么我们就需要进行更新</span><br>                 dist[v] = dist[u] + _matrix[u][v]; <span class="hljs-comment">// 更新路径中的值</span><br>                 pPath[v] = u;                      <span class="hljs-comment">// 记录我们的父亲为u</span><br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6 makefile详解</title>
    <link href="/2022/12/17/xv6%20makefile%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/12/17/xv6%20makefile%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#makefile_1">makefile语法格式</a></li><li><a href="#qemu_9">生成qemu可执行文件</a></li><li><ul><li><a href="#kernel_41">生成kernel可执行文件</a></li><li><ul><li><a href="#kernelOBJS_55">生成kernel下的OBJS</a></li><li><a href="#kernelld_112">kernel.ld</a></li><li><a href="#build_OBJS_KCSAN_174">build OBJS_KCSAN</a></li><li><a href="#build_initcode_193">build initcode</a></li></ul></li><li><a href="#fsimg_224">生成一个fs.img文件系统</a></li><li><ul><li><a href="#mkfs_238">mkfs</a></li><li><a href="#_249">用户程序的编译</a></li></ul></li></ul></li><li><a href="#_290">配置工具</a></li></ul><h1 id="makefile语法格式"><a href="#makefile语法格式" class="headerlink" title="makefile语法格式"></a>makefile语法格式</h1><p>makefile就是一个深搜的过程，最上面的语句是顶级目标，顶级目标还有依赖</p><p>如果依赖不存在，下面我们还要写，</p><p>所以就是上面没有的，要在下面实现，再下面都实现了，上面的顶级目标才能实现</p><h1 id="生成qemu可执行文件"><a href="#生成qemu可执行文件" class="headerlink" title="生成qemu可执行文件"></a>生成qemu可执行文件</h1><p><code>make qemu</code></p><p><code>qemu</code> 依赖于<code>kernel</code> 和<code>fs.img</code>，把内核加载进去，文件系统挂载进去，之后一个操作系统就可以跑起来了</p><p>模拟risc-v指令集的CPU，比较关键的就是-kernel $K&#x2F;kernel和-driver file&#x3D;fs.img</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br>QEMU = qemu-system-riscv64<span class="hljs-comment"># 指定QEMU版本risc-v 的CPU</span><br><span class="hljs-comment"># --》 指定了使用的操作内核是kernel/kernel,-m 模拟了操作系统使用的内存128M，使用了3个cpu个数，</span><br>QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp <span class="hljs-variable">$(CPUS)</span> -nographic<br><span class="hljs-comment"># </span><br>QEMUOPTS += -global virtio-mmio.force-legacy=false<br><span class="hljs-comment"># 把文件系统挂载上去，最终就是模拟出来的一个计算机</span><br>QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0<br>QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(LAB)</span>,net)<br>QEMUOPTS += -netdev user,id=net0,hostfwd=udp::<span class="hljs-variable">$(FWDPORT)</span>-:2000 -object filter-dump,id=net0,netdev=net0,file=packets.pcap<br>QEMUOPTS += -device e1000,netdev=net0,bus=pcie.0<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># qemu依赖于kernel， fs.img  </span><br><span class="hljs-section">qemu: $K/kernel fs.img</span><br><span class="hljs-variable">$(QEMU)</span> <span class="hljs-variable">$(QEMUOPTS)</span>-------&gt;这里有了操作系统和用户程序还缺少硬件<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bd6752861632e20f2b31a68479f9ba36.png"></p><h2 id="生成kernel可执行文件"><a href="#生成kernel可执行文件" class="headerlink" title="生成kernel可执行文件"></a>生成kernel可执行文件</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">$K/kernel: <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(OBJS_KCSAN)</span> $K/kernel.ld $U/initcode</span><br><span class="hljs-comment"># 把所有.o文件用kernel.ld配置的链接器进行链接起来,生成一个kernel</span><br><span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> -T $K/kernel.ld -o $K/kernel <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(OBJS_KCSAN)</span><br><span class="hljs-comment"># 把kernel反汇编成kernel.asm，让我们能够进行debug</span><br><span class="hljs-variable">$(OBJDUMP)</span> -S $K/kernel &gt; $K/kernel.asm<br><span class="hljs-comment"># 把asm中的一些数据进行过滤，方便进行查找  </span><br><span class="hljs-variable">$(OBJDUMP)</span> -t $K/kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; $K/kernel.sym<br><br></code></pre></td></tr></table></figure><h3 id="生成kernel下的OBJS"><a href="#生成kernel下的OBJS" class="headerlink" title="生成kernel下的OBJS"></a>生成kernel下的OBJS</h3><p>kernel下的许多程序函数，都需要在 <code>kernel/main.c</code>函数中使用</p><p>(1)编译目标定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br><span class="hljs-comment"># 展开kernel/entry.o</span><br><span class="hljs-comment"># s\换行符</span><br><span class="hljs-comment"># 我们可以把OBJS这个变量别名理解为一个string</span><br><span class="hljs-comment"># 这里是编译内核态的代码，kernel依赖于这些代码</span><br><span class="hljs-comment"># 所以这下面的要一个一个开始生成</span><br>OBJS = \<br>  $K/entry.o \<br>  $K/kalloc.o \<br>  $K/string.o \<br>  $K/main.o \<br>  $K/vm.o \<br>  $K/proc.o \<br>  $K/swtch.o \<br>  $K/trampoline.o \<br>  $K/trap.o \<br>  $K/syscall.o \<br>  $K/sysproc.o \<br>  $K/bio.o \<br>  $K/fs.o \<br>  $K/log.o \<br>  $K/sleeplock.o \<br>  $K/file.o \<br>  $K/pipe.o \<br>  $K/exec.o \<br>  $K/sysfile.o \<br>  $K/kernelvec.o \<br>  $K/plic.o \<br>  $K/virtio_disk.o<br></code></pre></td></tr></table></figure><blockquote><p>%.o就是一个通配符，所有的.o都依赖于.c文件,这些都是kernel下的程序</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">$K/%.o: $K/%.c</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(EXTRAFLAG)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p>.S汇编都是下面这样生成的</p><blockquote><p>riscv64-linux-gnu-gcc -c -o kernel&#x2F;entry.o kernel&#x2F;entry.S</p></blockquote><p>.c就是下面这样编译的，规则是不一样的</p><blockquote><p>riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2 -DSOL_PGTBL -DLAB_PGTBL -MD -mcmodel&#x3D;medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -c -o kernel&#x2F;kalloc.o kernel&#x2F;kalloc.c</p></blockquote><p>到这里整个 <code>kernel</code>的 <code>OBJS</code> 都被build</p><hr><h3 id="kernel-ld"><a href="#kernel-ld" class="headerlink" title="kernel.ld"></a>kernel.ld</h3><p>这是kernel目录底下的链接脚本，指导着我们把kernel的依赖文件链接成一个目标文件</p><p>链接器 <code>ld</code> 将按照脚本内的指令将 <code>.o</code>文件生成可执行文件</p><p>主要描述的就是处理链接脚本的方式，以及生成可执行文件的内容布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ld">OUTPUT_ARCH( &quot;riscv&quot; )<br>ENTRY( _entry )虚拟地址的路口<br>这下面都是虚拟地址，这个就是kernel的虚拟地址空间<br>SECTIONS<br>&#123;<br>  /*<br>   * ensure that entry.S / _entry is at 0x80000000,<br>   * where qemu&#x27;s -kernel jumps.<br>   */<br>  . = 0x80000000;这个就是设置entry入口为0x80000000，“.&quot;就是当前位置<br>  /*<br>   * 这里text里面存放的就是用户的代码<br><br>  */<br>  .text : &#123;<br>    *(.text .text.*)把目标文件中的所有.o文件中的text节都拿出来，生成一个全新的text节<br>    . = ALIGN(0x1000);做一个4KB对齐<br>    _trampoline = .;保存trampoline代码，记录当前位置<br>    *(trampsec)保存trampoline代码<br>    . = ALIGN(0x1000);<br>    ASSERT(. - _trampoline == 0x1000, &quot;error: trampoline larger than one page&quot;);<br>    PROVIDE(etext = .);<br>  &#125;<br><br>  .rodata : &#123;<br>    . = ALIGN(16);<br>    *(.srodata .srodata.*) /* do not need to distinguish this from .rodata */<br>    . = ALIGN(16);<br>    *(.rodata .rodata.*)<br>  &#125;<br><br>  .data : &#123;<br>    . = ALIGN(16);<br>    *(.sdata .sdata.*) /* do not need to distinguish this from .data */<br>    . = ALIGN(16);<br>    *(.data .data.*)<br>  &#125;<br><br>  .bss : &#123;<br>    . = ALIGN(16);<br>    *(.sbss .sbss.*) /* do not need to distinguish this from .bss */<br>    . = ALIGN(16);<br>    *(.bss .bss.*)<br>  &#125;<br><br>  PROVIDE(end = .);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ca4b755ab83ce2b96a63adbe24fea7b3.jpeg"><br><img src="https://img-blog.csdnimg.cn/img_convert/6d3eb0726d2b2af0a59030718ceaf31e.png"></p><h3 id="build-OBJS-KCSAN"><a href="#build-OBJS-KCSAN" class="headerlink" title="build OBJS_KCSAN"></a>build OBJS_KCSAN</h3><p>这些程序都是处理和硬件中断相关的程序</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJS_KCSAN = \<br>  $K/start.o \<br>  $K/console.o \<br>  $K/printf.o \<br>  $K/uart.o \<br>  $K/spinlock.o<br><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">$K/%.o: $K/%.c</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(EXTRAFLAG)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><h3 id="build-initcode"><a href="#build-initcode" class="headerlink" title="build initcode"></a>build initcode</h3><p>用户空间初始化程序</p><p>在 <code>kernel/main.c</code>中使用到了这个程序，执行<strong>第一个用户</strong>程序 <code>&quot;init&quot;</code>程序,这一段可加可不加，kernel编译中只加了这一部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a user program that calls exec(&quot;/init&quot;)</span><br><span class="hljs-comment">// assembled from ../user/initcode.S</span><br><span class="hljs-comment">// od -t xC ../user/initcode</span><br>uchar initcode[] = &#123;<br>    <span class="hljs-number">0x17</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">0x97</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x02</span>,<br>    <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xef</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x69</span>,<br>    <span class="hljs-number">0x74</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br><span class="hljs-section">$U/initcode: $U/initcode.S</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o<br><span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o<br><span class="hljs-variable">$(OBJCOPY)</span> -S -O binary $U/initcode.out $U/initcode<br><span class="hljs-variable">$(OBJDUMP)</span> -S $U/initcode.o &gt; $U/initcode.asm<br></code></pre></td></tr></table></figure><h2 id="生成一个fs-img文件系统"><a href="#生成一个fs-img文件系统" class="headerlink" title="生成一个fs.img文件系统"></a>生成一个fs.img文件系统</h2><p>这个就是生成一个文件系统,相当于一个硬盘的镜像（用来存放用户程序的)</p><blockquote><p>这里的mkfs&#x2F;mkfs程序，就是将后面的 ( U P R O G S ) , (UPROGS), (UPROGS),(UEXTRA)用户编译好的程序,写入 <code>fs.img</code>这个文件系统中</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 这些都是伪目标，可以直接使用</span><br><span class="hljs-section">fs.img: mkfs/mkfs README <span class="hljs-variable">$(UEXTRA)</span> <span class="hljs-variable">$(UPROGS)</span></span><br>mkfs/mkfs fs.img README <span class="hljs-variable">$(UEXTRA)</span> <span class="hljs-variable">$(UPROGS)</span><br></code></pre></td></tr></table></figure><blockquote><p>mkfs&#x2F;mkfs fs.img README user&#x2F;_cat user&#x2F;_echo user&#x2F;_forktest user&#x2F;_grep user&#x2F;_init user&#x2F;_kill user&#x2F;_ln user&#x2F;_ls user&#x2F;_mkdir user&#x2F;_rm user&#x2F;_sh user&#x2F;_stressfs user&#x2F;_usertests user&#x2F;_grind user&#x2F;_wc user&#x2F;_zombie user&#x2F;_pgtbltest</p></blockquote><h3 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h</span><br>gcc <span class="hljs-variable">$(XCFLAGS)</span> -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c<br></code></pre></td></tr></table></figure><p><code>mkfs/mkfs</code>就是往文件系统中写文件的程序</p><blockquote><p>gcc -DSOL_PGTBL -DLAB_PGTBL -Werror -Wall -I. -o mkfs&#x2F;mkfs mkfs&#x2F;mkfs.c</p></blockquote><h3 id="用户程序的编译"><a href="#用户程序的编译" class="headerlink" title="用户程序的编译"></a>用户程序的编译</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">UPROGS=\<br>$U/_cat\<br>$U/_echo\<br>$U/_forktest\<br>$U/_grep\<br>$U/_init\<br>$U/_kill\<br>$U/_ln\<br>$U/_ls\<br>$U/_mkdir\<br>$U/_rm\<br>$U/_sh\<br>$U/_stressfs\<br>$U/_usertests\<br>$U/_grind\<br>$U/_wc\<br>$U/_zombie\<br><br>ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o<span class="hljs-comment">#  这个对标的就是C语言中的一些库函数，如printf，malloc之类的</span><br><span class="hljs-comment"># 这里的_就是一个字符，后面的%就是匹配所有以_开头的文件</span><br><span class="hljs-comment"># 依赖中的%.o,就是匹配所有.o结尾的文件，同时还要添加一个ULIB,依次去匹配这些东西</span><br><span class="hljs-section">_%: %.o <span class="hljs-variable">$(ULIB)</span></span><br><span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> -T $U/user.ld -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(OBJDUMP)</span> -S <span class="hljs-variable">$@</span> &gt; <span class="hljs-variable">$*</span>.asm<br><span class="hljs-variable">$(OBJDUMP)</span> -t <span class="hljs-variable">$@</span> | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="hljs-variable">$*</span>.sym<br><br></code></pre></td></tr></table></figure><p><code>ulib</code>中包含的就是一些string和内存操作的一些库函数<br><code>printf</code> 包含了和标准输出相关的一些函数<br><code>umalloc</code>包含了malloc相关的动态开辟之类的函数<br><code>usys</code>里面包含的就是系统调用相关的入口函数</p><p>这些将来就可以被OS调用，从文件系统中加载到内存中进行执行</p><p>用户态生成这些应用文件</p><p>硬盘构建完了上面这些在mkfs中使用到的编译完之后，就能构建fs.img</p><h1 id="配置工具"><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h1><p>指定工具的版本，如果找不到合适的版本就输出错误信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TOOLPREFIX := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-built_in">if</span> riscv64-unknown-elf-objdump -i 2&gt;&amp;1 | grep &#x27;elf64-big&#x27; &gt;/dev/null 2&gt;&amp;1; \</span><br><span class="hljs-variable">then echo &#x27;riscv64-unknown-elf-&#x27;; \</span><br><span class="hljs-variable">elif riscv64-linux-gnu-objdump -i 2&gt;&amp;1 | grep &#x27;elf64-big&#x27; &gt;/dev/null 2&gt;&amp;1; \</span><br><span class="hljs-variable">then echo &#x27;riscv64-linux-gnu-&#x27;; \</span><br><span class="hljs-variable">elif riscv64-unknown-linux-gnu-objdump -i 2&gt;&amp;1 | grep &#x27;elf64-big&#x27; &gt;/dev/null 2&gt;&amp;1; \</span><br><span class="hljs-variable">then echo &#x27;riscv64-unknown-linux-gnu-&#x27;; \</span><br><span class="hljs-variable">else echo &quot;***&quot; 1&gt;&amp;2; \</span><br><span class="hljs-variable">echo &quot;*** Error: Couldn&#x27;t find a riscv64 version of GCC/binutils.&quot; 1&gt;&amp;2; \</span><br><span class="hljs-variable">echo &quot;*** To turn off this <span class="hljs-built_in">error</span>, run &#x27;gmake TOOLPREFIX= ...&#x27;.&quot; 1&gt;&amp;2; \</span><br><span class="hljs-variable">echo &quot;***&quot; 1&gt;&amp;2; exit 1; fi)</span><br></code></pre></td></tr></table></figure><p>配置<code>编译器</code>，<code>汇编器</code>，<code>链接器</code>，<code>copy工具</code>，<code>dump工具</code>（反汇编)</p><hr><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CC = <span class="hljs-variable">$(TOOLPREFIX)</span>gcc<span class="hljs-comment">#  指定编译器</span><br>AS = <span class="hljs-variable">$(TOOLPREFIX)</span>gas<span class="hljs-comment">#  汇编器</span><br>LD = <span class="hljs-variable">$(TOOLPREFIX)</span>ld<span class="hljs-comment">#  链接器，前面都加上工具的版本</span><br>OBJCOPY = <span class="hljs-variable">$(TOOLPREFIX)</span>objcopy<span class="hljs-comment"># 把一个目标文件的内容拷贝到另一个目标文件中</span><br>OBJDUMP = <span class="hljs-variable">$(TOOLPREFIX)</span>OBJDUMP<span class="hljs-comment"># objdump是把二进制文件反汇编成一个.asm文件</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mit6.1810</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mmap</title>
    <link href="/2022/12/14/mmap/"/>
    <url>/2022/12/14/mmap/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">使用示例</a></li><li><a href="#_38">函数原型</a></li><li><ul><li><a href="#mmap_40">mmap</a></li><li><a href="#munmap_61">munmap</a></li></ul></li><li><a href="#_71">传统读写文件</a></li><li><a href="#mmap__90">mmap 原理</a></li><li><ul><li><a href="#eager_107">eager实现</a></li><li><a href="#lazy_113">lazy实现</a></li><li><a href="#_147">缺点</a></li></ul></li></ul><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">void</span> *start;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">sb</span>;</span><br><br>    fd = open(<span class="hljs-string">&quot;text.txt&quot;</span>, O_RDONLY|O_CREAT); <span class="hljs-comment">// 打开文件text.txt</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd=%d\n&quot;</span>,fd);<br>    fstat(fd, &amp;sb); <span class="hljs-comment">// 获取文件状态</span><br>    start = mmap(<span class="hljs-literal">NULL</span>, sb.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>); <span class="hljs-comment">// 建立内存映射</span><br>    <span class="hljs-keyword">if</span>(start == MAP_FAILED)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)start,<span class="hljs-string">&quot;asd&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, (<span class="hljs-type">char</span>*)start); <span class="hljs-comment">// 输出内存内容</span><br>    munmap(start, sb.st_size); <span class="hljs-comment">// 解除内存映射</span><br>    close(fd); <span class="hljs-comment">// 关闭文件</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c26b5e6a13d3410ab15e622c28717d43.png" alt="请添加图片描述"></p><blockquote><p>这段代码实现将文件text.txt 打开，并用mmap函数将文件映射到虚拟内存中，通过执政start对文件进行读写，可以在中断中看到由文件写入的数据，程序结束后，可以查看text.txt文件，来查看写入的数据</p></blockquote><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><blockquote><p>void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);</p></blockquote><ul><li><code>addr</code> :制定映射的起始地址，通常是NULL，由内核来分配，是一个虚拟地址</li><li><code>len</code>：代表将文件中映射到内存的部分的长度，以及内存地址的区间大小</li><li><code>prot</code>：映射区域（内存)的保护方式，这块地址的方式<ul><li><code>PROT_EXEC</code>：映射区域可执行，X</li><li><code>PROT_READ</code>: 映射区域可读取，R</li><li><code>PROT_NONE</code>: 映射区域不能存取，</li><li><code>PROT_WRITE</code>: 映射区域可以写入 ,W</li></ul></li><li><code>flag</code>：映射区的特性标志位<ul><li><code>MAP_SHARD</code>:写入映射区的数据会复制回文件，和其他映射文件的进程共享，多个进程可以共享,实现 <code>进程间通信</code></li><li><code>MAP_PRIVATE</code>:对映射区的写入操作会产生一个映射区的复制，对此区域的修改不会写会原文件,这一部分的内容只会出现的内存，而不对文件修改，</li></ul></li><li><code>fd</code>：要映射到内存中的文件描述符，有open函数打开文件时返回的值,内核可以通过他得到对应的 <code>struct file</code></li><li><code>offset</code>：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小（4K）的整数倍。offset移动，相当与从文件的不同位置进行映射</li></ul><p>函数的返回值</p><blockquote><p>实际分配的内存的起始地址,我们可以使用这个地址，来对文件进行修改，读取</p></blockquote><h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h2><blockquote><p>int munmap( void * addr, size_t len )</p></blockquote><p>该调用在进程地址空间中解除一个映射关系,来表明应用程序完成了对文件的操作，addr是mmap时返回的地址，len是映射区的长度</p><p>如果这个len就是内存中对应的映射区地址，这一块就直接释放掉了，如果不是，就把addr+len这一部分给解除映射，我们使用的addr移动len</p><p>解除映射之后，对原来映射地址的访问会导致段错误</p><h1 id="传统读写文件"><a href="#传统读写文件" class="headerlink" title="传统读写文件"></a>传统读写文件</h1><ul><li>把文件内容读入到内存中,从内核态拷贝回用户态，获得对应文件的数据。</li><li>用户态修改文件相应的内容。</li><li>把修改过的数据从用户态拷贝回内核态文件中。</li></ul><p><img src="https://img-blog.csdnimg.cn/a2381b1599f34a90a06b48a3ff590e5a.png" alt="请添加图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">read(fd, buf, <span class="hljs-number">1024</span>);  <span class="hljs-comment">// 读取文件的内容到buf</span><br>...                   <span class="hljs-comment">// 修改buf的内容</span><br>write(fd, buf, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 把buf的内容写入到文件</span><br></code></pre></td></tr></table></figure><p>其中，（页缓存） <code>page cache</code>类似inode cache，把磁盘中的数据缓存在内存中，减少和磁盘进行交互,提高效率，内核使用page cache 将文件的数据块关联起来，所以我们在读写文件的时候，实际上操作的是 <code>page cache</code></p><blockquote><p>最大的影响就是，读写都需要进行数据的拷贝，如果数据两很大，那对性能影响就很大</p></blockquote><h1 id="mmap-原理"><a href="#mmap-原理" class="headerlink" title="mmap 原理"></a>mmap 原理</h1><p><img src="https://img-blog.csdnimg.cn/e9527df4360f4815b1eea8d3e0afb2e4.png" alt="请添加图片描述"></p><p><img src="https://img-blog.csdnimg.cn/52b1d6fd88f04c249c689c52c79dd6cc.png" alt="请添加图片描述"></p><p>与传统读写文件相比，mmap就是可以直接在用户空间读写 <code>page cache</code>，这样就可以免去将 <code>page cache</code>的数据在内核与用户之间的拷贝，mmap映射的正是文件的 <code>page cache</code>，而非磁盘</p><p><code>mmap</code> 将文件映射到进程的虚拟内存空间中，通过对这段内存的 <code>lord</code> 和 <code>store</code> ，实现对文件的读取和修改，不使用 <code>read</code> 和 <code>write</code></p><p>off为映射的部分在文件中的偏移量，len为映射的长度</p><p>图中实际含义</p><p>从文件描述符对应的offset开始映射长度为len的内容到虚拟地址va(由内核决定)，va+len,范围内都是其对应的虚拟地址</p><h2 id="eager实现"><a href="#eager实现" class="headerlink" title="eager实现"></a>eager实现</h2><p>如果内存使用的是eager方式来实现</p><blockquote><p>对于文件的读写，内核会从文件的offset开始，将数据拷贝到内核中，设置好PTE指向物理内存的位置，后程序就可以使用load或者store来修改内存中文件的内容，完成后，使用munmap，将dirty block写回文件中，我们可以很容易找到哪个block是dirty，因为对应的PTE_D被设置了</p></blockquote><h2 id="lazy实现"><a href="#lazy实现" class="headerlink" title="lazy实现"></a>lazy实现</h2><p>但是现在的计算机都不会这样做，都是以 <code>lazy</code>的方式实现</p><ul><li>记录这个PTE属于这个文件描述符</li><li>存储相应的信息在VMA（Virtual Memory Area）)结构体中（这些信息来表示对应的虚拟地址的实际内容在哪里)<ul><li>文件描述符</li><li>偏移量等</li><li>地址范围</li><li>标志位</li><li>长度</li></ul></li></ul><blockquote><p>调用mmap是不会开辟物理地址的，只会把数据存储起来，等待后续实际的调用，再实际的对对应的page进行开辟物理内存</p></blockquote><ul><li>对VMA记录的某个范围内进行读写操作，触发page fault，就会实际的开辟物理页，将该va和该物理地址进行映射，将VMA中记录的offset标志位开始读取数据到对应的物理地址中</li></ul><p>如果其他进程直接修改了文件的内容，内容不会出现在内存中，</p><p>mmap并不会主动将 <code>mmap</code>修改的page cache <code>同步</code>到磁盘，而是需要用户进行触发</p><ul><li><code>munmap</code>解除文件映射的时候会触发</li><li>msync函数主动进行数据同步</li><li>进程退出</li><li>系统关机</li></ul><p><img src="https://img-blog.csdnimg.cn/73d5f26b863c4e4eb3084fbfb85537de.png" alt="请添加图片描述"></p><blockquote><ol><li>虚拟地址空间获得一段连续的地址</li><li>在没有读写的时候，这个地址指向不存在的地方（所以上图中，起始地址和终止地址还没分配给进程)</li><li>根据偏移量，进程要读取文件了，数据占两个页</li><li>进程开始使用内存，所以OS要给这两个页分配内存，触发page fault</li><li>将对应的offset文件数据拷贝到物理内存对应的page上</li></ol></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>如果文件很小，小于4KB，但是再内存中都是按照4KB为基本单位，就会造成一个内存空间的浪费</li><li>创建mmap，销毁munmap，page fault开销很大</li></ol>]]></content>
    
    
    <categories>
      
      <category>mit6.1810</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux java c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于xv6的Copy-On-Write</title>
    <link href="/2022/12/10/%E5%9F%BA%E4%BA%8Exv6%E7%9A%84Copy-On-Write/"/>
    <url>/2022/12/10/%E5%9F%BA%E4%BA%8Exv6%E7%9A%84Copy-On-Write/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">为什么需要写时拷贝呢？</a></li><li><a href="#page_fault_16">page fault的执行流程</a></li><li><a href="#CopyOnWrite_32">Copy-On-Write处理方法</a></li><li><ul><li><a href="#PTE_49">PTE</a></li><li><a href="#_61">引用计数</a></li><li><a href="#_69">虚拟地址空间</a></li></ul></li><li><a href="#_84">核心代码</a></li></ul><h1 id="为什么需要写时拷贝呢？"><a href="#为什么需要写时拷贝呢？" class="headerlink" title="为什么需要写时拷贝呢？"></a>为什么需要写时拷贝呢？</h1><p>当 <code>shell</code>执行指令的时候会 <code>fork()</code>，而这个 <code>fork()</code>出来的进程首先会调用的就是 <code>exec</code>来执行对应的命令，如果我们将 <code>fork()</code>创建的进程对地址空间进行了完整的拷贝,那将是一个巨大的消耗</p><p>因为在实际应用中，<code>fork()</code>拷贝的大部分内存都是不会用到的,最典型的就是在UNIX系统中，通常调用 <code>fork()</code>后便会调用 <code>exec()</code>,而 <code>exec()</code>做的第一件事就是把原来的地址空间给舍弃掉，那么原来拷贝过来的数据就全没用了</p><p>所以这个时候就需要copy-on-write机制</p><ul><li>这是一个系统级别的优化</li><li>对于从 <code>fork()</code>-&gt;<code>exec()</code>的执行模式是一个很好的优化<ul><li>避免 <code>fork()</code>会把父进程的进程地址空间进行完全的拷贝</li><li>解决因为 <code>exec()</code>把拷贝完的地址空间给舍弃，而造成我们无效的操作</li></ul></li><li>可以极大的减少拷贝<ul><li>对于特定的页使用极少的内存就可以维护</li></ul></li></ul><h1 id="page-fault的执行流程"><a href="#page-fault的执行流程" class="headerlink" title="page fault的执行流程"></a>page fault的执行流程</h1><p>page fault的执行流程和系统调用类似，同样是需要从用户态进入到内核态，并在usertrap中判断是什么原因导致的进入内核,<br>后执行对应的page fault处理方法，执行完再返回回到用户态，继续原来的操作</p><hr><p>我们可以通过<code>scause</code>的值来判断是否为page fault导致的</p><p>从图中可知，<code>scause</code>=12，13，15的时候分别是instruction page fault,load page fault,store page fault</p><p><img src="https://img-blog.csdnimg.cn/3f5070a60f4c48b99b920f7738889b96.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xsULkO3b-1670655836900)(https://cdn.jsdelivr.net/gh/zevin02/picb@master/imgss/20221209190124.png)]"></p><h1 id="Copy-On-Write处理方法"><a href="#Copy-On-Write处理方法" class="headerlink" title="Copy-On-Write处理方法"></a>Copy-On-Write处理方法</h1><ul><li>fork之后，让子进程和父进程共享物理内存page,同时将对应的page设置为COW page</li></ul><p><img src="https://img-blog.csdnimg.cn/3b7b1cf922934decbd87f4a751904492.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XzgtMaqw-1670655836901)(https://cdn.jsdelivr.net/gh/zevin02/picb@master/imgss/20221210145755.png)]"></p><ul><li>当我们需要修改某个进程对应的内存的时候，就会触发page fault</li><li>page fault 处理方法<ul><li>对于由于COW而导致的page fault的page 需要为其分配一个新的物理page</li><li>将其和父进程共享的page内容拷贝到新的page中</li><li>把新page的PTE标记为RW，取消COW</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/3a721dc74439454cac5cf67f26f31722.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-p3cnstsA-1670655836902)(https://cdn.jsdelivr.net/gh/zevin02/picb@master/imgss/20221210145847.png)]"></p><h2 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h2><p>在RISC-V中的PTE，第8，9位是给supervisor保留的，按需自由设置，所以我们可以选取其中的一个位设置为COW的标志位</p><p><img src="https://img-blog.csdnimg.cn/c2bceea76d894e4b84cd890c35c34fcc.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kxNNIHV6-1670655836902)(https://cdn.jsdelivr.net/gh/zevin02/picb@master/imgss/20221210145939.png)]"></p><p>我们可以使用PTE中的RSW bit来标记PTE为COW page</p><p>我们可以定义<code>PTE_COW=1&lt;&lt;8</code></p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><code>Copy-On-Write</code>是推迟为子进程开辟物理内存,最大程度减少拷贝的一个机制</p><p>一个物理页可能被多个进程所引用，为了能够使某个物理内存能够被释放，就需要对每个物理页都添加一个引用计数，表示有多少个进程引用了该物理页，直到该物理页的引用计数为0的时候，该物理页才能够被释放</p><p>在开辟物理页的时候，将其引用计数设置为1，当 <code>fork()</code>子进程的时候，增加引用计数，触发 <code>page fault</code>将对应的引用计数减1</p><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>进程地址空间</p><p><img src="https://img-blog.csdnimg.cn/f556dfe7567b491ca2112f312f877069.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TXB7578T-1670655836903)(https://cdn.jsdelivr.net/gh/zevin02/picb@master/imgss/20221210150015.png)]"></p><p>子进程拷贝完父进程的页表之后，将每个页的PTE都设置清空 <code>PTE_W</code>,设置 <code>PTE_COW</code></p><p>而对于上述的操作，会影响<code>text</code><br>区，这一段也并没有 <code>PTE_W</code>,如果我们对其进行 <code>COW</code>操作就会出现问题</p><p>因为用户虚拟地址中的 <code>text</code>区是保存存储代码的，这块的虚拟地址不能发生COW，所以对于 <code>va&lt;PGSIZE</code>，我们就需要直接拦截</p><h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><p>设置COW 标志位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="hljs-comment">// valid</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_U (1L &lt;&lt; 4) <span class="hljs-comment">// user can access</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="hljs-comment">//判断COW page</span></span><br></code></pre></td></tr></table></figure><p>修改fork的处理机制，修改 <code>uvmcopy</code>,使得fork的子进程印射到父进程的地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span><span class="hljs-comment">//将两个pagetable进行复制，两个不同的进程虚拟地址相同映射到页表的相同位置</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br>  <span class="hljs-comment">// char *mem;</span><br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    *pte&amp;=(~PTE_W);<span class="hljs-comment">//把w权限给取消掉</span><br>    *pte|=PTE_COW;<span class="hljs-comment">//设置为cow页,这个操作并不会影响其父进程</span><br>    pa = PTE2PA(*pte);<br>    flags = PTE_FLAGS(*pte);<br>    <span class="hljs-comment">// if((mem = kalloc()) == 0)</span><br>      <span class="hljs-comment">// goto err;</span><br>    <span class="hljs-comment">// memmove(mem, (char*)pa, PGSIZE);</span><br><br>    <span class="hljs-keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//  kfree((void*)pa);//减少引用计数</span><br><br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      refadd(pa);<span class="hljs-comment">//添加引用计数</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err:<br>  uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 <code>usertrap</code>对 <code>page fault</code>进行识别与处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br><br>  ……………<span class="hljs-comment">//省略</span><br>  <span class="hljs-comment">//--------&gt;begin</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">15</span> || r_scause() == <span class="hljs-number">13</span>||r_scause()==<span class="hljs-number">12</span>))<br>  &#123;<br>    uint64 va = r_stval(); <span class="hljs-comment">// 获得错误的虚拟地址</span><br>    <span class="hljs-keyword">if</span> (va &lt; PGSIZE)<span class="hljs-comment">//解决segment fault，这些va小于pgsize都是在text区</span><br>    &#123;<br>      p-&gt;killed = <span class="hljs-number">1</span>;<br>    &#125;<br>  <br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">// va=PGROUNDDOWN(va);//16进制向下取整</span><br>      <span class="hljs-keyword">if</span> (va &lt; p-&gt;sz &amp;&amp; iscow(p-&gt;pagetable, va)) <span class="hljs-comment">// 是因为cow引起的page fault</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (cowalloc(p-&gt;pagetable, PGROUNDDOWN(va)) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 为新的页表分配内存</span><br>        &#123;<br>          p-&gt;killed = <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        p-&gt;killed = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//-------&gt;end</span><br>  …………<span class="hljs-comment">//省略</span><br>  usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure><p>标识COW page</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">iscow</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">pte_t</span> *pte = <span class="hljs-built_in">walk</span>(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (*pte &amp; PTE_COW)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对产生 <code>page fault</code>的 <code>va</code>进行分配物理页</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cowalloc</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span> <span class="hljs-comment">//为page fault的虚拟地址进行拷贝新的物理地址，内容从父进程里面全部拷贝过来</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">pte_t</span> *pte = <span class="hljs-built_in">walk</span>(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//这个函数就是用来进行分配物理空间的</span><br>  uint64 pa = <span class="hljs-built_in">PTE2PA</span>(*pte);<br>  <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP) <span class="hljs-comment">//所有的物理地址大小都是4096字节，对齐，end是内核物理地址的最底段，PHYSTOP是内核物理地址的最顶端</span><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cowalloc&quot;</span>);<br>  <span class="hljs-keyword">if</span> (ref.refcnt[(uint64)pa / PGSIZE] == <span class="hljs-number">1</span>)<span class="hljs-comment">//引用计数为1的话，就说明已经没有人使用该page了，就可以直接使用了</span><br>  &#123;<br>    *pte |= PTE_W;<br>    *pte &amp;= ~PTE_COW;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br><br>    uint64 ka = (uint64)<span class="hljs-built_in">kalloc</span>(); <span class="hljs-comment">//引用计数初始化</span><br>    <span class="hljs-keyword">if</span> (ka == <span class="hljs-number">0</span>)                  <span class="hljs-comment">//物理内存已经满了，这里我们采取简单的方法，直接将这个进程给杀掉,但是实际上在课上讲过，可以使用LRU的方法，把最近一直没有使用的页表给释放出来，然后新的进程去使用这个页表，可以提高效率</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">memmove</span>((<span class="hljs-type">void</span> *)ka, (<span class="hljs-type">void</span> *)pa, PGSIZE); <span class="hljs-comment">//把他原来对应物理内存的地址进行拷贝过来，都是4096字节</span><br>    *pte &amp;= (~PTE_COW);                      <span class="hljs-comment">//取消他的cow标志位</span><br>    *pte |= PTE_W;                           <span class="hljs-comment">//添加写权限</span><br>     *pte&amp;=(~PTE_V);<br>    uint flag = <span class="hljs-built_in">PTE_FLAGS</span>(*pte);<br>    <span class="hljs-comment">// uvmunmap(pagetable, va, 1, 1);                      //这个地方因为是取消映射，也就是之前映射对应的物理地址对应的引用计数要减1</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">mappages</span>(pagetable, va, PGSIZE, ka, flag) != <span class="hljs-number">0</span>) <span class="hljs-comment">//进行新的映射</span><br>    &#123;<br>      <span class="hljs-comment">//映射失败，同时页需要减少引用计数</span><br>      <span class="hljs-built_in">kfree</span>((<span class="hljs-type">void</span> *)ka);<br>      *pte|=(PTE_V);<span class="hljs-comment">//添加这个有效的标志位</span><br>      <span class="hljs-comment">// uvmunmap(pagetable, va, 1, 1);</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">kfree</span>((<span class="hljs-type">void</span>*)<span class="hljs-built_in">PGROUNDDOWN</span>(pa));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>修改 <code>copyout</code>,有些COW页操作不是来自用户空间而是来自内核空间，因为 <code>copyout</code>是从内核态拷贝到用户态，是会对用户页产生写操作，而内核进程不会触发 <code>usertrap</code>，所以我们需要进行对其进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyout</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 dstva, <span class="hljs-type">char</span> *src, uint64 len)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 n, va0, pa0;<br><br>  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>    va0 = <span class="hljs-built_in">PGROUNDDOWN</span>(dstva);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">iscow</span>(pagetable,va0))<span class="hljs-comment">//每次都需要对这个va进行判断是否为cow page</span><br>    &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cowalloc</span>(pagetable,va0)==<span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>    &#125;<br>    ...<span class="hljs-comment">//省略</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加引用计数的结构体</p><p>每个页的起始地址都是4096对齐，所以都是可以被4096整除</p><p>这里的 <code>KERNBASE</code>和 <code>PHYSTOP</code>代表这内存物理地址的起始和结束，而 <code>end</code>是 <code>Free memory的</code>起始地址，这个 <code>end</code>是动态变化的，内核自己的代码和数据都是存在 <code>kernel text</code>和 <code>kernel data</code>中,所以这个结构体是存在 <code>kernel data</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">spinlock</span> lock;<br>  <span class="hljs-type">int</span> refcnt[PHYSTOP / PGSIZE];<span class="hljs-comment">//每个物理地址都是PGSIZE对齐</span><br>&#125; ref;<br></code></pre></td></tr></table></figure><p>修改 <code>kinit</code>，初始化ref结构体,kalloc只会分配 <code>end~PHYSTOP</code>间的内存，所以我们使用的物理内存都在这个范围内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kinit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">initlock</span>(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  <span class="hljs-built_in">initlock</span>(&amp;ref.lock, <span class="hljs-string">&quot;ref&quot;</span>);<br>  <span class="hljs-built_in">freerange</span>(end, (<span class="hljs-type">void</span> *)PHYSTOP);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 <code>freerange</code>，初始化空闲内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">PGROUNDUP</span>((uint64)pa_start);<br>  <span class="hljs-keyword">for</span> (; p + PGSIZE &lt;= (<span class="hljs-type">char</span> *)pa_end; p += PGSIZE)<br>  &#123;<br>    ref.refcnt[(uint64)p / PGSIZE] = <span class="hljs-number">1</span>; <span class="hljs-comment">//因为下面调用kfree要把每个物理地址上的引用计数都减少1,为0才能够释放空间，所以这里我们先给每个初始化成1,保证能够释放空间成功</span><br>    <span class="hljs-built_in">kfree</span>(p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 <code>kalloc</code>，初始化引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">run</span> *r;<br><br>  <span class="hljs-built_in">acquire</span>(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span> (r)<br>  &#123;<br>    kmem.freelist = r-&gt;next;<br>    <span class="hljs-built_in">acquire</span>(&amp;ref.lock);<br>    ref.refcnt[(uint64)r / PGSIZE] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">release</span>(&amp;ref.lock);<br>  &#125;<br><br>  <span class="hljs-built_in">release</span>(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">if</span> (r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span> *)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)r;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 <code>kfree</code>，减少引用计数，直到引用计数为0时，才能把该物理页释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;kfree&quot;</span>);<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">run</span> *r;<br>  <span class="hljs-built_in">acquire</span>(&amp;ref.lock);<br>  --ref.refcnt[(uint64)pa / PGSIZE];<br>  <span class="hljs-comment">// release(&amp;ref.lock);</span><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-keyword">if</span> (ref.refcnt[(uint64)pa / PGSIZE] == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">release</span>(&amp;ref.lock);<br>    <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE); <span class="hljs-comment">//当引用计数为0的时候，才把这个空间释放，同时添加到空闲链表里面</span><br>    r = (<span class="hljs-keyword">struct</span> run *)pa;<br>    <span class="hljs-built_in">acquire</span>(&amp;kmem.lock);<br>    r-&gt;next = kmem.freelist;<br>    kmem.freelist = r;<br>    <span class="hljs-built_in">release</span>(&amp;kmem.lock);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">release</span>(&amp;ref.lock);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>增加引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">refadd</span><span class="hljs-params">(uint64 pa)</span> <span class="hljs-comment">//添加引用计数</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;refadd&quot;</span>);<br>  <span class="hljs-built_in">acquire</span>(&amp;ref.lock); <span class="hljs-comment">//添加的时候要上锁，避免出现多线程同时操作同一个数的情况</span><br>  ref.refcnt[pa / PGSIZE]++;<br>  <span class="hljs-built_in">release</span>(&amp;ref.lock);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mit6.1810</category>
      
    </categories>
    
    
    <tags>
      
      <tag>risc-v xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编函数的调用约定</title>
    <link href="/2022/11/05/%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2022/11/05/%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">汇编的调用约定</a></li><li><a href="#_17">函数调用过程中的编程约定</a></li><li><ul><li><a href="#_18">有关寄存器的编程约定</a></li><li><a href="#_31">函数跳转和返回指令的编程约定</a></li></ul></li><li><a href="#_42">示例</a></li></ul><h1 id="汇编的调用约定"><a href="#汇编的调用约定" class="headerlink" title="汇编的调用约定"></a>汇编的调用约定</h1><p>函数调用过程的概述<br>stack frame<br><img src="https://img-blog.csdnimg.cn/fadda0b23037428da368f2e393029836.png" alt="在这里插入图片描述"></p><blockquote><p>调用一个函数的时候，就会压入栈帧里面，在调用A函数后，再调用B函数，B函数的地址就会继续压栈，当B函数处理完之后，在栈帧里面的B地址就会出栈，入宫函数过多的话，有可能会出现爆栈的情况</p></blockquote><p>函数调用约定</p><ul><li>caller就是一个函数调用者，callee就是被调用函数</li><li>在caller中调用call，调用了callee，callee执行完之后返回，返回到调用call的下一个地址</li></ul><p><img src="https://img-blog.csdnimg.cn/c262e14a68b741de9517fd995d9d5af0.png" alt="在这里插入图片描述"></p><blockquote><p>这里有一个问题，函数调用的时候，那些函数的调用参数，和函数的返回值应该放在哪里呢？<br>这就是我们下面要解决的问题</p></blockquote><h1 id="函数调用过程中的编程约定"><a href="#函数调用过程中的编程约定" class="headerlink" title="函数调用过程中的编程约定"></a>函数调用过程中的编程约定</h1><h2 id="有关寄存器的编程约定"><a href="#有关寄存器的编程约定" class="headerlink" title="有关寄存器的编程约定"></a>有关寄存器的编程约定</h2><p><strong>x0-x31</strong>就是寄存器的最初始化的名字，最开始的32个寄存器<br><strong>ABI</strong>就是在函数的时候吧这些寄存器普遍化修改的别名，主要使用的就是这些别名，我们之后都是使用这些别名，更好的进行理解<br><img src="https://img-blog.csdnimg.cn/227e46ac11824db894696d6e9c57cc63.png" alt="在这里插入图片描述"></p><blockquote><p><strong>N&#x2F;A:<strong>就是not available，没有人维护<br><strong>ra</strong>:return address,就是jal函数返回后的下一个地址,由</strong>调用者</strong>来进行维护，因为函数返回之后要达到对应的位置<br><strong>sp</strong>:stack pointer:就是用来存放栈指针，由<strong>被调用者</strong>来维护，因为出栈和入栈主要就是由<strong>被调用的子函数</strong>来执行<br><strong>t</strong>:temporary:临时寄存器，用来函数调用者<strong>保存函数的一些临时变量</strong><br><strong>s</strong> :save ：保存寄存器，就是和t是反过来的，对于<strong>调用者</strong>来说，要<strong>保证save里面的值在调用前和调用后值是不变</strong>的<br><strong>a</strong>：argument参数寄存器，用于在函数时候保存函数的参数，以及传递返回值</p></blockquote><blockquote><p>我们在写risc-v的时候，一般使用<strong>a0,a1</strong>来进行返回<br>使用<strong>a0-a7</strong>来进行传递函数的参数</p></blockquote><h2 id="函数跳转和返回指令的编程约定"><a href="#函数跳转和返回指令的编程约定" class="headerlink" title="函数跳转和返回指令的编程约定"></a>函数跳转和返回指令的编程约定</h2><p>（1）<br><img src="https://img-blog.csdnimg.cn/cacc897c8d334dff860c0ca186684187.png" alt="在这里插入图片描述"><br>（2）<br><img src="https://img-blog.csdnimg.cn/df36448d8baf4fe38068d130168a6f3d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0f62661d343440ceb6537af173f0f376.png" alt="在这里插入图片描述"></p><blockquote><p>我们要将函数的ra寄存器保存在栈里面，避免之后调用的时候这个ra寄存器没了，寄存器没了的话，函数返回地址就没了，不知道返回到那里，所以我们要用s寄存器来保存ra的值，退栈的时候恢复ra的值<br>在c语言里面调用汇编代码<br><img src="https://img-blog.csdnimg.cn/711cb1f9a3eb45febc8527e1b15721a0.png" alt="在这里插入图片描述"></p><ul><li>汇编</li></ul></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"># Calling Convention<br># Demo how to write nested routines<br>#<br><span class="hljs-meta"># void _start()</span><br># &#123;<br>#     <span class="hljs-comment">// calling nested routine</span><br>#     aa_bb(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br># &#125;<br>#<br><span class="hljs-meta"># int aa_bb(int a, int b)</span><br># &#123;<br><span class="hljs-meta">#     return square(a) + square(b);</span><br># &#125;<br>#<br><span class="hljs-meta"># int square(int num)</span><br># &#123;<br><span class="hljs-meta">#     return num * num;</span><br># &#125;<br><br>.text# Define beginning of text section<br>.global_start# Define entry _start,这个_start是一个全局的标签地址<br><br>_start:<br>la sp, stack_end<span class="hljs-meta"># prepare stack for calling functions  ，同样进入主函数之后就开辟了栈内存空间</span><br><br># aa_bb(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>li a0, <span class="hljs-number">3</span><br>li a1, <span class="hljs-number">4</span># 给函数两个参数的值，传参<br>call aa_bb# 一个<span class="hljs-number">3</span>,一个<span class="hljs-number">4</span><br><br>stop:<br>j stop# Infinite loop to stop execution<br><br><span class="hljs-meta"># int aa_bb(int a, int b)</span><br><span class="hljs-meta"># return a^2 + b^2</span><br>aa_bb:<br><span class="hljs-meta"># prologue</span><br>addi sp, sp, <span class="hljs-number">-16</span># 压栈<br>sw s0, <span class="hljs-number">0</span>(sp)# 这里把s0,s2保存起来，函数的参数，以及栈指针，把sp+<span class="hljs-number">0</span>存储到s0里面<br>sw s1, <span class="hljs-number">4</span>(sp)<br>sw s2, <span class="hljs-number">8</span>(sp)<br>sw ra, <span class="hljs-number">12</span>(sp)# 这里还要保存ra的值，sw 是存字，把 ra 的低位四字节存入地址 rs1+立即数中。<br><br><span class="hljs-meta"># cp and store the input params</span><br>mv s0, a0<br>mv s1, a1<br><br><span class="hljs-meta"># sum will be stored in s2 and is initialized as zero</span><br>li s2, <span class="hljs-number">0</span><br><br>mv a0, s0<br>jal square# 这里是尾调用，所以就不会回来了，如果不保存ra的话，就会把ra的地址给改调了<br>add s2, s2, a0# 上一层函数函数运行的结果的在a0里面，因为这就是用来处理函数参数和返回值的寄存器<br><br>mv a0, s1<br>jal square<br>add s2, s2, a0# a0里面放的就是第二个参数调用函数处理的结果，放到s2里面<br><br>mv a0, s2# 再把s2的值放到参数寄存器里面，返回<br><br><span class="hljs-meta"># epilogue</span><br>lw s0, <span class="hljs-number">0</span>(sp)# 恢复寄存器，退出栈帧<br>lw s1, <span class="hljs-number">4</span>(sp)<br>lw s2, <span class="hljs-number">8</span>(sp)<br>lw ra, <span class="hljs-number">12</span>(sp)<br>addi sp, sp, <span class="hljs-number">16</span># 把栈镇退出<br>ret# 返回<br><br><span class="hljs-meta"># int square(int num)</span><br>square:<br><span class="hljs-meta"># prologue</span><br>addi sp, sp, <span class="hljs-number">-8</span><br>sw s0, <span class="hljs-number">0</span>(sp)# 因为这里是最后一次调用函数所以不用存储函数的返回值ra<br>sw s1, <span class="hljs-number">4</span>(sp)<br><br># `mul a0, a0, a0` should be fine,<br><span class="hljs-meta"># programing as below just to demo we can contine use the stack</span><br>mv s0, a0<br>mul s1, s0, s0<br>mv a0, s1<br><br><span class="hljs-meta"># epilogue</span><br>lw s0, <span class="hljs-number">0</span>(sp)<br>lw s1, <span class="hljs-number">4</span>(sp)<br>addi sp, sp, <span class="hljs-number">8</span><br><br>ret<br><br><span class="hljs-meta"># add nop here just for demo in gdb</span><br>nop<br><br><span class="hljs-meta"># allocate stack space，开辟了栈空间</span><br>stack_start:<br>.rept <span class="hljs-number">12</span><br>.word <span class="hljs-number">0</span><br>.endr<br>stack_end:<br><br>.end# End of file<br></code></pre></td></tr></table></figure><p>在汇编代码里面调用c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"># C all ASM<br><br>.text# Define beginning of text section<br>.global_start# Define entry _start<br>.globalfoo<span class="hljs-meta"># foo is a C function defined in test.c，c函数定义到这里</span><br><br>_start:<br>la sp, stack_end<span class="hljs-meta"># prepare stack for calling functions</span><br><br>li a0, <span class="hljs-number">1</span><br>li a1, <span class="hljs-number">2</span><br>call foo # 调用c函数<br><br>stop:<br>j stop# Infinite loop to stop execution<br><br>nop<span class="hljs-meta"># just for demo effect</span><br><br>stack_start:<br>.rept <span class="hljs-number">12</span><br>.word <span class="hljs-number">0</span><br>.endr<br>stack_end:<br><br>.end# End of file<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RISC_V汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构 java 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言指令</title>
    <link href="/2022/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">算术运算指令</a></li><li><ul><li><a href="#ADD_2">ADD</a></li><li><a href="#ADDI_27">ADDI</a></li><li><a href="#SUB_38">SUB</a></li><li><a href="#_48">伪指令</a></li><li><a href="#LUI_50">LUI</a></li><li><a href="#LI_59">LI</a></li><li><a href="#AUIPC_67">AUIPC</a></li><li><a href="#LA_76">LA</a></li></ul></li><li><a href="#_87">逻辑运算指令</a></li><li><a href="#_108">内存读写指令</a></li><li><a href="#_118">条件分支指令</a></li><li><a href="#_133">无条件跳转指令</a></li></ul><h1 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h1><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><table><thead><tr><th>语法</th><th>ADD RD，RS1,RS2</th><th></th></tr></thead><tbody><tr><td>例子</td><td>add x5,x6,x7</td><td>x5&#x3D;x6+x7</td></tr></tbody></table><blockquote><p>编码格式：<strong>R-type</strong><br>opcode(7):0110011(OP)<br>从RS里面取出数据，把里面的数据计算，得出的结果放在rd里面<br>func3取值000,func7取值0000000</p></blockquote><p><img src="https://img-blog.csdnimg.cn/df0917b9201f4095a16b06bcc4b1e8a3.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">.text# Define beginning of text section，告诉汇编器，所有的数据都放到text section里面<br>.global_start# Define entry _start   这里面就是程序的入口，_start就是主体程序<br><br>_start:<br>li x6, <span class="hljs-number">1</span># x6 = <span class="hljs-number">1</span>   li就是进行赋值<br>li x7, <span class="hljs-number">2</span># x7 = <span class="hljs-number">2</span><br>add x5, x6, x7# x5 = x6 + x7<br><br>stop:<br>j stop# Infinite loop to stop execution  j跳转，跳转到stop，就死循环，不退出<br><br>.end# End of file<br></code></pre></td></tr></table></figure><h2 id="ADDI"><a href="#ADDI" class="headerlink" title="ADDI"></a>ADDI</h2><p><img src="https://img-blog.csdnimg.cn/30004089845a433fb05d6680fb3c3bdf.png" alt="在这里插入图片描述"><br>使用了<strong>立即数</strong>少了一个寄存器，占12个bit位，用一个立即数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">_start:<br>li x6, <span class="hljs-number">2</span># x6 = <span class="hljs-number">2</span>，li这里就是一个赋值运算的操作<br>addi x5, x6, <span class="hljs-number">1</span># x5 = x6 + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>注意sub没有subi，减一个正数相当于加一个负数</p><h2 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">_start:<br>li x6, <span class="hljs-number">-1</span># x6 = <span class="hljs-number">-1</span><br>li x7, <span class="hljs-number">-2</span># x7 = <span class="hljs-number">-2</span><br>sub x5, x6, x7# x5 = x6 - x7<br></code></pre></td></tr></table></figure><p>和前面的add一样</p><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p><img src="https://img-blog.csdnimg.cn/ad490a52cfb84d5c8af2ca1f9e345faa.png" alt="在这里插入图片描述"></p><h2 id="LUI"><a href="#LUI" class="headerlink" title="LUI"></a>LUI</h2><p>LUI：把一个数左移12位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">_start:<br>lui x5, <span class="hljs-number">0x12345</span><span class="hljs-meta"># int x5 = 0x12345 &lt;&lt; 12</span><br>addi x5, x5, <span class="hljs-number">0x678</span># x5 = x5 + <span class="hljs-number">0x678</span><br></code></pre></td></tr></table></figure><p>最后x5&#x3D;0x12345678</p><h2 id="LI"><a href="#LI" class="headerlink" title="LI"></a>LI</h2><p>LI 赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">li x5, <span class="hljs-number">0x80</span><br></code></pre></td></tr></table></figure><p>x5&#x3D;0x80</p><h2 id="AUIPC"><a href="#AUIPC" class="headerlink" title="AUIPC"></a>AUIPC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">auipc x5, <span class="hljs-number">0x12345</span># x5 = PC + (<span class="hljs-number">0x12345</span> &lt;&lt; <span class="hljs-number">12</span>)<br><br>auipc x6, <span class="hljs-number">0</span># x6 = PC, to obtain the current PC<br></code></pre></td></tr></table></figure><p>有利于构造相对地址<br>auipc就是把一个数左移12位，后再加上pc值</p><h2 id="LA"><a href="#LA" class="headerlink" title="LA"></a>LA</h2><p>常用于加载一个函数或者变量的地址，上面的赋值一个数都可以用li，而赋值地址就只能使用la</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">_start:<br>la x5, _start# x5 = _start<br>jr x5<br></code></pre></td></tr></table></figure><p>这里给x5加载_start地址<br>jr跳转到x5里面，就是死循环</p><h1 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h1><p>and x5,x6,x7按位与操作</p><blockquote><p>x5&#x3D;x6&amp;x7</p></blockquote><p>or x5,x6,x7和c语言或操作</p><blockquote><p>x5&#x3D;x6|7</p></blockquote><p>xor x5,x6,x7异或操作</p><blockquote><p>x5&#x3D;x6^x7</p></blockquote><p>NOT:取反操作</p><blockquote><p>等价于xori rd ,rs ,-1&#x3D;&#x3D;~rs</p></blockquote><p>sll:左移逻辑上，只补0</p><blockquote><p>sll x5,x6,x7<br>x5&#x3D;x6&lt;&lt;x7<br>srl:右移</p></blockquote><p>sra：算术移位</p><h1 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h1><p><strong>内存读取指令</strong>：LOAD，将数据从<strong>内存读取到寄存器</strong>里面<br><strong>内存写指令</strong>：STORE，将数据从<strong>寄存器放到内存</strong>中<br>lw，把把数据从内存里面读取到寄存器里面<br>sw，就是把数据从寄存器里面放到内存里面<br>最典型的就是ra</p><blockquote><p>一个a函数调用b函数<br>b函数需要使用sw将ra值存到内存里面，大部分就是栈顶的位置sp<br>b函数执行完毕，就要把内存栈顶的ra返回到寄存器中，继续我们的使用</p></blockquote><h1 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h1><p><img src="https://img-blog.csdnimg.cn/267df9b718664bdca0208f1c061b69d5.png" alt="在这里插入图片描述"><br>如果条件成立就跳转到最后一个最后一个地址上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># i = 0</span><br><span class="hljs-meta"># while (i &lt; 5) i++;</span><br><br>li x5, <span class="hljs-number">0</span><br>li x6, <span class="hljs-number">5</span><br>loop:<br>addi x5, x5, <span class="hljs-number">1</span><br>bne x5, x6, loop<br></code></pre></td></tr></table></figure><p>bne最后一个就是要跳转的地址<br><img src="https://img-blog.csdnimg.cn/20ae433503fb4ddebb6aef5e794cb37a.png" alt="在这里插入图片描述"></p><h1 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h1><p>JAL（jump and link）<br>语法</p><blockquote><p>JAL RD ,LABEL<br>这里的RD，就是为了跳转回来爱能执行子过程，后面的函数<br>lable就是要跳转到的地方,RD就是label地址处理完之后返回的地址</p></blockquote><p>JALR（jump and link register）</p><blockquote><p>jalr x0, 0(x5)<br>跳转到x5+0的位置，x0保存</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># int a = 1;</span><br><span class="hljs-meta"># int b = 1;</span><br>#<br><span class="hljs-meta"># void sum()</span><br># &#123;<br><span class="hljs-meta">#     a = a + b;</span><br><br># &#125; <br>#<br><span class="hljs-meta"># void _start()</span><br># &#123;<br><span class="hljs-meta">#     sum();</span><br># &#125;<br><br>.text# Define beginning of text section<br>.global_start# Define entry _start<br># _start就是函数的入口<br>_start:<br>li x6, <span class="hljs-number">1</span><br>li x7, <span class="hljs-number">2</span><br>jal x5, sum  <span class="hljs-meta"># call sum, return address is saved in x5，把函数地址保存在x5里面</span><br><br>stop:<br>j stop# Infinite loop to stop execution<br><br>sum:<br>add x6, x6, x7# x6 = x6 + x7<br>jalr x0, <span class="hljs-number">0</span>(x5)<span class="hljs-meta"># return   这里是跳转到x5+0的地址，是要进行相对地址进行处理的</span><br><br>.end# End of file<br></code></pre></td></tr></table></figure><p><strong>J&#x2F;JR</strong> 是不返回的跳转，J&#x2F;JR就是一个伪指令</p>]]></content>
    
    
    <categories>
      
      <category>RISC_V汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编 risc-v</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言初识</title>
    <link href="/2022/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E8%AF%86/"/>
    <url>/2022/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">汇编语言初始</a></li><li><a href="#_3">缺点</a></li><li><a href="#_6">优点</a></li><li><a href="#_10">应用场景</a></li><li><a href="#_14">汇编语言语言语法介绍</a></li><li><ul><li><a href="#label_24">label</a></li><li><a href="#operation_33">operation</a></li><li><a href="#comment_50">comment</a></li></ul></li><li><a href="#_53">汇编指令操作对象</a></li><li><ul><li><a href="#_71">汇编指令编码格式</a></li></ul></li></ul><h1 id="汇编语言初始"><a href="#汇编语言初始" class="headerlink" title="汇编语言初始"></a>汇编语言初始</h1><p>汇编语言是一种<strong>低级</strong>的语言,这个语言更加接近硬件，可以绕开编译器的优化</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p><code>难移植</code>：我们为<code>x86</code>写的汇编语言无法使用在<code>ARM</code>架构下，但是对于高级语言不存在这个问题，高级的语言可以适配在任何<strong>底层硬件架构</strong>之下</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p><code>灵活</code>：对于高级语言，都要受限制于底层的编译器，<code>编译器</code>会对指令进行优化，但是因为汇编语言和硬件打交道，所以可以绕开编译器，做各种自己需要做的事情，不经过编译器的处理<br><code>强大</code>：可以直接对底层硬件进行控制</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>直接访问底层硬件的地方：如写一个操作系统驱动，操作硬件</li><li>对性能极致的优化，不需要借助编译器进行优化</li></ul><h1 id="汇编语言语言语法介绍"><a href="#汇编语言语言语法介绍" class="headerlink" title="汇编语言语言语法介绍"></a>汇编语言语言语法介绍</h1><ul><li>一个完整的RISC-V汇编程序有多条语法（statement）组成</li><li>一条典型的RISC-V汇编语句包含<strong>3部分</strong>组成</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[label:]  [operation] [comment]<br></code></pre></td></tr></table></figure><blockquote><p><strong>.S</strong>里面会保护一些预处理的指令<br><strong>.s</strong>里面包含的就是纯粹的汇编指令<br><strong>.asm</strong>里面会有一些注释，其他内容都一样</p></blockquote><h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p><code>label</code>可以理解为一个<strong>地址</strong>，不过给那个地址起了一个名字,任何以“**:<strong>”结尾都是label<br>例如：看下面的代码<br>我们在汇编里面没有</strong>函数名<strong>这个概念，函数名对应的就是该函数所在的地址，我们把这个地址命名为</strong>label**，所以我们用这个函数名就能够定位到我们需要的函数体里面<br><img src="https://img-blog.csdnimg.cn/fc5d8382700049e2b91d1b6a758fe16a.png" alt="在这里插入图片描述"><br>_start:<br>stop:<br>这两个都是label，其实都是对地址起了别名</p><h2 id="operation"><a href="#operation" class="headerlink" title="operation"></a>operation</h2><p><strong>instruction(指令)</strong>：直接对应二进制机器指令的字符串<br><strong>pseudo-instruction（伪指令）</strong>：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生的多条实际指令（instruction）</p><blockquote><p>伪指令，方便我们使用，类似就是把一个复杂的指令起了一个别名，汇编器能把他进行分解转化成真正的机器指令进行处理,<br>类似linux中alias ll&#x3D;ls -l<br>还有li，sw，lw这些其实都是把一些指令起了一个别名，方便我们使用，提高效率</p></blockquote><p><strong>directive（指示&#x2F;伪操作）</strong>：通过类似指令的形式（以“.”开头），通知汇编器如何控制代码的产生，不对应任何具体的指令，只是<strong>汇编器</strong>里面的东西<br><img src="https://img-blog.csdnimg.cn/9f0c1fa5dbb5435a905e3d8e0b949eed.png" alt="在这里插入图片描述">  </p><p>.macro<br>.endm<br>.text<br>这些都是一个<strong>directive</strong></p><p><strong>macro</strong>：采用.macro&#x2F;.endm自定义的宏，就类似于C语言的宏</p><h2 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h2><p>#开头往后的所有内容都是注释</p><h1 id="汇编指令操作对象"><a href="#汇编指令操作对象" class="headerlink" title="汇编指令操作对象"></a>汇编指令操作对象</h1><p><strong>寄存器</strong></p><ul><li>32个通用寄存器，x0～x31（RV32I（risc-v32位下的整数指令集）通用寄存器组），这里的每个寄存器都是32位</li><li>在risc-v中hart在执行算术逻辑运算时所操作的数据必须来自寄存器<br><img src="https://img-blog.csdnimg.cn/992d680325e944fe86b04a9873861313.png" alt="在这里插入图片描述"></li></ul><blockquote><p><strong>xlen&#x3D;32</strong>,因为是32位risc-v器，所以最低位为0,最高位为31<br><strong>x0</strong>这个寄存器是一个特殊寄存器，不能对他进行写操作，我们读取出来的数据一定是<strong>0</strong><br>其他寄存器都是可读可写的<br>pc寄存器，是不能进行访问的，内部是原来保存当前程序执行到哪个位置 的概念program counter，程序计算器</p></blockquote><blockquote><p><strong>hart</strong>在执行算术逻辑运算时所操作的数据必须来自寄存器，处理完数据之后，先放到寄存器里面，保存下来，也要从寄存器里面再搬出去，放到别的地方去</p></blockquote><p><strong>内存</strong></p><ul><li>Hart可以执行在寄存器和内存之间的数据读写的操作</li><li>读写操作使用字节为基本单位进行寻址</li><li>rv32最多可以访问2^32个字节的内存空间</li></ul><h2 id="汇编指令编码格式"><a href="#汇编指令编码格式" class="headerlink" title="汇编指令编码格式"></a>汇编指令编码格式</h2><p><img src="https://img-blog.csdnimg.cn/ad90fa38a4114b819baa76dd70bbffd5.png" alt="在这里插入图片描述"></p><blockquote><ol><li>指令长度：<strong>ILEN1</strong>=32bits</li><li>指令对齐：<strong>IALIGN</strong>=32bits</li><li>32个bit划分成不同的<strong>域（field）</strong></li><li>func3&#x2F;func7和opcode共同决定了最终的指令类型</li><li>指令在内存中按照<strong>小端序</strong>排列</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/29c359a177a348cb967618a299b3401b.png" alt="在这里插入图片描述"><br>这个是对opcode7个bit位的描述</p><blockquote><p>opcode最后两位都是11<br>[2,4]位为一组<br>[5,6]为一组<br>我们观察上面add的opcode[2,4]&#x3D;100,[5,6]&#x3D;01,对比下面的指令，我们发现他对应的就是OP，说明ADD是一个基本指令<br><img src="https://img-blog.csdnimg.cn/5464506fd44e4555991e83e72ae0f399.png" alt="在这里插入图片描述"><br>6种指令格式</p><ul><li>R-TYPE：每条指令中有<strong>3个field</strong>*，用于指定<strong>3个寄存器参数</strong>，rs，rd</li></ul><blockquote><p>rs:register source ,rd:register destination,例如a+b&#x3D;c，则rs里面存放a，b；rd里面存放的是c，使用5个bit，代表是32位</p></blockquote></blockquote><p><img src="https://img-blog.csdnimg.cn/8c65b5c7169f40cda1ee1230add7073a.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW5-,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>常见的伪指令可以查看risc-v：25章</p>]]></content>
    
    
    <categories>
      
      <category>RISC_V汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>1024程序员节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL补充知识</title>
    <link href="/2022/10/25/MySQL%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/10/25/MySQL%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">视图</a></li><li><a href="#_24">用户管理</a></li><li><ul><li><a href="#_34">如何增加普通用户</a></li><li><a href="#_44">如何删除普通用户</a></li><li><a href="#_45">如何给用户赋权</a></li><li><a href="#_59">如何给用户取消权限</a></li><li><a href="#_65">删除用户</a></li><li><a href="#_74">刷新</a></li></ul></li><li><a href="#_81">图形化</a></li><li><a href="#CMySQL_94">C语言连接MySQL</a></li></ul><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是一个虚拟表，其内容由查询定义，同真实的表一样，视图包含一系列带有名称的列和行结构</p><p>把查询的结构形成一个新的表<br>如下把用户查询的结果当作新 表，myview</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> myview <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> ename,job <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6e0cfa71acc646dabd9e4279f6db8603.png" alt="在这里插入图片描述"><br>这里面查询的结果就是之前查询的结果，把查询的结果临时保存起来<br><img src="https://img-blog.csdnimg.cn/2aa511db98bd4b06bbc934a0a898fd73.png" alt="在这里插入图片描述"></p><p>我们在修改myview里面的数据的时候，其实就是对原始表的数据进修修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> myview <span class="hljs-keyword">set</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SMITH&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个表就相当于做了一个中间的媒介<br><img src="https://img-blog.csdnimg.cn/a6c8ee928ea34f858c9ce371df784900.png" alt="在这里插入图片描述"><br>我们修改这个视图，会影响基表<br>删除这个视图，不会影响原表的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> myview;<br></code></pre></td></tr></table></figure><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>如果我们每次都只能使用root，这样会存在安全隐患，这是，就需要使用MySQL的用户管理<br>用户（root，张三，李四），和Linux差不多，用户权限的概念</p><p>用户管理都在一张表里面</p><ul><li><code>host</code>:代表这个用户可以从哪个主机登录</li><li><code>user</code>:用户名</li><li><code>authentication_string</code>:用户密码通过password函数加密之后</li><li><code>*_priv</code>:用户拥有的权限</li></ul><h2 id="如何增加普通用户"><a href="#如何增加普通用户" class="headerlink" title="如何增加普通用户"></a>如何增加普通用户</h2><p>创建用户同时设置密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;xzw&#x27;</span>@<span class="hljs-string">&#x27;127.0.0.1&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;12345678&#x27;</span>;<br></code></pre></td></tr></table></figure><p>登录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>u<span class="hljs-string">&#x27;username&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="如何删除普通用户"><a href="#如何删除普通用户" class="headerlink" title="如何删除普通用户"></a>如何删除普通用户</h2><h2 id="如何给用户赋权"><a href="#如何给用户赋权" class="headerlink" title="如何给用户赋权"></a>如何给用户赋权</h2><p>grant 权限列表 on 库,to对象名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-number">102</span>db.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> xzw@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>给这个用户添加一个select权限</p><p>grant all 添加所有权限,设置所有权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;hostname&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="如何给用户取消权限"><a href="#如何给用户取消权限" class="headerlink" title="如何给用户取消权限"></a>如何给用户取消权限</h2><p>revoke from对应添加权限里面的grant 和to</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span>  <span class="hljs-operator">*</span> . <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test_db @<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> username;<br></code></pre></td></tr></table></figure><p>这个比较明确</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> username@<span class="hljs-string">&#x27;hostname&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><p>修改完数据之后，要刷新一下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush privileges;<br></code></pre></td></tr></table></figure><h1 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h1><p>使用图形化界面来访问MySQL<br>MySQL Workbench：可以支持远程连接</p><ol><li>MySQL workbench +Windows（mysql）：不跨网络</li><li>MySQL workbench+Linux（mysql）：跨网络（比较仿真的），不太完全的，配置端口号，把root密码设计复杂<br>但是我们服务器没什么东西，无所谓</li></ol><p>开放端口才能链接上网络<br>mysql 一般都要修改端口号</p><p>我们从官网下载的安装包<br>在特定的项目的路径下面建立软连接</p><h1 id="C语言连接MySQL"><a href="#C语言连接MySQL" class="headerlink" title="C语言连接MySQL"></a>C语言连接MySQL</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">ln -s ~/mysql-connector-c<span class="hljs-number">-6.1</span><span class="hljs-number">.11</span>-linux-glibc2<span class="hljs-number">.12</span>-x86_64/include include<br>ln -s ~/mysql-connector-c<span class="hljs-number">-6.1</span><span class="hljs-number">.11</span>-linux-glibc2<span class="hljs-number">.12</span>-x86_64/lib lib        <br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mysql:test.cc<br>g++ test.cc -o mysql -<span class="hljs-built_in">std</span>=c++<span class="hljs-number">11</span> -I./include -L./lib -lmysqlclient<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql/mysql.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cout&lt;&lt;<span class="hljs-string">&quot;client version: &quot;</span>&lt;&lt;<span class="hljs-built_in">mysql_get_client_info</span>()&lt;&lt;endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建MySQL句柄</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MYSQL *my = <span class="hljs-built_in">mysql_init</span>(<span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><ul><li>连接数据库</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">mysql_real_connect</span>(my, host.<span class="hljs-built_in">c_str</span>(), user.<span class="hljs-built_in">c_str</span>(), password.<span class="hljs-built_in">c_str</span>(), db.<span class="hljs-built_in">c_str</span>(), port, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//失败返回nullptr，成功就链接上了</span><br></code></pre></td></tr></table></figure><ul><li>设置字符集</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">mysql_set_character_set</span>(my, <span class="hljs-string">&quot;utf8&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>访问数据库的操作</li></ul><p>  所有对数据库的操作都是使用这一个函数进行操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">int</span> res <span class="hljs-operator">=</span> mysql_query(my, sql.c_str()); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>执行数据库操作,成功返回<span class="hljs-number">0</span>，失败返回<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>获得select执行的结果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MYSQL_RES* result=<span class="hljs-built_in">mysql_store_result</span>(my);<span class="hljs-comment">//获取最近一次的数据结果,把查询的结果都放在MYSQL_RES里面</span><br></code></pre></td></tr></table></figure><ul><li>获取列数和行数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> rows=<span class="hljs-built_in">mysql_num_rows</span>(result);<span class="hljs-comment">//获取执行结果的行数</span><br><span class="hljs-type">int</span> cols=<span class="hljs-built_in">mysql_num_fields</span>(result);<span class="hljs-comment">//获取结果的列数</span><br></code></pre></td></tr></table></figure><ul><li>获得表中列名,表名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MYSQL_FIELD* field=<span class="hljs-built_in">mysql_fetch_field</span>(result);<span class="hljs-comment">//field里面就是所有的列名字</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cols;i++)<br>&#123;<br>  cout&lt;&lt;field[i].name&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印数据库里面的每个数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//我们最重要的是获取表中的数据</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)<br>&#123;<br>  MYSQL_ROW line=<span class="hljs-built_in">mysql_fetch_row</span>(result);<span class="hljs-comment">//这个MYSQL_ROW实际上就是一个二维数组,获取完整的一行记录</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++)<br>  &#123;<br>    cout&lt;&lt;line[j]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<span class="hljs-comment">//将记录内部的多列字符串，依次打印</span><br>  &#125;<br>  cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql/mysql.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string host = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;        <span class="hljs-comment">//登录的主机</span><br>string user = <span class="hljs-string">&quot;root&quot;</span>;             <span class="hljs-comment">//登录的用户</span><br>string password = <span class="hljs-string">&quot;@xzw108858!!&quot;</span>; <span class="hljs-comment">//登录密码</span><br>string db = <span class="hljs-string">&quot;db1&quot;</span>;                <span class="hljs-comment">//连接到这个数据库里面</span><br><span class="hljs-type">int</span> port = <span class="hljs-number">3306</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;client version: &quot;</span> &lt;&lt; <span class="hljs-built_in">mysql_get_client_info</span>() &lt;&lt; endl;<br>  <span class="hljs-comment">// 1.连接数据库</span><br>  <span class="hljs-comment">// 2. 访问数据库</span><br>  <span class="hljs-comment">// 3. 关闭数据库</span><br>  <span class="hljs-comment">//创建mysql句柄</span><br>  MYSQL *my = <span class="hljs-built_in">mysql_init</span>(<span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-comment">//连接上数据库,这里连接上默认选择的字符串形式是latin</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">mysql_real_connect</span>(my, host.<span class="hljs-built_in">c_str</span>(), user.<span class="hljs-built_in">c_str</span>(), password.<span class="hljs-built_in">c_str</span>(), db.<span class="hljs-built_in">c_str</span>(), port, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;connect fail&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//这里链接上去之后，要设置支付格式</span><br>  <span class="hljs-built_in">mysql_set_character_set</span>(my, <span class="hljs-string">&quot;utf8&quot;</span>);<br>  <span class="hljs-comment">//这里我们就连接上去了</span><br><br>  cout &lt;&lt; <span class="hljs-string">&quot;connect success&quot;</span> &lt;&lt; endl;<br><br>  <span class="hljs-comment">//访问数据库</span><br>  <span class="hljs-comment">// string sql=&quot;delete from myclass where name=\&#x27;主\&#x27;&quot;;//写入一个sql语句</span><br>  string sql = <span class="hljs-string">&quot;select * from myclass where room=\&#x27;ds\&#x27;&quot;</span>;<br>  <span class="hljs-type">int</span> res = <span class="hljs-built_in">mysql_query</span>(my, sql.<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">//执行数据库操作</span><br><br>  <span class="hljs-comment">//select 需要获取执行结果</span><br>  MYSQL_RES* result=<span class="hljs-built_in">mysql_store_result</span>(my);<span class="hljs-comment">//获取最近一次的数据结果</span><br><br>  cout &lt;&lt; res &lt;&lt; endl;<br>  <span class="hljs-keyword">if</span> (res)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;faliue&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-comment">//使用完，把句柄关闭</span><br>  <span class="hljs-comment">// select 是最不好处理的，执行完，需要对数据进行进一步解析</span><br><br>  <span class="hljs-comment">//获取行号和列号</span><br>  <span class="hljs-type">int</span> rows=<span class="hljs-built_in">mysql_num_rows</span>(result);<span class="hljs-comment">//获取执行结果的行数</span><br>  <span class="hljs-type">int</span> cols=<span class="hljs-built_in">mysql_num_fields</span>(result);<span class="hljs-comment">//获取结果的列数</span><br>  cout&lt;&lt;<span class="hljs-string">&quot;行数=&quot;</span>&lt;&lt;rows&lt;&lt;<span class="hljs-string">&quot;列数=&quot;</span>&lt;&lt;cols&lt;&lt;endl;<br><br>  <span class="hljs-comment">//获取表中列名</span><br>  MYSQL_FIELD* field=<span class="hljs-built_in">mysql_fetch_field</span>(result);<span class="hljs-comment">//field里面就是所有的列名字</span><br>  <span class="hljs-comment">//打印出列的名字，这个我们一般不用</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cols;i++)<br>  &#123;<br>    cout&lt;&lt;field[i].name&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>  &#125;<br>  cout&lt;&lt;endl;<br><br>  <span class="hljs-comment">//我们最重要的是获取表中的数据</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)<br>  &#123;<br>    MYSQL_ROW line=<span class="hljs-built_in">mysql_fetch_row</span>(result);<span class="hljs-comment">//这个MYSQL_ROW实际上就是一个二维数组,获取完整的一行记录</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++)<br>    &#123;<br>      cout&lt;&lt;line[j]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<span class="hljs-comment">//将记录内部的多列字符串，依次打印</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>  &#125;<br><br>  <span class="hljs-built_in">free</span>(result);<span class="hljs-comment">//使用完就需要把获取的东西，进行释放，避免内存泄漏</span><br>  <span class="hljs-built_in">mysql_close</span>(my);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2022/10/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2022/10/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_3">前导</a></li><li><a href="#_10">布隆过滤器</a></li><li><ul><li><a href="#_11">特点</a></li><li><a href="#_14">映射方式</a></li><li><a href="#hash__25">hash 函数</a></li><li><a href="#BloomFilter_86">BloomFilter</a></li><li><ul><li><a href="#set_98">set</a></li><li><a href="#test_121">test</a></li><li><a href="#reset_150">reset</a></li><li><a href="#_163">相关问题</a></li></ul></li><li><a href="#_173">应用</a></li><li><ul><li><a href="#_191">示例</a></li><li><ul><li><a href="#_197">哈希切分</a></li><li><ul><li><a href="#_214">例子</a></li></ul></li></ul></li></ul></li></ul></li></ul><p>今天是1024程序员节,祝各位节日快乐啦!!!</p><h1 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h1><p>我们之前使用位图<code>bitset</code>,只能将一个整数映射到比特位上，来判断某个数是否存在</p><p>但是假如我们也想把判断一个字符串是否存在呢？<br>我们如何一个字符串映射到一个位置上，应该这么操作呢？<br>所以就出现了今天要介绍的<code>布隆过滤器</code></p><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>对于不存在的值，查找一定是不存在</li><li>对于存在的值，查找可能会不准确</li></ul><h2 id="映射方式"><a href="#映射方式" class="headerlink" title="映射方式"></a>映射方式</h2><p>我们之前学过<code>hash</code>，字符串映射可以有字符串映射的hash函数，把对应的字符串映射到某个位置上，但是如果我们也使用那样的方式会出现什么问题呢？</p><blockquote><ol><li>对于不存在的字符串，我们使用hash检测，没有问题</li><li>但是对于存在的自负床，那么就有可能会出现hash冲突的，可能会出现误判，</li></ol></blockquote><p>这里我们无法解决冲突的问题，那么我们就要尽可能的降低冲突</p><p>所以我们就要对一个字符串使用多个hash函数映射 ，映射到不同的地方，来降低冲突</p><p><img src="https://img-blog.csdnimg.cn/d8d63b84589948b088d2c3b762f054e0.png" alt="在这里插入图片描述"></p><h2 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash 函数"></a>hash 函数</h2><p>这里我们运用3个hash函数,来索引到不同的位置</p><p><code>BKDRHash</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BKDRHash</span> <span class="hljs-comment">//特化，全特化,这个是最强的</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : key)<br>        &#123;<br>            ret *= <span class="hljs-number">31</span>;<br>            ret += e;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>APHashs</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">APHash</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> hash = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">size_t</span> ch;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<br>            &#123;<br>                hash ^= ((hash &lt;&lt; <span class="hljs-number">7</span>)) ^ s[i] ^ (hash &gt;&gt; <span class="hljs-number">3</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                hash ^= (~(hash &lt;&lt; <span class="hljs-number">11</span>)) ^ s[i] ^ (hash &gt;&gt; <span class="hljs-number">5</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hash;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>DJBHash</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DJBHash</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> hash = <span class="hljs-number">5381</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s)<br>        &#123;<br>            hash += (hash &lt;&lt; <span class="hljs-number">5</span>) + ch;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hash;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> N, <span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span> = string, <span class="hljs-keyword">class</span> HashFunc1 = BKDRHash, <span class="hljs-keyword">class</span> HashFunc2 = APHash, <span class="hljs-keyword">class</span> HashFunc3 = DJBHash&gt; <span class="hljs-comment">//给个默认类型,一个值我们让他映射3个位置</span><br><span class="hljs-keyword">class</span> BloomFilter<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    bitset&lt;N * <span class="hljs-number">4</span>&gt; _bs; <span class="hljs-comment">//给个模板参数，要开多少bit位</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>把一个字符串设置进bloomfilter里面<br>因为我们使用了3个函数函数映射了3个位置，同时还要和开辟的bit位进行取模，映射到对应的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//标记成存在</span><br>    HashFunc1 h1;<br>    HashFunc2 h2;<br>    HashFunc3 h3;<br><br>    <span class="hljs-type">size_t</span> len = <span class="hljs-number">4</span> * N;<br>    <span class="hljs-type">size_t</span> index1 = <span class="hljs-built_in">h1</span>(key) % len;<br>    <span class="hljs-type">size_t</span> index2 = <span class="hljs-built_in">h2</span>(key) % len;<br>    <span class="hljs-type">size_t</span> index3 = <span class="hljs-built_in">h3</span>(key) % len;<br><br>    _bs.<span class="hljs-built_in">set</span>(index1);<br>    _bs.<span class="hljs-built_in">set</span>(index2);<br>    _bs.<span class="hljs-built_in">set</span>(index3);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><blockquote><p>因为我们映射到了3个不同的位置，所以如果一个索引位不在，就不在，但是如果3个索引位都在，它大概率就在，但也会出现误判</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//因为我们映射到了3个位置，所以一个在不能说明它就在，但是如果一个不在，他就不在</span><br>    HashFunc1 h1;<br>    HashFunc2 h2;<br>    HashFunc3 h3;<br><br>    <span class="hljs-type">size_t</span> len = <span class="hljs-number">4</span> * N;<br>    <span class="hljs-type">size_t</span> index1 = <span class="hljs-built_in">h1</span>(key) % len;<br>    <span class="hljs-type">size_t</span> index2 = <span class="hljs-built_in">h2</span>(key) % len;<br>    <span class="hljs-type">size_t</span> index3 = <span class="hljs-built_in">h3</span>(key) % len;<br>    <span class="hljs-comment">// cout &lt;&lt; index1 &lt;&lt; endl;</span><br>    <span class="hljs-comment">// cout &lt;&lt; index2 &lt;&lt; endl;</span><br>    <span class="hljs-comment">// cout &lt;&lt; index3 &lt;&lt; endl;</span><br>    <span class="hljs-keyword">if</span> (_bs.<span class="hljs-built_in">test</span>(index1) == <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (_bs.<span class="hljs-built_in">test</span>(index2) == <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (_bs.<span class="hljs-built_in">test</span>(index3) == <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//前面只要有一个位不在，就是不在</span><br>    <span class="hljs-comment">//走到这里，就是三个位都存在，但是也可能会出现误判</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>我们需要删除吗？</p><blockquote><p>其实对于bloom过滤器来说，我们不需要删除</p></blockquote><p>原因</p><ul><li>把对应的位删除,删除自己的同时可能会把和别人冲突的位也删掉了，会影响到别的值</li></ul><p>那么如何扩展一下，使得布隆过滤器能够支持删除</p><ul><li>每个位置存储多个bit位，存储引用计数，（有多少个值映射到了当前的位置）<br>缺点</li><li>使用引用计数可以支持删除，但是整体消耗空间变多了，达不到我们的目的，所以我们还是尽量不支持删除</li></ul><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul><li>如何选择哈希函数,布隆过滤器的长度</li></ul><blockquote><ol><li>一个数映射到多个位置,我们给的布隆过滤器长度偏小,很容易映射满,出错率高,所以布隆过滤器长度大,出错率低</li><li>哈希函数越多,映射位置越多,准确性高,但是效率低,所以哈希函数个数和效率成反比,和准确率成正比</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/6e42dcfd07bb4985a3bb20f0aed347fc.png" alt="在这里插入图片描述">* 公式<br><img src="https://img-blog.csdnimg.cn/ae9a36feccaa4a66872e97fba51a548a.png" alt="在这里插入图片描述">k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>使用场景</p><blockquote><p><strong>数据量大</strong>，<strong>节省空间</strong>，<strong>允许误判</strong>，这样的场景，就可以使用布隆过滤器</p></blockquote><ol><li><p>用户注册</p><blockquote><p>用户进行注册页面时候输入<strong>昵称</strong>，<strong>密码</strong><br>按正常逻辑，我们就要在数据库里面对昵称判断是否存在，获得结果返回，但是在数据库操作太慢了，还有网络时延<br>那么我们就可以使用bloomfilter，把所有的数据，加载到里面<br>如果不存在，这是准确的，就可以直接进行操作<br>如果存在，就继续到数据库里面进行判断</p></blockquote></li><li><p>垃圾邮件</p></li></ol><blockquote><p>如果是垃圾邮件，就可以把它放到一个垃圾邮箱里面，就标记一个黑名单，放到布隆过滤器里面，<br>以后接收邮件，就判断该人是否在黑名单里面，在就不收，否则就收</p></blockquote><p>总结：利用布隆过滤器可以减少和磁盘的IO，或者网络请求，因为访问本地的数据库速度很慢，更不要说跨网络数据传递<br>这样我们就可以使用布隆过滤器，先进行赛选，不在的话，就没有后续的操作，在的话再去准确的查询</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>给两个文件，分别由100亿个query，我们只有1G内存，如何找到两个文件的交集？分别用精确和近似的算法</p><blockquote><p><strong>近似</strong>：把这分别的两份100亿的query查询都放进布隆过滤器，两个地方都存在就是交集，都不存在就不是交集,这个时候是近似的交集(但是会存在不是交集的进去)</p></blockquote><p>但是如果想要使用准确的算法,我们就需要使用哈希切分</p><h4 id="哈希切分"><a href="#哈希切分" class="headerlink" title="哈希切分"></a>哈希切分</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs erlang">哈希切分就可以实现精确查询<br>A           B<br>假设A有<span class="hljs-number">100</span>G，那么切成多份，但是我们需要使用哈希切，而不是平均切<br>读取<span class="hljs-keyword">query</span>，使用hash算法，如i=BKDRhash（<span class="hljs-keyword">query</span>）<span class="hljs-comment">%200;我们要创建是200个小文件</span><br>这个<span class="hljs-keyword">query</span>就进入ai好的小文件<br><br>同样B也是一样的<br><br>这样相同的就进入同一个小文件<br>Ai和Bi小文件找交集即可:因为相同的<span class="hljs-keyword">query</span>一定进入了编号相同的小文件<br>这样就加载到内存，放进set相同就有，不同就没<br><br>有可能有的桶很大，有的桶很小，找交集不好找<br>如果Ai和Bi都太大，超过内存，可以考虑换个哈希算法，再切分一次，<br></code></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;u&gt;一个超过<span class="hljs-number">100</span>G的<span class="hljs-keyword">log</span> file <span class="hljs-keyword">log</span>中存这IP地址，涉及算法找到出现次数最多的IP(统计次数)，如何找到TOPK的IP，如何直接使用Linux系统命令&lt;/u&gt;<br><br> 一次读取ip,i=BKDRHash(ip)%<span class="hljs-number">200</span>;<span class="hljs-comment">//分成100份</span><br> i是多少，ip就进入对应的编号的i小文件里面<br> 相同的ip一定进入了同一个小文件，那么我们使用<span class="hljs-built_in">map</span>统计一个小文件中的ip的次数，就是它准确的次数<br> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>,int&gt; maxCountIP<br><br> 出现次数最多的<span class="hljs-number">10</span>个ip<br> priority_queue&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>,int&gt;,vector&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>,int&gt;&gt;,greater&gt; minhead;小堆<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>1024程序员节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++位图</title>
    <link href="/2022/10/23/C++%E4%BD%8D%E5%9B%BE/"/>
    <url>/2022/10/23/C++%E4%BD%8D%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#bit_set_8">bit_set的模拟实现</a></li><li><a href="#_54">位图的应用</a></li></ul><p>我们如果要查看100亿个数中某个数是否存在是完全不合理的，内存根本存放不下这么多的数，会爆炸<br>这样我们就可以用一个bit位来代表一个数<br>例如一个字节8个bit位，其中如果第2位被设置成1，说明2，这个数存在<br>这个也是一种映射关系</p><p>但是位图只能处理整数，这个就是它最大的问题</p><h1 id="bit-set的模拟实现"><a href="#bit-set的模拟实现" class="headerlink" title="bit_set的模拟实现"></a>bit_set的模拟实现</h1><ul><li>bitset里面的成员对象我们设置为vector里面是char，可以对里面的比特位进行操作</li><li>通过计算在第几个char中第几个位里面</li><li>运用位运算来进行置1，或置0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;HashTable.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> N&gt; <span class="hljs-comment">//设置开多大的空间,这里的空间，指的是开多少个bit位</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bit_set</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// vector&lt;int&gt; _bits;  //一个字节8个bit位</span><br>    vector&lt;<span class="hljs-type">char</span>&gt; _bits; <span class="hljs-comment">//</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bit_set</span>()<br>    &#123;<br>        _bits.<span class="hljs-built_in">resize</span>(N / <span class="hljs-number">8</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//我们就多浪费一个字节,都初始化成0</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span> <span class="hljs-comment">//把对应的x位设置成1</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//先计算x在第几个char里面</span><br>        <span class="hljs-type">size_t</span> i = x / <span class="hljs-number">8</span>;<br>        <span class="hljs-comment">//再计算，它再这个的第几个bit位</span><br>        <span class="hljs-comment">//直接%就行了</span><br>        <span class="hljs-type">int</span> j = x % <span class="hljs-number">8</span>; <span class="hljs-comment">//在第j个bit位里面</span><br>        <span class="hljs-comment">//直接把它和那个数进行或一下</span><br>        _bits[i] |= (<span class="hljs-number">1</span> &lt;&lt; j); <span class="hljs-comment">//把这个1左移j位</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span> <span class="hljs-comment">//把对应的x位设置成0</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//进行按位与</span><br>        <span class="hljs-type">size_t</span> i = x / <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> j = x % <span class="hljs-number">8</span>;<br>        _bits[i] &amp;= (~(<span class="hljs-number">1</span> &lt;&lt; j)); <span class="hljs-comment">// 把上面的取反即可</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span> <span class="hljs-comment">//查找一下这个数是存在</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> i = x / <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> j = x % <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">bool</span>)_bits[i] &amp; (~(<span class="hljs-number">1</span> &lt;&lt; j)); <span class="hljs-comment">//这样不会改变上面的bits里面的值,如果存在的话就会返回1，不存在就会返回0</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="位图的应用"><a href="#位图的应用" class="headerlink" title="位图的应用"></a>位图的应用</h1><ol><li>给定100亿个数，设计算法，找到只出现一次的整数<br>思路我们可以使用两个位图，组成00，01，10，11序列</li></ol><p>我们只要用这个判断出现的是01即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">twobit</span><br>&#123;<br>    <span class="hljs-comment">//00代表没有</span><br>    <span class="hljs-comment">//01代表1个</span><br>    <span class="hljs-comment">//10代表2个</span><br><span class="hljs-keyword">private</span>:<br>    bit_set&lt;N&gt; bts1;<span class="hljs-comment">//左边的0</span><br>    bit_set&lt;N&gt; bts2;<span class="hljs-comment">//右边的0</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x)</span><span class="hljs-comment">//用两个bit位来表示,上层添加了一个数</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!bts1.<span class="hljs-built_in">find</span>(x)&amp;&amp;!bts2.<span class="hljs-built_in">find</span>(x))<br>        &#123;<br>            <span class="hljs-comment">//00</span><br>            bts2.<span class="hljs-built_in">set</span>(x);     <span class="hljs-comment">//第一个0不变，第二个变为1</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!bts1.<span class="hljs-built_in">find</span>(x)&amp;&amp;bts2.<span class="hljs-built_in">find</span>(x))<span class="hljs-comment">//已经出现了一次了</span><br>        &#123;<br>            <span class="hljs-comment">//01</span><br>            bts2.<span class="hljs-built_in">reset</span>(x);<span class="hljs-comment">//第二个变为0</span><br>            bts1.<span class="hljs-built_in">set</span>(x);<span class="hljs-comment">//第一变为1</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//这个地方就是已经出现了很多次</span><br>            bts2.<span class="hljs-built_in">set</span>(x);<br>            bts1.<span class="hljs-built_in">reset</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintOnceNum</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!bts1.<span class="hljs-built_in">find</span>(i)&amp;&amp;bts2.<span class="hljs-built_in">find</span>(i))<br>            &#123;<br>                <span class="hljs-comment">//打印是01的数字</span><br>                <span class="hljs-comment">//这个就是只出现一次</span><br>                cout&lt;&lt;i&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>给两个文件，分别由100亿个整数，我们只有1G内存，如何找到两个文件的交集</li></ol><ul><li>法1：一个文件中的整数，set到一个位图，读取第二个整数是否在一个位图，在就有，不在就没有交集,这个就要用O（N），交集中，会把重复值找出来，多次出现</li><li>法2：思路2，读取一个整数设计到位图bs1，再把另一个文件中的整数，set到位图bs2，a.把bs1中的值，一次和bs2中的值进行与一下，再去看，与完是1的位置的值，就是交集,全1是1</li></ul><ol start="3"><li>一个文件中100亿个int，1g内存，找到出现次数不超过2次的整数，<br>这个方法的思路和上面只出现一次的思路很相似<br>但是这次是用3个bit位进行操作</li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/2022/10/21/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/10/21/MySQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_11">什么是事务</a></li><li><a href="#_35">为什么会出现事务</a></li><li><a href="#_41">事务的版本支持</a></li><li><a href="#_46">事务的提交方式</a></li><li><a href="#_74">实验演示</a></li><li><ul><li><a href="#_75">正常演示</a></li><li><a href="#_134">非正常演示</a></li></ul></li><li><a href="#_169">事务隔离级别</a></li><li><ul><li><a href="#mysql_170">理解mysql服务</a></li><li><a href="#_192">查看设置隔离级别</a></li><li><a href="#_211">隔离级别</a></li><li><ul><li><a href="#_212">读提交</a></li><li><a href="#_224">可重复读</a></li><li><a href="#_233">串行化</a></li><li><a href="#_235">隔离性</a></li></ul></li></ul></li><li><a href="#_246">一致性</a></li></ul><p>数据库作为一个网络服务器，我们在操作的时候，别人也可以在操作，我们进行增删改查的时候，别人也可以进行增上改查，所以可能会不安全，会出现多执行流<br>例如</p><blockquote><p>在买票的时候，当A检查到还有一张票，将票卖掉，此时，数据库还没有更新，客户端B检查了票数，发现大于0，于是又卖了一张票，然后A将票数更新了，发现一张票被卖了两次</p></blockquote><p>CURD满足的属性</p><ol><li>买票的过程必须是原子的（原子性）</li><li>买票相互之间不能影响（隔离性）</li><li>买完票要永久有效（持久性）</li><li>买前，买后都必须要是确定的状态（一致性）</li></ol><h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>[Transaction]<br>事务本质就是一组SQL语句，理论上，事务本就不应该属于MySQL，而是应该在应用层上面，完成的一件事情，完成一系列相关操作的sql语句集合叫做事务</p><blockquote><p>假如说你从学校毕业了，那么学校教务系统，后台的MySQL中就不需要你的信息了，那么管理员会运行几条sql命令来输出你的（姓名，电话，籍贯等信息），同时还有一些sql操作输出你的成绩，这些操作组合起来，就构成了一个”事务”</p></blockquote><p>事务&#x3D;原子性的操作多条的sql语句</p><p><img src="https://img-blog.csdnimg.cn/4af9beddae954042ab0c857b139f6ef1.png" alt="在这里插入图片描述"><br>再比如：</p><blockquote><p>张三给李四转账200<br>张三的账户余额update减少200，李四的账户余额update增加200，在数据库角度是执行两条sql<br>所有的sql操作，一般都会被mysql包装成事务，无论是一条还是多条的sql，都是一样的对待的</p></blockquote><p>一个完整的事务，绝不是简单的sql集合，还必须要满足4条属性ACID</p><ul><li><strong>原子性</strong>（atomicity，或称不可分割性),</li></ul><blockquote><p>执行一条sql，要么全部都执行完，要么全部不完成，而一旦事务在执行的时候出现了错误，就回滚（rollback），到事务开始前的状态，前面成功的sql也取消掉，就像这个事情没有发生过一样</p></blockquote><ul><li><strong>一致性</strong>：(Consistency):</li></ul><blockquote><p>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。<br>比如：如果从A账户转账到B账户，不可能因为A账户扣了钱，而B账户没有加钱</p></blockquote><ul><li><strong>隔离性</strong>：(isolation,又称独立性):</li></ul><blockquote><p>允许多个事务同时处理任务的时候，不影响别人</p></blockquote><ul><li><strong>持久性</strong>：(durablity):</li></ul><blockquote><p>数据库把数据更新完，数据的修改必须是持久的，不会因为系统故障而丢失</p></blockquote><h1 id="为什么会出现事务"><a href="#为什么会出现事务" class="headerlink" title="为什么会出现事务"></a>为什么会出现事务</h1><p>事务是被MySQL设计出来，为了当应用程序访问数据库的时候，事务可以简化我们的编程模型，不需要我们去考虑各种并发各种潜在错误，<br>所以当我们去使用事务的时候，要么提交，要么回滚，不会考虑网络中断的问题，</p><p>我们后面就把MySQL里面的一行信息称为一行记录</p><h1 id="事务的版本支持"><a href="#事务的版本支持" class="headerlink" title="事务的版本支持"></a>事务的版本支持</h1><p>MySQL只有innodb支持事务，mysiam不支持事务,这就是我们使用innodb的原因，mysiam适合查询检索retrieve</p><p><img src="https://img-blog.csdnimg.cn/9f05061324944f20b4f117b7de1da29c.png" alt="在这里插入图片描述"></p><h1 id="事务的提交方式"><a href="#事务的提交方式" class="headerlink" title="事务的提交方式"></a>事务的提交方式</h1><p>事务的提交有两种：</p><ul><li>自动提交</li><li>手动提交</li></ul><p>  查看事务的提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/533fbdd9f0e843acb00c80a78d73a22f.png" alt="在这里插入图片描述"><br>设置为手动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> autocommit<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cb17131d07df406898066b96759c507d.png" alt="在这里插入图片描述"></p><p>设置MySQL的隔离级别设置为未提交，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read uncommitted;<br></code></pre></td></tr></table></figure><p>查看隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@tx</span>_isolation;<br></code></pre></td></tr></table></figure><p>处于R级别</p><p><img src="https://img-blog.csdnimg.cn/cdc7321eadc54246b940e95850a4d653.png" alt="在这里插入图片描述"></p><h1 id="实验演示"><a href="#实验演示" class="headerlink" title="实验演示"></a>实验演示</h1><h2 id="正常演示"><a href="#正常演示" class="headerlink" title="正常演示"></a>正常演示</h2><p>创建一个account表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> account ( id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment, name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, balance <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">default</span> <span class="hljs-number">0.0</span> );<br></code></pre></td></tr></table></figure><p>查看表结构<br><img src="https://img-blog.csdnimg.cn/3f41f7617cbe4fc19c7fdfba43a3ed02.png" alt="在这里插入图片描述"></p><ul><li><p>证明事务的开始和回滚</p><ul><li>启动事务</li></ul><p>  两种方式<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;<br></code></pre></td></tr></table></figure></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br></code></pre></td></tr></table></figure><ul><li>插入一批数据</li></ul><p>  <img src="https://img-blog.csdnimg.cn/ebd94e3fc4f14a30b7e5100f91f0ea3a.png" alt="在这里插入图片描述"></p><ul><li>设置回滚地址</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">savepoint</span>  s1;<br></code></pre></td></tr></table></figure><p>数据操作的一端查看数据<br><img src="https://img-blog.csdnimg.cn/a9c2371df7a54dc7a2857e423139731b.png" alt="在这里插入图片描述"><br>打开的另一个终端也查看数据<br><img src="https://img-blog.csdnimg.cn/e53430b8ac254577878105ca10a898cc.png" alt="在这里插入图片描述"><br>假如说，我们操作的一端后悔插入了赵六,因为我们设置了s2，所以我们可以回滚到s2处，这样就不需要我们去进行删除操作</p><ul><li>回滚到设置的地方</li></ul><p>  这里我们设置回滚到s2地方</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> s2;<br></code></pre></td></tr></table></figure><p>在两个不同的终端查看都是一样的结果</p><p><img src="https://img-blog.csdnimg.cn/eff452cc441546ab9d7848375e658a33.png" alt="在这里插入图片描述"><br>rollback 后面什么都不带就是直接回滚到最开始的地方</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">rollback</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/40941fb2b41e4dffb34537b76e5e0875.png" alt="在这里插入图片描述"></p><ul><li>提交</li></ul><p>  事务结束，就提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/dfd624cbfd2b45cd914f464604d739a0.png" alt="在这里插入图片描述"></p></li></ul><p>总结：<br>命令行启动事务</p><ol><li>start transaction&#x2F;begin</li><li>正常的sql操作</li><li>rollback&#x2F;&#x2F;savepoint&#x2F;rollback to sp</li><li>commit</li></ol><h2 id="非正常演示"><a href="#非正常演示" class="headerlink" title="非正常演示"></a>非正常演示</h2><ul><li>客户端崩溃实验<br><img src="https://img-blog.csdnimg.cn/b73899354fbe40ce9e71bdd0de2103b5.png" alt="在这里插入图片描述"><br>我们插入了一批数据，然后直接让他ctrl &#x2F;,让MySQL崩溃掉</li></ul><p>一方的MySQL关闭了,没有进行commit操作，另一个终端会直接回滚到事务开始前的状态<br><img src="https://img-blog.csdnimg.cn/b5901b28b0ae41aca8ff0a2e13669c9d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d8edec169c8f4dc59c560b6dae0bc002.png" alt="在这里插入图片描述"><br>当命令行输入，手动启动（begin &#x2F;start transaction）一个事务的时候，和MySQL中是否事务会自动提交无关</p><blockquote><p>只要我们是begin，start transaction,就必须要我们进行手动提交<br>那么自动调教的设置，是给谁设置的呢</p></blockquote><ul><li><p>提交<br>我们把事务进行提交<br><img src="https://img-blog.csdnimg.cn/c5d5b3cb45794e5e84639055778cc41a.png" alt="在这里插入图片描述"><br>提交在崩溃，事务就不会再回滚了，这个就叫做事务的持久性</p><ul><li>证明单sql和事务的关系<br>这里我们把自动提交关闭<br>这里我们就使用了单条sql命令，然后奔溃<br><img src="https://img-blog.csdnimg.cn/34a3f29e43554bdbac47d040420fc089.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a458474f0ca44df6b4be59064ab58b44.png" alt="在这里插入图片描述"><br>我们发现，它左边insert的数据，也没了，进行了回滚</li></ul><blockquote><p>其实我们之前的所有单条sql，本质上再mys ql里面，全部各自会以事务的方式进行提交，自动提交<br>我们写的4，5条sql，实际上应该是4，5个事务</p></blockquote><ul><li>自动提交给谁设置的<br>MySQL中的单条sql设置的，我们时默认行为<br>回滚（原子性）<br>持久（commit）</li></ul><p>事务操作的注意事项</p><blockquote><ul><li>如果一个事务已经被提交了，就不能再回滚了</li></ul></blockquote></li></ul><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><h2 id="理解mysql服务"><a href="#理解mysql服务" class="headerlink" title="理解mysql服务"></a>理解mysql服务</h2><ul><li>MySQL服务可能会被多个客户端线程访问，访问的方式都是以事务的形式形成</li><li>一个事务可能有多条sql组成，意味着，任何一个事务，都有执行前，执行中，执行后阶段，事务的原子性，是让用户层，要么看到执行前，要么看到执行后，而对于执行中出现的任何问题，都可以随时回滚，所以单个事务，对用户表现出来的情况，都是原子性的</li><li>但是，因为所有的事务都有个执行过程，那么在多个事务执行多个sql的时候，就会互相影响，同时操作同一行数据</li><li><blockquote><p>你妈让你好好学习，要么别学，要么学最好，中间怎么努力学习，你妈不关心，你的学习对于你妈妈来说就是原子的，</p></blockquote></li><li>为了保证事务执行的过程中，尽量不受干扰，就有了一个重要特征：隔离性</li><li>数据库中，允许事务受不同程度的干扰，就有了一个重要特征：隔离级别</li></ul><p><strong>隔离级别</strong></p><ul><li>读未提交[Read Uncommitted]:在改隔离级别下，所有的事务，都能看到别的事务<br>没提交的执行结果，读到了对方未提交的数据</li></ul><p>我们在一个终端，启动事务，插入数据，没有提交 <img src="https://img-blog.csdnimg.cn/dd9846f6ab3f43d983fc8b3991e6ddf0.png" alt="在这里插入图片描述"><br>在另一个终端里面查看，是可以查看到的<br><img src="https://img-blog.csdnimg.cn/126f6d186c0243b2a4acac680fb326a4.png" alt="在这里插入图片描述"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这个隔离级别相当于没有任何隔离性，会出现别人读到脏数据，别人修改数据也会影响你<br>会出现脏读<br></code></pre></td></tr></table></figure><ul><li>读提交[Read Committed]：你提交了，别人才会读到你的数据</li><li>可重复读[Repeatable Read]：MySQL默认的隔离级别，</li><li>串行化 [Serilaize];最高的隔离级别，效率太低了，并发没用了</li></ul><h2 id="查看设置隔离级别"><a href="#查看设置隔离级别" class="headerlink" title="查看设置隔离级别"></a>查看设置隔离级别</h2><ul><li>查看全局隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-variable">@global</span>.tx_isolation;<br></code></pre></td></tr></table></figure><ul><li>查看当前隔离级别,只能在本次会话有效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-variable">@session</span>.tx_isolation;<br></code></pre></td></tr></table></figure><ul><li>设置<br>恢复成全局默认设置，设置成全局的就要重启才可以<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level Repeatable Read;<br></code></pre></td></tr></table></figure>但是如果设置为session的，就不需要进行这样的操作,只会影响自己<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session transaction isolation level Repeatable Read;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>读提交，这里我们会发现一方修改的数据，另一个不受影响，读不到对方未提交的数据<br><img src="https://img-blog.csdnimg.cn/2b6f8af8b8b24f3598ffc5a97cd820f2.png" alt="在这里插入图片描述"><br>但是此时当前是事务未commit，在同一个事务内，同样的读取，在不同的时间段，读到不同的值，这种现象就叫做不可重复读问题</p><p><strong>不可重复读，存在问题</strong></p><blockquote><ol><li><strong>读提交</strong>，你一提交，别人能读到！&#x3D;你已提交，和你并行运行的事务也能读到（并行发事务不应该读到，一开始读到什么数据，之后都要读到什么数据）</li><li>不可重复读有什么问题——-应用层有什么问题呢<br><img src="https://img-blog.csdnimg.cn/ca0b81e057db4d78867f1a22d403231d.png" alt="在这里插入图片描述"><br>给一个用户会被触发多次sql<br>不可重复读，就是两个同时启动的事务，一方改变了数据，commit之后，但是另一方还在事务中，读到的数据，就是已经commit上去之后的</li></ol></blockquote><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><ul><li>就是为了解决不可重复读问题的</li><li>可重复读，就是两个同时启动的事commit之后，但是另一方还在事务中，读到的数据，还是对方还没begin之前的数据，和对方commit无关</li><li>我永远看到的数据都是一样的，这就叫做可重复读，<br>运行期间看不到对方的操作<br>都commit之后就能看得到了</li></ul><p>MySQL对于insert也能处理RR(幻读)</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>变成单进程，效率非常低，指的是事务之间的串行化，不是mysql里面sql语句的串行化，把事务进行排队</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>MySQL的内部机制，让“同时”启动，并发执行的事务，看到不同的数据（增删改），能不能看到，就叫做隔离性<br>我们作为一个事务，可以看到不同可见性的数据，程度不同，叫做隔离级别</p><p>为何要存在隔离级别</p><blockquote><p>为了安全，不需要各自种类繁多的隔离级别，无脑串行化最安全<br>不仅仅是为了考虑安全问题，有可能就不考虑安全问题，<br>在安全和效率之间，寻找平衡点，也不需要各种种类繁多的隔离级别<br>这个平衡点不是MySQL来决定的，而是由我们来决定的</p></blockquote><h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>持久性，原子性，隔离性共同组成了一致性<br>需要由用户和MySQL共同决定<br>是事务维护的最终目标</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引操作</title>
    <link href="/2022/10/18/MySQL%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/10/18/MySQL%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">索引操作</a></li><li><ul><li><a href="#_2">创建主键索引</a></li><li><a href="#_37">创建普通键索引</a></li><li><a href="#_64">唯一键索引</a></li></ul></li><li><a href="#_79">全文索引</a></li><li><a href="#_86">索引创建原则</a></li></ul><h1 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h1><h2 id="创建主键索引"><a href="#创建主键索引" class="headerlink" title="创建主键索引"></a>创建主键索引</h2><ul><li>法1</li></ul><p>  在创建表的时候，在字段后面添加primary key就行了，会自动创建一个b+树来管理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user1 (id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key);<br></code></pre></td></tr></table></figure><p>空间不会不够，b+树可以局部加载</p><ul><li>法2</li></ul><p>  在创建表的最后，指定某列或者某几列是主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> u1 ( id <span class="hljs-type">int</span>, name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>), <span class="hljs-keyword">primary</span> key(id));<br></code></pre></td></tr></table></figure><ul><li>法3</li></ul><p>  使用alter</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> u1 <span class="hljs-keyword">add</span>  <span class="hljs-keyword">primary</span> key(id);<br></code></pre></td></tr></table></figure><p>查看索引<br><img src="https://img-blog.csdnimg.cn/8f8c24b0365746bb90619cf0f774af30.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> u1\G;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/769825b8f54445ab803d57e30cd05980.png" alt="在这里插入图片描述"><br>删除主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> u1 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br></code></pre></td></tr></table></figure><p>再查看<br><img src="https://img-blog.csdnimg.cn/5920d7d3a7284321a8ae922f74130fd2.png" alt="在这里插入图片描述"></p><ul><li>创建唯一键索引</li></ul><h2 id="创建普通键索引"><a href="#创建普通键索引" class="headerlink" title="创建普通键索引"></a>创建普通键索引</h2><ul><li>法1：在键表的时候，就指定某列为索引,必须要有主键索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> u3(name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>),id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,index (name));<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5748cf85f5e949be999be97e00267d0c.png" alt="在这里插入图片描述"><br>一定是有两个b+树，一个表可以有好多个索引</p><ul><li>法2：在建表之后，使用alter来增加</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> u3 <span class="hljs-keyword">add</span> index (name);<br></code></pre></td></tr></table></figure><ul><li>法3：使用create index来增加索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index myindex <span class="hljs-keyword">on</span> u3 (name);<br></code></pre></td></tr></table></figure><p>创建的时候给这个表起一个别名<br><img src="https://img-blog.csdnimg.cn/222d8a137b054af3bca8e7a62e7115e5.png" alt="在这里插入图片描述"></p><p>删除普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> u3 <span class="hljs-keyword">drop</span> index name;<br></code></pre></td></tr></table></figure><h2 id="唯一键索引"><a href="#唯一键索引" class="headerlink" title="唯一键索引"></a>唯一键索引</h2><ul><li>法1</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> u2 (id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">unique</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d2ded57cef7848a58a41efcab655f862.png" alt="在这里插入图片描述"><br>唯一键和普通索引没有任何差别，它只不过是多加了一个UNI，这个关键字</p><ul><li>法2</li></ul><p>  表已经键好了，在创建唯一键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> uu <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span>(name);<br></code></pre></td></tr></table></figure><h1 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h1><p>我们目前所有索引建立都是基于一列的，而且我们一列信息都不大</p><p>但是如果一列是文章呢？100000字，<br>当文章字段或者有大量文字的字段进行检索式，会使用全文索引，MySQL提供全文索引机制，但是又要求，必须是使用<strong>mysiam</strong>，而且默认的全文索引支持英文，不支持中文</p><h1 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h1><p>不能无脑添加索引</p><ul><li>比较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合创建索引</li><li>不会再where自居中的字段不该创建索引</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2022/10/18/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/10/18/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">索引</a></li><li><a href="#MySQL_10">MySQL</a></li><li><a href="#_40">认识磁盘</a></li><li><a href="#MySQL_59">MySQL与磁盘交互的基本单位</a></li><li><a href="#_70">建立共识</a></li><li><a href="#_95">索引的理解</a></li><li><ul><li><a href="#page_115">单个page</a></li></ul></li><li><a href="#_162">多页情况</a></li><li><a href="#_192">什么是主键索引</a></li><li><ul><li><a href="#B_212">为什么只能是B+树</a></li></ul></li><li><a href="#vs_235">聚簇索引vs非聚簇索引</a></li><li><ul><li><a href="#_236">非聚簇索引</a></li><li><a href="#_243">聚簇索引</a></li></ul></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引：提高数据库的性能，提高数据库的检索速度，不用加内存，不用改sql，不用改程序，速度可以提高成败上千倍，但是插入，更新，删除的速度就比较慢</p><p>常见的索引</p><ul><li>主键索引（primary key）</li><li>唯一键索引（unique）</li><li>普通索引（index）</li></ul><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL的工作过程</p><ul><li>mysql对数据做的CURD的操作，根据冯诺依曼体系，mysql是不可能直接去访问磁盘的</li><li>实际上数据库对数据做的所有访问，全部都是在内存中进行的，</li><li>如果数据有变化，再定期的把数据刷新到磁盘里面</li><li>sync使用，使用这个系统调用，把内核数据刷新到磁盘里面，不经过OS</li></ul><p><img src="https://img-blog.csdnimg.cn/ebf8cf4d7ae04133ad14250efd8f00d9.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a27e130b3115434b85e8a91f4f7b2be1.png" alt="在这里插入图片描述"></p><ul><li>示例，添加索引前</li></ul><blockquote><p>我们插入了大量的数据，然后从里面进行查找数据，这样我们就会发现了查询的结果会查很久</p></blockquote><ul><li>查询员工号2&#x3D;998877<br><img src="https://img-blog.csdnimg.cn/1ada73fd83544574a3b02e7baff30c11.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4200f753f75440f0b0f540fab407ecbb.png" alt="在这里插入图片描述"></li></ul><p>我们发现很慢，时间过了很久才能查询出来</p><ul><li>示例，添加索引后</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> EMP <span class="hljs-keyword">add</span> index(empno);<br></code></pre></td></tr></table></figure><p>我们在添加索引之后，发现查找的非常块，几乎每花什么时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> EMP <span class="hljs-keyword">where</span> empno<span class="hljs-operator">=</span><span class="hljs-number">998877</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3ced48297abf431a9e76327060090cab.png" alt="在这里插入图片描述"><br>我们会发现搜索的时间不到一秒</p><h1 id="认识磁盘"><a href="#认识磁盘" class="headerlink" title="认识磁盘"></a>认识磁盘</h1><p>数据存储效率很低，路上还要有带宽限制，因为我们在传输数据的时候，不仅要在自己的磁盘中传送，还要在网络中进行跨网络传输</p><p>所有的数据都是基于LInux文件系统的</p><p>要找到一个文件的全部，本质上，就是在磁盘中找到所有保存文件的扇区</p><p>磁盘里面：磁头确认的是哪一个面，磁盘确认的是哪个圈，扇区来进行确认是哪一块区域，来定位到某一个扇区（CHS定位方案），磁盘使用的方案<br>磁盘的使用，使用的LBA，逻辑块地址（可以理解为虚拟地址和物理地址），这个是操作系统使用的方案</p><ul><li><p>结论<br>我们已经能够在硬件层面上定位到对应的地址了，任何一个数据块（扇区），在系统软件上，直接按照扇区（512字节，会造成过度寻址，所以我们基本都是使用4096来进行寻址，4页）</p></li><li><p>如果OS直接用硬件提供的数据大小进行交互，那么系统软件，</p></li></ul><p>磁盘的交互都是使用4KB进行交互<br>连续磁盘访问</p><h1 id="MySQL与磁盘交互的基本单位"><a href="#MySQL与磁盘交互的基本单位" class="headerlink" title="MySQL与磁盘交互的基本单位"></a>MySQL与磁盘交互的基本单位</h1><p>MySQL作为一款软件，可以想象成一个特殊的文件系统，它有更高的IO 场景，为了提高效率，</p><ul><li>MySQL数据交互的<strong>基本单位</strong>：<strong>16KB</strong></li></ul><p>也就是说，磁盘这个硬件的基本单位是<strong>512字节</strong>，而MySQL使用16kb进行IO交互，即<br>MySQL和磁盘进行数据交互（通过OS）的基本单位是16KB，这个基本数据单位在mysql里面叫做<strong>page</strong></p><p>如果它的基本单位和磁盘一样的话，万一磁盘的基本单位变了，它也要跟着变，兼容性不行<br><img src="https://img-blog.csdnimg.cn/7808cedb3c474e7191c0b327476d9e0f.png" alt="在这里插入图片描述"><br>所以这里规定MySQL数据交互的基本单位是16KB&#x3D;1page</p><h1 id="建立共识"><a href="#建立共识" class="headerlink" title="建立共识"></a>建立共识</h1><ul><li>MySQL中数据文件，一定是在磁盘当中的，以<strong>page为基本单位</strong></li><li>MySQL的CURD操作，都需要计算，找到对应的插入位置，或者找到对应要修改或者查询的数据</li><li>只要涉及计算，就要有CPU参与，为了cpu参与，一定把数据加载到内存，cpu只和内存打交道（根据需要把数据从外设掉到内存中，不是所有数据都加载进去）</li><li>所以在特定时间内，数据一定是在磁盘中有，内存中也有，后序操作完内存数据之后，以特定的刷新策略，刷新到磁盘里面，这个时候就涉及磁盘和内存数据的交互，此时基本单位就是page（即便只改一个字节，也要以16kb的大小来进行交互）</li><li>为何更高的效率，一定要减少系统和内存之间的IO请求次数</li></ul><p>IO请求—-系统中一定存在大量的IO 请求————操作系统一定也要管理这些IO请求<br>先描述再组织</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_io</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">char</span> * start,*end;<br><span class="hljs-type">pid_t</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><p>磁盘中,磁盘中一定是要对这些io请求进行管理的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">requestt_io</span>* <span class="hljs-title">queue</span>;</span><span class="hljs-comment">//访问对应的磁盘，都有对应的对应进行保存起来</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="索引的理解"><a href="#索引的理解" class="headerlink" title="索引的理解"></a>索引的理解</h1><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<span class="hljs-comment">--再id这个地方添加主键，建立了一个主键索引</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> age <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br></code></pre></td></tr></table></figure><p>我们这里是故意乱序的进行数据的插入<br><img src="https://img-blog.csdnimg.cn/30d45977ee494de488ee4baaa2864f16.png" alt="在这里插入图片描述"><br>我们select之后，发现：查询的结果是按照主键顺序进行排序的<br><img src="https://img-blog.csdnimg.cn/b85a97ccc00943828dded8a09b0c3b40.png" alt="在这里插入图片描述"></p><p>我们中断一下，排序的工作是由谁操作的，为什么要这样干呢?<br>为何IO交互要使用page?</p><blockquote><p>每次交互都使用<strong>page</strong>（16 KB），这样一次可以预加载很多，可以充分利用局部性原理。<a href="#fn1">1</a></p></blockquote><h2 id="单个page"><a href="#单个page" class="headerlink" title="单个page"></a>单个page</h2><blockquote><p>为何MySQL和磁盘进行IO交互的时候，要采用page的方案进行交互，用多少，加载多少的方式不香吗？</p><ul><li><p>如上面的5条数据，MySQL要查id&#x3D;2，第一次加载，id&#x3D;1，第二次加载id&#x3D;2，一次一条数据，就要进行2次IO，如果要找id&#x3D;5，就需要5次IO</p></li><li><p>但是如果5条数据都被保存再page里面（16kb能保存很多记录），第一次IO查找的时候，整个page就直接加载MySQL的buffer pool里面了，这里完成了一次IO，但是往后的id&#x3D;1，3，4，5等，就不需要进行IO了，而是直接再内存里面进行了，大大减小了IO 的次数</p></li><li><p>你怎么保证，用户下次找的数据，就再这个page里面，我们不能保证，但是会由很大的概率，因为由<strong>局部性原理</strong>，往往IO 效率低下唉，最主要矛盾不是单次IO的数据量大小，而是IO 的次数</p></li></ul></blockquote><p>正式理解索引结构,一定会存在page结构体</p><blockquote><ol><li><pre><code class="hljs">mysql会预先开辟一段空间来保留这些page</code></pre></li><li><pre><code class="hljs">MySQL在，任何一个时刻，一定会存在大量的page页，存在MySQL内部</code></pre></li><li><pre><code class="hljs">MySQL本身也要对page进行管理，也是要先描述再组织</code></pre></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * <span class="hljs-title">prev</span>;</span><span class="hljs-comment">//指向前一个page</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * <span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向后一个page</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">buff</span><span class="hljs-params">(<span class="hljs-number">16</span>kb-其他字段占用的大小)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对page的管理，就是对链表的管理</p></blockquote><p>之后的操作都是再内存当中实现的<br>mysql插入数据时按照<strong>主键</strong>来进行排序，插入后，page里面就是有序的,查找的时候，就能优化查找算法，有序的就可以提高查找效率，如二分查找，方便我们进行查找</p><p>理解多个page</p><ul><li>在page之间和page里面查找数据，都是基于链表的，线性遍历，一个遍历一遍，没找到，下一个继续遍历，效率非常的低，还是O（N）的方式进行遍历</li></ul><p>页内目录</p><blockquote><p>用目录查找，效率就很高，第一章是什么，在第几页，这样查找就很快，以空间换时间<br>先在一个page里面提高搜索效率，那么在所有page里面，效率也提高了很多<br>有了目录，就能一次淘汰很多数据，这样就会导致单页中数据减少，我们是先遍历数据目录，再去便利数据记录，这样提高的效率就很大，我们先遍历目录，</p></blockquote><p><img src="https://img-blog.csdnimg.cn/52bc13a678e742c1847ab12887cbf4fa.png" alt="在这里插入图片描述"></p><blockquote><p>假如说数据500条，我们目录10条，这样就是只要遍历10次目录，遍历50次目录中对应的数据，大大减少了遍历的次数</p></blockquote><ul><li>所以有主键的时候，默认的进行排序，可以方便我们引入<strong>页内目录</strong>，方便查询</li></ul><p>page之间也是线性的，怎么提高page之间的搜索效率</p><ol><li><p>page内部的效率问题</p></li><li><p>page和page之间的效率问题！</p></li></ol><h1 id="多页情况"><a href="#多页情况" class="headerlink" title="多页情况"></a>多页情况</h1><p>数据不断的插入新增，mysql很容易容量不足，所以就需要开辟一个新的page来保存数据，然后通过指针的方式，来将所有的page组织起来<br>问题</p><ul><li><p>因为我们要保证一个整体有序，所以新来的数据，不会放在新的page里面，</p></li><li><p>这样我们就可以通过多个page的遍历，page内部用目录进行定位数据，可是这样也有效率问题，在page里面我们也需要用mysql进行遍历，这样就显得我们之前的page，有点没用了,我们查找一个数据，需要把前面的所有page遍历一遍，</p></li></ul><p>解决方案</p><p>给我们的一个一个page也带上目录，</p><p>把每个page里面最小的记录，作为每个page的键值，这样page和page之间键值就不会重复了<br>在page里面中在开一个page，里面就只保存下面所管理的主键和指针，只保存一个一个目录<br>用一个page专门来保存page目录，和page对应的地址，一个page可以管理2000多个page<br>直接到顶层的page目录</p><p><img src="https://img-blog.csdnimg.cn/e7c3286251ab427f89d2f0c842814020.png" alt="在这里插入图片描述"><br>数据量很大的话，还要继续在中间增加page目录<br>相当于一个b+树，一个节点可以索引到很多地址，至此， 我们就已经可以给我们的表user构建完主键索引了<br>随便找一个id&#x3D;？，我们发现，现在查找的page树一定减少了，说明我们IO次数也减少了，那么效率也高了</p><p>在page之间，和page内部都添加目录结构，这样就能构建一个b+树</p><p><img src="https://img-blog.csdnimg.cn/25b1b4a48a5c441c80045e5e327bc227.png" alt="在这里插入图片描述"></p><h1 id="什么是主键索引"><a href="#什么是主键索引" class="headerlink" title="什么是主键索引"></a>什么是主键索引</h1><ol><li>所有的数据最终都可以在磁盘中，也可以在mysql的buffer pool内存中</li><li>我们所有的数据，都必须要以page为单位进行IO，以page为单位组织</li></ol><blockquote><p>在MySQL内部，将热点数据，以B+树的形式将所有的page页进行组织，形成的数据结构与其配套的查找算法，叫做索引</p></blockquote><p>添加索引，就给业内加目录，给顶层添加目录结构，方便对数据进行筛查<br>如果没有添加索引，所有的数据都是以链表的形式串联起来，数据没有做优化，没有排序，插入什么样就是什么样的，</p><p>有了b+树，每次从叶子节点中，进行搜索，一路找下去，就可以查找到对应的数据了<br>现在我们就不用加载很多数据到内存中，不需要查找的page就不需要加载到内存中了，我们需要哪个page加载哪个page即可，一路把我们查询过程中的路径page加载进去即可</p><p>只要我们把页目录加载进去之后，这些目录就常驻了，以后就不需要再加载到内存了，减少了IO的次数</p><p>但是其实目录页本来就没多少，所以可以直接都加载进来，</p><p>但是如果插入数据，删除数据的时候，会影响一下效率，因为会影响整个页目录的结构，<br>修改了一个数据，都要以整个page进行刷新到磁盘中</p><h2 id="为什么只能是B-树"><a href="#为什么只能是B-树" class="headerlink" title="为什么只能是B+树"></a>为什么只能是B+树</h2><ul><li>链表：线性遍历，效率太低</li><li>二叉树：可能会退化成线性结构</li><li>AVL&#x2F;RBtree：二叉树，相较于多阶B+树，意味着，整体的树比较高，需要系统与磁盘进行的IO page更多，而B+，矮胖的，层级低，数据量大，访问次数少</li><li>Hash：有的索引就是基于Hash，但是Innodb，hash有的时候也能O（1），但是最大的问题，不能够支持区间性的范围查找，比如我们要查找（40，60），但是hash是乱序的，无法实现区域性哈希，但是b+树，只需要知道自己找40，到40里面查找即可</li><li>B树，B+树下面的叶子节点都被链表连起来，这样page之间，都能够查找，跨范围，而且非叶子节点也会携带数据，增加的空间大小，逻辑上没有解耦</li></ul><p>B+树</p><ul><li>只有叶子节点有数据</li><li>叶子节点相连，非常便于进行范围查找</li><li>IO次数较少</li></ul><p><img src="https://img-blog.csdnimg.cn/ee5d5029723049ec8c850276b322d5d2.png" alt="在这里插入图片描述"><br>创建了一个索引，它就会创建一个文件叫.ibd，index_block_data,这个说明数据和索引合在一起的<br>把索引和数据都加载进去了</p><p>B+树在哪里</p><blockquote><ul><li>在磁盘上，有完整的B+和数据</li><li>在内存中有局部高频被访问的B+核心Page</li><li>mysql查找一定会伴生着mysql进行根据B+进行page的换入换出！</li></ul></blockquote><p>同样，文件也是，内存中，一定是被打开的文件</p><h1 id="聚簇索引vs非聚簇索引"><a href="#聚簇索引vs非聚簇索引" class="headerlink" title="聚簇索引vs非聚簇索引"></a>聚簇索引vs非聚簇索引</h1><h2 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h2><p>：数据和索引分离</p><p>myisam的叶子节点不存储数据，只存储数据对应的地址，这样就能保存更多键值和索引关系，把数据放到对应的一个地方，用指针进行索引</p><p>把索引page和数据page进行分离，也就是叶子节点没有数据，只有对应数据的地址</p><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>innodb就是聚簇索引<br>把数据和索引聚合在一起</p><p><strong>辅助索引</strong></p><p>MySQL除了会建立主键索引之外，还会建立按照其他列信息建立索引，一般这叫做辅助索引，其他字段也能建立索引<br>和主键索引没有差别，无非是主键不能重复，而非主键可以重复</p><p>主键就是叶子有地址，有索引<br>同样是构建b+树，innodb非主键索引中叶子节点保存对应地址的索引，但是没有保存数据，太浪费空间了，包含的是对应主键，再根据主键进行查询索引，回调索引，两边索引，先获得主键，再主键索引，获得索引的记录，</p><p>附上数据，太浪费空间了，会造成数据的冗余，但是myisam不需要进行回表，查询效率还是回更高一点，但是innodb支持事务，而mysiam不保证事务</p><hr><ol><li>下一次访问的数据，有很大概率会和上一次访问的数据重叠 <a href="#fnref1">↩︎</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内外链接</title>
    <link href="/2022/10/13/%E5%86%85%E5%A4%96%E9%93%BE%E6%8E%A5/"/>
    <url>/2022/10/13/%E5%86%85%E5%A4%96%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">内连接</a></li><li><a href="#_25">外连接</a></li></ul><p>表的连接分为内连接和外连接</p><h1 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h1><p>实际上就是使用where子句对两种表形成笛卡尔积进行赛选，我们前面学习的查询也基本都是内链接，他是使用最多的一种查询</p><p>有连接关系才可以用inner join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段 <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> 连接条件 <span class="hljs-keyword">and</span> 其他条件<br></code></pre></td></tr></table></figure><ul><li>显示SMITH 的名字和部门名、</li><li>使用普通方法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,dname <span class="hljs-keyword">from</span> emp ,dept <span class="hljs-keyword">where</span> emp.deptno<span class="hljs-operator">=</span>dept.deptno <span class="hljs-keyword">and</span> ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SMITH&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>使用inner join这个内连接方法，后面的where就是对新建立表进行数据的筛选</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.deptno<span class="hljs-operator">=</span>dept.deptno <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span>&quot;SMITH&quot;;<br></code></pre></td></tr></table></figure><p>内连接，数据没有匹配上，就会直接被过滤掉</p><h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><p>外连接又分成左外连接，右外连接</p><p>如果进行联合查询，左边完全显示，就是左外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> exam <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> stu <span class="hljs-keyword">on</span> exam.id<span class="hljs-operator">=</span>stu.id;<br></code></pre></td></tr></table></figure><p>左外连接，就是以左表为主，去右边里面去找，即使没找到，也要把数据保留下来，评不上的就是NULL，不会删除左表的任何数据</p><ul><li>请找到非法学生，查找NULL即可</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> exam <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> stu <span class="hljs-keyword">on</span> exam.id<span class="hljs-operator">=</span>stu.id <span class="hljs-keyword">where</span> stu.id <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>这里筛选出来的就是非法的</p><p>同理，右外连接就是以右表为主<br>查找没有参加考试的同学</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> exam <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> stu <span class="hljs-keyword">on</span> exam.id<span class="hljs-operator">=</span>stu.id <span class="hljs-keyword">where</span> exam.id <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><ul><li>列出部门名称和这些部门名称的员工信息，同时列出没有员工的部门</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,dname <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.deptno<span class="hljs-operator">=</span>dept.deptno;<br></code></pre></td></tr></table></figure><ul><li>查找没有员工的部门</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,dname <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.deptno<span class="hljs-operator">=</span>dept.deptno <span class="hljs-keyword">where</span> emp.deptno <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql 数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL复合查询</title>
    <link href="/2022/10/12/MySQL%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/10/12/MySQL%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">练习</a></li><li><a href="#_51">多表查询</a></li><li><a href="#_79">自链接</a></li><li><a href="#_93">子查询</a></li><li><ul><li><a href="#_96">单行子查询</a></li><li><a href="#_105">多行子查询</a></li><li><a href="#_124">多列子查询</a></li></ul></li><li><a href="#_145">合并查询</a></li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ul><li>查询工资大于500或岗位为manager的雇员，同时还要满足姓名的首字母是大写的J</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (sal<span class="hljs-operator">&gt;</span><span class="hljs-number">2500</span> <span class="hljs-keyword">or</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;MANAGER&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">substring</span>(ename,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<span class="hljs-operator">=</span><span class="hljs-string">&#x27;J&#x27;</span>;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (sal<span class="hljs-operator">&gt;</span><span class="hljs-number">2500</span> <span class="hljs-keyword">or</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;MANAGER&#x27;</span>) <span class="hljs-keyword">and</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;J%&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>按照部门号升序而雇员的工资降序排序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> deptno <span class="hljs-keyword">asc</span> ,sal <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><ul><li>使用年薪进行降序排列,先把每个人的年薪算出来</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sal<span class="hljs-operator">*</span><span class="hljs-number">12</span><span class="hljs-operator">+</span>ifnull(comm,<span class="hljs-number">0</span>) 年薪 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 年薪 <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/1c5883a7543f421989bfdd3e64abf34d.png" alt="在这里插入图片描述"></p><ul><li>显示工资最高的员工的名字和工作岗位</li></ul><p>  先获得最高的工资是多少，再在where里面使用这个数据,我们就可以使用符合查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,job,<span class="hljs-built_in">max</span>(sal<span class="hljs-operator">*</span><span class="hljs-number">12</span><span class="hljs-operator">+</span>ifnull(comm,<span class="hljs-number">0</span>)) <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><p>在where里面套select，里面的先查询，进行子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,job,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5e1b2fcd516446a49e6e173a2d354640.png" alt="在这里插入图片描述"></p><ul><li>显示工资高于平均工资的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp);<br></code></pre></td></tr></table></figure><ul><li>显示每个部门的平均工资和最高工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(sal) 最高工资,<span class="hljs-built_in">avg</span>(sal) 平均工资 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br></code></pre></td></tr></table></figure><ul><li>显示平均工资低于2000的部门号和它的平均工资</li></ul><p>  having是在group by 之后进行操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">avg</span>(sal) 平均工资 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno <span class="hljs-keyword">having</span> 平均工资<span class="hljs-operator">&lt;</span><span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4fa09487cf1144398fb65ea6f51c9de1.png" alt="在这里插入图片描述"></p><ul><li>显示每种岗位的雇员总数，平均工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> job,<span class="hljs-built_in">count</span>(ename),<span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0fbd0a09555541e1b5cadc263da86116.png" alt="在这里插入图片描述"></p><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多个组合成笛卡尔集<br>因为我们的数据都会被拆成不能再拆<br>重命名可以再from里面进行，select里面也可以，但是不能再where里面进行重命名</p><p>从第一张表中的第一条记录和另一张表中的所有记录进行组合,就是把数据一条一条的取出来，</p><p>所以，在我看来，所有的多表查询，都是单表查询<br>计算多张表里面的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">one</span>,emp two,emp three;<br></code></pre></td></tr></table></figure><ul><li>显示雇员名，雇员工资以及所在的部门名,通过雇员所在的部门id来查找对应的值,使用外键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal,dname,dept.deptno <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.deptno<span class="hljs-operator">=</span>dept.deptno;<br></code></pre></td></tr></table></figure><p>我们认为所有的select查询出来的：”记录“，都可以把它看作”表“</p><ul><li>显示部门号为10的部门名，员工名和工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,dname,sal,emp.deptno <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> dept.deptno<span class="hljs-operator">=</span>emp.deptno <span class="hljs-keyword">and</span> emp.deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ul><li>显示各个员工的姓名，工资，及工资级别</li></ul><p>  因为前一个表会和后一个表的每一项都进行一个组合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> grade,ename,sal,deptno <span class="hljs-keyword">from</span> emp,salgrade <span class="hljs-keyword">where</span> sal <span class="hljs-keyword">between</span> losal <span class="hljs-keyword">and</span> hisal;<br></code></pre></td></tr></table></figure><h1 id="自链接"><a href="#自链接" class="headerlink" title="自链接"></a>自链接</h1><p>自链接是值在同一张表连接查询</p><ul><li>显示ford的上级领导的编号和姓名</li></ul><p>可以先把两张表进行组合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> mgr.ename,mgr.empno <span class="hljs-keyword">from</span> emp work,emp mgr <span class="hljs-keyword">where</span> work.ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;FORD&#x27;</span> <span class="hljs-keyword">and</span> work.mgr<span class="hljs-operator">=</span>mgr.empno;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/59fcba02ec3c44e4822cdd9da866b4ee.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,empno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (<span class="hljs-keyword">select</span> mgr <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;FORD&#x27;</span>)<span class="hljs-operator">=</span>empno;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8a55afed62924e3fa983d35facd71aa5.png" alt="在这里插入图片描述"></p><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>也叫做嵌套查询<br>在其他sql当中嵌套select的过程</p><h2 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h2><p>查询的结果只有一列，一行</p><ul><li>显示和SMITH同一部分的员工</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (<span class="hljs-keyword">select</span> deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SMITH&#x27;</span>)<span class="hljs-operator">=</span>deptno;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4403314379e54f8abd25e6fd6f9fed18.png" alt="在这里插入图片描述"></p><h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h2><p>查询的结果有多行的时候，可以用一些关键字来进行过滤</p><ul><li>in 在一个范围内查找，不存在（属于一员）</li></ul><p>  查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,job,sal,deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>) <span class="hljs-keyword">and</span> deptno<span class="hljs-operator">!=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f6011dbcd25a4e30bd956d7e62c6e99c.png" alt="在这里插入图片描述"></p><ul><li>all关键字（比所有的都怎么样）</li></ul><p>  显示工资比部门30的所有员工的工资都高的员工姓名，工资和部门号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal,deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><ul><li>any(比任意一个都要高)</li></ul><p>  显示工资比部门30的任意员工的工资都高的员工姓名，工资和部门号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal,deptno <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><h2 id="多列子查询"><a href="#多列子查询" class="headerlink" title="多列子查询"></a>多列子查询</h2><ul><li>查找和smith的部门和岗位完全相同的所有雇员，不含smith本人</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (deptno,job)<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> deptno,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SMITH&#x27;</span>) <span class="hljs-keyword">and</span> ename<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;SMITH&#x27;</span> ;<br></code></pre></td></tr></table></figure><ul><li>显示每个高于自己部门平均工资的员工的姓名，部门，工资，平均工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">one</span>,(<span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">avg</span>(sal) 平均工资 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno) avg_tb <span class="hljs-keyword">where</span> (avg_tb.deptno<span class="hljs-operator">=</span>one.deptno) <span class="hljs-keyword">and</span> sal<span class="hljs-operator">&gt;</span>平均工资;<br></code></pre></td></tr></table></figure><ul><li>查找每个部门工资最高的人的姓名，工资，部门，最高工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,sal,emp.deptno,maxsal <span class="hljs-keyword">from</span> emp,(<span class="hljs-keyword">select</span> ename,sal,deptno,<span class="hljs-built_in">max</span>(sal) maxsal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno) maxtb <span class="hljs-keyword">where</span> emp.deptno<span class="hljs-operator">=</span>maxtb.deptno <span class="hljs-keyword">and</span> emp.sal<span class="hljs-operator">=</span>maxtb.maxsal;<br></code></pre></td></tr></table></figure><ul><li>显示每个部门的信息（部门名，部门编号，地址）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> getno.deptno,dname,loc,num <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) num <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno) getno,(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept) deptdetail <span class="hljs-keyword">where</span> getno.deptno<span class="hljs-operator">=</span>deptdetail.deptno;<br></code></pre></td></tr></table></figure><h1 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h1><ul><li>union,基本不会用</li></ul><p>  将最终查询的结果进行结果,会自动去掉结果中的重复行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;MANAGER&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span>  sal<span class="hljs-operator">&gt;</span><span class="hljs-number">2500</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-string">&#x27;MANAGER&#x27;</span> <br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span><span class="hljs-number">2500</span>;<br></code></pre></td></tr></table></figure><ul><li>union all:使用完，不会去掉重复的数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希</title>
    <link href="/2022/10/12/%E5%93%88%E5%B8%8C/"/>
    <url>/2022/10/12/%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#unordered_mapunordered_set_1">unordered_map与unordered_set</a></li><li><a href="#_54">哈希</a></li><li><ul><li><a href="#_55">哈希本质</a></li><li><a href="#_63">哈希函数</a></li><li><a href="#_70">哈希冲突：</a></li></ul></li><li><a href="#_108">哈希函数</a></li><li><a href="#_116">闭散列</a></li><li><a href="#_293">散列表（哈希桶）</a></li></ul><h1 id="unordered-map与unordered-set"><a href="#unordered-map与unordered-set" class="headerlink" title="unordered_map与unordered_set"></a>unordered_map与unordered_set</h1><p>功能：</p><p>功能基本一样</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1.</span> unorder_xxx遍历不按照<span class="hljs-built_in">key</span>进行排序 ,命名体现了<br><span class="hljs-number">2.</span> unorder_xxx只有单向迭代器，没有提供反向迭代器<br><span class="hljs-number">3.</span> unorder_xxx综合效率略胜<span class="hljs-built_in">map</span>和<span class="hljs-built_in">set</span><br></code></pre></td></tr></table></figure><p>unordered对于无序的数据效率很高<br>set底层使用对于顺序插入的数据效率就会很高</p><p>demo.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_set</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//set是排序+去重</span><br><span class="hljs-comment">//unordered_set：只能实现去重,没有实现排序</span><br><br><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; us;<br>    us.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    us.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    us.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br>    us.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    us.<span class="hljs-built_in">insert</span>(<span class="hljs-number">7</span>);<br>    us.<span class="hljs-built_in">insert</span>(<span class="hljs-number">6</span>);<br>    us.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">auto</span> it=us.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span>(it!=us.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        it++;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//这个就不用去重,</span><br><br>    unordered_multiset&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">12</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">12</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">auto</span> dt=us.<span class="hljs-built_in">begin</span>();<br><br>     <span class="hljs-keyword">while</span>(dt!=s.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout&lt;&lt;*dt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        dt++;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="哈希本质"><a href="#哈希本质" class="headerlink" title="哈希本质"></a>哈希本质</h2><p>哈希&#x2F;散列<br>本质上就是映射，找到一个值进行映射，把数据映射到对应的地方</p><p>使用示例<br>计数排序：<br>1.统计每个数字出现次数，范围很集中，可以使用，但是对于随机的一堆整数，就按照范围来开空间，很分散，最好不要这样，</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>除留余数法<br>10 122 31 400<br>%10把对应的数放到它余数对应的位置</p><p>开10个空间，分配到不同的地方</p><h2 id="哈希冲突："><a href="#哈希冲突：" class="headerlink" title="哈希冲突："></a>哈希冲突：</h2><p>不同的数用哈希放到了同一个地方,不能保证每个值都开辟一个空间<br>但是我想要映射到一个相对固定的地方去<br>我们最常用的方法就是将</p><p>如何解决哈希冲突</p><ol><li>闭散列</li></ol><blockquote><p>闭散列：开放定址法，当发生hash冲突的时候，如果哈希表未被装满，说明在哈希表中必然还有空的位置，那么就把key存放到下一个“空位置”中去<br>* 线性探测<br>从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>二次探测<br>&gt;我们下一次探测到其平方的位置上，这样就不会让数据太集中<br></code></pre></td></tr></table></figure><ol start="2"><li>开散列&#x2F;哈希桶&#x2F;拉链法<br>6 26 36 46，<br>把尾数为6的都挂起来,放到同一个桶里面，这样就不会出现争抢位置，现在我们出现的争抢就内部解决，不会互相影响了，从根源上更好的去管理这个东西</li></ol><p>表长度100</p><p><strong>控制负载因子</strong>，能够极大的控制住效率–负载因子到了就扩容,<br>但一个桶的长度超过一定的值之后，就把他转化成一个红黑树,这样效率就很高了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//极端场景下</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Date</span><br>&#123;<br>    forward_list&lt;T&gt; _list;<br>    set&lt;T&gt; _list;<br>    <span class="hljs-type">size_t</span> len<br>&#125;;<br>len 大于一定值的时候，就把forward_list 里面的数据插入到set里面，再把单链表里面的数据给删除掉<br><br></code></pre></td></tr></table></figure><p>极端场景</p><ol><li>存50个值，40个值冲突，挂在同一个桶上</li><li>存储了10000个值，平均每个桶的长度100，阶段场景山有些桶可能有上千个值</li></ol><h1 id="哈希函数-1"><a href="#哈希函数-1" class="headerlink" title="哈希函数"></a>哈希函数</h1><ul><li>除留余数法:我们将每个数和其对应vector长度进行取余，当达到负载因子就要进行重新扩容，重新映射</li><li>平方取中法</li></ul><blockquote><p>假如关键字1234，就把它平方&#x3D;1522356，取中间3位，223，<br>如果它不够3位，就继续对他进行平方，直到取出3位位置，也存在哈希冲突<br>不常用</p></blockquote><h1 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h1><p>使用线性探测；冲突的时候，就往后进行探测，直到到达空位置，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> <span class="hljs-comment">//状态标记</span><br> &#123;<br>     EXISTS,<br>     EMPTY,<br>     DELETE<br> &#125;;<br><br> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>&gt;<br><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">HashData</span><br> &#123;<br>     pair&lt;K, V&gt; _kv;<span class="hljs-comment">//里面的每一个元素都是一个pair</span><br>     Status _status = EMPTY;<span class="hljs-comment">//一开始的节点都设置为空</span><br> &#125;;<br><br> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hash</span><span class="hljs-comment">//哈希函数，将其转化成为一个可以进行取余的数，仿函数</span><br> &#123;<br>     <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">     </span>&#123;<br>         <span class="hljs-keyword">return</span> key; <span class="hljs-comment">//返回一个无符号数,负数的话，也变成一个正数</span><br>     &#125;<br> &#125;;<br><br> <span class="hljs-comment">//如果是key是string走的就是这个特化版本</span><br> <span class="hljs-comment">//模板的特化，上面有一个基础的类模板</span><br> <span class="hljs-keyword">template</span> &lt;&gt;<br><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hash</span>&lt;string&gt; <span class="hljs-comment">//把这个参数直接确定,因为string用的很经常</span><br> &#123;<br>     <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span><br><span class="hljs-function">     </span>&#123;<br>         <span class="hljs-type">size_t</span> val = <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : s)<br>         &#123;<br>             val *= <span class="hljs-number">131</span>;<br>             val += e;<br>         &#125;<br>         <span class="hljs-keyword">return</span> val;<br>     &#125;<br> &#125;;<br><br> <span class="hljs-comment">//这个hash表即可给map也可给set</span><br> <span class="hljs-comment">//找一个值，遇到空才停，遇到删除还要继续找</span><br> <span class="hljs-comment">//出现的问题</span><br> <span class="hljs-comment">// 1.删除一个值，这个值应该设置成多少</span><br> <span class="hljs-comment">// 2.删除完毕之后，后面冲突的值怎么办,现在，把一个值删除之后，就要把他的状态标记成删除，不清理数据</span><br><br> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashFunc</span> = Hash&lt;K&gt;&gt;<span class="hljs-comment">//这个可以支持int和string两种，其他的要我们自己来写仿函数</span><br><br> <span class="hljs-keyword">class</span> HashTable<br> &#123;<br> <span class="hljs-keyword">private</span>:<br>     vector&lt;HashData&lt;K, V&gt;&gt; _table; <span class="hljs-comment">//我们数据不是都是按顺序的存储</span><br>     <span class="hljs-type">size_t</span> _n = <span class="hljs-number">0</span>;                 <span class="hljs-comment">//有效数据的个数，直接在这里给一个缺省参数</span><br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">     散列表的载荷因子a=表中元素的个数/散列表的长度,a越大，冲突的概率就越大，a越小，冲突的概率就越小，如果超过了一定值，就要扩容</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function">HashData&lt;K, V&gt; *<span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">     </span>&#123;<br>         <span class="hljs-keyword">if</span> (_table.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>         &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//没找到</span><br>         &#125;<br>         HashFunc hc;<span class="hljs-comment">//仿函数,实现哈希函数</span><br>         <span class="hljs-type">size_t</span> start = <span class="hljs-built_in">hc</span>(key) % _table.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//模上它的vector的元素大小,如果模上它的容量的话，可能回超出size的范围，无法访问_table[i],只能访问size以内的</span><br>         <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>         <span class="hljs-type">size_t</span> index = start;<br><br>         <span class="hljs-keyword">while</span> (_table[index]._status != EMPTY) <span class="hljs-comment">//在这里死循环了</span><br>         &#123;<br>             <span class="hljs-comment">//数据存在，就继续往下探测</span><br>             <span class="hljs-keyword">if</span> (_table[index]._kv.first == key &amp;&amp; _table[index]._status == EXISTS)<br>             &#123;<br>                 <span class="hljs-keyword">return</span> &amp;_table[index];<span class="hljs-comment">//存在且等于，就直接返回对于的数组的地址回去</span><br>             &#125;<br>             i++;<br>             index = start + i * i; <span class="hljs-comment">//这个是依次探测,二次探测</span><br>             <span class="hljs-comment">//如果到最后还有数据的话，那就要绕回来</span><br>             index %= _table.<span class="hljs-built_in">size</span>();<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>     &#125;<br><br>     <span class="hljs-function"><span class="hljs-type">bool</span>  <span class="hljs-title">Erase</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">     </span>&#123;<br>         HashData&lt;K, V&gt; *ret = <span class="hljs-built_in">Find</span>(key);<br>         <span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">nullptr</span>)<br>         &#123;<br>             <span class="hljs-comment">//找不到要删除的值</span><br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>         <span class="hljs-keyword">else</span><br>         &#123;<br>             <span class="hljs-comment">//找到了那个值</span><br>             ret-&gt;_status = DELETE;<span class="hljs-comment">//我们不需要进行手动删除，直接把它的状态设置为删除即可</span><br>             _n--;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span><br><span class="hljs-function">     </span>&#123;<br><br>         HashData&lt;K, V&gt; *ret = <span class="hljs-built_in">Find</span>(kv.first);<br>         <span class="hljs-keyword">if</span> (ret != <span class="hljs-literal">nullptr</span>)<br>         &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//有一个重复的值</span><br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (_table.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || _n * <span class="hljs-number">10</span> / _table.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">7</span>)<br>         &#123;<br>             <span class="hljs-comment">//越小，冲突的概率就越低，效率越高，但是空间浪费越高</span><br>             <span class="hljs-comment">//繁殖，冲突的概率越高，效率越低，浪费越小</span><br>             <span class="hljs-comment">//载荷因子大于0.7就要进行扩容</span><br>             <span class="hljs-type">size_t</span> newsize = _table.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> ? <span class="hljs-number">10</span> : _table.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>;<span class="hljs-comment">//table的大小变小了，假如说一开始还没有给这个table进行赋值，这个就没有大小，所以写一个对0进行操作</span><br>             <span class="hljs-comment">// vector&lt;HashData&lt;K,V&gt;&gt;  newtable;</span><br><br>             <span class="hljs-comment">// newtable.resize(newsize);//扩完容，就会把没有元素的地方初始化成0</span><br>             <span class="hljs-comment">// //扩容完，要重新改变值的位置，原来冲突的可能不冲突了，不冲突的可能就冲突了，建立新的映射关系</span><br>             <span class="hljs-comment">// //遍历原表，把原表的数据重新映射到新表</span><br>            <br>             HashTable&lt;K, V, HashFunc&gt; newHT;<span class="hljs-comment">//这里用一个新对象，调用自己</span><br>             newHT._table.<span class="hljs-built_in">resize</span>(newsize);<br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _table.<span class="hljs-built_in">size</span>(); i++)<br>             &#123;<br>                 <span class="hljs-keyword">if</span> (_table[i]._status == EXISTS)<br>                 &#123;<br>                     <span class="hljs-comment">//数据存在,就往我们新的ht里面插入</span><br>                     <span class="hljs-comment">// newHT._table.insert(_table[i]._kv);</span><br>                     newHT.<span class="hljs-built_in">Insert</span>(_table[i]._kv);<br>                 &#125;<br>             &#125;<br>             _table.<span class="hljs-built_in">swap</span>(newHT._table); <span class="hljs-comment">//把两个进行交换即可，这样就可以把我们想要的table给转换过来了</span><br>         &#125;<br>         HashFunc hc;<br>         <span class="hljs-type">size_t</span> start = <span class="hljs-built_in">hc</span>(kv.first) % _table.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//模上它的vector的元素大小,如果模上它的容量的话，可能回超出size的范围，无法访问_table[i],只能访问size以内的</span><br>         <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>         <span class="hljs-type">size_t</span> index = start; <span class="hljs-comment">//探测旁边</span><br>                               <span class="hljs-comment">//现在我们可以用探测i平方</span><br>                               <span class="hljs-comment">/*</span><br><span class="hljs-comment">                                   vector&lt;int&gt; v;</span><br><span class="hljs-comment">                                   v.reserve(10);</span><br><span class="hljs-comment">                                   for(int i=0;i&lt;10;i++)</span><br><span class="hljs-comment">                                   &#123;cin&gt;&gt;v[i]&#125;//这样是不行的，因为[]必须要保证这个地址上是有数据的</span><br><span class="hljs-comment">                               */</span><br>         <span class="hljs-comment">//如果这个位置没数据，就直接放进去，如果有数据，就要开始线性探测</span><br>         <span class="hljs-comment">//空或者删除都可以放</span><br><br>         <span class="hljs-comment">//线性探测的大逻辑,很容易拥堵在一起，尤其是相连的一块，你占我，我占你</span><br>         <span class="hljs-comment">//二次探测</span><br><br>         <span class="hljs-keyword">while</span> (_table[index]._status == EXISTS)<br>         &#123;<br>             <span class="hljs-comment">//数据存在，就继续往下探测</span><br>             i++;<br>             index = start + i * i; <span class="hljs-comment">//这个是依次探测</span><br>             <span class="hljs-comment">//如果到最后还有数据的话，那就要绕回来</span><br>             index %= _table.<span class="hljs-built_in">size</span>();<br>         &#125;<br>         <span class="hljs-comment">//一定是在一个可以放数据的地方</span><br>         _table[index]._kv = kv;<br>         _table[index]._status = EXISTS; <span class="hljs-comment">//插入设置存在</span><br>         _n++;<br><br>         <span class="hljs-comment">//找空位置的代价会很大</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>     &#125;<br> &#125;;<br></code></pre></td></tr></table></figure><h1 id="散列表（哈希桶）"><a href="#散列表（哈希桶）" class="headerlink" title="散列表（哈希桶）"></a>散列表（哈希桶）</h1><p>将vector里面的数据结构换成单链表<br>把冲突的数据都串在一起</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>&gt;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HashNode</span><br>&#123;<br>    pair&lt;K, V&gt; _kv;<br>    HashNode&lt;K, V&gt; *_next; <span class="hljs-comment">//我们用一个单链表,我们自己弄的</span><br>    <span class="hljs-built_in">HashNode</span>(<span class="hljs-type">const</span> pair&lt;K, V&gt; &amp;kv)<br>        : _kv(kv), _next(<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hash</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> key; <span class="hljs-comment">//负数也给他转化成非负数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashFunc</span> = Hash&lt;K&gt;&gt;<br><span class="hljs-keyword">class</span> HashTable<br>&#123;<br>    <span class="hljs-keyword">typedef</span> HashNode&lt;K, V&gt; Node;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;Node *&gt; _table; <span class="hljs-comment">//链表里面的元素挂起来,指针数组</span><br>    <span class="hljs-type">size_t</span> _n = <span class="hljs-number">0</span>;         <span class="hljs-comment">//有效数据，计算负载因子</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (_table.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        HashFunc hc;<br>        <span class="hljs-type">size_t</span> index = <span class="hljs-built_in">hc</span>(key) % _table.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (_table[index] == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//没找到</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//在它对应的链表下面找，看看能不能找的到</span><br>            Node *cur = _table[index]; <span class="hljs-comment">//_table[index]就是对应链表的头节点</span><br>            <span class="hljs-keyword">while</span> (cur)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;_kv.first == key)<br>                    <span class="hljs-keyword">return</span> cur;<br>                cur = cur-&gt;_next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Erase</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (_table.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到了，就把它给删除掉</span><br>        HashFunc hc;<br>        <span class="hljs-type">size_t</span> index = <span class="hljs-built_in">hc</span>(key) % _table.<span class="hljs-built_in">size</span>();<br>        Node *cur = _table[index];<br>        Node *prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;_kv.first == key)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(prev==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    <span class="hljs-comment">//头删除</span><br>                    _table[index]=cur-&gt;_next;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                prev-&gt;_next = cur-&gt;_next;<br>                <span class="hljs-keyword">delete</span> cur;<br>                --_n;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                prev = cur;<br>                cur = cur-&gt;_next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;K, V&gt; &amp;kv)</span></span><br><span class="hljs-function">    </span>&#123;<br><br>        Node *ret = <span class="hljs-built_in">Find</span>(kv.first);<br>        <span class="hljs-keyword">if</span> (ret)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        HashFunc hc;<br><br>        <span class="hljs-keyword">if</span> (_n == _table.<span class="hljs-built_in">size</span>()) <span class="hljs-comment">//这里我们可以让负载因子变得大一点,负载因子=1的时候扩容`</span><br>        &#123;<br>            <span class="hljs-type">size_t</span> newcp = _table.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> ? <span class="hljs-number">10</span> : _table.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//这里就自己来挪动，使用和闭散列一样的方法，不好，因为会一直要new节点，</span><br>            vector&lt;Node *&gt; newTable;<br>            newTable.<span class="hljs-built_in">resize</span>(newcp); <span class="hljs-comment">//扩容后要进行重新映射</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _table.<span class="hljs-built_in">size</span>(); i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (_table[i])<br>                &#123;<br>                    <span class="hljs-comment">//有数据</span><br>                    Node *cur = _table[i];<br>                    <span class="hljs-keyword">while</span> (cur)<br>                    &#123;<br>                        <span class="hljs-comment">//把这个数据弄下来，直接</span><br>                        Node *next = cur-&gt;_next;<br>                        <span class="hljs-type">size_t</span> index = <span class="hljs-built_in">hc</span>(cur-&gt;_kv.first) % newTable.<span class="hljs-built_in">size</span>();<br>                        <span class="hljs-comment">//然后进行头插</span><br>                        cur-&gt;_next = newTable[index];<br>                        newTable[index] = cur;<br>                        cur = next;<br>                    &#125;<br>                &#125;<br>                _table[i] = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//弄完了就把对应的数据给清空即可</span><br>            &#125;<br>            <span class="hljs-comment">// newcp里面的数据都是我们想要的</span><br>            _table.<span class="hljs-built_in">swap</span>(newTable);<br>        &#125;<br>        <span class="hljs-type">size_t</span> index = <span class="hljs-built_in">hc</span>(kv.first) % _table.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//没有数据</span><br>        Node *newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(kv); <span class="hljs-comment">//新的头节点</span><br>        newnode-&gt;_next = _table[index];<br>        _table[index] = newnode; <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//用头插法把数据插进去，因为重新映射代价比较大</span><br><br>        _table[index] = newnode;<br>        _n++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 哈希算法 散列表 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL函数</title>
    <link href="/2022/10/11/MySQL%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/11/MySQL%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">函数</a></li><li><ul><li><a href="#_2">日期函数</a></li></ul></li><li><a href="#_46">字符串函数</a></li><li><a href="#_125">数学函数</a></li><li><a href="#_164">其他函数</a></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><ul><li>current_date():当前日期</li><li>current_data():当前时间</li><li>current_timestamp:获得时间戳</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_date</span>();<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c636ffa0b9f444bab0743764d2866562.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_time</span>();<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7b030dc10a574904b42b5abb39ba85e3.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">current_timestamp</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0e38d6c8a8a644b7a16f795b754764e9.png" alt="在这里插入图片描述"></p><ul><li>date_add(date,interval )日期相加</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> date_add(<span class="hljs-string">&#x27;2017-2-12&#x27;</span>,<span class="hljs-type">interval</span> <span class="hljs-number">10</span> <span class="hljs-keyword">day</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/53719131ae72400487763c17674c9ce4.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> date_add(<span class="hljs-string">&#x27;2017-2-12&#x27;</span>,<span class="hljs-type">interval</span> <span class="hljs-number">10</span> <span class="hljs-keyword">month</span>);<br></code></pre></td></tr></table></figure><p>创建表，记录日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">day</span>( id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,timed <span class="hljs-type">date</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">day</span> (timed) <span class="hljs-keyword">values</span> (<span class="hljs-built_in">current_date</span>());<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">day</span>;<br></code></pre></td></tr></table></figure><ul><li>创建一个评论区:保存大家的评论(昵称，id，)</li></ul><p>  now插入当前的时间,设置timestap可以自动更新时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> msg modify sendtime <span class="hljs-type">timestamp</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> msg (content,sendtime) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;tw是zg&#x27;</span>,now());<br></code></pre></td></tr></table></figure><p>查询两分钟以内的帖子，将评论的时间+2分钟，&lt;now（）,就是2分钟以内的时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> msg <span class="hljs-keyword">where</span> date_add(sendtime,<span class="hljs-type">interval</span> <span class="hljs-number">2</span> <span class="hljs-keyword">minute</span>) <span class="hljs-operator">&gt;=</span>now();<br></code></pre></td></tr></table></figure><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ul><li>charset(str),查看编码集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> charset(<span class="hljs-string">&#x27;中国&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6d901aa9ec9943efb7914329694915d1.png" alt="在这里插入图片描述"></p><ul><li>contact :连接字符串</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;你好&#x27;</span>,<span class="hljs-string">&#x27;码&#x27;</span>,<span class="hljs-string">&#x27;吃了吗&#x27;</span>);<br></code></pre></td></tr></table></figure><p>要求显示student表中的信息，显示格式”xxx的语文是xxx分，数学是xxx分，英语xxx分”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(name,<span class="hljs-string">&#x27;的语文成绩是：&#x27;</span>,chinese,<span class="hljs-string">&#x27;数学成绩是:&#x27;</span>,math,english) 成绩单 <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;cxk&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat (<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/61ca7e207a5b4341a442cbf966c00402.png" alt="在这里插入图片描述"></p><ul><li>length：求字符串的字节数</li></ul><p>  计算表中姓名的字节数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> length(name) <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f93b1ddccbee490b80cbf2dcb23cf82e.png" alt="在这里插入图片描述"></p><ul><li>replace:将表中的数据中S都替换成上海</li></ul><p>  将nihao改成NIHAO</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> replace (<span class="hljs-string">&#x27;hello nihaoma&#x27;</span>,<span class="hljs-string">&#x27;nihao&#x27;</span>,<span class="hljs-string">&#x27;NIHAO&#x27;</span>); <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> replace(ename,<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>) <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><p>只是把数据赛选出来之后，才进行替换<br><img src="https://img-blog.csdnimg.cn/a7ea7ca78fa74773adaaeb37cb579a6d.png" alt="在这里插入图片描述"></p><ul><li><p>substring：获得子串,和c++差不多<br>从第二个开始截取多少个字节</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;abcdef&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li><p>ucase:把小写变大写</p><ul><li>lcase:把小写变大写</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> lcase(<span class="hljs-string">&#x27;abcdeDEF&#x27;</span>);<br><span class="hljs-keyword">select</span> ucase(<span class="hljs-string">&#x27;abcde&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>instr();查找后一字符串在前一个中的第一次出现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> instr(<span class="hljs-string">&#x27;abc123adsd123&#x27;</span>,<span class="hljs-string">&#x27;123&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6914ea8b94fc4434b6b151e5dca6bc0e.png" alt="在这里插入图片描述"></p><ul><li>left()从左边截取多少个字符,</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">left</span>(<span class="hljs-string">&#x27;12345&#x27;</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/af0fd5a3082d43d3843dfe1838bd2ab3.png" alt="在这里插入图片描述"></p><ul><li>ltrim:把不要的去掉，去掉空字符</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ltrim (<span class="hljs-string">&#x27;     abcde&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>rtrim :清洗右边</li></ul><p>  <img src="https://img-blog.csdnimg.cn/3c4964d0d8d44eec95644717598f0273.png" alt="在这里插入图片描述"><br>  trim清洗两边</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ltrim (<span class="hljs-string">&#x27;abcde    &#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>以首字母小写的方式来显示员工的姓名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(lcase(<span class="hljs-keyword">left</span>(ename,<span class="hljs-number">1</span>)) ,<span class="hljs-built_in">substring</span>(ename,<span class="hljs-number">2</span>)) <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/052330c1b898405eb8302fd13a30af77.png" alt="在这里插入图片描述"></p><h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><ul><li>abs(绝对值)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><ul><li>bin()将10进制转化成2进制</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> bin(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>hex:将10进制转成16进制</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> hex(<span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ccacd09f06be4faf9a062472df08bc13.png" alt="在这里插入图片描述"></p><ul><li>ceiling: 向上取整</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceiling</span>(<span class="hljs-number">2.2</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceiling</span>(<span class="hljs-number">-2.2</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3cc73a7ff49b4f96a9d70a948e1a0239.png" alt="在这里插入图片描述"></p><ul><li>floor():向下取整</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">2.2</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/84aadd5e645e4d59996144e6040aa590.png" alt="在这里插入图片描述"></p><ul><li>format()格式话，四舍五入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> format(<span class="hljs-number">3.1415</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/727d2be1c1644d738adeba5bc619b57f.png" alt=" "></p><ul><li>rand():取随机值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> rand();<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/96951e816aaf443a97780654c3ef3b5f.png" alt="在这里插入图片描述"></p><ul><li>mod()：取模</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><ul><li>user :查询当前用户</li><li>MD5（str）对一个字符串进行md5摘要，获得32位字符串</li><li>database显示当前在使用的数据库</li><li>password（），mysql使用该函数对用户进行加密</li><li>ifnull（val1，val2）：如果val1位空，返回val2，否则返回val1<br><img src="https://img-blog.csdnimg.cn/446005ed2506488e9e3eb9cc1dc6d47c.png" alt="在这里插入图片描述"></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL表的增删查改</title>
    <link href="/2022/10/09/MySQL%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/"/>
    <url>/2022/10/09/MySQL%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#CREATE_2">CREATE</a></li><li><a href="#Retrieve_69">Retrieve</a></li><li><a href="#Update_293">Update</a></li><li><a href="#Delete_323">Delete</a></li><li><ul><li><a href="#_336">截断表</a></li></ul></li><li><a href="#_348">插入查询的数据</a></li><li><a href="#_372">聚合函数</a></li><li><a href="#group_by_410">group by</a></li></ul><p>CURD：create() retrieve updata delete</p><h1 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h1><p>增加数据<br>insert</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> s(<br>   <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>   <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> sn <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> comment<span class="hljs-string">&#x27;学生的学号&#x27;</span>,<br>   <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span> ,<br>   <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> qq <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span><br>   <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/801626a0c7a141a2992a18e5aab7c6be.png" alt="在这里插入图片描述"></p><p>正常插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> s(id,sn,name,qq) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-number">21</span>,<span class="hljs-string">&#x27;as&#x27;</span>,<span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure><ul><li>单行全列插入,可以省略前面的key,建议不要省略</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> s <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,<span class="hljs-number">222</span>,<span class="hljs-string">&#x27;as2&#x27;</span>,<span class="hljs-number">212</span>);<br></code></pre></td></tr></table></figure><ul><li>插入局部列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> s(id,sn,name) <span class="hljs-keyword">values</span> (<span class="hljs-number">222</span>,<span class="hljs-number">2222</span>,<span class="hljs-string">&#x27;asss&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e96f519c0b814a399469f0926707a65b.png" alt="在这里插入图片描述"></p><ul><li>插入多行数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> s(id,sn,name,qq) <span class="hljs-keyword">values</span> (<span class="hljs-number">22234</span>,<span class="hljs-number">224322</span>,<span class="hljs-string">&#x27;as53ss&#x27;</span>,<span class="hljs-number">1231</span>),(<span class="hljs-number">8</span>,<span class="hljs-number">76</span>,<span class="hljs-string">&#x27;65&#x27;</span>,<span class="hljs-number">31312</span>);<br></code></pre></td></tr></table></figure><p>插入的数据用，隔开</p><p><img src="https://img-blog.csdnimg.cn/368295a2d54842dca9c4b7ac2af1c106.png" alt="在这里插入图片描述"></p><ul><li>插入的数据和主键出现冲突</li></ul><p>  出现冲突，就帮助我们修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> s (id,sn,name,qq) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-number">21</span>,<span class="hljs-string">&#x27;asdasd&#x27;</span>,<span class="hljs-number">127</span>) <span class="hljs-keyword">on</span> duplicate key <span class="hljs-keyword">update</span> sn<span class="hljs-operator">=</span><span class="hljs-number">1</span>,id<span class="hljs-operator">=</span><span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><p>这个会把冲突那个数据修改，</p><p>0 row affected;表中有冲突数据，但是冲突数据和update值一样<br>1 row affected :表中没有冲突数据，数据插入<br>2 row affected :表中有冲突数据，不求额数据被更新</p><p>不存在插入，存在修改即可，替换之前的那些数据</p><ul><li>replace 替换</li></ul><p>  和刚才的insert替换一样的<br>  没有冲突直接插入<br>  有冲突替换再插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">replace <span class="hljs-keyword">into</span> l(id) <span class="hljs-keyword">value</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>创造和之前的表一样的结构<br>like</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> duplicate_tb_bak <span class="hljs-keyword">like</span> duplicate_tb;<br><br></code></pre></td></tr></table></figure><h1 id="Retrieve"><a href="#Retrieve" class="headerlink" title="Retrieve"></a>Retrieve</h1><p>查询<br>select</p><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">[db1]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> exam_result(<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">primary</span> key auto_increment,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> chinese <span class="hljs-type">float</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0.0</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> math <span class="hljs-type">float</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0.0</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> english <span class="hljs-type">float</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0.9</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4fb9d98a8856459d9a85caff8dd92f27.png" alt="在这里插入图片描述"></p><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">[db1]<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam_result (name,chinese,math,english) <span class="hljs-keyword">values</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-string">&#x27;tsz&#x27;</span>,<span class="hljs-number">67</span>,<span class="hljs-number">98</span>,<span class="hljs-number">56</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-string">&#x27;swk&#x27;</span>,<span class="hljs-number">87</span>,<span class="hljs-number">78</span>,<span class="hljs-number">77</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-string">&#x27;cmd&#x27;</span>,<span class="hljs-number">88</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-string">&#x27;lxd&#x27;</span>,<span class="hljs-number">82</span>,<span class="hljs-number">84</span>,<span class="hljs-number">67</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-string">&#x27;sq&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">73</span>,<span class="hljs-number">78</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-string">&#x27;sgm&#x27;</span>,<span class="hljs-number">75</span>,<span class="hljs-number">65</span>,<span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><ul><li>全列查询</li></ul><p>  通常情况下，不建议使用* 进行全列查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e2f1affee9b745399f0c54db0ac396f5.png" alt="在这里插入图片描述"><br>select 后面跟上要查询的列,指定列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql;">select id,name from exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/63588e5cf4794694b726aa4521a8582f.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> english,id,name <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p>也可以包含一个不存在的字段，只能是一个可被计算的表达式<br><img src="https://img-blog.csdnimg.cn/51c0ccc527624ca68be0e6055a2d6a7b.png" alt="在这里插入图片描述"><br>把所有人的id和英语成绩查出来，把英语成绩+10分 ,没有影响原始数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> english<span class="hljs-operator">+</span><span class="hljs-number">10</span> ,id <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/baf16d05aba941f4b9e63f6b5fe4dde5.png" alt="在这里插入图片描述"><br>我想知道所有人的总分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> english<span class="hljs-operator">+</span>chinese<span class="hljs-operator">+</span>math <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/10985fb215be4306856af1ff497c2e4c.png" alt="在这里插入图片描述"><br>select 后面的数据+as “ “,将其进行重命名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> english<span class="hljs-operator">+</span>chinese<span class="hljs-operator">+</span>math <span class="hljs-keyword">as</span> 总分 <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0627887e845c4e9789c1993aad042fd2.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id 唯一值,name 昵称,english<span class="hljs-operator">+</span>chinese 分数 <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6ed7231620a540b6a9d996fd54f93e8e.png" alt="在这里插入图片描述"></p><ul><li>去重</li></ul><p>  <img src="https://img-blog.csdnimg.cn/98b00f3dc04243dda152c5114c085457.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-keyword">distinct</span> math <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6eda20e597034ae0b58575d342bc9a3f.png" alt="在这里插入图片描述"><br>把所有成绩从高到底进行排序 按总分排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name,chinese<span class="hljs-operator">+</span>english<span class="hljs-operator">+</span>math 总分 <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 总分;<br></code></pre></td></tr></table></figure><p>默认是升序排列asc(ascending)<br><img src="https://img-blog.csdnimg.cn/f0cd4b88ff774efa9283ecf3b68cc395.png" alt="在这里插入图片描述"></p><p>降序的话desc (descending)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name,chinese<span class="hljs-operator">+</span>english<span class="hljs-operator">+</span>math 总分 <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 总分 <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/233bbc1949224eebb15003a7f061fbd6.png" alt="在这里插入图片描述"></p><ul><li>where条件</li></ul><p>  给查询设置条件<br>  比较运算符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name, math  <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> math<span class="hljs-operator">&gt;=</span><span class="hljs-number">80</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a32ac29541ee46af972783a6a20ba007.png" alt="在这里插入图片描述"><br>查询&lt;80分的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name, math  <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> math<span class="hljs-operator">&lt;=</span><span class="hljs-number">80</span>;<br></code></pre></td></tr></table></figure><p>查询&#x3D;98分的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name, math  <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> math<span class="hljs-operator">=</span><span class="hljs-number">98</span>;<br></code></pre></td></tr></table></figure><p>查询字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name, math  <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;tsz&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/97ba1a333534467799d5567480712290.png" alt="在这里插入图片描述"><br>查询NULL ,空字段<br>&lt;&#x3D;&gt;NULL或者IS</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> t2 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5724a93fa558411e90f02c16b421040c.png" alt="在这里插入图片描述"><br>查询非空字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> t2 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/525ab6a13faa4841a3bb97eaf55bd49a.png" alt="在这里插入图片描述"><br>查询区间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,chinese,math <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> chinese <span class="hljs-keyword">between</span> <span class="hljs-number">80</span> <span class="hljs-keyword">and</span> <span class="hljs-number">95</span>;<br></code></pre></td></tr></table></figure><p>[80,95]包含这两个数的</p><p><img src="https://img-blog.csdnimg.cn/894dd0a1306d4237a3bca11397add0ca.png" alt="在这里插入图片描述"><br>逻辑运算符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,chinese,math <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> chinese <span class="hljs-operator">&gt;=</span><span class="hljs-number">70</span> <span class="hljs-keyword">and</span> chinese <span class="hljs-operator">&lt;=</span><span class="hljs-number">98</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,chinese,math <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> chinese <span class="hljs-operator">=</span><span class="hljs-number">70</span> <span class="hljs-keyword">or</span> chinese <span class="hljs-operator">=</span><span class="hljs-number">98</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/144b14487a564b91bc51cc4d4fb0f6a1.png" alt="在这里插入图片描述"><br>IN(),把里面满足条件的都挑选出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name,math <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> math <span class="hljs-keyword">IN</span>(<span class="hljs-number">58</span>,<span class="hljs-number">78</span>,<span class="hljs-number">98</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3aba321f6cc647f8bb98615ff5886fb6.png" alt="在这里插入图片描述"><br>查询包含一个字符存在的<br>LIKE:模糊匹配，%表示任意多个自读，_表示任意一个字符,后面只能跟一个字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;s%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/76764e2828464cd29217be81fa795d6f.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;s_&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/dd0a6aa02798432881862221b4834d8f.png" alt="在这里插入图片描述"><br>查询语文成绩大于英语成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name ,english ,chinese <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> chinese<span class="hljs-operator">&gt;</span>english;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/35f31952e00d40cf86d3ee324b6b2418.png" alt="在这里插入图片描述"><br>查询总分&lt;200<br>用别名查询可以<br><img src="https://img-blog.csdnimg.cn/5e918992cd7544128cd2ffe60751c4d5.png" alt="在这里插入图片描述"><br>只能加和<br><img src="https://img-blog.csdnimg.cn/d59fd9236f7b4b85892d2565f15b6eb8.png" alt="在这里插入图片描述"></p><ol><li>按照条件赛选数据</li><li>按照要求计算数据<br>select一般都是where先执行早于前面的，起别名都是最后操作的,先执行筛选条件的操作</li></ol><p>where 子句中不能使用where别名,也不能起一个别名</p><p>语文成绩大于80并且不姓’s’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,chinese,math,english <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> chinese<span class="hljs-operator">&gt;</span><span class="hljs-number">80</span> <span class="hljs-keyword">and</span> name  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;s%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>孙某同学，否则要求总成绩&gt;200并且语文成绩&lt;数学成绩并且英语成绩&gt;80</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span><span class="hljs-keyword">select</span> id,name, chinese,math,english, english<span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>chinese 总分 <span class="hljs-keyword">from</span> exam_result<br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">where</span> (name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;s_&#x27;</span>) <span class="hljs-keyword">or</span> <br><span class="hljs-operator">&gt;</span>(english<span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>chinese<span class="hljs-operator">&gt;</span><span class="hljs-number">200</span> <span class="hljs-keyword">and</span> chinese<span class="hljs-operator">&lt;</span>math <span class="hljs-keyword">and</span> english<span class="hljs-operator">&gt;</span><span class="hljs-number">80</span>)<br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 总分 <span class="hljs-keyword">desc</span>; <br></code></pre></td></tr></table></figure><p>null不进行任何的表达式计算<br><img src="https://img-blog.csdnimg.cn/e1f6a6269948413a85fde582bae88913.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/02e8b6eb47bb439786a906631e3b5ce3.png" alt="在这里插入图片描述"></p><p>NULL在排序的时候被视作比所有只都小</p><p>查询同学成绩，按数学降序，英语升序，语文升序<br>多个条件排序 ，优先按照前面的排序，相同按后面的排序，再相同再按后面的排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> math <span class="hljs-keyword">desc</span> ,english <span class="hljs-keyword">asc</span>, chinese <span class="hljs-keyword">asc</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0aa61a439b1745cc996d7119f9aa979a.png" alt="在这里插入图片描述"><br>总分大于200，降序排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name ,english<span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>chinese 总分 <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> english <span class="hljs-operator">+</span>math<span class="hljs-operator">+</span>chinese <span class="hljs-operator">&gt;</span><span class="hljs-number">200</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 总分 <span class="hljs-keyword">desc</span>; <br></code></pre></td></tr></table></figure><p>order by 是最后执行的，筛选数据是最先执行的</p><p>查询姓s的同学或者姓c的同学，结果按照数学成绩排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,math <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;s%&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;c%&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> math <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d157f13fd327406da443ef08da65ed7c.png" alt="在这里插入图片描述"><br>找到总分前三名同学,所有操作都执行了<br><strong>limit 3</strong>，赛选3个，放最后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,math<span class="hljs-operator">+</span>chinese<span class="hljs-operator">+</span>english 总分 <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 总分 <span class="hljs-keyword">desc</span> limit <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>使用limit进行分页limit 2,2从第2条记录往后选两条数据,截取数据库中的一部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> exam_result limit <span class="hljs-number">2</span>,<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9ed2f71449ff4ccfbc6e62ba32b6de43.png" alt="在这里插入图片描述"><br>从第一行开始找4条记录<br><img src="https://img-blog.csdnimg.cn/c16874c4797a4b3bbeec966cd4da6fcc.png" alt="在这里插入图片描述"></p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>更新<br><img src="https://img-blog.csdnimg.cn/74cd975f14454d7a962ea81041bbe8ac.png" alt="在这里插入图片描述"></p><p>将s同学的成绩改成80分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> exam_result <span class="hljs-keyword">set</span> math<span class="hljs-operator">=</span><span class="hljs-number">80</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;swk&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fb5b12525aa44b5ab1308d1943e0f543.png" alt="在这里插入图片描述"><br>将cmd的数学成绩改成60，语文改成70</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> exam_result <span class="hljs-keyword">set</span> math<span class="hljs-operator">=</span><span class="hljs-number">60</span> ,chinese<span class="hljs-operator">=</span><span class="hljs-number">70</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;cmd&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8ea6e1ccdb154dba9cd58e3eeac854f1.png" alt="在这里插入图片描述"><br>将总成绩倒数前三的，加上30分</p><p>先筛选数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name ,chinese<span class="hljs-operator">+</span>english<span class="hljs-operator">+</span>math 总分 <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 总分 <span class="hljs-keyword">asc</span> limit <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> exam_result <span class="hljs-keyword">set</span> math<span class="hljs-operator">=</span>math<span class="hljs-operator">+</span><span class="hljs-number">30</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> math<span class="hljs-operator">+</span>english<span class="hljs-operator">+</span>chinese <span class="hljs-keyword">asc</span> limit <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7ecf586ea3cc463da849647c44bb6b07.png" alt="在这里插入图片描述"><br>把每个数据的语文*2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> exam_result <span class="hljs-keyword">set</span> chinese<span class="hljs-operator">=</span>chinese<span class="hljs-operator">*</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>删除姓s同学的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;s%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/995c58ac0ef7445498b52e150cbc1b40.png" alt="在这里插入图片描述"><br>删除整张表的数据，不是删除表(慎重)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p>但是再插入数据之后，自增字段还会继续<br><img src="https://img-blog.csdnimg.cn/bb33e1142eaa493a92e441f3f31a714b.png" alt="在这里插入图片描述"></p><h2 id="截断表"><a href="#截断表" class="headerlink" title="截断表"></a>截断表</h2><p>截断表：清空表，和delete差别就是会把auto_increment进行清零<br><img src="https://img-blog.csdnimg.cn/000e920a315b4dcba52b8232e6b6edab.png" alt="在这里插入图片描述"><br>区别还有<br>日志：MySQL的日志，需要承担很大的功能要求</p><ol><li>bin log:上下翻动的时候，都能记得住，我们所有的sql操作，mysql服务器就能给我们记录下来，该log可以用来多主机同步，在增量上备份</li><li>redo log:承担MySQL数据持久化，和mysql的crash_safe功能，突然崩溃的时候，避免数据丢失，保持安全（）</li><li>undo log:在事务中承担回滚的日志，数据操作回复的功能</li></ol><p>delete会更新日志的，truncate不会更新</p><h1 id="插入查询的数据"><a href="#插入查询的数据" class="headerlink" title="插入查询的数据"></a>插入查询的数据</h1><p>insert 和select可以结合使用<br>新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> duplicate_tb <span class="hljs-keyword">values</span> (<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;aaa&#x27;</span>),(<span class="hljs-number">200</span>,<span class="hljs-string">&#x27;bbb&#x27;</span>),(<span class="hljs-number">200</span>,<span class="hljs-string">&#x27;bbb&#x27;</span>),(<span class="hljs-number">300</span>,<span class="hljs-string">&#x27;ccc&#x27;</span>);<br></code></pre></td></tr></table></figure><p>新键一个备份的表，把它变成duplicate表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> duplicate_tb_bak <span class="hljs-keyword">like</span> duplicate_tb;<br><br></code></pre></td></tr></table></figure><p>把不重复的数据都插到备份的表里面</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> duplicate_tb_bak <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> duplicate_tb;<br></code></pre></td></tr></table></figure><p>但是我们用一个<strong>rename</strong>,把该表进行修改即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">rename <span class="hljs-keyword">table</span> duplicate_tb <span class="hljs-keyword">to</span> old_duplicate;<br></code></pre></td></tr></table></figure><h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>按行来记录在一起<br>将同类别，进行聚合处理<br>count:计算数据个数<br>sum：计算数据和<br>avg：计算数据<br>max<br>min</p><p>计算exam_result 里面有多少数据<br>count(*)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) 人数 <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ae34405edac945158c3bb814e86c60ef.png" alt="在这里插入图片描述"><br>计算有几个人有id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2b55223e22404d90badff71ba75c8d29.png" alt="在这里插入图片描述"><br>统计id<strong>不相重复</strong>的有多少人</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> id) <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5e4f5fa4889146f5b5785f21751040e3.png" alt="在这里插入图片描述"><br>统计班级的数学总分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(math) <span class="hljs-keyword">from</span> exam_result;<br></code></pre></td></tr></table></figure><p>统计数学成绩不及格的人总分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(math) <span class="hljs-keyword">from</span> exam_result <span class="hljs-keyword">where</span> math<span class="hljs-operator">&lt;</span><span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b57aaacc7801453ea7ba290746130e94.png" alt="在这里插入图片描述"><br>统计数学成绩的平均数</p><h1 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h1><p>按列来进行数据统计<strong>分类</strong><br>先分组，再对select进行数据的赛选统计</p><p>显示每个部门的平均工资<br>按部门对员工进行分组,分组不是目的，还要对每一组进行聚合求值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno, <span class="hljs-built_in">avg</span>(sal),<span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br></code></pre></td></tr></table></figure><p>先执行from emp，后按部门分组，再进行计算</p><p><img src="https://img-blog.csdnimg.cn/4817080ee397493d82c6724062e8f865.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">avg</span>(sal) 平均工资 ,<span class="hljs-built_in">min</span>(sal) 最低工资 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno,job;<br></code></pre></td></tr></table></figure><p>同一部门，同义工作的进行分组<br><img src="https://img-blog.csdnimg.cn/3bd88409937a478ea17ae761032c06fd.png" alt="在这里插入图片描述"></p><p>显示平均工资小于2000的部门和它的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno ,ename,<span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&lt;</span><span class="hljs-number">2000</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br></code></pre></td></tr></table></figure><p>having经常和group by进行赛选，相当于where<br>先分完组，再对数据进行赛选</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno ,ename,<span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno <span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span>(sal)<span class="hljs-operator">&lt;</span><span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><p>having要先分组，才能有效果,分组之后才能有效果</p><p>where和having</p><blockquote><p>根本原因在于，两者的执行次序是不一样的<br>where是过滤表的数据的<br>having是过滤分组的数据<br>两者不冲突</p></blockquote><p>除了10号部门，平均工资小于2000部门和它的工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno ,ename,<span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">!=</span><span class="hljs-number">10</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno <span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span>(sal)<span class="hljs-operator">&lt;</span><span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/01a51939146c4b2c919917f06c848d0c.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据类型</title>
    <link href="/2022/10/05/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/10/05/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">数据类型</a></li><li><ul><li><a href="#_2">数据库类型的分类</a></li><li><ul><li><a href="#_7">数值类型</a></li><li><a href="#_47">字符串类型</a></li></ul></li><li><a href="#_72">日期</a></li><li><a href="#enum_set_83">enum 和set</a></li></ul></li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数据库类型的分类"><a href="#数据库类型的分类" class="headerlink" title="数据库类型的分类"></a>数据库类型的分类</h2><p><img src="https://img-blog.csdnimg.cn/77c4b4a86ebc4a40953da4e27e461f16.png" alt="在这里插入图片描述"><br>类型也是一种约束 ，限制，不让你做某件事情</p><ul><li>可以决定占用空间的大小，既要考虑类型也要考虑磁盘，</li><li>检验sql是否合法，语法检查上左右类型不匹配</li></ul><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><ul><li>tinyint<br><img src="https://img-blog.csdnimg.cn/ff17580e140e4e19b8d8a851f88e70f5.png" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/34195f388bcd4228ad1fa6d86e13bcc6.png" alt="在这里插入图片描述"><br>无符号数0-255<br><img src="https://img-blog.csdnimg.cn/4d9621eb6a184af9b98b00ccbd06b8fd.png" alt="在这里插入图片描述"><br>tinyint：当我们插入的时候，如果数据越界（sql就会重新终止，或者变到这个非法范围最接近的数）<br>字符串也同样接收<br><img src="https://img-blog.csdnimg.cn/82159829decb41f7acf4b3f437661198.png" alt="在这里插入图片描述"><br>通过数据类型来约束我们，在mysql里面只允许插入合法类型,合法数值，<strong>建议不要使用unsigned</strong></p><ul><li>bit<br>bit(m),m指定位数，默认为1，1-64<br>bit显示字段的时候，是<strong>按照ascill对应的值</strong>进行显示</li></ul><p><img src="https://img-blog.csdnimg.cn/bcd590fc7df848aa85c9ac0f2974e8f0.png" alt="在这里插入图片描述"></p><p>bit按照ascill值显示</p><p><img src="https://img-blog.csdnimg.cn/150fa16676eb434d97b64c49e1c3b494.png" alt="在这里插入图片描述"><br>1，0在ascill表中都是不可显示的</p><ul><li>float<br>float (m,d),m代表显示长度，d是指定小数点后面的位数，占4个字节<br>float(4,2)显示-99.9~99.99<br>msql在保存时会采取四舍五入的方案</li></ul><p><img src="https://img-blog.csdnimg.cn/5289822393984f0d9d7997a78ec5a437.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/fe4407eae79d4e88a1fa3db3720800a1.png" alt="在这里插入图片描述"><br>采用四舍五入的方法，mysql存储的仍然是99.99<br>unsigned加后面float只支持无符号数</p><ul><li>decimal<br>decimal（m,d）和float一样<br><img src="https://img-blog.csdnimg.cn/c245446a3b3c4dcbac7b9e73d36948d7.png" alt="在这里插入图片描述"><br>float在存储的时候，精度不是很高，所以在float精度7位当中，我们<strong>只推荐decimal</strong>，<strong>精度更高</strong>，double也不要使用，decimal支持的精度最大64位<br><img src="https://img-blog.csdnimg.cn/02d23905515540deb0395e5ef4dad0f0.png" alt="在这里插入图片描述"><br>decimal整数最大位数m&#x3D;65，支持小数最大位数d&#x3D;30，如果d被省略了，默认为0，m被省略，默认为10，我们建议不要省略</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li><p>char<br>char （l）：固定长度字符串，l是可以存储的长度，最大长度为255,单位是字符<br>l即可以插入的长度的最大值,放l个字符<br><img src="https://img-blog.csdnimg.cn/82f1d25a39664e0ba4c5735df6f8df48.png" alt="在这里插入图片描述"><br>字符！&#x3D;字节<br><strong>一个英文单词&#x2F;汉字就是一个字符</strong></p></li><li><p>varchar<br>varchar(l):<strong>可变长度</strong>字符串，l表示字符串长度,单位是字符，最大长度是65535个<strong>字节</strong>,不是字符,</p></li></ul><p><img src="https://img-blog.csdnimg.cn/0e4923e69afd4142b67223504d7a82b6.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5664f98aa7cb4fa1badc7e21627c63f0.png" alt="在这里插入图片描述"><br>和char的区别<br>char（8）我们存abcd，它会开8个空间，空间浪费<br>varchar（8）我们存abcd，它会存4个字节,调整开辟空间的量，空间不会浪费</p><p>说明</p><ul><li>我们可以使用65532个字节，varchar的长度是65535个，有1-3个用来记录我们用了多少个字节</li><li>当我们使用utf8编码的时候，我们最大的使用参数是65535&#x2F;3&#x3D;21844，一个字符占用3字节</li><li>变长效率比较低，不变效率比较高</li></ul><p>越界都会报错</p><p><img src="https://img-blog.csdnimg.cn/5540be05e3b7437aaecff7f9152d87f5.png" alt="在这里插入图片描述"></p><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><ul><li>date：年-月-日，占3字节</li><li>datatime :时间日期 ，年-月-日-时-分-秒，占8字节</li><li>timestamp:时间戳，从1970年开始，格式和datetime一样，占4个字节,我们创建出来，就会自动更新,默认就是当前时间 ，最近修改的时间记录下来</li></ul><p><img src="https://img-blog.csdnimg.cn/aa653ea9880c4556a787f641240967e7.png" alt="在这里插入图片描述"><br>格式都是一样的，在数据库里面</p><p>字段得全，分隔符我们写的不同格式，在mysql中都会做调整，所以，我们最好就按照mysql里面的操作进行操作<br><img src="https://img-blog.csdnimg.cn/9bea2a1b934f4456ab07084e4f111ad8.png" alt="在这里插入图片描述"><br>这个地方修改了t1之后t3会自动更新</p><h2 id="enum-和set"><a href="#enum-和set" class="headerlink" title="enum 和set"></a>enum 和set</h2><ul><li>enum枚举类型，单选<br>enum（选项1，选项2.。。）最多是65535个选项，在里面还是以整数进行存储的</li></ul><p><img src="https://img-blog.csdnimg.cn/e96e62899eed41b0b1c31d1dcd31b4cc.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/75b94e156219464992ac7f9079b4bc32.png" alt="在这里插入图片描述"><br>底层还是存储整数</p><ul><li>set集合，多选<br>set（选项1，选项2.。。）最多是65535个选项，在里面还是以整数进行存储的<br>案例：调查一个人的喜好</li></ul><p><img src="https://img-blog.csdnimg.cn/678af5badfe3437ca45576dc8021037f.png" alt="在这里插入图片描述"><br>用，进行分割</p><p><img src="https://img-blog.csdnimg.cn/bfbee0e677cd4387bf43a6dc872faeeb.png" alt="在这里插入图片描述"><br>set它也是用1，2，3来表示对应的爱好,它是用比特位来表示选择什么选项,1,2代表是比特位的位数</p><p>select * from votes where find_in_set(‘swim’，sports);&#x2F;&#x2F;这样会把爱好游泳的都搜查出来<br><img src="https://img-blog.csdnimg.cn/c2824a88792240dfaac113c2d1f40679.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL约束</title>
    <link href="/2022/10/05/MySQL%E7%BA%A6%E6%9D%9F/"/>
    <url>/2022/10/05/MySQL%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">表的约束</a></li><li><ul><li><a href="#_5">空属性</a></li><li><a href="#_24">默认值</a></li><li><a href="#_41">列描述</a></li><li><a href="#zerofill_54">zerofill</a></li><li><a href="#_66">主键</a></li><li><a href="#_107">自增长</a></li><li><a href="#_121">唯一键</a></li><li><a href="#_153">外键</a></li></ul></li></ul><p>MySQL为了让我们的表结构里面的数据完整性一致性非常强，mysql是给我们提供强约束的，在建表的时候就要把约束建立好</p><h1 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h1><p>真正的约束字段是数据类型，但是数据类型约束很单一，需要一些额外的约束，<br>mysql是和数据打交道的，mysql一定要尽量保证数据不要出现偏差，</p><h2 id="空属性"><a href="#空属性" class="headerlink" title="空属性"></a>空属性</h2><ul><li>两个属性：null和not null</li></ul><p>c&#x2F;c++ :null,0,‘\0’<br>mysql:<strong>NULL</strong>为不存在（空）！&#x3D;0！&#x3D;‘’\0’，就是我们没填<br>显示出来NULL就说明这个字段没填<br>这边的NULL显示的是yes，说明可以为null，就是我们可以不填<br><img src="https://img-blog.csdnimg.cn/ab965227c1b940eead3867383587664d.png" alt="在这里插入图片描述"><br>有的时候我们希望插入的时候字段都要有，不能为空,要么就别写，要么就都要写</p><p>添加约束not null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> myclass(name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,room <span class="hljs-type">varchar</span>(<span class="hljs-number">24</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/dc11aa59c6774fb0a4f5444ec2194222.png" alt="在这里插入图片描述"><br>这样保证了在表里面的数据都是有值的<br><img src="https://img-blog.csdnimg.cn/018e0667200440a48bd956210b897019.png" alt="在这里插入图片描述"></p><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>如果我们没有填写的话，它就会填进去我们设置的默认值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> friend (name <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,age <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>,sex <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d3b2fbdb560245fc8d3e3ff03fda9a07.png" alt="在这里插入图片描述"></p><p>默认值最大的意义是允许为空，但是一旦为空的时候，就填入一个缺省值,这样也就是不会出现空值<br><img src="https://img-blog.csdnimg.cn/27aefab050754e2b83a66af9df87de0d.png" alt="在这里插入图片描述"><br>如果即用not null也有default，那么这个not null没有意义了，因为有default了，这个字段永远不为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t11 (name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;as&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/39e2395c634a42c3813e89d9abb3bb01.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8d907830b2e845648a1399dfc8534abc.png" alt="在这里插入图片描述"></p><h2 id="列描述"><a href="#列描述" class="headerlink" title="列描述"></a>列描述</h2><p>comment 专门用来描述这个字段是什么意思的，给程序员来进行了解的,就是注释</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> t2 (name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,age <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;这是用户的年纪&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查看列描述</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t2\G;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ef0ba04a0d7a498e8eb05299e07b21a2.png" alt="在这里插入图片描述"></p><h2 id="zerofill"><a href="#zerofill" class="headerlink" title="zerofill"></a>zerofill</h2><p>显示宽度</p><p>用0补位，int（5）zerofill,超过了正常位数，就正常显示，如果没有超过，前面就要用0来补位，满足5位,不影响数据的大小</p><p><img src="https://img-blog.csdnimg.cn/ccfc6833258f486ebb5e6d1293f8674b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ccd6cdbfa99a473bbcf09b91351e8e81.png" alt="在这里插入图片描述"><br>我们再b那边再增加一个字段，zerofill这样它如果没有达到里面填写的位数的话，就会用0来补齐<br><img src="https://img-blog.csdnimg.cn/3a9d342f46e94df1a81d2345ea1653bd.png" alt="在这里插入图片描述"></p><p>如图，我们设置的5位，但是只填了3位，剩下的就用0来补齐<br><img src="https://img-blog.csdnimg.cn/36923f7c454a4c94bc15c92d428c4888.png" alt="在这里插入图片描述"></p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>所有的表都要有主键</p><p>数据库存入数据不是唯一目的，也要方便提取<br>一般而言，要求数据库表中的记录，有一个特定的唯一标识，来标定唯一性！</p><p>主键：priority key用来唯一约束该字段里面的数据，不能重复，不能为空，一张表里面最多只有<strong>一个主键</strong>,主键对应的字段为唯一值</p><ul><li>创建表的时候，直接在字段上指定主键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t33 (id tinyint <span class="hljs-keyword">primary</span> key comment <span class="hljs-string">&#x27;这是用户的主键&#x27;</span>,name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>));<br></code></pre></td></tr></table></figure><p>这里的额外的字段<br><img src="https://img-blog.csdnimg.cn/b303b0f0d6dd4b50a6f8d708af3623d0.png" alt="在这里插入图片描述"><br>重复的插入一个id&#x3D;12，就会给我们报错<br><img src="https://img-blog.csdnimg.cn/958409da3d954f939705283fcf30eeec.png" alt="在这里插入图片描述"><br>这样之后id一定不会重复,以后我们就可以用主键来快速找到一个人的信息<br><img src="https://img-blog.csdnimg.cn/361ba5f9ebdb418ca87247bb0502abb6.png" alt="在这里插入图片描述"><br>我们可以用<strong>主键</strong>来筛选出我们要的东西<br><img src="https://img-blog.csdnimg.cn/e5283e2236634582becb3d7075da2477.png" alt="在这里插入图片描述"></p><p>主键的删除,只是删除主键约束,这个时候，就允许我们的id可以重复,因为我们只是把主键约束给删除掉，并没有删除其他的数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t33 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br></code></pre></td></tr></table></figure><p>添加主键，要我们明确是添加到哪一列上，<br>添加前有重复值，它就会报错,只能添加在那一列是唯一值的</p><ul><li>复合主键</li></ul><p>  设置多个主键,<br>  把主键的设置放在最后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t55 (id <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) zerofill,course <span class="hljs-type">char</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;课程&#x27;</span>,score <span class="hljs-type">decimal</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;60&#x27;</span> comment <span class="hljs-string">&#x27;这个是默认的得分&#x27;</span>,<span class="hljs-keyword">primary</span> key(id,course));<br></code></pre></td></tr></table></figure><p>有一个值冲突，不算冲突，两个值都冲突才算冲突<br><img src="https://img-blog.csdnimg.cn/821c9c27e38c4f23a45d0f6e1cfcb23a.png" alt="在这里插入图片描述"></p><h2 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h2><p><strong>auto_increment</strong> :当对应的字段，不给值，会自动被系统触发，系统自动会给你填入，会帮你最大值+1，<strong>通常必须搭配主键使用</strong>，必须使用整数，一张表只能有一个自增长，最开始我们没有设置就是从0开始增长，建议不要设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t09 (id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment<span class="hljs-string">&#x27;自增长&#x27;</span>,name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b9507780cef443ce93182f33164d90cf.png" alt="在这里插入图片描述"><br>我们发现，不给id设置，系统会自动对id进行给值，每次都是之前的+1，从最大值往后递增</p><p><img src="https://img-blog.csdnimg.cn/80803d01d2014dd6b53b6dfff80f8a1a.png" alt="在这里插入图片描述"><br>我们设置自增的话，这个字段就不要我们自己设置<br>auto_increment 必须和主键进行搭配,否则就会报错</p><h2 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h2><p>主键只能有一个，唯一键可以有很多个</p><p>唯一键允许为空，主键不能为空，主键能标识唯一性，唯一键也能标识唯一键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tt (id <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;唯一键&#x27;</span>,name <span class="hljs-type">char</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>null字段允许为空<br><img src="https://img-blog.csdnimg.cn/8b967a40f3d946e7989016b21f94b0dc.png" alt="在这里插入图片描述"><br>这里我们重复向唯一键中插入值，它不允许我们插入相同的值<br><img src="https://img-blog.csdnimg.cn/ce9ad1d857b04e369ef6588ce6a6e579.png" alt="在这里插入图片描述"><br>没有给id赋值，它允许为空，null，null代表的没有字段<br><img src="https://img-blog.csdnimg.cn/962226ba5ac44960b6e9953682fad1dc.png" alt="在这里插入图片描述"><br>在unique 前面加上not null，这个unique就变成了primary key，一旦变成非空，就变成了主键,所以不要取设置not null字段<br><img src="https://img-blog.csdnimg.cn/cd35e217093746fda0fcc9bf19fb602f.png" alt="在这里插入图片描述"><br>主键和唯一键有什么区别??</p><blockquote><p>主键和唯一键并不冲突，在一张表中，可以有一个主键，在其他列也可以同时有唯一键<br>表其实就是MySQL级别的，”类 or struct对象“的集合，表中保存的其实就是某些场景下的属性字段！<br>数据库本身是一个对数据约束很严格的技术<br>我们，身上不止有一个属性具有唯一性（学号）：qq，手机号，b站账号，这些都是具有唯一性的,<br>我们身上需要具有很多要有唯一性的列<br>当然，也有很多不具有唯一性的列，：名字，身高，成绩<br>主键不是设置了主键属性，你才成为了主键，而是对应的属性被选择成为了主键（从众多具有唯一性的属性中，选择了一个，它成为了主键，而没有被选择，依旧需要唯一性的列，就被成员了唯一键）</p></blockquote><p>主键和唯一键（互相补充，设计一个约束更强的表，不要插入不合理的数据）<br><img src="https://img-blog.csdnimg.cn/32bfc0b557fd4d8aa7e637b712ee6078.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t43 (id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key comment <span class="hljs-string">&#x27;user school id&#x27;</span>,name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;user name&#x27;</span>,qq <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unique</span> comment<span class="hljs-string">&#x27;user qq_id&#x27;</span>,telephone <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unique</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d557f51ce0a2416180bfcfaf7b00c334.png" alt="在这里插入图片描述"><br>一般不要拿自己身上的属性做主键，因为万一某个变了，就失效了，用一个自增，与业务无关的东西，不影响表的整体结构</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>外键主要是为了关联两张表，一张表的数据和另一张表的数据进行关联起来<br>外键是定义主表和从表之间的关系，表和表之间存在的关系就是<br>学生和班级拆成哪张表，我们数据库最好把表拆分到不能拆<br>让两个不同的表产生关系</p><p>外键一般是另一张表的主键，把外键当作主键的表叫做主表，包含外键的表叫做从表</p><p>外键vs外键约束</p><blockquote><p>外键约束，再从表中插入一个主表中没有的值，是不被允许的<br>再主表中删除一个主键对应的值，从表中的数据全部删除了，这个才能被删除<br>表中产生的逻辑关系叫做外键，外键约束时逻辑上正确</p></blockquote><p>我们先创建一个主表</p><p>再创建一个从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">foreign</span> key (哪一个字段) <span class="hljs-keyword">references</span> table_name (主键的字段)<br></code></pre></td></tr></table></figure><p>创建了一个外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu (id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, name <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, class_id <span class="hljs-type">int</span>, <span class="hljs-keyword">foreign</span> key (class_id) <span class="hljs-keyword">references</span> class(id) );<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0454642ef4ce480f8b20f9cd63fa7d26.png" alt="在这里插入图片描述"><br>我们插入了class里面有的值，它就允许我们进行插入了<br><img src="https://img-blog.csdnimg.cn/9504ce93cce54a68ab51767c8ea58685.png" alt="在这里插入图片描述"><br>插入class 里面没有的值，就不允许我们进行插入了<br><img src="https://img-blog.csdnimg.cn/91ecc56e3eb941bf97ee2898fc7ebbe9.png" alt="在这里插入图片描述"><br>表和表之间数据完整性</p><p>从主表中删除数据，不允许我们删除，因为从表里面还有id&#x3D;10的数据<br><img src="https://img-blog.csdnimg.cn/d28b84da7fa24b70b93f3d002df02a40.png" alt="在这里插入图片描述"><br>外键约束，可以保证强约束，只有添加了外键约束，mysql才能帮我们取维护表和表之间逻辑关系</p><p>删除一个数据，把外键对应的数据都删除之后，才能把删除没对应的数据</p><p>综合案例<br><img src="https://img-blog.csdnimg.cn/e2c8c2df507f435dba90aa26cebd9441.png" alt="在这里插入图片描述"><br><strong>table goods</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> customer_id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">13</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> address <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">unique</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> email <span class="hljs-type">char</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">unique</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> sex enum(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> card_id <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br></code></pre></td></tr></table></figure><p><strong>table customer</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> customer_id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">13</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> address <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">unique</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> email <span class="hljs-type">char</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">unique</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> sex enum(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> card_id <span class="hljs-type">char</span>(<span class="hljs-number">11</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br></code></pre></td></tr></table></figure><p><strong>table purchases</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span>   <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> purchases(<br><span class="hljs-operator">&gt;</span>   order_id <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) zerofill <span class="hljs-keyword">primary</span> key, <br><span class="hljs-operator">&gt;</span>   customer_id <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span>,<br><span class="hljs-operator">&gt;</span>   goods_id <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span>, <br><span class="hljs-operator">&gt;</span>   nums <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>,<br><span class="hljs-operator">&gt;</span>   <span class="hljs-keyword">foreign</span> key(goods_id) <span class="hljs-keyword">references</span> goods(goods_id),<br><span class="hljs-operator">&gt;</span>   <span class="hljs-keyword">foreign</span> key(customer_id) <span class="hljs-keyword">references</span> customer(customer_id)<br><span class="hljs-operator">&gt;</span>   );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL基础知识</title>
    <link href="/2022/10/03/MYSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/10/03/MYSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h1><p>数据库本质上就是一种软件，帮助我们更方便对数据操作，让我们有一些更方便的操作，SQL语句，给数据库进行识别<br>数据库还是要自己去访问文件的</p><ol><li>数据库站在软件的角度，也是用文件的方式进行数据保存的</li><li>数据库中直接和文件打交道，这个模块叫做数据库的存储引擎，没有搜索引擎的话，就要我们自己去磁盘中去找，</li></ol><p>站在文件角度</p><p>数据库服务器（类似于一个管理系统）<br>数据库表结构（类似于一个一个的文件）<br>数据客户端（就是我们访问的地方）</p><p>数据库是一个网络服务器<br>mysql是客户端<br>mysqld就是服务器<br>是一个CS模式</p><p>mysql 127.1 3306连接服务器，其实是在本地进行访问，mysql也可以跨网络</p><p>mysql或数据库属于应用层还是其他层的软件呢<br>：就是一个应用层服务</p><p>站在系统角度，属于内置的还是自己安装，底层一定是直接或间接的访问OS 的文件接口<br>就是需要我们自己安装的，</p><p>建立一个数据库的本质就是建立一个目录<br>create database (basename);创建一个数据库&#x3D;mkdir （目录）</p><p>进入一个数据库，本质就是进入一个目录<br>use (basename); &#x3D;cd (目录)<br><img src="https://img-blog.csdnimg.cn/6a017ad444f3491492bbdc00d6692ee7.png" alt="在这里插入图片描述"></p><p>创建表，本质就是创建特定的文件<br>create table;</p><p>查看表结构<br>desc table_name;<br><img src="https://img-blog.csdnimg.cn/45a4a560ef3f4aa9849fb4a1257c403e.png" alt="在这里插入图片描述"><br>show tables;显示数据库里面的表<br><img src="https://img-blog.csdnimg.cn/c7abb11848a14a80ab51252d1ad017d9.png" alt="在这里插入图片描述"><br>插入数据<br><img src="https://img-blog.csdnimg.cn/ac54c97954324efeb71d4812dc5e006a.png" alt="在这里插入图片描述"><br>第一行都是属性名称，每一行都是叫做一条记录，每一列叫做属性内容，这叫做逻辑存储结构</p><p><img src="https://img-blog.csdnimg.cn/6d7c6d6af2bb4486b83e621ca132c337.png" alt="在这里插入图片描述"></p><h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><p>MySQL是一个可移植的数据库，几乎能在所有的操作系统上都能运行，非可移植性的有各自条件编译来判定是什么系统上的，</p><h1 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a>SQL的分类</h1><p>SQL也有种类的不同，因为使用sql的人，他的需求是不同的</p><ul><li>DDL（data definition language）：数据定义语言，用来维护存储数据的结构，：create，drop ，alter；建立表，删除表，改变表（教师）</li><li>DML（data manipulation language ）: 数据操纵语言，用来对数据进行操纵,insert delete update（学生用户）</li><li>DCL数据控制语言，主要负责权限管理，事务，grant revoke commit(管理员)</li></ul><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>sql都是直接或间接通过存储引擎操作的<br>我们主要用的存储引擎就是innodb，MyISAM</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL库/表的操作</title>
    <link href="/2022/10/03/MySQL%E5%BA%93!%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/10/03/MySQL%E5%BA%93!%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="库的操作"><a href="#库的操作" class="headerlink" title="库的操作"></a>库的操作</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database [if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>] db_name [create_specification],[create_specification]...<br>[<span class="hljs-keyword">default</span>] <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> charset_name<br>[<span class="hljs-keyword">default</span>] <span class="hljs-keyword">collate</span> collation_name<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>红色的表示关键字</li><li>[]是可选项，我们后面基本都不写</li><li>character set：指定数据库存储采用的字符集</li><li>collate ：指定数据库字符集的校验规则:所谓的校对规则，指的是取的时候我们如何识别一个二进制序列</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们设定它的存储是按照utf8设置的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database test charset<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>我们设置它是按照utf8进行存储和校验的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database db2 charset<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">collate</span> utf8_general_ci;<br></code></pre></td></tr></table></figure><p>查看数据使用的存储于校验</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;character_set_database&#x27;</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看存储<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;collation_database&#x27;</span>;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看校验<br></code></pre></td></tr></table></figure><p>查看数据库支持的字符集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> charset;<br></code></pre></td></tr></table></figure><p>查看数据库支持的校验规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">collation</span>;<br></code></pre></td></tr></table></figure><h3 id="校验规则测试"><a href="#校验规则测试" class="headerlink" title="校验规则测试"></a>校验规则测试</h3><p><img src="https://img-blog.csdnimg.cn/1823d812b67e41558e25ffe2681e6a1b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0f45f40223094ce0bcd1c602261bdda8.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d6b5096e1c734eb89b9933ae41fbab76.png" alt="在这里插入图片描述"><br>在utf8_test里面的操作<br><img src="https://img-blog.csdnimg.cn/bfbcf9af619b47fd822b393d5ff8896a.png" alt="在这里插入图片描述"><br>utf8不区分大小写,select后面是筛选条件</p><p>在utf8_bin里面</p><p><img src="https://img-blog.csdnimg.cn/8c5de788983c437bb0ab772a0a073772.png" alt="在这里插入图片描述"><br>不同的校验规则会给我们不同的搜索结果</p><p><img src="https://img-blog.csdnimg.cn/e7fa342b9fbd47e7a52074ef5eb6ffdc.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/22854d972a994d759aff943e31396d90.png" alt="在这里插入图片描述"></p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>本质上就是在数据库中把对应的目录给删除掉了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database db_name;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d53f8d055a644e5cbbfba686cff2cb12.png" alt="在这里插入图片描述"><br>删除之后</p><ul><li>数据库内部看不到对应的数据库</li><li>对应的数据库文件夹被删除，级联被删除，里面的数据表全部被删除</li></ul><p>所以不要随意的删除数据库<br>数据库也可以直接用linux命令进行删除</p><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p>查看创建数据库的详情</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database utf8_bin_test;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/dca89867afe942c8ba52d037ebaeba79.png" alt="在这里插入图片描述"></p><h3 id="查看访问数据库的人的信息"><a href="#查看访问数据库的人的信息" class="headerlink" title="查看访问数据库的人的信息"></a>查看访问数据库的人的信息</h3><p>可以查看几个人访问，在使用哪个数据库<br><img src="https://img-blog.csdnimg.cn/92952cca128a4767a24faaf9cfa423b4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/66d3778fd0fe4c228a012cb72f764379.png" alt="在这里插入图片描述"></p><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><blockquote><p>alter database db_name [alter_spacification [,alter_spacification]…]</p></blockquote><ul><li>对数据库的修改主要是修改数据库的字符集，校验规则</li></ul><p>例如：将数据库的字符集改成gdk</p><p><img src="https://img-blog.csdnimg.cn/d4161c7106f241c29a513b0d03515b27.png" alt="在这里插入图片描述"><br>数据库最好不要修改，一改影响太大了</p><h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>语法;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name(<br>field1 datatype comment <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>field2 datatype,<br>field3 datatype<br>)<br></code></pre></td></tr></table></figure><p>说明</p><ul><li>field表示列名</li><li>datatype表示列的类型</li><li>character set字符集，如果没有指定字符集，就以所在的数据库的字符集为准</li><li>collate校验规则，如果没有指定校验规则，则以所在的数据库的校验规则为准</li><li>comment就是做一个filed的注释</li></ul><p>样例<br><img src="https://img-blog.csdnimg.cn/7a8a0e84c5cc45e98a6711fc1ef63483.png" alt="在这里插入图片描述"><br>查看表结构<br><img src="https://img-blog.csdnimg.cn/3261cdb4e8144101b53f0167c1e8c334.png" alt="在这里插入图片描述"></p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>创建好了之后不要轻易修改表结构,如字段名称，字段大小，字段类型，表的字符集类型，表的引擎等等，我们还有需求，添加字段，删除字段，这个时候，我们就需要取修改表<br><img src="https://img-blog.csdnimg.cn/0f552d3cc0864ce18c88c6b259b00538.png" alt="在这里插入图片描述"><br>add,modify drop(增加，修改，删除)<br>示例1：<br>增加一个字段add,新加的结构为null,默认新增加的字段会在最后一列<br><img src="https://img-blog.csdnimg.cn/454dfd857d3c42e58280ae9326a5d473.png" alt="在这里插入图片描述"><br>可以设置它在某个字段的后面，但是我们不建议这样操作<br><img src="https://img-blog.csdnimg.cn/1f7503e063f34042a2936a69b0e279f5.png" alt="在这里插入图片描述"></p><p>删除一列 drop<br><img src="https://img-blog.csdnimg.cn/9be5bde863f24c9a83ff754e00b3f4a7.png" alt="在这里插入图片描述"><br>修改一列： modify<br><img src="https://img-blog.csdnimg.cn/a24322069f8a4af1aa9b7bf7d373f3bc.png" alt="在这里插入图片描述"><br>修改表名<br>alter table users rename to emplyee<br><img src="https://img-blog.csdnimg.cn/f96fe327d5db44a6a5332dc715cd4778.png" alt="在这里插入图片描述"></p><p>也建议轻易不要去修改<br>修改表中的列名<br><img src="https://img-blog.csdnimg.cn/8c591900912e428ba464892f3d31200b.png" alt="在这里插入图片描述"></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> table_name;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3923bf50c709455d97d3dc9066f6e10d.png" alt="在这里插入图片描述"></p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> stu (id, name, password, birthday) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;12&#x27;</span>,<span class="hljs-string">&#x27;2022-01-02&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-string">&#x27;1999-03-04&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql 数据库 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map和set的实现</title>
    <link href="/2022/09/18/map%E5%92%8Cset%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/18/map%E5%92%8Cset%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="RBTree"><a href="#RBTree" class="headerlink" title="RBTree"></a>RBTree</h1><p>红黑树修改版本</p><p>RBTreeNode树里面的每一个节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span><br>&#123;<br>    RED,<br>    BLACK<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-comment">//这里只有一个T变量，可以是一个key也可以是一个pair</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeNode</span><br>&#123;<br>    RBTreeNode&lt;T&gt; *_left;<br>    RBTreeNode&lt;T&gt; *_right;<br>    RBTreeNode&lt;T&gt; *_parent;<br>    T _data;<span class="hljs-comment">//只使用T的data变量</span><br>    Color _col; <span class="hljs-comment">//控制颜色</span><br>    <span class="hljs-built_in">RBTreeNode</span>(<span class="hljs-type">const</span> T &amp;data)<br>        : _data(data), _left(<span class="hljs-literal">nullptr</span>), _right(<span class="hljs-literal">nullptr</span>), _parent(<span class="hljs-literal">nullptr</span>), _col(RED) <span class="hljs-comment">//一开始的颜色给红色</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>树的迭代器Iterator</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ptr</span>&gt; <span class="hljs-comment">// T是变量类型，Ref返回的是里面的值，Ptr返回的是里面的地址</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTreeIterator</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> RBTreeNode&lt;T&gt; Node;<span class="hljs-comment">//里面的存储的元素类型是T</span><br>    <span class="hljs-keyword">typedef</span> RBTreeIterator&lt;T,Ref, Ptr&gt; Self;<span class="hljs-comment">//迭代器进行重定义</span><br>    Node *_node;<br>    <span class="hljs-built_in">RBTreeIterator</span>(Node *node)<br>        : _node(node)<br>    &#123;<br>    &#125;<br><br>    Ref <span class="hljs-keyword">operator</span>*() <span class="hljs-comment">//这个返回的是T&amp;返回的是值</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> _node-&gt;_data;<br>    &#125;<br>    Ptr <span class="hljs-keyword">operator</span>-&gt;()<br>    &#123;<br>        <span class="hljs-keyword">return</span> &amp;_node-&gt;_data;<br>    &#125;<br>    Self&amp; <span class="hljs-keyword">operator</span>++()<span class="hljs-comment">//返回的是自己这个指针</span><br>    <span class="hljs-comment">//中序遍历，从小到大</span><br>    &#123;<br>        <span class="hljs-comment">// 1. 左边都访问过了，假如右树存在，下一个就要访问右树的最左节点</span><br>        <span class="hljs-comment">// 2. 如果右为空，我所在的子树完了，我是父亲的左边，下一个访问父亲</span><br>        <span class="hljs-comment">// 2.1我是父亲的右边，访问的父亲的父亲</span><br><br>        <span class="hljs-keyword">if</span> (_node-&gt;_right) <span class="hljs-comment">//右不为空</span><br>        &#123;<br>            Node *min = _node-&gt;_right; <span class="hljs-comment">//找右的最左节点</span><br>            <span class="hljs-keyword">while</span> (min-&gt;_left)<br>            &#123;<br>                min = min-&gt;_left;<br>            &#125;<br>            _node = min;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//右为空，找孩子是父亲左的祖先</span><br>            Node *cur = _node;<br>            Node* parent=cur-&gt;_parent;<br>            <span class="hljs-comment">//如果cur是父亲的右</span><br>            <span class="hljs-keyword">while</span>(parent&amp;&amp;cur==parent-&gt;_right)<br>            &#123;<br>                cur=parent;<br>                parent=parent-&gt;_parent;<br>            &#125;<br>            <span class="hljs-comment">//cur是父亲的左</span><br>            _node=parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Self&amp; <span class="hljs-keyword">operator</span>--()<br>    &#123;<br>        <span class="hljs-comment">//右根左，和++反过来的</span><br>        <span class="hljs-comment">//左不为空，到左节点的最右边</span><br>        <span class="hljs-comment">//左为空，是父亲的右节点，到父亲</span><br>        <span class="hljs-comment">//是父亲的左节点，到孩子是父亲的右节点</span><br>        <span class="hljs-keyword">if</span>(_node-&gt;_left)<br>        &#123;<br>            <span class="hljs-comment">//左不为空，</span><br>            Node* max=_node-&gt;_left;<br>            <span class="hljs-keyword">while</span>(max-&gt;_right)<br>            &#123;<br>                max=max-&gt;_right;<br>            &#125;<br>            _node=max;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Node* parent=_node-&gt;_parent;<br>            <span class="hljs-keyword">while</span>(parent&amp;&amp;parent-&gt;_left==_node)<br>            &#123;<br>                <br>                _node=parent;<br>                parent=parent-&gt;_parent;<br>            &#125;<br>            _node=_node-&gt;_parent;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Self&amp; s)<br>    &#123;<br>        <span class="hljs-keyword">return</span> _node!=s._node; <br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>RBTree</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// set传的T是key RBTree&lt;K,K,SetKeyOfT&gt;</span><br><span class="hljs-comment">// map传的T是pair  RBTree&lt;K,pair&lt;K,pair&lt;K,V&gt;,MapKeyOfT&gt;</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyOfT</span>&gt; <span class="hljs-comment">// KeyOfT是一个仿函数，我们要取出T的first</span><br><span class="hljs-comment">//K是为了获得T里面的第一个参数的类型</span><br><span class="hljs-comment">//T里面就是树里面存储的元素</span><br><span class="hljs-comment">//KeyOfT是获得出T里面第一个参数的值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RBTree</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> RBTreeNode&lt;T&gt; Node;<br><br><span class="hljs-keyword">private</span>:<br>    Node *_root;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span> _InOrder(Node *root)<span class="hljs-comment">//中序遍历</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        _InOrder(root-&gt;_left);<br>        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        _InOrder(root-&gt;_right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RotateR</span><span class="hljs-params">(Node *parent)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//右单旋转</span><br>        Node *subL = parent-&gt;_left;           <span class="hljs-comment">//子节点</span><br>        Node *subLR = subL-&gt;_right;           <span class="hljs-comment">//子节点的右节点</span><br>        Node *parentparent = parent-&gt;_parent; <span class="hljs-comment">//出问题节点的父节点</span><br>        parent-&gt;_left = subLR;<br>        subL-&gt;_right = parent;<br>        parent-&gt;_parent = subL;<br>        <span class="hljs-keyword">if</span> (subLR)<br>            subLR-&gt;_parent = parent;<br><br>        <span class="hljs-comment">//和父节点的父节点连接</span><br>        <span class="hljs-keyword">if</span> (parent == _root)<br>        &#123;<br>            <span class="hljs-comment">//要旋转的节点已经是根</span><br>            <span class="hljs-comment">//更新根</span><br>            _root = subL;<br>            _root-&gt;_parent = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//更新顶部</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//父节点上面还有节点</span><br>            <span class="hljs-keyword">if</span> (parentparent-&gt;_left == parent)<br>            &#123;<br>                <span class="hljs-comment">//是左节点</span><br>                subL-&gt;_parent = parentparent;<br>                parentparent-&gt;_left = subL;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                subL-&gt;_parent = parentparent;<br>                parentparent-&gt;_right = subL;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RotateL</span><span class="hljs-params">(Node *parent)</span> <span class="hljs-comment">//左单旋</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *subR = parent-&gt;_right;<br>        Node *subRL = subR-&gt;_left;<br>        Node *parentparent = parent-&gt;_parent;<br>        parent-&gt;_parent = subR;<br>        subR-&gt;_left = parent;<br>        parent-&gt;_right = subRL;<br>        <span class="hljs-keyword">if</span> (subRL)<br>            subRL-&gt;_parent = parent;<br>        <span class="hljs-keyword">if</span> (parent == _root)<br>        &#123;<br>            _root = subR;<br>            _root-&gt;_parent = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (parentparent-&gt;_right == parent)<br>            &#123;<br>                parentparent-&gt;_right = subR;<br>                subR-&gt;_parent = parentparent;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                parentparent-&gt;_left = subR;<br>                subR-&gt;_parent = parentparent;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> RBTreeIterator&lt;T, T &amp;, T *&gt; Iterator;<br>    <span class="hljs-keyword">typedef</span> RBTreeIterator&lt;T,<span class="hljs-type">const</span> T&amp;,<span class="hljs-type">const</span> T*&gt; const_Iterator;<br><br>    <span class="hljs-comment">//中序遍历就是从小到大的</span><br>    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-comment">//因为它是走中序，所以第一个是最左节点,最小值</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *min = _root; <span class="hljs-comment">//最小值，就是左节点</span><br>        <span class="hljs-keyword">while</span> (min &amp;&amp; min-&gt;_left)<br>        &#123;<br>            min = min-&gt;_left;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(min);<br>    &#125;<br>    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//最大值的下一个节点</span><br>        <span class="hljs-comment">//最右边的下一个是null</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-function">Iterator <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> K&amp; key)</span><span class="hljs-comment">//K是为了取出V里面的第一个参数</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node* cur=_root;<br>        KeyOfT kot;<span class="hljs-comment">//使用仿函数，调用</span><br>        <span class="hljs-keyword">while</span>(cur)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">kot</span>(cur-&gt;_data)&lt;key)<br>            &#123;<br>                cur=cur-&gt;_right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">kot</span>(cur-&gt;_data)&gt;key)<br>            &#123;<br>                cur=cur-&gt;_left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">end</span>();<span class="hljs-comment">//没有找到，就返回end</span><br>    &#125;<br><br>    <span class="hljs-built_in">RBTree</span>()<br>        : _root(<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>    &#125;<br>    ~<span class="hljs-built_in">RBTree</span>()<br>    &#123;<br>        <span class="hljs-built_in">Destroy</span>(_root);<br>        _root=<span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-built_in">RBTree</span>(<span class="hljs-type">const</span> RBTree&lt;K,T,KeyOfT&gt;&amp;t)<br>    &#123;<br>        _root=<span class="hljs-built_in">Copy</span>(t._root);<br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">Copy</span><span class="hljs-params">(Node* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">//前序遍历</span><br>        Node* newRoot=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(root-&gt;_data);<br>        newRoot-&gt;_col=root-&gt;_col;<br><br>        newRoot-&gt;_left=<span class="hljs-built_in">Copy</span>(root-&gt;_left);<br>        newRoot-&gt;_right=<span class="hljs-built_in">Copy</span>(root-&gt;_right);<br>        <span class="hljs-keyword">if</span>(newRoot-&gt;_left)<br>        &#123;<br>            newRoot-&gt;_left-&gt;_parent=newRoot;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newRoot-&gt;_right)<br>        &#123;<br>            newRoot-&gt;_right-&gt;_parent=newRoot;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> newRoot;<br>    &#125;<br><br>    RBTree&lt;K,T,KeyOfT&gt;&amp; <span class="hljs-keyword">operator</span>=(RBTree&lt;K,T,KeyOfT&gt; t)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(_root,t._root);<span class="hljs-comment">//这里的t是拷贝构造，所以这里的交换不会影响t</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Destroy</span><span class="hljs-params">(Node* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">Destroy</span>(root-&gt;_left);<br>        <span class="hljs-built_in">Destroy</span>(root-&gt;_right);<br>        <span class="hljs-keyword">delete</span> root;<span class="hljs-comment">//后序遍历</span><br><br>    &#125;<br>    <span class="hljs-function">pair&lt;Iterator,<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;data)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (_root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            _root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>            _root-&gt;_col = BLACK;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">Iterator</span>(_root),<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//</span><br><br>        <span class="hljs-comment">//因为我们需要知道它的T的参数是什么</span><br>        <span class="hljs-comment">//这里我们添加一个</span><br>        KeyOfT kot; <span class="hljs-comment">//使用这个来进行比较,仿函数</span><br><br>        Node *cur = _root;<br>        Node *parent = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//还要找到父亲</span><br>        <span class="hljs-keyword">while</span> (cur)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">kot</span>(cur-&gt;_data) &gt; <span class="hljs-built_in">kot</span>(data)) <span class="hljs-comment">//这里如果是pair，我们就得按照k去比较大小,所以这里我们需要知道它是key还是pair</span><br>            &#123;<br>                <span class="hljs-comment">//取出它的有效比较对象来进行比较</span><br>                parent = cur;<br>                cur = cur-&gt;_left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">kot</span>(cur-&gt;_data) &lt; <span class="hljs-built_in">kot</span>(data)) <span class="hljs-comment">//比他大，在右边</span><br>            &#123;<br>                <span class="hljs-comment">//只要把key取出来就都可以使用这个东西</span><br>                parent = cur;<br>                cur = cur-&gt;_right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">Iterator</span>(cur),<span class="hljs-literal">false</span>);<span class="hljs-comment">//这个值存在，就返回这个已近有的节点</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//走到这里，就可以链接上</span><br>        cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br><br>        Node* newnode=cur;<span class="hljs-comment">//把这个新节点给保持起来</span><br>        cur-&gt;_col = RED; <span class="hljs-comment">//新增节点颜色给红色</span><br><br>        cur-&gt;_parent = parent;              <span class="hljs-comment">//链接上父亲</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">kot</span>(parent-&gt;_data) &gt; <span class="hljs-built_in">kot</span>(data)) <span class="hljs-comment">//父亲的值也能取出来</span><br>        &#123;<br>            <span class="hljs-comment">//比他小，在左边</span><br>            parent-&gt;_left = cur;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent-&gt;_right = cur;<br>        &#125;<br>        <span class="hljs-comment">//插入之前一定是红黑树</span><br>        <span class="hljs-comment">//这里就要控制平衡，通过颜色</span><br>        <span class="hljs-comment">//插入黑节点（影响路径），还是红节点（只影响自己的，不影响其他区域）</span><br><br>        <span class="hljs-comment">//往上调整</span><br>        <span class="hljs-comment">//我为红，父亲如果为红，爷爷一定是黑色</span><br>        <span class="hljs-comment">// 1.叔叔存在且为红</span><br>        <span class="hljs-keyword">while</span> (parent &amp;&amp; parent-&gt;_col == RED) <span class="hljs-comment">//往上处理,父亲颜色为红色，就要处理，黑色就不要处理,为红，就不是根</span><br>        &#123;<br>            Node *grandparent = parent-&gt;_parent;<br>            <span class="hljs-keyword">if</span> (parent == grandparent-&gt;_left)<br>            &#123;<br>                Node *uncle = grandparent-&gt;_right; <span class="hljs-comment">//叔叔就是在右边</span><br>                <span class="hljs-comment">//叔叔存在且为红</span><br>                <span class="hljs-keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)<br>                &#123;<br>                    <span class="hljs-comment">//叔叔存在，且为红</span><br>                    <span class="hljs-comment">//变色，继续向上处理</span><br>                    parent-&gt;_col = BLACK;<br>                    uncle-&gt;_col = BLACK;<br>                    grandparent-&gt;_col = RED;<br><br>                    cur = grandparent; <span class="hljs-comment">//继续迭代往上操作</span><br>                    parent = cur-&gt;_parent;<br>                &#125;<br><br>                <span class="hljs-comment">//叔叔不存在</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">//不存在，或存在且为黑</span><br>                &#123;<br>                    <span class="hljs-comment">//不存在,进行旋转</span><br>                    <span class="hljs-comment">//旋转+变色</span><br>                    <span class="hljs-keyword">if</span> (cur == parent-&gt;_left)<br>                    &#123;<br>                        <span class="hljs-built_in">RotateR</span>(grandparent); <span class="hljs-comment">//进行右单旋转</span><br>                        <span class="hljs-comment">//变色</span><br>                        parent-&gt;_col = BLACK;<br>                        grandparent-&gt;_col = RED;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">//双旋</span><br>                        <span class="hljs-comment">//左右双旋</span><br>                        <span class="hljs-comment">// p进行右单旋，g左单旋，g变红藕，cur变黑，</span><br>                        <span class="hljs-built_in">RotateL</span>(parent);<br>                        <span class="hljs-built_in">RotateR</span>(grandparent);<br>                        cur-&gt;_col = BLACK;<br>                        grandparent-&gt;_col = RED;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//父亲是祖父的右边</span><br>            &#123;<br>                Node *uncle = grandparent-&gt;_left; <span class="hljs-comment">//叔叔就是在右边</span><br>                <span class="hljs-comment">//叔叔存在且为红</span><br>                <span class="hljs-keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)<br>                &#123;<br>                    <span class="hljs-comment">//叔叔存在，且为红</span><br>                    <span class="hljs-comment">//变色，继续向上处理</span><br>                    parent-&gt;_col = BLACK;<br>                    uncle-&gt;_col = BLACK;<br>                    grandparent-&gt;_col = RED;<br><br>                    cur = grandparent; <span class="hljs-comment">//继续迭代往上操作</span><br>                    parent = cur-&gt;_parent;<br>                &#125;<br><br>                <span class="hljs-comment">//叔叔不存在</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">//不存在，或存在且为黑</span><br>                &#123;<br>                    <span class="hljs-comment">//不存在,进行旋转</span><br>                    <span class="hljs-comment">//旋转+变色</span><br>                    <span class="hljs-keyword">if</span> (cur == parent-&gt;_right)<br>                    &#123;<br>                        <span class="hljs-built_in">RotateL</span>(grandparent); <span class="hljs-comment">//进行右单旋转</span><br>                        <span class="hljs-comment">//变色</span><br>                        parent-&gt;_col = BLACK;<br>                        grandparent-&gt;_col = RED;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-built_in">RotateR</span>(parent);<br>                        <span class="hljs-built_in">RotateL</span>(grandparent);<br>                        cur-&gt;_col = BLACK;<br>                        grandparent-&gt;_col = RED;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        _root-&gt;_col = BLACK; <span class="hljs-comment">//根的一定是黑色</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">Iterator</span>(newnode),<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RBtree.hpp&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> xzw<br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">map</span><br>    &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MapKeyOfT</span> <span class="hljs-comment">//仿函数,泛型编程，复用同一棵树</span><br>        &#123;<br>            <span class="hljs-function"><span class="hljs-type">const</span> K &amp;<span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;K, V&gt; &amp;kv)</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">return</span> kv.first; <span class="hljs-comment">//返回的是第一个参数</span><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::Iterator Iterator;<span class="hljs-comment">//对于一个类型的使用，我们就要声明，不然编译器以为是一个变量</span><br><br>        <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>.<span class="hljs-built_in">end</span>();<br>        &#125;<br><br>        <span class="hljs-function">pair&lt;Iterator,<span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;K, V&gt; &amp;kv)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>.<span class="hljs-built_in">Insert</span>(kv);<br>        &#125;<br><br><br>        V&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> K&amp;key)<br>        &#123;   <br>            <span class="hljs-keyword">auto</span> ret=<span class="hljs-type">_t</span>.<span class="hljs-built_in">Insert</span>(<span class="hljs-built_in">make_pair</span>(key,<span class="hljs-built_in">V</span>()));<br>            <span class="hljs-keyword">return</span> ret.first-&gt;second;<br>        &#125;<br>    <span class="hljs-keyword">private</span>:<br>        RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; <span class="hljs-type">_t</span>; <span class="hljs-comment">//用第二个模板参数来控制</span><br>    &#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RBtree.hpp&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> xzw<br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">set</span><br>    &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SetKeyOfT</span> <span class="hljs-comment">//仿函数</span><br>        &#123;<br>            <span class="hljs-function"><span class="hljs-type">const</span> K &amp;<span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;k)</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">return</span> k; <span class="hljs-comment">//返回的是第一个参数</span><br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::Iterator Iterator; <span class="hljs-comment">//取出它的内嵌类型，再进行重命名</span><br><br>        <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>.<span class="hljs-built_in">end</span>();<br>        &#125;<br>        <span class="hljs-function">Iterator <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> K&amp; key)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>.<span class="hljs-built_in">Find</span>(key);<br>        &#125;<br>        <span class="hljs-function">pair&lt;Iterator,<span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">_t</span>.<span class="hljs-built_in">Insert</span>(key);<br>        &#125;<br><br><br>    <span class="hljs-keyword">private</span>:<br>        RBTree&lt;K, K, SetKeyOfT&gt; <span class="hljs-type">_t</span>; <span class="hljs-comment">//用第二个模板参数来控制</span><br>    &#125;;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 算法 图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="/2022/09/16/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2022/09/16/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">前导</a></li><li><a href="#_17">以太网的帧格式</a></li><li><a href="#mac_40">mac地址</a></li><li><a href="#MTUTCP_46">MTU对于TCP协议的影响</a></li><li><a href="#ARP_56">ARP</a></li><li><a href="#DNS_89">DNS</a></li><li><ul><li><a href="#DNS_92">DNS背景</a></li><li><a href="#_98">域名介绍</a></li><li><a href="#_107">域名解析流程</a></li></ul></li><li><a href="#ICMP_112">ICMP</a></li><li><ul><li><a href="#_119">功能</a></li><li><a href="#_127">类型</a></li></ul></li><li><a href="#NAT_141">NAT技术</a></li><li><ul><li><a href="#_154">缺陷</a></li><li><a href="#_160">代理服务器</a></li></ul></li></ul><h1 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h1><p><img src="https://img-blog.csdnimg.cn/355204c8aef84b9aaddcd749cd4383d4.png" alt="在这里插入图片描述"><br>为什么要把数据包由F-&gt;G呢？</p><blockquote><p>是由目的IP决定的，是由路由查找完成的</p></blockquote><p>如何把数据包由F-&gt;G？</p><blockquote><p>数据链路层决定的，怎么把报文从一跳跳到下一跳</p></blockquote><blockquote><p>凡是能够跳转到下一跳<br>一定是直接相连的节点，直接连接的节点，一定是在同一个局域网（网段）<br>所谓的网络，本质就是各种局域网相连的过程</p></blockquote><p>局域网通信的问题！！！</p><blockquote><p>同一个局域网，两台节点能直接通信，<br>以太网&amp;&amp;令牌环网</p></blockquote><h1 id="以太网的帧格式"><a href="#以太网的帧格式" class="headerlink" title="以太网的帧格式"></a>以太网的帧格式</h1><p><img src="https://img-blog.csdnimg.cn/36a29449ff88447382006d491ca76644.png" alt="在这里插入图片描述"><br>有效载荷：网络层以上包含的所有报头及有效载荷都在数据帧的有效载荷中</p><p>如何分离报头和有效载荷</p><blockquote><p>头14个字节，尾部4个字节</p></blockquote><p>如何决定将自己的有效载荷交付给上一层</p><blockquote><p>通过类型决定,0800就是IP地址，0806就是ARP请求或应答</p></blockquote><p>为什么要规定1500上限</p><blockquote><p>数据帧很大，意味着主机发的数据帧很长，在<code>物理层光电信号</code>发送的时候需要较多的时间，意味着一个数据帧在网络中转发的时候，占据一个单位时间就会变长，增加局域网中冲突的概率，所以一定是尽快发送，时间越短，可发的数据量越少</p></blockquote><p><code>mac地址</code>：唯一标识一台主机的，在出厂的时候就配好了，6个字节48位<br><code>目的地址</code>：发给谁，目的的<code>mac地址</code>，6个字节<br><code>源地址</code>：从哪个主机发送的，<code>mac地址</code>，6个字节<br><code>类型</code>：有效载荷装的是什么，<code>0800</code>，两个字节，代表IP数据报，<code>0806</code>，ARP请求<br><code>CRC</code>：校验，对数据进行校验工作，4个字节</p><p><img src="https://img-blog.csdnimg.cn/96448a65c3394c0787fa0621d9d01df8.png" alt="在这里插入图片描述"></p><h1 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h1><ul><li>MAC地址用来标识数据链路层中相连的<strong>节点</strong></li><li>长度为48位，6字节，一般用16进制数字加上冒号的形式来表示(08:00:27:03:fb:19)</li><li>在网卡出厂时就确定了，不能修改，mac地址通常是全球唯一的</li></ul><p>路由器MTU可能不同在路上也能分片：因为<code>13位片偏移</code>是相对于相比较原始的报文分的，所以不会影响</p><h1 id="MTU对于TCP协议的影响"><a href="#MTU对于TCP协议的影响" class="headerlink" title="MTU对于TCP协议的影响"></a>MTU对于TCP协议的影响</h1><p><code>MSS</code>（Max Segment Size）:TCP单个数据报的最大消息长度（1460）<br><img src="https://img-blog.csdnimg.cn/00a720c1fe5c447ca2b53955b0323b85.png" alt="在这里插入图片描述"></p><ul><li>TCP的数据报不能无限大，还是受制于MTU</li><li>TCP在建立连接的时候，通信双方也会进行MSS协商</li><li>双方在发送<code>SYN</code>的时候，会在TCP 头部写上自己能支持的MSS值</li><li>双方得知对方的MSS值之后，就会选择<strong>较小</strong>的作为最终的<code>MSS</code></li><li>MSS的值就是在TCP首部40个字节<strong>变长选项</strong>中</li></ul><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>根据路由表，结合目的IP，根据目的网络进行查找<br>如何在局域网中，通过IP地址，获得该主机对应的MAC地址？<br>ARP协议（地址转化协议），把IP地址转化为MAC地址，在一个局域网内发现对方mac地址的协议<br>ARP协议是数据链路层的协议<br>数据发送的时候是怎么知道对应主机的MAC地址<br>如果是ARP请求的时候，只会交付给ARP，不会给网络层协议（交付的是管理数据，ARP请求，）<br>给网络层交付的是（用户数据）</p><p><img src="https://img-blog.csdnimg.cn/e647f2fc0c7d4abb9a3a8eac7be12480.png" alt="在这里插入图片描述"></p><blockquote><ul><li>源主机发出ARP请求， 询问要去的IP地址对应的MAC地址，并将这个请求广播到本地网段</li><li>目的主机收到了这个广播的ARP请求，发现其中的IP地址和本机相符，则发送一个ARP应答数据报给源主机，将自己的硬件地址MAC地址，写在应答包里面<br>先<code>广播</code>再<code>单发</code>的过程</li></ul></blockquote><p>ARP报文格式<br><img src="https://img-blog.csdnimg.cn/065fb8f49089422a9cf3a731b18fc364.png" alt="在这里插入图片描述"><br>数据报文也被MAC帧封装，一定是再MAC帧上层，</p><ul><li><code>硬件类型</code>指的是链路层的网络类型，有以太网，令牌环网，无线wifi，这里1为以太网（不变的）</li><li><code>协议类型</code>值要转化的地址类型，0x0800为IP地址（不变的）</li><li><code>硬件地址长度</code>，6字节为MAC地址</li><li><code>协议地址长度</code>，4字节为IP地址</li><li><code>op</code>字段为1表示ARP请求，op字段为2表示ARP应答</li><li><code>发送端以太网地址</code>我请求的人自己的mac地址</li><li><code>发送端ip地址</code>，请求的人自己的IP地址</li><li><code>目的以太网地址</code> 这是我们需要的，就填成f</li></ul><p><img src="https://img-blog.csdnimg.cn/263c84f0d5304523b4cc361f6e23d745.png" alt="在这里插入图片描述"><br>系统也会维护一些缓存IP和mac地址映射，发过数据就会有保存，缓存有时间限制<br><img src="https://img-blog.csdnimg.cn/481e302815c34c77bfbe35dcb556356a.png" alt="在这里插入图片描述"><br>发消息先要做ARP，ARP的消息会先被缓存起来<br>ping 检测网络连通性，发送报文，先ARP，ping成功就成功ARP了</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>Domain Name System<br>DNS就是一套从域名映射到IP的系统</p><h2 id="DNS背景"><a href="#DNS背景" class="headerlink" title="DNS背景"></a>DNS背景</h2><p>IP地址的记忆麻烦,于是就产生了DNS系统</p><blockquote><ul><li>一个系统管理的机构，维护系统内部的每一个主机的IP和主机名</li><li>如果新计算机接入网络，将这个信息注册导数据库中</li><li>用户输入域名的时候，会自动查询DNS服务器，由DNS服务器检索数据库，进行查找对应的IP地址</li></ul></blockquote><h2 id="域名介绍"><a href="#域名介绍" class="headerlink" title="域名介绍"></a>域名介绍</h2><p>主域名是用来识别主机名称和主机所属的组织机构的一种分层结构的名称</p><blockquote><p><a href="http://www.baidu.com/">www.baidu.com</a></p></blockquote><p>域名使用**.**连接</p><blockquote><ul><li>com:一级域名，表示一个企业域名，同级的还有<strong>net</strong>（网络提供商）,<strong>org</strong>(非盈利组织)，edu(教育组织)，gov(政府)，cn(中国)，</li><li>baidu:二级域名，公司名</li><li>www:只是一个习惯的用法，之前人们使用域名的时候，往往命名类似于ftp.xxx.xxx&#x2F;<a href="http://www.xxx.xxx这样的格式,来表示主机支持的协议/">www.xxx.xxx这样的格式，来表示主机支持的协议</a></li></ul></blockquote><h2 id="域名解析流程"><a href="#域名解析流程" class="headerlink" title="域名解析流程"></a>域名解析流程</h2><ul><li>浏览器的缓存当中域名和IP地址的对应关系</li><li>本地的hosts文件当中也会缓存域名和IP地址对应的关系</li></ul><h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>Internet Control Message Protocol（互联网控制报文协议）<br>ICMP是网络层的协议，不经过传输层</p><p>一个搭建好的网络，要先进行一个简单的测试，来检验一下这个网络是否通畅，但是IP协议并不提供可靠传输，如果丢包了，IP协议并不能通知传输层是否丢包以及丢包原因</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中报文丢失的原因</li><li>ICMP也是基于IP协议工作的，但是它不是传输层的功能，它还是在网络层上面的协议</li><li>ICMP也只能搭配IPV4使用，如果是IPV6，需要使用ICMPv6</li></ul><p>如果这个报文无法送达，那么就由最后一个路由器返回ICMP报文给主机A，告知无法送达<br><img src="https://img-blog.csdnimg.cn/3a5cb631447e43d3974799a06a3eedb0.png" alt="在这里插入图片描述"></p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>一种是用于诊断的查询信息，是查询报文的类型，</li><li>一种是通知报文无法送达的原因，是差错报文类型<br><img src="https://img-blog.csdnimg.cn/21d90040237c44dfba5bf0616e092196.png" alt="在这里插入图片描述"></li></ul><p>ping命令的底层使用的就是ICMP协议，ping命令没有端口号，因为ping命令没有使用传输层协议,绕过了传输层,直接使用IP报文</p><p><img src="https://img-blog.csdnimg.cn/780f60a4725c43d1b71e751cbca9df84.png" alt="在这里插入图片描述"></p><blockquote><ul><li>ping的是域名，而不是url，一个域名可以被DNS解析成IP地址</li><li>ping命令不光能验证网络的连通性，也能统计响应实际，和TTL</li><li>ping命令会先发送一个ICMP echo request 给对端</li><li>对端接收到之后，会返回一个ICMP Echo Reply</li></ul></blockquote><h1 id="NAT技术"><a href="#NAT技术" class="headerlink" title="NAT技术"></a>NAT技术</h1><p><img src="https://img-blog.csdnimg.cn/d3ff34b82e854edc921f32e81a609f37.png" alt="在这里插入图片描述"><br>我们在进行路由的时候会把源端口换成路由器的WAN口号，目的地址就一直保持不变，这样就能够不断的进行路由<br>现在我们要进行服务端返回给客户端</p><p>路由器还可以进行NAT，构建了一个转化表，具有唯一性，可以互为键值对<br>IN_MAP将源IP源端口和转化的wan口IP进行映射<br>OUT_MAP可以将转化的wan口IP映射成源IP<br>每个路由器都能建立映射关系，构建一个虚拟的子网，大大减少了</p><ol><li>映射模式：虚拟机就相当于在计算机里面跑计算机，我们就可以把我们自己的计算机看作一个路由器，把虚拟机的ip地址给映射一下，就可以维护这个虚拟的ip了</li><li>桥接模式：我们把虚拟机和自己的计算机看作是相同的地位</li></ol><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>由于NAT依赖这个转化表，所以由许多限制</p><blockquote><ul><li>无法从NAT外部向内部服务器建立连接</li><li>转化表的生成和销毁都需要额外的开销</li><li>通信过程一旦NAT设备异常，即使存在热备（备胎），所有的TCP连接也会断开</li></ul></blockquote><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>路由器往往都具有NAT功能，通过NAT设备进行中转，完成子网和其他设备之间的同行过程</p><p>代理服务器看起来和NAT设备很像，客户端像代理服务器发送请求，代理服务器将真正的请求发送给真正要请求的服务器，服务器返回结果后，代理服务器又把结果传给客户端</p><p>正向代理，靠近客户端</p><ol><li>便于在内网对身份做认证，</li><li>加速内网访问服务</li><li>可以对访问内网的请求进行筛查</li></ol><p>反向代理，靠近服务器<br>服务端也有一个代理服务器，所有的请求都是先经过代理服务器，不给它做任何的资源，不做业务处理只做业务转发，这样代理服务器的转发可以根据后端每台机器的负载情况进行转发，，<br>4. 负载均衡<br>5. 安全，不会把公司主机暴露出去，</p><p>NAT和代理服务器的区别</p><blockquote><ul><li>应用上:NAT设备是网络基础设备之一,一般就内置在路由器中,解决的IP不足的问题;代理服务器更贴近现实,如用代理服务器进行翻墙,加速器</li><li>底层上:NAT工作在网络层,进行IP替换,代理服务器在应用层,直接对整个报头进行替换</li><li>使用上:NAT一般在局域网出口部署,代理服务器可以在局域网,也可以在广域网,也可以跨网络</li><li>NAT一般集成在防火墙,路由器等硬件设备上,代理服务器就是一个软件程序,需要部署在服务器上</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络 服务器 网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP基础（2）</title>
    <link href="/2022/09/11/IP%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
    <url>/2022/09/11/IP%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">网段划分</a></li><li><ul><li><a href="#_15">初步认识</a></li><li><a href="#IP_30">IP地址分类</a></li><li><a href="#IP_72">特殊IP</a></li></ul></li><li><a href="#IP_77">IP地址的数量限制</a></li><li><a href="#IPIP_83">私有IP地址和公网IP地址</a></li><li><a href="#_104">路由</a></li><li><a href="#_126">路由表生成算法</a></li></ul><h1 id="网段划分"><a href="#网段划分" class="headerlink" title="网段划分"></a>网段划分</h1><p>IP地址分为两部分，网络号和主机号</p><blockquote><ul><li><code>网络号</code>：保证相互两个网段之间有不同的标识</li><li><code>主机号</code>: 在同一网段内，主机之间具有相同的网络号，但是必须有不同的主机号</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/8a5be5d6f0a3471496e71d4688878ef9.png" alt="在这里插入图片描述"></p><blockquote><ul><li>不同的子网就是把网络号相同的主机放在一起</li><li>如果在子网里面增加一台主机，则这台主机的网络号和这个子网的网络号一致，但是主机号必须不能和子网中其他的主机重复</li></ul></blockquote><p>IP地址不用的时候就要回收回来<br>但是，手动管理子网内的IP，是一个相当麻烦的事情</p><blockquote><ul><li>有一种技术叫做DHCP，可以自动给子网内新增主机节点分配IP地址，避免了手动管理IP的不变</li><li>一般路由器都有带DHCP的功能，因此路由器可以看作一个DHCP服务器</li></ul></blockquote><h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><p><img src="https://img-blog.csdnimg.cn/de4947ad3bbc45579f0fd6e875e1fb4e.png" alt="在这里插入图片描述"></p><blockquote><p>如，</p><ul><li>一个计算机学院1班2号的学生，捡到了一个学生证，里面有它的学院和专业代码,要把学生证还给对方</li><li>它首先现在自己这个学院专业这个群里面，找到负责人</li><li>负责人，收到了消息，把这个消息发在全校所有学院专业的群里面,每个人都来查看是谁的，不是就扔掉这个（公网）</li><li>校学生负责人收到了消息，知道了她是经管的，并@经管学生负责人</li><li>经管学生负责人收到了，看到了班级和个人，就把消息发给了那个人</li></ul></blockquote><blockquote><ul><li>在路上的人只关心学号的前半部分，通过划分不同的群，来进行查找的，这样就能一次排除一个或者多个群</li><li>到达目标群（经管院），就不关心前半部分了，只关心后半部分</li></ul></blockquote><p>网络划分本质：提高查找效率，减少查找的难度，便于组网</p><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p><img src="https://img-blog.csdnimg.cn/89c0c938cca447c48dd4663e8b9b93ae.png" alt="在这里插入图片描述"></p><ul><li>A类：0.0.0.0到127.255.255.255。</li><li>B类：128.0.0.0到191.255.255.255。</li><li>C类：192.0.0.0到223.255.255.255。</li><li>D类：224.0.0.0到239.255.255.255。</li><li>E类：240.0.0.0到247.255.255.255。</li></ul><blockquote><p>分类划分之后，可以让不同国家组织根据自己的体量选择适合自己的网段<br><img src="https://img-blog.csdnimg.cn/16822689dc5048d2b1e29bb11476357c.png" alt="在这里插入图片描述"></p></blockquote><p>弊端</p><blockquote><p>大多数的组织都申请B类网络地址，这样也很浪费空间，理论上，申请b类地址，一个子网内可以允许6万5千多太主机，A类就更多了，<br>在实际网络中，不可能有这么多主机，就造成很大浪费</p></blockquote><p>针对这种浪费IP的情况，又引入了CIDR（Classless interdomain Routing），不进行划分</p><blockquote><ul><li>引入一个额外的子网掩码（subnet mask）来区分网络号</li><li>子网掩码是一个32位的正整数，前面全1，后面全0</li><li>将IP地址和子网掩码来进行按位与，得到的就是网络号</li><li>网络号和主机号的划分和这个IP地址是A类，B类，C类是无关的</li><li>子网后面有多少个0，就代表这个网络里面允许有多少个主机号</li></ul></blockquote><p>例1.</p><table><thead><tr><th>IP地址</th><th>140.252.20.68</th><th>8C FC 14 44</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.255.255.0</td><td>FF FF FF 00</td></tr><tr><td>网络号</td><td>140.252.20</td><td></td></tr><tr><td>子网地址范围</td><td>140.252.20.0~140.252.20.255</td><td></td></tr></tbody></table><p>子网掩码为FF FF FF 00</p><p>例2.</p><table><thead><tr><th>IP地址</th><th>140.252.20.68</th><th>8C FC 14 44</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.255.255.240</td><td>FF FF FF F0</td></tr><tr><td>网络号</td><td>140.252.20.64</td><td>8C FC 14 40</td></tr><tr><td>子网地址范围</td><td>140.252.20.64</td><td></td></tr></tbody></table><p>子网掩码FF FF FF F0</p><h2 id="特殊IP"><a href="#特殊IP" class="headerlink" title="特殊IP"></a>特殊IP</h2><blockquote><ul><li>将IP地址中的主机地址全部设置为全0，就是网络号，代表了这个局域网</li><li>将这个IP地址中的主机地址全部设置成全1，就是广播地址，用于给一个链路中的所有主机发送数据包</li><li>127.* 的IP地址用于本地环回，</li></ul></blockquote><h1 id="IP地址的数量限制"><a href="#IP地址的数量限制" class="headerlink" title="IP地址的数量限制"></a>IP地址的数量限制</h1><p>现在IP地址不够了</p><blockquote><ul><li><code>动态分配IP地址</code>：接入网络的时候，设备分配IP地址，走了之后，IP地址回收</li><li><code>NAT技术</code>（后面介绍）</li><li><code>IPV6</code>:IPV6并非ipv4的简单升级，IPV6用16个字节128位来标识一个IP地址，但是IPV6没有普及</li></ul></blockquote><h1 id="私有IP地址和公网IP地址"><a href="#私有IP地址和公网IP地址" class="headerlink" title="私有IP地址和公网IP地址"></a>私有IP地址和公网IP地址</h1><p>如果一个组织内部组建局域网，IP地址只用于局域网内部的通信，而不连接到Internet上，理论上任意IP都是可以，但是RFC1918规定了用于组建居于网内的私有IP地址</p><blockquote><ul><li>10.* ,前8位是网络号，共又16777216个地址</li><li>172.16.到172.31。，前12位是网络号，共1048576个地址</li><li>192.168.* ，前16位是网络号，共65535个地址<br>包含在这个范围内的，都是私有IP，其余的被称为公网IP（全局IP）</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/be2a122b5885445aa45ae15e7280c4b4.png" alt="在这里插入图片描述"></p><p>路由器最大的功能是可以用来组件局域网的</p><ul><li>路由器有两个IP，LAN口，子网IP，对内部的，WAN口，公网IP，对外的</li><li>我们自己的请求在对外发送的时候，我们的源IP地址可能一直在被中间路由器替换，（NAT技术）</li><li>替换成路由器的WAN口IP</li><li>不同子网的人，想要直接通信还是得去公网通信，无法跳过公网</li><li>墙，就是信息屏障，把报文直接丢弃掉</li><li>路由器LAN口连接的主机，都从属于这个路由器的子网中</li><li>不同的路由器，子网IP都是一样的（通常都是192.168.1.1），子网内的主机IP不能重复，但是子网间的IP地址可以重复</li><li>每一个家用路由器，又作为运营商路由器的子网中的一个节点，这样的运营商路由器可能有很多级，最外层的运营商路由器，WAN口IP就是一个公网IP</li></ul><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在复杂的网络结构中，找到一条通往终点的路线</p><p>在网络中只看目标网络<br><img src="https://img-blog.csdnimg.cn/d2e26b85d30c41fea2f58f634874d22f.png" alt="在这里插入图片描述"><br>IP数据包的传输过程也和问路一样</p><blockquote><ul><li>当IP数据包，到啊的路由器的时候，路由器回先查看目的IP</li><li>路由器决定这个数据包是能直接发送给目标主机，还是需要发送给下一个路由器</li><li>依次反复，一直到达目标IP地址</li></ul></blockquote><p>每个节点都会维护一个路由表</p><p>路由表如下<br><img src="https://img-blog.csdnimg.cn/26911cee33a0403ea88cf22827626d5a.png" alt="在这里插入图片描述"></p><blockquote><ul><li>这台主机有两个网络接口，一个网络接口连接到10.0.24.0，另一个网络接口连接到link-local网络</li><li>路由表的<code>Destination</code>是目的网络地址，<code>Genmask</code>是子网掩码，<code>Gateway</code>是下一跳的地址，<code>Iface</code>是发送接口，<code>Flags</code>的U标志表示次条目有效，G标志表示此条目的吓一跳地址是某个路由器的地址，没有G标志的条目表示目的网络地址是与本主机接口直接相连的，不必经过路由转发</li></ul></blockquote><ul><li>当数据到达路由器的时候，该路由器会用目的IP地址用<code>子网掩码</code>进行按位与，同<code>destination</code>进行对比，如果匹配就到这个子网去，就从这个对应的<code>Iface</code>发出</li><li>如果没有找到的话，就从<code>默认路由default</code>发出，</li><li>数据包经过不断路由后，最终就能到达目标主机所在的目标网络，此时就不用根据目标IP中的网络号进行路由，而是用主机号进行路由，最终就能发送给目标主机了</li></ul><h1 id="路由表生成算法"><a href="#路由表生成算法" class="headerlink" title="路由表生成算法"></a>路由表生成算法</h1><p>路由可分为静态路由和动态路由：</p><ul><li>静态路由：是指由网络管理员手工配置路由信息。</li><li>动态路由：是指路由器能够通过算法自动建立自己的路由表，并且能够根据实际情况进行调整。<br>路由表相关生成算法：距离向量算法、LS算法、Dijkstra算法等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip 网络 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP基础（1）</title>
    <link href="/2022/09/07/IP%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
    <url>/2022/09/07/IP%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">绪论</a></li><li><a href="#_14">基本概念</a></li><li><a href="#IP_21">IP报头</a></li><li><a href="#IP_46">IP分片</a></li><li><ul><li><a href="#_80">分片的原理</a></li></ul></li><li><a href="#_109">网段划分</a></li></ul><p>IP最大的意义，在于路径选择</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>IP&#x3D;网络号+主机号</p><blockquote><p>比如我们去天安门，首先要先是到北京对应的网络号，到了北京后，再在里面找到天安门对应的号码<br>先找对方的所在网络的网络号，再找它在这个网络里面的子网络号</p></blockquote><p>TCP vs IP 各自解决什么问题</p><blockquote><p>a. 决策问题vs 执行问题<br>b. IP提供了一种能力， <strong>较大概率</strong>将数据从A主机跨网络传送给主机B的能力<br>IP层不提供可靠性机制</p></blockquote><p><img src="https://img-blog.csdnimg.cn/36fb133cd4fd4a77ab5ce453aae75283.png" alt="在这里插入图片描述"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>主机</code>：配有ip地址，也会进行路由控制（端到端）<br><code>路由器</code>：配有ip地址，进行路由控制（路上的点到点）<br><code>节点</code>：主机和路由器的统称<br><code>数据段</code>：数据流，一段一段数据进行ip到达</p><h1 id="IP报头"><a href="#IP报头" class="headerlink" title="IP报头"></a>IP报头</h1><p><img src="https://img-blog.csdnimg.cn/eea07a18abb248a5abbec3c3ee91ce9d.png" alt="在这里插入图片描述"><br>如何分离与封装 ，如何向上交付</p><p>标准长度20字节<br><code>4位首部长度</code>:和TCP 的4位首部长度一样<br><code>16位总长度</code>:报文总大小，用来解决TCP粘包问题，进行分离报头和有效载荷，<strong>只针对自己的报文</strong>，不对分片负责<br><code>8位协议</code>:交付给上层的什么协议（<strong>TCP或UDP</strong>），这个是我们来填充的，<strong>应用层填充</strong>的，用来解决分用问题，向上交付<br><code>16位首部校验和</code>:路上传输的时候，保证数据的准确性<br><code>32位源IP</code>：从哪里来<br><code>32位目的IP</code>：到哪里去,交付给谁<br><code>4位版本</code>:基本都是IPV4<br><code>8位服务类型</code>：3位优先权字段（弃用了），1位保留字段（必须为0），4为TOS字段，分别表示，最小迟延，最大吞吐量，最高可靠性，最小成本，只能选其一，比如ssh，最小延迟比较重要,中间路由器都能看到<br><code>8位生存时间TTL</code>:每经过一个路由器，TTL-1，减到0，就不再被转发，在网络里面传输，等了好久没有达到，这个报文就丢弃了，避免网络资源浪费<br><code>16位标识</code>:如果没有分片，不同的报文，标识符是不一样的，如果分了片，标识符是一样的，（相同标识符代表的是同一个报文）<br><code>13位片偏移</code>:报文的有效载荷在原始报文的<strong>原始报文中有效载荷</strong>中的偏移量，就可以进行组合，自己偏移量+报文长度就是下一个片偏移量的开始<br><code>3位标志</code>:</p><blockquote><ul><li><code>1位保留</code>（还没用，或者还没想好怎么用），</li><li><code>1位标志禁止分片</code>（如果被设置为1，假如上层给链路层1800byte&gt;1500byte，也不会被分片，就丢弃了）,</li><li><code>1位标志更多报文</code>（分片后后面还有报文），1代表后面还有报文，0代表最后一个报文</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/69663003ec9f44edb30b850270378602.png" alt="在这里插入图片描述"></p><h1 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h1><p>IP分片不是大部分情况</p><ol><li><p>为什么要分片</p><blockquote><p>数据链路层一次可以往网络里面发送的数据大小是有限制MTU：1500字节</p></blockquote></li><li><p>网络层向数据链路层传输有大小限制，如果IP报文过大，如何处理呢?</p><blockquote><p>IP报文过大，就要就行分片</p></blockquote></li><li><p>为什么要在网络层就行分片</p><blockquote><p>因为分开的报文，都要添加ip报头，只有网络层才能够添加IP报头，有报头才能够在网络里面传送<br>，因为链路层无法得知网络层的任何细节，实现了解耦</p></blockquote></li><li><p>那么谁来组转呢</p><blockquote><p>所以报文必须有组转细节，谁分片谁组装，对端的网络层ip协议来进行<strong>组装</strong>，分片的过程传输层不知道，也不需要知道 ，在我们这边的网络层进行分片，到对端的网络层进行组装，传输层就没法感知到发送的报文被分片了</p></blockquote></li><li><p>分片就真的好吗？</p><blockquote><p>万一丢失了一个怎么办？可能会提高丢包的风险<br>组装失败，对端整个报文全部丢弃，对端一个都收不到，就相当于丢包了，对于TCP来说可以重传<br>对于UDP来说，就丢失了，</p></blockquote></li><li><p>如果我不想分片，谁说了算</p><blockquote><p>传输层决定，什么时候发，怎么发，发多少的问题，<code>TCP</code>控制自己的单个报文大小1480，就不用分片了<br>UDP没有发送缓冲区，就没有办法了</p></blockquote></li><li><p>如何组合呢</p><blockquote><p>我们把相同标识符放在一起，按偏移量进行升序排序，进行组合</p></blockquote></li><li><p>我怎么知道有没有报文丢失呢？</p><blockquote><p>最开始丢了，中间丢了，最后的丢了<br>排列在一起，片偏移的0没了，最开始的丢了<br>从第一个报文的偏移量+有效长度&#x3D;下一个报文的偏移量，以此类推，就可以找到，中间丢失的情况<br>报文的最后一个标志位为0，代表最后的没丢</p></blockquote></li><li><p>接收方，如何得知报文时独立的，还是一个分片的</p><blockquote><p>正常报文直接向上交付，分片报文要进行组合排序<br>未经过分片的报文，13位片偏移&#x3D;0，3位标志位的标志设置位0<br>其他的都是经过分片的报文 ，就放到一个容器里面进行整合，再向上交付</p></blockquote></li></ol><h2 id="分片的原理"><a href="#分片的原理" class="headerlink" title="分片的原理"></a>分片的原理</h2><p>假如传输层给网络层发送了1500个字节</p><blockquote><ul><li>对于网络层来说1500就是有效载荷大小</li><li>网络层加上自己的报头20字节，总共1520个字节，超过了1500字节，就要进行分片</li><li>MTU&#x3D;1500字节，1500&#x3D;1480+20（ip的报头，传到链路层中，每个报文的有效载荷最大只能是1480<br>伪代码</li><li>将每个分片好的1500交付给链路层</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X=<span class="hljs-number">1500</span>；<span class="hljs-comment">//传输层发送给链路层的大小1500</span><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<span class="hljs-comment">//这里面存储，数据分片后每一块的字节</span><br><span class="hljs-keyword">while</span>(X&gt;=<span class="hljs-number">1480</span>)<br>&#123;<br><span class="hljs-keyword">new</span>=<span class="hljs-number">1480</span>;<br>res.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span>);<br>X-=<span class="hljs-number">1480</span>;<br>&#125;<br><span class="hljs-keyword">if</span>（X）<br>&#123;<br>res.<span class="hljs-built_in">push</span>(X);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:res)<br>&#123;<br><span class="hljs-comment">// 给每一个报文添加上报头，都是拷贝同一个报头</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="网段划分"><a href="#网段划分" class="headerlink" title="网段划分"></a>网段划分</h1>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip 网络 网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP延申</title>
    <link href="/2022/09/05/TCP%E5%BB%B6%E7%94%B3/"/>
    <url>/2022/09/05/TCP%E5%BB%B6%E7%94%B3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">粘包问题</a></li><li><a href="#TCP__41">TCP 异常处理</a></li><li><a href="#UDP_56">用UDP实现可靠传输</a></li><li><a href="#TCP_65">TCP相关实验</a></li><li><ul><li><a href="#Listen_66">理解Listen的第二个参数</a></li></ul></li></ul><h1 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h1><p>粘包问题中的”包“，指的是应用层的数据包<br>TCP是基于字节流的，只维护发送出去多少，确认了多少，并不会维护消息和消息的边界，这就导致了粘包问题，他在应用层取数据的时候，不知道从哪里到哪里是一个完整的应用层数据包，面向字节流读文件都会有这种问题</p><p><img src="https://img-blog.csdnimg.cn/c0f342c23ef74cdf8b057d600b6bf1bc.png" alt="在这里插入图片描述"><br>数据就变得混乱了</p><p>怎么解决呢？</p><blockquote><p>由于找不到应用层的数据始末，所以去TCP 上面做功夫肯定是不行的，所以解决这个问题就是要在应用层协议中加上包和包之间边界，比如在应用层数据报的结尾加上一个**;**这样在读取的时候，就能区分出一个完整的应用层数据报了，</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f5b90044b4474d329d9c25fcb91b691a.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b375bf16d3d441fb94cde35da35a90f6.png" alt="在这里插入图片描述"></p><p>读取http请求的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-built_in">getline</span>(sock,buffer);<span class="hljs-comment">//按行读</span><br><span class="hljs-keyword">if</span>(buff==<span class="hljs-string">&quot;\n&quot;</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//报头读完了</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//在包头里面找到content-length=80</span><br><span class="hljs-built_in">recv</span>(sck,buffer,<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><ol><li>定长发送，缓冲区大小都是1024</li><li>特殊字符，遇到这个字符就分离</li><li>自描述，自己进行定制协议</li></ol><h1 id="TCP-异常处理"><a href="#TCP-异常处理" class="headerlink" title="TCP 异常处理"></a>TCP 异常处理</h1><p>TCP协议传输时会出现以下几种情况<br>连接崩溃的情况</p><ul><li>机器关机&#x2F;重启：会<strong>释放文件描述符</strong>，发送<code>FIN</code>，和正常关闭一样，和进程终止是一样的</li><li>进程终止：和机器重启一样,底层会自动4次挥手，文件描述符自动关</li></ul><blockquote><p>在进程毫无准备的情况下，突然结束进程，<br>我们知道TCP 连接是通过socket进行的，socket本质就是打开了一个文件，文件就存在于PCB的文件描述符表之中，每次打开一个socket文件都会在文件描述符表添加一项，删除会减少的一项<br>当强制结束进程时，PCB没了，里面的文件描述符表也没了，就相当于自动关闭了，也依然会执行四次挥手的过程</p></blockquote><ul><li><p>网线断开&#x2F;机器断电：断电时没有时间给操作系统去反应，来不及四次挥手，如果客户端断电，客户端不会给服务器发送任何数据，服务器会尝试重新连接，重连一定次数的话，就会放弃连接，接收端的连接还在，当接收端对我进行写入，会收到一个<code>reset</code>然后TCP 内不设置一个<code>保活定时器</code>（比较鸡肋），询问对方是否还在，不在就释放连接  </p><p>但是最好不要把保活定时器作为一个应用层的工具，因为不同的应用层对于连接是否需要关闭是不一样的，比如QQ，在断线之后，也会定期尝试重新连接</p></li></ul><h1 id="用UDP实现可靠传输"><a href="#用UDP实现可靠传输" class="headerlink" title="用UDP实现可靠传输"></a>用UDP实现可靠传输</h1><blockquote><ul><li>引入序列号：保证数据的顺序型</li><li>引入确认应答机制：对端收到的数据都要进行应答</li><li>超时重传：数据隔一段时间没收到进行重新传</li><li>校验和：使用校验和，避免发送错误</li><li>流量控制：对发送的数据进行管理</li></ul></blockquote><p>TCP 太重了，udp比较轻量化</p><h1 id="TCP相关实验"><a href="#TCP相关实验" class="headerlink" title="TCP相关实验"></a>TCP相关实验</h1><h2 id="理解Listen的第二个参数"><a href="#理解Listen的第二个参数" class="headerlink" title="理解Listen的第二个参数"></a>理解Listen的第二个参数</h2><p>listen第二个参数+1&#x3D;在TCP层建立正常连接的个数，不是只能在服务器段维护几个连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;port&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">uint16_t</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> sockfd = Sock::<span class="hljs-built_in">Socket</span>();<br>    Sock::<span class="hljs-built_in">Setoptsocket</span>(sockfd);<br>    Sock::<span class="hljs-built_in">Bind</span>(sockfd, port);<br>    Sock::<span class="hljs-built_in">Listen</span>(sockfd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br><span class="hljs-comment">//这里我们没有调用accept</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fc55a9ae21b14ae28a422829bffb08b8.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/571d1462387d4994b49b4e47fd138bad.png" alt="在这里插入图片描述"><br>Linux内核协议栈为一个TCP连接管理使用两个队列</p><ol><li><code>半连接队列</code>（用来保存处于SYN_RECV和SYN_SEND状态的请求），握手之中</li><li><code>全连接队列</code>（acceptd队列）（用来保存处于established状态，但是应用层<strong>没有调用accept取走</strong>的请求，暂时没有被读取），握手成功</li></ol><p>全连接队列长度会受listen第二个参数影响（n+1）：长度至少为1</p><p><strong>为什么要维护队列（全链接）？为什么这个队列不能过长？为什么这个队列不能没有？</strong></p><p><img src="https://img-blog.csdnimg.cn/5d0c9ba731e04237898580e92928ccd2.png" alt="在这里插入图片描述"></p><blockquote><ol><li>上层的服务太忙了， 服务打满了，来不及去接收新的服务，只能让它在队列里面（避免内部资源没有被充分利用）</li><li>当内部满的时候，一旦有人退出，就可以立马把队列里面的取走，保证内部资源被100%利用</li><li>如果把队列弄太长了，维护队列也是有成本的，成本太高了，长时间链接没有反应，客户就会把服务关掉，把省出来的，让服务去使用，让服务以较高的效率提供服务</li><li>listen就相等于在门口叫号的</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络 tcp/ip 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的管理机制（3）</title>
    <link href="/2022/09/05/TCP%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%883%EF%BC%89/"/>
    <url>/2022/09/05/TCP%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">滑动窗口</a></li><li><ul><li><a href="#_54">快重传（高速重发）</a></li><li><a href="#_86">超时重传</a></li></ul></li><li><a href="#_121">流量控制</a></li><li><a href="#_157">拥塞控制(网络问题)</a></li><li><a href="#_195">延迟应答</a></li><li><a href="#_210">捎带应答</a></li><li><a href="#TCP_228">TCP总结</a></li></ul><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><code>滑动窗口</code>：<strong>发送缓冲区</strong>的一部分,和对方的接收能力有关<br><code>16位窗口大小</code>：<strong>接收缓冲区</strong>剩余的大小<br><img src="https://img-blog.csdnimg.cn/6c6187b659b945fb858a4e3ee25e411b.png" alt="在这里插入图片描述"></p><blockquote><p>像这种一收一发，就变成串行了，效率很低<br>为了提高效率要允许一次发多个数据,可是允许一次发送多个数据，<br>那么一次 要给对方多少呢？<br>由接收方决定，要让对方能接收，在每次返回ack都会又窗口大小</p></blockquote><p>如图</p><p><img src="https://img-blog.csdnimg.cn/901ac4984007499a9e5529cea6084782.png" alt="在这里插入图片描述"><br>我们没有等待ack连续发了很多报文</p><blockquote><ul><li>窗口大小：无需等待服务端确认应答ack而可以发送数据的最大值,上图的窗口大小是4000字节</li><li>前4个段不需要ack，直接发送</li><li>收到第一个ACK之后，滑动窗口就向后移动，继续发送数据,</li><li>滑动窗口滑动后的变化取决于对方的接收能力</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/e9c3574b6dda49acbeda0695a143a9a4.png" alt="在这里插入图片描述"></p><p>假如说客户端硬件设备比较先进，一直在给服务端发送数据，那么就会把服务器端的内核缓冲区给挤爆，如果有阻塞机制的话，那么服务器端就阻塞在了那边，如果没有阻塞机制的话，那么服务器端的前面的数据就会被覆盖掉</p><p>所以这个时候就会有一个叫做滑动窗口的机制，服务端告诉客户端，用来存放数据的缓冲区有多大，如果满了的话，就不要再发送了</p><p>滑动窗口就是为了防止数据丢失，防止出现丢包的情况<br><img src="https://img-blog.csdnimg.cn/c6d1a19f1fa6481b94e4eb83a64c7947.png" alt="在这里插入图片描述"><br>可以在<strong>应答报文</strong>中填写上<strong>我自己</strong>的<strong>接收缓冲区</strong>的<strong>剩余空间</strong>大小</p><p>16位的滑动窗口就是滑动窗口大小不能超过2^16,32位序号就是序号的数值不能超过2 ^32，</p><ul><li>recvfrom和sendto这些函数实际上就是一个拷贝函数：TCP 当中有接收缓冲区，和发送缓冲区，recvfrom，sendto就是把数据拷贝到TCP 缓冲区里面，以及从TCP 缓冲区里面把数据拷贝到用户层，</li><li>文件描述符的生命周期是谁这进程的,一旦客户端建立好联系之后死机了，进程退出了，此时文件描述符也就退出了</li><li><strong>流量控制</strong>：填写TCP 滑动窗口的大小，告知对方自己能够接收到上限，达到两个方向上传输速度的控制，就叫做流量控制</li></ul><h2 id="快重传（高速重发）"><a href="#快重传（高速重发）" class="headerlink" title="快重传（高速重发）"></a>快重传（高速重发）</h2><p>如果丢包了怎么处理呢</p><p><img src="https://img-blog.csdnimg.cn/c2f079568258451dbdb9df24f74147c3.png" alt="在这里插入图片描述"></p><ol><li><strong>ACK丢失</strong>：像上面这样的，即使ACK600丢失了，也不需要进行重传，因为后续的ACK700可以被发送方收到，后续的报文可以说明前面的报文已经获取了（收到多少窗口往右移动就可以了）<br>因为：ACK保证前面的全部收到，所以TCP是允许少量的丢包的</li></ol><p><img src="https://img-blog.csdnimg.cn/f464574de0b04906bafc051813429d88.png" alt="在这里插入图片描述"></p><blockquote><ul><li>滑动窗口是一个环形队列，窗口不断移动的本质，就是窗口绕着那个环转圈，不可能越界，不可能出现溢出，</li><li>write一直写数据会阻塞住就是环形队列被打满了</li></ul></blockquote><ol start="2"><li>还有一种情况是发送方的<strong>数据报文丢失</strong><br>那么发送方会连续收到接收方发来的相同的报文，<strong>连续收到三个</strong>，就要重新发送对应的报文，这种机制就叫做“<strong>高速重发控制</strong>”，也叫“快重传”</li></ol><p><img src="https://img-blog.csdnimg.cn/adb46c819aab427a983d0313b7324672.png" alt="在这里插入图片描述"></p><ul><li>主机的1001-2000的报文丢了但是后面的报文收到了没有丢，确认序号依旧是1001</li><li>主机A会收到连续大量的确认1001，</li><li>主机A如果连续收到了3个以上同样的ack，就说明1001以后的有些报文丢失了，主机A会立即进行重传,对方也会重新更新它的窗口序列，并返回</li><li>主机A补发了1001-2000，我不确定到底补发多少，先发这么多，等待对方反馈，获得新的ack，也可以无脑的把1001后面的全部发送过去，但是我们少发一点，效率高，一点一点发送，网络也不会丢失太多</li></ul><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><img src="https://img-blog.csdnimg.cn/c62eb24c1a1842fdbfa22f8cca3c2692.png" alt="在这里插入图片描述"><br>TCP 的发送方在<strong>规定时间</strong>内<strong>没有收到确认报文</strong>就要重传已发送的报文</p><p>没有收到确认报文的原因有两种</p><ol><li>发送方的发送报文丢失</li><li>确认方的确认报文丢失，如果是这样的话，接收方会收到一份相同的报文，TCP 协议通过<strong>序列号</strong>（序号没有变化）识别出了这个重复报文呢，就会进行丢弃，（<strong>TCP具有去重能力</strong>），所以也能够保证报文的按序达到，</li></ol><p>去重也是可靠性的表现</p><p><strong>如何保证TCP 有超时重传的机制</strong></p><ul><li>需要超时重传实际上也就说明了发送方数据发送出去后也不能将数据删除或者覆盖掉（因为可能对面没有收到，还要重新发送一次）</li><li>需要发送方收到对方的ACK才可以把数据移除掉</li></ul><p><strong>超时重传的时间</strong></p><blockquote><ul><li>在最理想情况下，找到一个最小的时间，保证“确认应答一定会在这个时间内返回”</li><li>时间的长短和网络环境有关</li><li>时间长，会影响重传的效率</li><li>时间短，会频繁发送重复的包（这个问题不大，有去重的机制）</li></ul></blockquote><p><strong>TCP 为了保证高性能通信，动态计算了这个最大超时时间（不能让一直等待）</strong></p><blockquote><ul><li>由于这个和带宽（用于表示一秒钟内网络传输的总容量）有关，所以这个超时时间是动态的</li><li>Linux中，超时以<strong>500ms</strong>为<strong>一个单位</strong>进行控制，每次判定超时重发的超时时间都是<strong>500ms的整数倍</strong></li><li>如果重新发出一次还得不到银达，就要等待2*500ms进行重新发送，</li><li>如果还是不能应答，就在等待4*500进行重传，一次类推以指数形式递增，累积到一定的重传次数，TCP 就会认为网络或者对端主机出现了异常，强制<strong>关闭连接</strong>,(把自己关闭掉)</li></ul></blockquote><p><strong>快重传vs超时重传</strong></p><p>ACK 的语义非常重要，因为决定了即使收到了后面的数据</p><blockquote><ul><li>快重传是为了提高效率而进行的</li><li>超时重传是为了快重传无法解决的时候，才会超时重传，兜底用的</li></ul></blockquote><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>保证了发送的速度合理</p><p>我们上文解释过了窗口的含义，还有一个概念是滑动窗口<br>滑动窗口其实就是发送缓冲区的一部分（实际上缓冲区是头尾相接的环形）<br><img src="https://img-blog.csdnimg.cn/f09445e8fcbc40ea81d427f45c44eb7f.png" alt="在这里插入图片描述"><br>假设A收到了B发来的确认报文，窗口大小是20字节，确认号是31，这样就可以构造出自己<code>滑动窗口</code>的宽度</p><p>在没有收到B确认报文的情况下，允许A 可以把滑动窗口的数据都发出去，但是在A 收到B 的确认报文之前，发送出去的数据都要暂时保留在这个滑动窗口里面，以便重传</p><p>显然，A的发送串口的数据不能超过B 的接收能力，</p><p>发送窗口的大小由前沿和后研进行决定，窗口越大，则网络吞吐效率高，</p><p>收到新确认，后沿就可以往前移动，没有收到的话，后沿就不能移动</p><p>前沿通常向前移动，但是由于接收方接受能力变低，前言可能也不会动</p><ol><li>第一次发送的时候怎么知道对方的接收能力？</li></ol><blockquote><p><strong>取决于对方什么时候给我发送的第一个报文</strong><br><strong>在握手期间协商窗口大小</strong>，还没发数据<br>返回ACK的时候填写上了自己的窗口大小<br>就能够构建出滑动窗口，就能够进行发送数据</p></blockquote><ol start="2"><li>如果接收缓冲区的窗口大小为0，怎么办</li></ol><blockquote><ul><li>发送方就知道了对方不能接收，就不要发了，只能等待，一直等待</li><li>如果接收方一直不收数据，主机A可以向主机B发送一个<strong>窗口探测</strong>的报文带<code>PSH</code>标志位（告诉对方赶紧读），没带数据</li><li>主机B收到数据就要给主机A回复，如果对方的窗口大小还是0，那么A就要<strong>轮询</strong>的<strong>发送窗口探测</strong></li><li>一旦主机B数据被读了，那么也可以给A发送一个同步的报文，主动通知A</li><li>如果B的告知同步报文丢失了，A还会轮询的发窗口探测，共同运行</li></ul></blockquote><p>滑动窗口既保证了发送方的效率，也保证了接收方的接受能力，这就是所谓的流量控制</p><h1 id="拥塞控制-网络问题"><a href="#拥塞控制-网络问题" class="headerlink" title="拥塞控制(网络问题)"></a>拥塞控制(网络问题)</h1><p>发送少量的数据丢失，就是正常的，可以重发，丢失了大量报文，就是网络问题，不应该重发</p><p><strong>拥塞控制</strong></p><blockquote><p>滑动窗口时靠内核进行维护的，我们在发送的时候不仅要考虑对方<code>滑动窗口</code>所能接收的最大值，还要考虑<code>网络</code>在内，因为一个计算机网络中都是有很多主机所<strong>共享</strong>的，因此可能会因为其他主机之间的通信变得十分拥堵，在<strong>网络拥堵</strong>的时候，如果发送大量的数据包，就会导致数据包<strong>时延</strong>，<strong>丢失</strong>,这个时候就会等一等<br>(是TCP发现网络拥塞(大家都执行，不是单一主机)，尝试去回复网络状况的机制)</p></blockquote><p>拥塞控制简单来说：网络发送<strong>拥堵</strong>的时候，TCP 会减少发送量，为了在发送时调节发送数据量，定义量拥塞窗口这个概念，拥赛窗口也是发送的窗口，他会根据网络的拥堵程度进行动态变化，发送窗口的大小实际上是拥塞窗口和接受窗口中的最小值：<br>（滑动窗口&#x3D;min｛拥塞窗口，对端窗口的大小｝）<br>:发送方既要考虑对方接收能力的问题，也要考虑网络状态的问题</p><p><img src="https://img-blog.csdnimg.cn/8e69f889f7cd43718effcef9eb1e8e97.png" alt="在这里插入图片描述"></p><ul><li>此处引入量拥塞窗口的概念：描述（发送时候<strong>网络状态</strong>）</li><li>发送的一开始定义拥塞窗口的大小为1</li><li>每次收到<code>ACK</code> 应答，<code>拥塞窗口</code><strong>+1</strong>，这样子实际上，我们第一次发送一个数据，收到回应之后，拥塞窗口就变成了2，在对端接收缓冲区允许的情况之下，我们可以发送2倍的数据</li><li>每次发送数据包的时候，讲<code>拥塞窗口</code>和接收端主机<code>反馈的窗口</code>大小进行比较，取较小的值作为<code>实际发送的窗口</code></li></ul><ol><li><strong>阀值</strong>主要时用来判断合适指数增长何时线性增长</li><li>ssthresh数值表示拥塞控制窗口大小的一个阀值，峰值会影响阀值的大小，这里的峰值就是引起数据丢包的窗口大小，每次出现丢包的情况阀值就会变成丢包时峰值的一半</li><li><strong>慢启动</strong>是能够防止一个快速的TCP发送压垮整个网络</li><li><strong>慢启动的阈值</strong>是为了避免传输速率指数级增长导致发送者在短时间内就会压垮整个网络，TCP拥堵算法也就是为防止这种事情发生，他为速率的增长提供了一个管理实体</li><li>一开始都是<strong>慢启动算法</strong>，刚开始的指数增长是为了尽快让传递批量数据，更快的达到不丢包的极限，所以就需要使用指数增长，从而达到<strong>慢启动阀值（ssthresh）的初始值</strong>之后，我们就<strong>线性增加</strong>即可了，此时不能再指数增长了，</li><li>出现网络拥塞，就要重新进行<strong>慢启动</strong></li></ol><p>发生快重传</p><blockquote><p>当发送端收到连续三个重复的确认时，把慢开始的阀值ssthresh减半，由于发送方并不认为此时网络拥塞，所以此时不执行慢开始算法，即：不会讲cwnd设置为1，而是设置成为ssthrsh减半之后的值</p></blockquote><p><img src="https://img-blog.csdnimg.cn/68ddf1b8ece8446e93280de8487312a1.png" alt="在这里插入图片描述"><br>6. 当网络拥塞的时候，发生超时重传或快重传后需要重新设置拥塞窗口大小，<strong>此时将慢启动的阀值设置为发送网络拥塞的一半，然后从1开始按照指数级发送数据，到达阀值再进行线性增长</strong></p><blockquote><ul><li>ssthresh设置为cwnd&#x2F;2</li><li>cwnd重置为1</li></ul></blockquote><h1 id="延迟应答"><a href="#延迟应答" class="headerlink" title="延迟应答"></a>延迟应答</h1><p>提高效率的一种策略，网络传输的时间可能比准备的时间还要长，所以我希望一次多发一些数据过去，提高效率</p><p>延迟应答：如果接受数据的主机立刻返回ACK 应答，这时候返回的窗口可能比较小，接收方收到数据等一会，上层可能会读取数据，过一会窗口可能变更大了</p><blockquote><ul><li>假设接收端缓冲区为1M，一次接收到500K 的数据</li><li>如果立即应答，返回的窗口就是500K，但实际上可能处理端处理的速度很快，10ms之内就把500K的数据从缓冲器里面消费掉，但这情况下，接收端接收大小还会变大，如果接收端稍微等待一会在应答，比如说等待200ms再应答，这个时候返回的窗口大小就是1M，一次可以多处理一点</li></ul></blockquote><p>因为窗口越大，网络吞吐量就越大，传输效率也就越高<br>但是并非所有的包都可以延迟应答</p><ul><li><code>数量限制</code>：每隔N个包就应答一次</li><li><code>时间限制</code>：超过最大延迟时间就应答一次</li></ul><p>具体的数量和超时时间，依操作系统不同也有会有差异。一般N取2，超时时间取200ms</p><h1 id="捎带应答"><a href="#捎带应答" class="headerlink" title="捎带应答"></a>捎带应答</h1><p>服务器最常见的就是<strong>一问一回</strong>的模式，如果每次消息都是一问一答，类似于</p><ol><li>请求</li><li>请求的ACK</li><li>响应</li><li>响应的ACK</li></ol><p>如果变成<code>捎带应答</code>，就是发送应答的时候，也能够发送有效数据</p><ol><li>请求</li><li>请求的ACK+响应</li><li>响应的ACK<br>这样就减少了包的传输个数，降低了通信成本，提高了效率</li></ol><h1 id="TCP总结"><a href="#TCP总结" class="headerlink" title="TCP总结"></a>TCP总结</h1><p><img src="https://img-blog.csdnimg.cn/5446e3991d7d4663a14036134d3a43df.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip 网络 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP连接管理（2）</title>
    <link href="/2022/08/31/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%EF%BC%882%EF%BC%89/"/>
    <url>/2022/08/31/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">三次握手</a></li><li><a href="#_41">四次挥手(以最小的成本协商达成连接关闭的认识)</a></li><li><ul><li><a href="#TIME_WAIT_49">理解TIME_WAIT</a></li><li><a href="#close_wait_102">理解close_wait</a></li></ul></li></ul><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>TCP服务器里面<br>发起建立连接一般都是client</p><p><img src="https://img-blog.csdnimg.cn/8157a1abe9174bf4be38df6783cb3269.png" alt="在这里插入图片描述"></p><ol><li>server里面存在有大量的连接，该如何管理呢？</li></ol><blockquote><p>先描述在组织<br>有描述连接的结构体，里面填充的就是描述连接的各自属性，后以各种数据结构连接起来<br>双方维护连接是有成本的（时间+空间）</p></blockquote><ol start="2"><li>为什么是3次握手(不是说三次握手一定成功,只是以较大概率建立连接的过程)</li></ol><blockquote><ul><li>我们并不担心第一次第二次丢了：因为第一次，第二次都有应答，第三次没有应答，就有可能有丢失的风险<br>两点：保证对方好着没，网络好着没</li><li>确认双方主机是否健康</li><li>验证全双工，三次握手，是我们能看到双方都能看到收发的最小次数！</li></ul><blockquote><p>对客户端来说：发送数据syn验证了自己能发送数据，收到syn+ack验证了自己能收到数据，同时发送成功<br>对服务端来说：客户端发送syn验证了自己能收数据，发送syn+ACK，得到客户端回应ack说明了自己能发送数据,没有第三次握手无法证明服务端有发送的能力</p></blockquote><ul><li>一次不行的原因：每次发送syn，服务端都要建立一个连接结构来管理，如果发送海量的syn，很容易受到攻击</li><li>两次不行的原因：第二次握手的时候，服务端认为建立成功了，可能这个报文客户端没收到，丢弃了，客户端发送大量的syn，服务器端还是会维护大量的健康连接，消耗维护资源（SYN洪水）</li><li>三次握手建立成功，双方是等量的消耗资源，可以杜绝纯小白，个人的攻击</li></ul></blockquote><ol start="3"><li>对于client来说三次握手怎么样算完成</li></ol><blockquote><p>因为3次握手没有响应，只要client把ack发送出去，client就认为它握手完成<br>一般而言双方的握手成功是有时间差的：server段认为收到才算成功</p></blockquote><ol start="4"><li>第三次ack丢失</li></ol><blockquote><p>client认为连接已经完成，server认为连接没有完成<br>client就会理所当然的给server段发送数据，server（认为链接都没建立好就发送数据）收到了这个报文，这个报文不是建立连接的报文，就会返回一个RST(证明，刚才建立的连接失败，client就会关闭连接)</p></blockquote><ol start="5"><li>三次握手是双方的操作系统自动完成的，用户层完全不参与</li></ol><blockquote><p>client-&gt;connect -&gt;发起三次握手（操作系统自动完成）<br>server-&gt;accept，握手成功</p></blockquote><h1 id="四次挥手-以最小的成本协商达成连接关闭的认识"><a href="#四次挥手-以最小的成本协商达成连接关闭的认识" class="headerlink" title="四次挥手(以最小的成本协商达成连接关闭的认识)"></a>四次挥手(以最小的成本协商达成连接关闭的认识)</h1><ol><li>断开连接是双方的事情，双方随时都有可能发生</li><li>分别发送FIN，双方分别应答，就是四次握手，一方发送fin就是把自己的发送缓冲区给关闭了</li><li>没有人以断开连接来发起攻击，因为这个是让服务器更轻松</li><li>断开连接的本质：双方达成连接都应该断开的共识，就是一个通知对方的机制</li></ol><p><img src="https://img-blog.csdnimg.cn/27b4db958c464e54bfd4e7f6d0c712ac.png" alt="在这里插入图片描述"></p><h2 id="理解TIME-WAIT"><a href="#理解TIME-WAIT" class="headerlink" title="理解TIME_WAIT"></a>理解TIME_WAIT</h2><p>主动断开连接的一方，就要进入TIME_WAIT状态</p><ol><li><pre><code class="hljs">TIME\_WAIT状态上，认为自己的连接已经释放了，因为它已近收发了四次报文，即使它已近结束了，但是它还不能释放自己的结构，还要维护一段时间，等待自己的ack发送成功</code></pre></li><li><pre><code class="hljs">不accept它也会建立连接</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;port&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">uint16_t</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> sockfd = Sock::<span class="hljs-built_in">Socket</span>();<br>    Sock::<span class="hljs-built_in">Bind</span>(sockfd, port);<br>    Sock::<span class="hljs-built_in">Listen</span>(sockfd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> newsock = Sock::<span class="hljs-built_in">Accept</span>(sockfd);<br>        cout&lt;&lt;newsock&lt;&lt;endl;<br>        <span class="hljs-comment">//这里我们让服务器先断开</span><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>连接建立成功这里estabilsh,我们把服务器断开，服务器就进入了time_wait状态<br><img src="https://img-blog.csdnimg.cn/8c6bd9a6c96d4a57a8d16b367e2b2ae4.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/17a02fc1d3614a3fbc6ea05b97430c21.png" alt="在这里插入图片描述"></p><p>一旦TIME_WAIT状态，服务是无法立即重启的</p><p><strong>MSL</strong>（max segment life）:报文最大传输时间，一个报文在网络里面最大的存活时间<br><img src="https://img-blog.csdnimg.cn/edcedde730e94b569edc574baa474049.png" alt="在这里插入图片描述"></p><p><strong>为什么要有TIME_WAIT?</strong></p><blockquote><p>TIME_WAIT一般是等待2msl的时间长度</p><blockquote><ol><li>尽量保证历史发送的网络数据在网络中消散，因为如果直接断开的话，还有一些双方发送的数据，并没有被读取</li><li>2msl刚好保证了数据是一来一回的,历史上的数据更好就卡在了出口路由器上，</li><li>尽量的保证最后一个ACK被对方收到，没有消息的话，就认为已近ack发送成功，如果中途收到fin，说明我发送ack失败</li></ol></blockquote></blockquote><p>** 为什么会bind error**</p><blockquote><p>我们断开连接之后，在连接，因为之前的服务器一方处于time_wait方面，这个连接没有断开，端口依旧被占用着,<br>因为一个端口号只能被一个进程绑定</p></blockquote><p><strong>无法立即重启有什么危害</strong></p><blockquote><p>1s都是很大的数据量，服务器的端口和ip都是不能改变的，客户不认识，连不上，所以必须使用地址复用的选项</p></blockquote><h2 id="理解close-wait"><a href="#理解close-wait" class="headerlink" title="理解close_wait"></a>理解close_wait</h2><p>调用一个close就是2次挥手<br>如果<strong>客户端调用close</strong>，<strong>而服务器不调用close</strong>，那么<strong>服务器</strong>就会一直处于<strong>close_wait</strong>状态,客户端就会处于fin_wait2状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;port&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">uint16_t</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> sockfd = Sock::<span class="hljs-built_in">Socket</span>();<br>    Sock::<span class="hljs-built_in">Setoptsocket</span>(sockfd);<br>    Sock::<span class="hljs-built_in">Bind</span>(sockfd, port);<br>    Sock::<span class="hljs-built_in">Listen</span>(sockfd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> newsock = Sock::<span class="hljs-built_in">Accept</span>(sockfd);<br>        cout&lt;&lt;newsock&lt;&lt;endl;<br>        <span class="hljs-comment">//这里我们不调用closefd,服务器就会处于close_wait状态</span><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2e9fbef37cd14fb2914d0bdfead13eaa.png" alt="在这里插入图片描述"></p><p>启示</p><blockquote><ol><li>一个fd被用完，千万不要忘记释放！</li><li>fd是有限制的，会造成fd泄露，fd被占用变得越来越少</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip 网络 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="/2022/08/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/08/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的公共祖先</a><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><blockquote><p><img src="https://img-blog.csdnimg.cn/9d1f995fc66d4e1eb3cf5c62b6348114.png" alt="在这里插入图片描述"><br>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p></blockquote><h2 id="保存路径法"><a href="#保存路径法" class="headerlink" title="保存路径法"></a>保存路径法</h2><p>记录从根到对应节点的路径，找到最近公共节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findpath</span><span class="hljs-params">(stack&lt;TreeNode*&gt;&amp; con,TreeNode* root,TreeNode* x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//走到空，没找到</span><br>        con.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//先入栈再说</span><br>        <span class="hljs-keyword">if</span>(root==x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findpath</span>(con,root-&gt;left,x))<span class="hljs-comment">//如果在左边找到了,就不要往右边去找</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findpath</span>(con,root-&gt;right,x))<span class="hljs-comment">//如果在右边找到了,就别要去左边找了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//左边也没找到，就要出栈</span><br>        con.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//往上面走告知在左边没找到        </span><br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">//方法2，记录路劲,使用栈,从根到底部的路劲</span><br>        stack&lt;TreeNode*&gt; pstack;<br>        stack&lt;TreeNode*&gt; qstack;<br>        <br>        <span class="hljs-built_in">findpath</span>(pstack,root,p);<br>        <span class="hljs-built_in">findpath</span>(qstack,root,q);<br>        <span class="hljs-type">int</span> diff=pstack.<span class="hljs-built_in">size</span>()-qstack.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//两者的差值</span><br>        <span class="hljs-keyword">if</span>(diff&lt;<span class="hljs-number">0</span>)<br>        diff=-diff;<br>        <span class="hljs-type">bool</span> plarger=pstack.<span class="hljs-built_in">size</span>()&gt;qstack.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> qlarger=!plarger;<br>            <span class="hljs-keyword">while</span>(diff--)<span class="hljs-comment">//把两个减到一样多</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(plarger)<br>                pstack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(qlarger)<br>                qstack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!pstack.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(pstack.<span class="hljs-built_in">top</span>()==qstack.<span class="hljs-built_in">top</span>())<span class="hljs-comment">//直到找到就返回</span><br>                <span class="hljs-keyword">return</span> pstack.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pstack.<span class="hljs-built_in">pop</span>();<br>                    qstack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="查找节点法"><a href="#查找节点法" class="headerlink" title="查找节点法"></a>查找节点法</h2><p>如果要找的节点在左右两边，那么我就是节点，如果都在左边，就去左边找，如果都在右边，就去右边找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(TreeNode* root,TreeNode* x)</span><span class="hljs-comment">//查找一个节点</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//走到空，就没找到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(root==x)<span class="hljs-comment">//为x就找到了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(root-&gt;left,x)||<span class="hljs-built_in">find</span>(root-&gt;right,x);<span class="hljs-comment">//没找到就去左边或右边找，找到了就为真</span><br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">//分别求出两个的路径</span><br>        <span class="hljs-comment">//用栈来存储路径</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//为空就没找到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root==p||root==q)<br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//其中一个就是要找的，那就是</span><br>        <span class="hljs-type">bool</span> pinleft=<span class="hljs-built_in">find</span>(root-&gt;left,p);<br>        <span class="hljs-type">bool</span> pinright=!pinleft;<br>        <span class="hljs-type">bool</span> qinleft=<span class="hljs-built_in">find</span>(root-&gt;left,q);<br>        <span class="hljs-type">bool</span> qinright=!qinleft;<br>        <span class="hljs-keyword">if</span>((pinleft&amp;&amp;qinright)||(pinright&amp;&amp;qinleft))<span class="hljs-comment">//在左右两边，那就是它了</span><br>        <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pinleft&amp;&amp;qinleft)<span class="hljs-comment">//都在左边，就去左边递归的找</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pinright&amp;&amp;qinright)<span class="hljs-comment">//都在右边，就去右边递归的找</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode 算法 动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的层序遍历及其变形</title>
    <link href="/2022/08/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2/"/>
    <url>/2022/08/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">二叉树的层序遍历</a></li><li><ul><li><a href="#_58">变形</a></li></ul></li></ul><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a><br>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。<br><img src="https://img-blog.csdnimg.cn/a65feee7f58c41c08e7519064c9cdc4a.png" alt="在这里插入图片描述"></p><blockquote><p>示例 1：<br>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：<br>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：<br>输入：root &#x3D; []<br>输出：[]</p></blockquote><p>层序遍历<br>使用队列，队头出队带入他的左右节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ret;<span class="hljs-comment">//用来记录的是每一层的元素</span><br>        queue&lt;TreeNode*&gt; s;<span class="hljs-comment">//用来入队，出队带入左右节点</span><br>        <span class="hljs-type">int</span> levelsize=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root)<span class="hljs-comment">//如果根不为空，就入队，进行后续的操作</span><br>        &#123;<br>            s.<span class="hljs-built_in">push</span>(root);<br>            levelsize=<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<span class="hljs-comment">//当队列为空，就结束了</span><br>        &#123;<br>            levelsize=s.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; v;<br>            <span class="hljs-keyword">while</span>(levelsize--)<span class="hljs-comment">//队列一层的元素</span><br>            &#123;<br>                TreeNode* parm=s.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//记录队头</span><br>                v.<span class="hljs-built_in">push_back</span>(parm-&gt;val);<span class="hljs-comment">//先入队</span><br>                <span class="hljs-keyword">if</span>(parm-&gt;left)<span class="hljs-comment">//左不为空，带入</span><br>                &#123;<br>                s.<span class="hljs-built_in">push</span>(parm-&gt;left);<br>                <br>                &#125;<br>                <span class="hljs-keyword">if</span>(parm-&gt;right)<br>                &#123;<br>                s.<span class="hljs-built_in">push</span>(parm-&gt;right);<br>                <br>                &#125;<br>                s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队</span><br>            &#125;<br>            ret.<span class="hljs-built_in">push_back</span>(v);<span class="hljs-comment">//插入一层的元素</span><br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><ol><li><pre><code class="hljs">计算第k层的节点个数</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">size=ret[k<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><ol start="2"><li><pre><code class="hljs">计算一共的节点个数</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:ret)<br>&#123;<br>total+=e.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//将每一个的元素个数相加</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><pre><code class="hljs">计算深度</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hight=ret.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//ret的个数</span><br></code></pre></td></tr></table></figure><ol start="4"><li><pre><code class="hljs">二叉树自底向上遍历</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">reverse</span>(ret.<span class="hljs-built_in">begin</span>(),ret.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//翻转一下即可</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode 算法 职场和发展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2022/08/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/08/28/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">二叉搜索树</a></li><li><ul><li><a href="#_2">概念</a></li></ul></li><li><a href="#_10">时间复杂度</a></li><li><ul><li><a href="#_17">应用</a></li><li><a href="#_37">实现</a></li><li><ul><li><a href="#key_38">key模型</a></li><li><ul><li><a href="#Insert_73">Insert</a></li><li><a href="#Find_164">Find</a></li><li><a href="#Erase_224">Erase</a></li><li><a href="#InOrder_392">InOrder</a></li></ul></li><li><a href="#KV_412">KV模型</a></li></ul></li></ul></li></ul><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>左子树的值小于根，右子树的值大于根<br>根的值大于左子树，小于右子树<br><img src="https://img-blog.csdnimg.cn/38e99296e576466183e8283696ce5c23.png" alt="在这里插入图片描述"><br>二叉搜索树就是用来查找的</p><blockquote><p>假如我们要查找7：7比3大，到3的右子树&#x3D;5，7比5大，到5的右子树7，查找到了</p></blockquote><p>二叉搜索树的中序遍历，可以实现从小到大排序的遍历</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>最坏情况1：查找：高度次<br>最坏情况2：O（N）:<br>如下图:这个效率就特别差，和单链表没有区别<br><img src="https://img-blog.csdnimg.cn/47f732cce20f4145a7704df5355f7879.png" alt="在这里插入图片描述"><br>后续用AVL树，RB树</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>搜索树的应用</p><ol><li>搜索，key搜索模型，key&#x2F;value模型</li><li>排序+去重</li></ol><p><strong>key模型</strong><br>可以用来判断值在不在，效率很搞O(logN)<br>应用场景</p><blockquote><ol><li>搜索树存储小区业主的车牌号，扫描，存在就通过，不存在就不让过</li><li>搜索树存储同学的学号</li><li>给一个英文作文，检查里面的单词拼写是否正确（我们把单词都存放进去，进行搜索存在与否）</li></ol></blockquote><p><strong>key&#x2F;value模型</strong><br>通过一个值查找另外一个值<br>应用场景</p><blockquote><ol><li>高铁站刷身份证进站，用身份证查早是否右买票</li></ol></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="key模型"><a href="#key模型" class="headerlink" title="key模型"></a>key模型</h3><p><strong>树的节点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span><br>    &#123;<br>        K _val;<span class="hljs-comment">//节点的值</span><br>        BSTNode&lt;K&gt; *_left;<span class="hljs-comment">//左子树</span><br>        BSTNode&lt;K&gt; *_right;<span class="hljs-comment">//右子树</span><br>        <span class="hljs-built_in">BSTNode</span>(<span class="hljs-type">const</span> K &amp;val)<span class="hljs-comment">//构造函数</span><br>            : _val(val), _right(<span class="hljs-literal">nullptr</span>), _left(<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p><strong>BStree的类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTree</span><br>    &#123;<br>        <span class="hljs-keyword">typedef</span> BSTNode&lt;K&gt; Node;<span class="hljs-comment">//把每个节点进行重命名</span><br><br>    <span class="hljs-keyword">private</span>:<br>        Node *_root;<span class="hljs-comment">//节点</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">BSTree</span>()<br>            : _root(<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p><img src="https://img-blog.csdnimg.cn/c0b3f80d64df4e379b5e47e5e3a3a393.png" alt="在这里插入图片描述"></p><p><strong>非递归版本</strong></p><blockquote><ol><li>插入一个值，从根往下面走，要插入的值比它大，走右边，比它小走左边，如果这个值已近存在了，就不要插入</li><li>直到走到空，就是我们要插入的地方</li><li>我们需要把这个节点链接上去，所以我们需要空节点对应的父节点，父节点连接上新添加的节点</li><li>如果根节点就是空，直接插入在根节点即可<br>例如：我们插入一个10</li></ol><blockquote><p>10&gt;8,先走右边，到9，10&gt;9走右边，走到了空，把它插入到这个地方</p></blockquote></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span> <span class="hljs-comment">//非线性叫做insert</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//插入重复的值，就返回失败</span><br>    <span class="hljs-keyword">if</span> (_root == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//一个节点都没有</span><br>    &#123;<br>        _root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Node *cur = _root;<span class="hljs-comment">//cur用来走到要插入的位置</span><br>        Node *prev;<span class="hljs-comment">//prev用来记录插入位置的父节点</span><br>        <span class="hljs-keyword">while</span> (cur)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;_val &gt; key)<span class="hljs-comment">//比要插入的值大，往左走</span><br>            &#123;<br>                prev = cur;<br>                cur = cur-&gt;_left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_val &lt; key)<span class="hljs-comment">//比要插入的值小，往右走</span><br>            &#123;<br>                prev = cur;<br>                cur = cur-&gt;_right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><span class="hljs-comment">//相等就别走了</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//走到这里cur就是空</span><br>        cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key);<br>        <span class="hljs-keyword">if</span> (prev-&gt;_val &lt; key)<span class="hljs-comment">//父节点小于插入节点</span><br>        &#123;<br>            prev-&gt;_right = cur;<span class="hljs-comment">//连接到父节点的右边</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            prev-&gt;_left = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递归版本</strong></p><p>我们使用引用就不需要用父节点来连接<br>例如:我们链接上的节点为10，走到9的右，root即是空，也是9右指针的别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> _InsertR(Node *&amp;root, <span class="hljs-type">const</span> K &amp;key) <span class="hljs-comment">//这里要多一个引用,指针的引用，进行修改才使用引用</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//走到空就插入,引用，root是上面的root-&gt;right别名</span><br>    &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key); <span class="hljs-comment">//直接链接上了 ，都是前面的别名，都连接起来了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;_val &gt; key)<br>    &#123;<br>        <span class="hljs-keyword">return</span> _InsertR(root-&gt;_left, key);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;_val &lt; key)  <br>    &#123;<br>        <span class="hljs-keyword">return</span> _InsertR(root-&gt;_right, key);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertR</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span> <span class="hljs-comment">//有序的方式就会变成单边树，栈爆了</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//递归有根，都要套一个子函数</span><br>    <span class="hljs-keyword">return</span> _InsertR(_root, key);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><p><strong>非递归版本</strong></p><blockquote><p>从根节<br>点往下走，比它大，走右边，比它小走左边，相等就找到了，走到空就说明没找到</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span> <span class="hljs-comment">//查找</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *cur = _root;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;_val &gt; key)<br>        &#123;<br>            cur = cur-&gt;_left;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_val &lt; key)<br>        &#123;<br>            cur = cur-&gt;_right;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//在这中间，就说明找到了</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//走到空就没找到</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>递归版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Node *<span class="hljs-title">FindR</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> _Find(_root, key);<br>&#125;<br>Node *_FindR(Node *root, <span class="hljs-type">const</span> K &amp;key)<br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;_val == key)<br>    &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;_val &gt; key)<br>    &#123;<br>        <span class="hljs-keyword">return</span> _FindR(root-&gt;_left, key);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> _FindR(root-&gt;_right, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Erase"><a href="#Erase" class="headerlink" title="Erase"></a>Erase</h4><p><img src="https://img-blog.csdnimg.cn/069e74bb1662471d8ee6ae64dc80fb1e.png" alt="在这里插入图片描述"></p><p>非递归版本</p><blockquote><ol><li>先找到要查找到要删除的节点</li><li>如果要删除的节点左子树为空，如果它是它父亲的左节点，它的父亲节点的左节点连接上删除节点的右指针</li></ol><blockquote><p>例如删除3，左为空，3是1的右节点，把1的右节点，连接到3的右节点</p></blockquote><ol start="3"><li>如果要删除的节点右子树为空，它为父节点的右节点，把它父节点的右节点连接到删除节点的左节点</li></ol><blockquote><p>例如删除10，右为空，10 是9的右节点，把10的左节点，连接到9的右节点上</p></blockquote><ol start="4"><li>如果要删除的节点左右子树都为空，要使用替换法删除，可以把要删除的节点的右子树的最左边或者要删除节点的左子树的最右边，把它和要删除节点进行替换，在把那个替换的节点删除</li></ol><blockquote><p>例如删除5，左右节点都不为空，把5右节点的最左边和5进行替换，</p></blockquote></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Erase</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//先查找,删除之后要保持搜索二叉树的状态</span><br>    <span class="hljs-comment">//有两个儿子，用左子树的最右节点，或者右子树的最左节点来进行替换删除</span><br>    <span class="hljs-comment">//先找到要删除的值，还要找到它的父亲</span><br>    Node *cur = _root;<br>    Node *parent = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;_val &lt; key)<br>        &#123;<br>            parent = cur;<br>            cur = cur-&gt;_right;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_val &gt; key)<br>        &#123;<br>            parent = cur;<br>            cur = cur-&gt;_left;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//这里面就找到了</span><br>            <span class="hljs-comment">//如果删除的是根节点，左为空，或右为空，没有父亲，我们还要单独处理</span><br><br>            <span class="hljs-keyword">if</span> (cur-&gt;_left == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//左为空</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//删除的是根节点</span><br>                &#123;<br>                    _root = _root-&gt;_right;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (parent-&gt;_left == cur)<br>                    &#123;<br>                        <span class="hljs-comment">//我是父亲的左</span><br>                        <span class="hljs-comment">//父亲的左，指向我的右</span><br>                        parent-&gt;_left = cur-&gt;_right;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;_right == cur)<br>                    &#123;<br>                        parent-&gt;_right = cur-&gt;_right;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">delete</span> cur;<br>                cur = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//右为空</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    _root = _root-&gt;_left;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (parent-&gt;_left == cur)<br>                    &#123;<br>                        <span class="hljs-comment">//我是父亲的左</span><br>                        <span class="hljs-comment">//父亲的左，指向我的右</span><br>                        parent-&gt;_left = cur-&gt;_left;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;_right == cur)<br>                    &#123;<br>                        parent-&gt;_right = cur-&gt;_left;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">delete</span> cur;<br>                cur = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//都不为空</span><br>                <span class="hljs-comment">//我们用右子树的最左节点,替换法删除</span><br>                Node *node = cur-&gt;_right;<br>                Node *parent = cur;<br>                <span class="hljs-keyword">if</span> (node-&gt;_left != <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//右子树右左节点</span><br>                &#123;<br><br>                    <span class="hljs-keyword">while</span> (node-&gt;_left)<br>                    &#123;<br>                        parent = node;<br>                        node = node-&gt;_left;<br>                    &#125;<br>                    <span class="hljs-built_in">swap</span>(cur-&gt;_val, node-&gt;_val);<br>                    parent-&gt;_left = node-&gt;_right;<br>                    <span class="hljs-keyword">delete</span> node;<br>                    node = <span class="hljs-literal">nullptr</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><span class="hljs-comment">//右子树没有左节点，直接把父和它的右节点连接起来即可</span><br>                &#123;<br>                    <span class="hljs-built_in">swap</span>(cur-&gt;_val, node-&gt;_val);<br>                    parent-&gt;_right = node-&gt;_right;<br>                    <span class="hljs-keyword">delete</span> node;<br>                    node = <span class="hljs-literal">nullptr</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>递归版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Node *<span class="hljs-title">EraseR</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function"></span>&#123;<br>    _EraseR(key, _root);<br>&#125;<br><span class="hljs-type">bool</span> _EraseR(<span class="hljs-type">const</span> K &amp;key, Node *&amp;root)<br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;_val &gt; key)<br>    &#123;<br>        <span class="hljs-keyword">return</span> _EraseR(key, root-&gt;_left);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;_val &lt; key)<br>    &#123;<br>        <span class="hljs-keyword">return</span> _EraseR(key, root-&gt;_right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Node *del = root;<br>        <span class="hljs-keyword">if</span> (root-&gt;_left == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br><br>            root = root-&gt;_right;<br>        &#125;<br><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;_right == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            root = root-&gt;_left;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//左右都不为空</span><br>            <span class="hljs-comment">//找到右子树的最左边，找替代节点</span><br><br>            Node *min = root-&gt;_right;<br>            <span class="hljs-keyword">while</span> (min-&gt;_left)<br>            &#123;<br>                min = min-&gt;_left;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(min-&gt;_val, root-&gt;_val); <span class="hljs-comment">//把替代节点替换上去，后面只需要再递归的去删除交换的节点就可以了</span><br>            <span class="hljs-comment">//递归到右子树的最左节点去删除</span><br>            <span class="hljs-keyword">return</span> _EraseR(key, root-&gt;_right);<br>        &#125;<br>        <span class="hljs-keyword">delete</span> del;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="InOrder"><a href="#InOrder" class="headerlink" title="InOrder"></a>InOrder</h4><p>中序遍历，左根右<br>在类里面递归遍历，我们可以使用子函数，这样外部就不需要用类里面的私有成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//套一个子函数就可以了</span><br>    _InOrder(_root);<br>&#125;<br><br><span class="hljs-type">void</span> _InOrder(Node *root) <span class="hljs-comment">//在外面或得不到根</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    _InOrder(root-&gt;_left);<br>    cout &lt;&lt; root-&gt;_val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    _InOrder(root-&gt;_right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="KV模型"><a href="#KV模型" class="headerlink" title="KV模型"></a>KV模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>&gt;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span><br>&#123;<br>    K _key;<br>    V _val;<br>    BSTNode&lt;K,V&gt; *_left;<br>    BSTNode&lt;K,V&gt; *_right;<br>    <span class="hljs-built_in">BSTNode</span>(<span class="hljs-type">const</span> K &amp;key,<span class="hljs-type">const</span> V&amp; val)<br>        : _val(val), _right(<span class="hljs-literal">nullptr</span>), _left(<span class="hljs-literal">nullptr</span>),_key(key)<br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//比如：key是身份证，value就是票的信息，vector&lt;info&gt; _vinfo</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">V</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTree</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> BSTNode&lt;K,V&gt; Node;<br><br><span class="hljs-keyword">private</span>:<br>    Node *_root;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BSTree</span>()<br>        : _root(<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key,<span class="hljs-type">const</span> V&amp; val)</span> <span class="hljs-comment">//非线性叫做insert</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//插入重复的值，就返回失败</span><br>        <span class="hljs-keyword">if</span> (_root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            _root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key,val);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Node *cur = _root;<br>            Node *prev;<br>            <span class="hljs-keyword">while</span> (cur)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;_key &gt; key)<br>                &#123;<br>                    prev = cur;<br>                    cur = cur-&gt;_left;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_key &lt; key)<br>                &#123;<br>                    prev = cur;<br>                    cur = cur-&gt;_right;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key,val);<br>            <span class="hljs-keyword">if</span> (prev-&gt;_key &lt; key)<br>            &#123;<br>                prev-&gt;_right = cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                prev-&gt;_left = cur;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <br><br>    <span class="hljs-function">Node* <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span> <span class="hljs-comment">//查找,返回对应的节点</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *cur = _root;<br>        <span class="hljs-keyword">while</span> (cur)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;_key &gt; key)<br>            &#123;<br>                cur = cur-&gt;_left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_key &lt; key)<br>            &#123;<br>                cur = cur-&gt;_right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> cur;<span class="hljs-comment">//找到就返回对应的节点</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//没有找到就返回空</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//套一个子函数就可以了</span><br>        _InOrder(_root);<br>    &#125;<br><br>    <span class="hljs-type">void</span> _InOrder(Node *root) <span class="hljs-comment">//在外面或得不到根</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        _InOrder(root-&gt;_left);<br>        cout &lt;&lt; root-&gt;_key &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        _InOrder(root-&gt;_right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Erase</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//先查找,删除之后要保持搜索二叉树的状态</span><br>        <span class="hljs-comment">//有两个儿子，用左子树的最右节点，或者右子树的最左节点来进行替换删除</span><br>        <span class="hljs-comment">//先找到要删除的值，还要找到它的父亲</span><br>        Node *cur = _root;<br>        Node *parent = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;_key &lt; key)<br>            &#123;<br>                parent = cur;<br>                cur = cur-&gt;_right;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_key &gt; key)<br>            &#123;<br>                parent = cur;<br>                cur = cur-&gt;_left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//这里面就找到了</span><br>                <span class="hljs-comment">//如果删除的是根节点，左为空，或右为空，没有父亲，我们还要单独处理</span><br><br>                <span class="hljs-keyword">if</span> (cur-&gt;_left == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//左为空</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">nullptr</span>)<br>                    &#123;<br>                        _root = _root-&gt;_right;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (parent-&gt;_left == cur)<br>                        &#123;<br>                            <span class="hljs-comment">//我是父亲的左</span><br>                            <span class="hljs-comment">//父亲的左，指向我的右</span><br>                            parent-&gt;_left = cur-&gt;_right;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;_right == cur)<br>                        &#123;<br>                            parent-&gt;_right = cur-&gt;_right;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">delete</span> cur;<br>                    cur = <span class="hljs-literal">nullptr</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;_right == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//右为空</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">nullptr</span>)<br>                    &#123;<br>                        _root = _root-&gt;_left;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (parent-&gt;_left == cur)<br>                        &#123;<br>                            <span class="hljs-comment">//我是父亲的左</span><br>                            <span class="hljs-comment">//父亲的左，指向我的右</span><br>                            parent-&gt;_left = cur-&gt;_left;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;_right == cur)<br>                        &#123;<br>                            parent-&gt;_right = cur-&gt;_left;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">delete</span> cur;<br>                    cur = <span class="hljs-literal">nullptr</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//都不为空</span><br>                    <span class="hljs-comment">//我们用右子树的最左节点,替换法删除</span><br>                    Node *node = cur-&gt;_right;<br>                    Node *parent = cur;<br>                    <span class="hljs-keyword">if</span> (node-&gt;_left != <span class="hljs-literal">nullptr</span>)<br>                    &#123;<br><br>                        <span class="hljs-keyword">while</span> (node-&gt;_left)<br>                        &#123;<br>                            parent = node;<br>                            node = node-&gt;_left;<br>                        &#125;<br>                        <span class="hljs-built_in">swap</span>(cur-&gt;_val, node-&gt;_val);<br>                        <span class="hljs-built_in">swap</span>(cur-&gt;_key, node-&gt;_key);<br>                        parent-&gt;_left = node-&gt;_right;<br>                        <span class="hljs-keyword">delete</span> node;<br>                        node = <span class="hljs-literal">nullptr</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-built_in">swap</span>(cur-&gt;_val, node-&gt;_val);<br>                        <span class="hljs-built_in">swap</span>(cur-&gt;_key, node-&gt;_key);<br>                        parent-&gt;_right = node-&gt;_right;<br>                        <span class="hljs-keyword">delete</span> node;<br>                        node = <span class="hljs-literal">nullptr</span>;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 数据结构 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类型转换</title>
    <link href="/2022/08/24/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/08/24/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#C_1">C的类型转换</a></li><li><a href="#C_15">C++的类型转换</a></li><li><ul><li><a href="#static_cast_19">static_cast</a></li><li><a href="#reinterpreter_cast_35">reinterpreter_cast</a></li><li><a href="#const_cast_49">const_cast</a></li><li><a href="#dynamic_cast_64">dynamic_cast</a></li></ul></li><li><a href="#_125">总结</a></li></ul><h1 id="C的类型转换"><a href="#C的类型转换" class="headerlink" title="C的类型转换"></a>C的类型转换</h1><ol><li><pre><code class="hljs">隐式类型转换：在编译的时候自动就进行，不需要我们手动操作（相近类型，意义相似类型就可以）</code></pre></li><li><pre><code class="hljs">强制类型转换：需要我们自己处理</code></pre></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">demo1</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>   <span class="hljs-type">double</span> d=i;<span class="hljs-comment">//隐式类型转换</span><br>   <span class="hljs-type">int</span>* p=&amp;i;<br>   <span class="hljs-type">int</span> address=(<span class="hljs-type">int</span>)p;<span class="hljs-comment">//强制类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h1><p>C++兼容C语言，所以C++也是强类型的语言<br>C++语言为了加强类型转换的可视性，引入了4种命名的强制类型转换操作符</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>static_cast:用于两个类型之间意义相近的,不能用在两个不相关类型之间的转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//C++语言为了加强类型转换的可视性，引入了4种命名的强制类型转换操作符</span><br>    <span class="hljs-comment">//static_cast:用于两个类型之间意义相近的,不能用在两个不相关类型之间的转换</span><br><br>    <span class="hljs-type">double</span> d=<span class="hljs-number">1.22</span>;<br>    <span class="hljs-type">int</span> a=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt; (d);<span class="hljs-comment">//里面写的是要转化到的类型</span><br>    cout&lt;&lt;a&lt;&lt;endl;<br><br>    <span class="hljs-comment">// int* p=static_cast&lt;int*&gt; (a);//int和int* 之间类型不相近，所以不能转换</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reinterpreter-cast"><a href="#reinterpreter-cast" class="headerlink" title="reinterpreter_cast"></a>reinterpreter_cast</h2><p>reinterpret_cast:用于两个不相关类型之间的转换,但是不能用在两个类型相近之间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//reinterpret_cast:用于两个不相关类型之间的转换</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>* p=<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt; (a);<br>    <span class="hljs-type">double</span> d=<span class="hljs-number">2.2</span>;<br>    <span class="hljs-comment">// int x=reinterpret_cast&lt;int&gt;(d);//这个不能用在两个相近类型之间的转换</span><br>    <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;endl;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>const_cast就是把原来一个const属性的变量去除了const属性,方便赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//const_cast就是把原来一个const属性的变量去除了const属性,方便赋值</span><br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<span class="hljs-comment">//保持内存的可见性,告诉编译器不要优化，每次都到内存里面取数据</span><br>    <span class="hljs-type">int</span>* p=<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt; (&amp;a);<br>    *p=<span class="hljs-number">2</span>;<br>    cout&lt;&lt;a&lt;&lt;endl;<span class="hljs-comment">//打印出来还是10，</span><br>    cout&lt;&lt;*p&lt;&lt;endl;<span class="hljs-comment">//这个是2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>dynamic_cast :主要用于向下转换：父类对象指针&#x2F;引用———&gt;&gt;子类指针&#x2F;引用（dynamic_cast是安全的）</p><ul><li>使用的时候，父类对象必须包含虚函数</li><li>失败的时候返回nullptr，说明原来对象为父类对象</li><li>成功，就能讲父类对象转换成子类对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> x;<br>    <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A* pa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果pa是指向父类对象，就不做处理</span><br>    <span class="hljs-comment">//如果pa是指向子类对象，就把它转回子类，并访问子类对象中的_b成员</span><br>    <span class="hljs-comment">// B* pb1=static_cast&lt;B*&gt; (pa);//父类能转成功，子类也能转成功</span><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;pb1=&quot;&lt;&lt;pb1&lt;&lt;endl;</span><br><br>    <span class="hljs-comment">//这个时候dynamic_cast就能用了，可以用来识别指向父类对象还是子类对象</span><br><br>    <span class="hljs-comment">//只能用于包含虚函数的类</span><br><br>    B* pb2=<span class="hljs-built_in">dynamic_cast</span>&lt;B*&gt; (pa);<br>    <span class="hljs-keyword">if</span>(pb2==<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">//如果是指向nullptr，说明pa指向的是父类对象，转换不成功,返回nullptr</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;转换失败&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;转换成功&quot;</span>&lt;&lt;endl;<br>        pb2-&gt;m=<span class="hljs-number">10</span>;<br><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//dynamic_cast :主要用于向下转换：父类对象指针/引用——————&gt;&gt;子类指针/引用（用dynamic_cast是安全的）</span><br>    <span class="hljs-comment">//向上转换：子类给父类（赋值兼容性规则，不需要转换）</span><br>    A a;<br>    B b;<br>    a=b;<span class="hljs-comment">//子给父，是天然可以的</span><br>    <span class="hljs-comment">// b=a;//父给自，是不行的，</span><br>    <span class="hljs-built_in">func</span>(&amp;a);<br>    <span class="hljs-built_in">func</span>(&amp;b);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>去const属性用const_cast</li><li>基本类型转换用static_cast</li><li>多态类之间的类型转换用dynamic_cast</li><li>不同类型的指针类型转换用reinterpret_cast</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ java 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2022/08/23/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2022/08/23/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#C98_3">C++98的智能指针</a></li><li><ul><li><a href="#auto_ptr_4">auto_ptr的模拟实现</a></li></ul></li><li><a href="#C11_73">C++11的智能指针</a></li><li><ul><li><a href="#_74">定制删除器</a></li><li><a href="#unique_ptr_87">unique_ptr的模拟实现</a></li><li><a href="#shared_ptr_192">shared_ptr的模拟实现</a></li><li><a href="#weak_ptr_429">weak_ptr</a></li></ul></li></ul><p>为了解决指针资源忘记或没有删除导致的内存泄露问题，C++就出现了智能指针的机制，可以在使用的时候初始化，在离开作用域之后就自动析构，删除资源</p><h1 id="C-98的智能指针"><a href="#C-98的智能指针" class="headerlink" title="C++98的智能指针"></a>C++98的智能指针</h1><h2 id="auto-ptr的模拟实现"><a href="#auto-ptr的模拟实现" class="headerlink" title="auto_ptr的模拟实现"></a>auto_ptr的模拟实现</h2><p>auto_ptr是最早期的智能指针形态，<br>它可以实现在</p><ul><li>构造函数里面初始化</li><li>在析构函数里面将资源销毁，不用我们去显示调用，避免内存泄露</li><li>但是它无法解决拷贝构造的问题,它是浅拷贝（会造成资源被多次析构）（使用管理权转移的方式来进行拷贝构造即构造之后，自己的资源就没了）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> xzw<br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_ptr</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        T *_ptr;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">//在构造函数</span><br>        <span class="hljs-built_in">auto_ptr</span>(T *ptr)<br>            : _ptr(ptr) <span class="hljs-comment">//原生指针支持拷贝</span><br>        &#123;<br>        &#125;<br>        ~<span class="hljs-built_in">auto_ptr</span>()<br>        &#123;<br>            <span class="hljs-keyword">if</span> (_ptr)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;delete&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">delete</span> _ptr; <span class="hljs-comment">//析构函数把他清理</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//如何解决拷贝问题,管理权转移，只有一个人析构它</span><br>        <span class="hljs-built_in">auto_ptr</span>(auto_ptr&lt;T&gt; &amp;sp)<br>            : _ptr(sp._ptr)<br>        &#123;<br>            <span class="hljs-comment">//资源转给你，</span><br>            <span class="hljs-comment">//把管理权转移</span><br>            sp._ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//自己置成空,自己没了，</span><br>        &#125;<br><br>        T &amp;<span class="hljs-keyword">operator</span>*()<br>        &#123;<br>            <span class="hljs-keyword">return</span> *_ptr;<br>        &#125;<br>        T *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-comment">//返回原生指针即可</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> _ptr;<br>        &#125;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    <span class="hljs-function">xzw::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(p1)</span></span>; <span class="hljs-comment">//拷贝构造,出了作用域就调用他们的析构函数,抛异常的话也会出作用域，也就自动调用析构函数，</span><br>    <span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    <span class="hljs-function">xzw::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;     <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-function">xzw::auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">//直接用new出来的资源给它</span><br>    *sp3 = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; __LINE__ &lt;&lt; *sp3 &lt;&lt; endl;<br>    cout &lt;&lt; *sp1 &lt;&lt; endl; <span class="hljs-comment">//出现空指针问题</span><br>    <span class="hljs-comment">//希望能够像指针一样使用，重载以下operator*</span><br><br>    <span class="hljs-comment">//结论就是auto_ptr是一个失败的设计.很多公司明确要求不能使用auto_ptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际工作中<strong>绝对不能使用auto_ptr</strong></p><h1 id="C-11的智能指针"><a href="#C-11的智能指针" class="headerlink" title="C++11的智能指针"></a>C++11的智能指针</h1><h2 id="定制删除器"><a href="#定制删除器" class="headerlink" title="定制删除器"></a>定制删除器</h2><p>默认情况下，智能指针底层的删除器都是用delete<br>但是不同的资源销毁的方式不同，直接用delete十分暴力，不合理，所以就有了定制删除器</p><p>比如:</p><ul><li>malloc -&gt; free</li><li>open -&gt; close</li><li>fopen -&gt; fclose</li><li>new[] -&gt; delete[]<br>…</li></ul><p>我们在下文会详细解释</p><h2 id="unique-ptr的模拟实现"><a href="#unique-ptr的模拟实现" class="headerlink" title="unique_ptr的模拟实现"></a>unique_ptr的模拟实现</h2><p><strong>unique_ptr对于拷贝构造的解决方式即直接把拷贝构造给禁止了</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> Uni_Ptr<br>&#123;<br><br>        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">defult_delete</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T* ptr)</span></span><br><span class="hljs-function">        </span>&#123;<br>            cout&lt;&lt;__LINE__&lt;&lt;endl;<br>            cout&lt;&lt;<span class="hljs-string">&quot;delete&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">delete</span> ptr;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>=default_delete&lt;T&gt;&gt;<span class="hljs-comment">//默认释放这个类型,在模板里面调用的不是仿函数,而是对应的类型</span><br><br>    <span class="hljs-comment">//原理简单粗暴，——防拷贝，直接不让你拷贝</span><br>    <span class="hljs-keyword">class</span> unique_ptr<br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        T *_ptr;<br>        <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&lt;T&gt; &amp;sp) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">//直接把它拷贝给弄掉</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">//在构造函数</span><br>        <span class="hljs-built_in">unique_ptr</span>(T *ptr)<br>            : _ptr(ptr) <span class="hljs-comment">//原生指针支持拷贝</span><br>        &#123;<br>        &#125;<br>        ~<span class="hljs-built_in">unique_ptr</span>()<br>        &#123;<br>            <span class="hljs-keyword">if</span> (_ptr)<br>            &#123;<br>                <span class="hljs-comment">// cout &lt;&lt; &quot;delete&quot; &lt;&lt; endl;</span><br>                <span class="hljs-comment">// delete _ptr; //析构函数把他清理</span><br>                D del;<br>                <span class="hljs-built_in">del</span>(_ptr);<span class="hljs-comment">//默认的情况就是用default_delete,</span><br>            &#125;<br>        &#125;<br><br>        T &amp;<span class="hljs-keyword">operator</span>*()<br>        &#123;<br>            <span class="hljs-keyword">return</span> *_ptr;<br>        &#125;<br>        T *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-comment">//返回原生指针即可</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> _ptr;<br>        &#125;<br>    &#125;;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Uni_Ptr::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-comment">// Uni_Ptr::unique_ptr&lt;int&gt; sp2(sp1);</span><br>    <span class="hljs-comment">// std::unique_ptr&lt;int&gt; sp(sp1);//不支持拷贝构造</span><br>&#125;<br></code></pre></td></tr></table></figure><p>unique_ptr对于定制删除器的使用，就是我们在外面写一个类的仿函数，在模板里面进行传参即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DeleteArray</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T *ptr)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;delete[]&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span>[] ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DeleteFile</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE *ptr)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fclose:&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">fclose</span>(ptr);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo6</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定制删除器</span><br>    <span class="hljs-comment">//默认情况下，智能指针在底层都是用delete</span><br>    <span class="hljs-comment">//那么如果不是new 出来，如new[],malloc,fopen</span><br>    <span class="hljs-comment">//unque_ptr是在类的模板参数里面（类型）</span><br>    <span class="hljs-function">Uni_Ptr::unique_ptr&lt;Date&gt; <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Date)</span></span>;<br>    Uni_Ptr::unique_ptr&lt;Date, DeleteArray&lt;Date&gt;&gt; <span class="hljs-built_in">s1</span>(<span class="hljs-keyword">new</span> Date[<span class="hljs-number">10</span>]); <span class="hljs-comment">//我们可以显示定制删除器</span><br>    <span class="hljs-function">Uni_Ptr::unique_ptr&lt;FILE,DeleteFile&gt; <span class="hljs-title">s2</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;1.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>))</span></span>;<span class="hljs-comment">//我们这里用fopen,要自己特制一个删除器</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shared-ptr的模拟实现"><a href="#shared-ptr的模拟实现" class="headerlink" title="shared_ptr的模拟实现"></a>shared_ptr的模拟实现</h2><p>shared_ptr是为了解决unique_ptr无法实现拷贝构造<br>新增加了一个引用计数的机制:</p><blockquote><p>同一个对象只能有一个引用计数，当调用构造函数的时候，第一个引用计数出现为1，后续如果有发生拷贝构造，引用计数就+1，当析构的时候，引用计数就-1，直到引用计数为0的时候，这个资源就销毁</p></blockquote><blockquote><p>即由最后一个管理的对象来进行对资源的释放</p></blockquote><ul><li>智能指针是线程安全的，因为对里面的引用计数进行了加锁处理，但是指向的资源不是线程安全的，这个需要使用者手动处理</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> Shared_Ptr<br>&#123;<br>    <span class="hljs-comment">//我们要实现定制删除器</span><br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">defult_delete</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T* ptr)</span></span><br><span class="hljs-function">        </span>&#123;<br>            cout&lt;&lt;__LINE__&lt;&lt;endl;<br>            <span class="hljs-keyword">delete</span> ptr;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>=default_delete&lt;T&gt;&gt;<span class="hljs-comment">//默认释放这个类型,在模板里面调用的不是仿函数,而是对应的类型</span><br>    <span class="hljs-keyword">class</span> shared_ptr<br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        T *_ptr;<br>        <span class="hljs-comment">// static int _refcout; //这样就只有一个了,属于所有对象共享,但是要在类外面初始化，所以我们应该一个资源配一个引用计数，因为static是属于类的</span><br>        <span class="hljs-type">int</span> *_pRefCount; <span class="hljs-comment">//这个就是引用计数,凡是用浅拷贝都是要用引用计数，才能搞定这个东西</span><br>        <span class="hljs-comment">//一个引用计数就要管理一个锁</span><br>        mutex *_mtx; <span class="hljs-comment">// 这样就可以访问同一个锁</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">//在构造函数,调用一次构造函数引用计数就加1</span><br>        <span class="hljs-built_in">shared_ptr</span>(T *ptr)<br>            : _ptr(ptr), _pRefCount(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>)), _mtx(<span class="hljs-keyword">new</span> mutex) <span class="hljs-comment">//原生指针支持拷贝,用指针，不同的人就可以指向同一个资源</span><br><br>        &#123;<br>            <span class="hljs-comment">//只有第一个人会调用构造函数</span><br>            <span class="hljs-comment">// _refcout=1;//就为1,管理不同的资源就会把别人的给修改了,</span><br>        &#125;<br><br>        <span class="hljs-built_in">shared_ptr</span>(<span class="hljs-type">const</span> shared_ptr&lt;T&gt; &amp;sp)                           <span class="hljs-comment">//调用拷贝构造</span><br>            : _ptr(sp._ptr), _pRefCount(sp._pRefCount), _mtx(sp._mtx) <span class="hljs-comment">//引用计数也拷贝过去</span><br>        &#123;<br>            <span class="hljs-comment">// ++_refcout;</span><br>            <span class="hljs-comment">// ++(*_pRefCount); //因为是同一个资源，所以就可以对它进行++，</span><br>            <span class="hljs-built_in">AddRef</span>();<br>        &#125;<br>        ~<span class="hljs-built_in">shared_ptr</span>()<br>        &#123;<br>            <span class="hljs-built_in">Release</span>();<br>        &#125;<br>        <span class="hljs-function">T *<span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _ptr;<br>        &#125;<br>        <span class="hljs-comment">//如何解决拷贝问题,管理权转移，只有一个人析构它</span><br><br>        T &amp;<span class="hljs-keyword">operator</span>*()<br>        &#123;<br>            <span class="hljs-keyword">return</span> *_ptr;<br>        &#125;<br>        T *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-comment">//返回原生指针即可</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> _ptr;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            _mtx-&gt;<span class="hljs-built_in">lock</span>();<br>            <span class="hljs-comment">//管理临界区</span><br>            (*_pRefCount)--; <span class="hljs-comment">//析构的时候，把引用计数--</span><br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (!(*_pRefCount) &amp;&amp; _ptr)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;delete&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">delete</span> _ptr; <span class="hljs-comment">//析构函数把他清理</span><br>                <span class="hljs-keyword">delete</span> _pRefCount;<br>                _ptr = <span class="hljs-literal">nullptr</span>;<br>                _pRefCount = <span class="hljs-literal">nullptr</span>;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// delete是把原来对应的空间给释放掉,但是对应的指针还在堆区里面，所以还能用</span><br>            &#125;<br>            _mtx-&gt;<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">if</span> (flag)<br>            &#123;<br>                <span class="hljs-keyword">delete</span> _mtx;<br>                _mtx = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddRef</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            _mtx-&gt;<span class="hljs-built_in">lock</span>();<br>            (*_pRefCount)++;<br>            _mtx-&gt;<span class="hljs-built_in">unlock</span>();<br>        &#125;<br>        shared_ptr&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> shared_ptr&lt;T&gt; &amp;sp) <span class="hljs-comment">//这个就牵扯到两个资源，</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (_ptr != sp._ptr) <span class="hljs-comment">//自己给自己赋值</span><br>            &#123;<br>                <span class="hljs-comment">//原来的引用计数减一</span><br>                <span class="hljs-built_in">Release</span>();<br>                _ptr = sp._ptr;             <span class="hljs-comment">// delete之后指针还在，指向不同的空间就行了</span><br>                _pRefCount = sp._pRefCount; <span class="hljs-comment">//现在引用计数也要和其相等</span><br>                _mtx = sp._mtx;<br>                <span class="hljs-built_in">AddRef</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br>    &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Shared_Ptr::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function">Shared_Ptr::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(sp)</span></span>;<br>    <span class="hljs-function">Shared_Ptr::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp)</span></span>;<br>    <span class="hljs-function">Shared_Ptr::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(sp)</span></span>;<br>    <span class="hljs-function">Shared_Ptr::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>))</span></span>; <span class="hljs-comment">//这样就可以做到构造的对象就只析构一次</span><br>    sp1 = sp4;<br>    sp2 = sp4;<br>    sp = sp4;<br>    <span class="hljs-comment">// sp3=sp4;</span><br><br>    <span class="hljs-comment">//指向的堆上资源的线程安全的问题是访问的人处理的，智能指针不管</span><br>    <span class="hljs-comment">//引用计数的线程安全问题是智能指针要处理的</span><br><br>    *sp4 = <span class="hljs-number">3</span>;<br>    *sp = <span class="hljs-number">4</span>;<br><br>    cout &lt;&lt; (*sp3) &lt;&lt; endl;<br>    cout &lt;&lt; __LINE__ &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Date</span><br>&#123;<br>    <span class="hljs-type">int</span> _year = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> _month = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> _day = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SharePtreFunc</span><span class="hljs-params">(Shared_Ptr::shared_ptr&lt;Date&gt; &amp;sp, <span class="hljs-type">size_t</span> n, mutex &amp;mtx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-function">Shared_Ptr::shared_ptr&lt;Date&gt; <span class="hljs-title">copy</span><span class="hljs-params">(sp)</span></span>;<br>        <span class="hljs-comment">//访问临界资源，加锁</span><br><br>        &#123;<br>            <span class="hljs-comment">//这里我们可以括一个匿名域</span><br>            <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">//这个支持中间解锁</span><br><br>            copy-&gt;_day++;<br>            copy-&gt;_month++;<br>            copy-&gt;_year++;<br>            <span class="hljs-comment">//或者unlock</span><br>            lock.<span class="hljs-built_in">unlock</span>();<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//这个我不想管它的线程安全</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//智能指针是线程安全的</span><br><span class="hljs-comment">//因为引用计数的加减都是加锁保护的，但是指向的资源不是线程安全的，要我们自己手动处理</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Shared_Ptr::shared_ptr&lt;Date&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Date)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> n = <span class="hljs-number">10000000</span>;<br>    mutex mtx;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(SharePtreFunc, std::ref(p), n, std::ref(mtx))</span></span>; <span class="hljs-comment">//这样就有线程安全问题,两个线程同时去++，就会有问题，</span><br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(SharePtreFunc, std::ref(p), n, std::ref(mtx))</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; p-&gt;_day &lt;&lt; endl;<br>    cout &lt;&lt; p-&gt;_month &lt;&lt; endl;<br>    cout &lt;&lt; p-&gt;_year &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>shared_ptr对于定制删除器的使用:就是在构造函数的时候加上，该可调用对象（函数指针，仿函数，lambda表达式）<br>使用lambda表达式最方便</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DeleteArray</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T *ptr)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;delete[]&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span>[] ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DeleteFile</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE *ptr)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fclose:&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">fclose</span>(ptr);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo6</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><br>    <span class="hljs-comment">//删除器在构造函数里面给对象</span><br>    <span class="hljs-function">std::shared_ptr&lt;Date&gt; <span class="hljs-title">srp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Date)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Date&gt; <span class="hljs-title">srp4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Date[<span class="hljs-number">10</span>],DeleteArray&lt;Date&gt;())</span></span>;<br>    <br>    <span class="hljs-comment">//使用lambda表达式就更加方便了</span><br><br>    <span class="hljs-function">std::shared_ptr&lt;Date&gt; <span class="hljs-title">srp3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Date[<span class="hljs-number">10</span>],[](Date* ptr)&#123;cout&lt;&lt;<span class="hljs-string">&quot;delete []&quot;</span>&lt;&lt;endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">delete</span>[] ptr;&#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::shared_ptr&lt;FILE&gt; <span class="hljs-title">srp1</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;1.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>),DeleteFile())</span></span>;<span class="hljs-comment">//在构造函数里面传删除器</span><br>    <span class="hljs-function">std::shared_ptr&lt;FILE&gt; <span class="hljs-title">srp2</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;1.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>),[](FILE* ptr)&#123;fclose(ptr);&#125;)</span></span>;<span class="hljs-comment">//在构造函数里面传删除器</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>shared_ptr会出现循环引用的问题<br>一个指针，你里面有一个智能指针，指向我，我里面有一个智能指针指向你，这就是循环引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> _val;<br><br>     shared_ptr&lt;ListNode&gt; _prev;<br>     shared_ptr&lt;ListNode&gt; _next;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;ListNode&gt; <span class="hljs-title">n1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ListNode)</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;ListNode&gt; <span class="hljs-title">n2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ListNode)</span></span>;<br>    cout &lt;&lt; n1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; n2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//这样就能解决循环引用的问题,一个指针，你里面有一个智能指针，指向我，我里面有一个智能指针指向你，这就是循环引用</span><br><br>     n1-&gt;_prev=n2;<span class="hljs-comment">//这样子会增加引用计数</span><br>     n2-&gt;_next=n1;<br>    cout &lt;&lt; n1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; n2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子会出现问题</p><p>weak_ptr是一个弱指针，没有引用计数的机制，可以支持shared_ptr对它进行拷贝构造和赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">weak_ptr</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        T *_ptr;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">weak_ptr</span>()<br>            : _ptr(<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>        &#125;<br>        <span class="hljs-built_in">weak_ptr</span>(<span class="hljs-type">const</span> shared_ptr&lt;T&gt; &amp;sp)<br>            : _ptr(sp.<span class="hljs-built_in">get</span>())<br>        &#123;<br>        &#125;<br>        weak_ptr&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> shared_ptr&lt;T&gt; &amp;sp)<br>        &#123;<br>            _ptr = sp.<span class="hljs-built_in">get</span>();<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> _val;<br>    Shared_Ptr::weak_ptr&lt;ListNode&gt; _prev; <span class="hljs-comment">//弱指针,不增加引用计数,只是可以访问指向的节点资源，但是不参与节点资源的释放管理,</span><br>    Shared_Ptr::weak_ptr&lt;ListNode&gt; _next;<br>    <br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;ListNode&gt; <span class="hljs-title">n1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ListNode)</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;ListNode&gt; <span class="hljs-title">n2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ListNode)</span></span>;<br>    cout &lt;&lt; n1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; n2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//这样就能解决循环引用的问题,一个指针，你里面有一个智能指针，指向我，我里面有一个智能指针指向你，这就是循环引用</span><br><br>     n1-&gt;_prev=n2;<br>     n2-&gt;_next=n1;<br>    cout &lt;&lt; n1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; n2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一点：如果使用对象的话，就要用强指针，如果要引用一个对象的话，就要用弱指针<br>即weak_ptr不会参与空间资源的管理，只是作为一个解决循环引用的工具</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++包装器</title>
    <link href="/2022/08/22/C++%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    <url>/2022/08/22/C++%E5%8C%85%E8%A3%85%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">概述</a></li><li><a href="#function_9">function</a></li><li><ul><li><a href="#function_10">function的使用</a></li><li><ul><li><a href="#_14">仿函数</a></li><li><a href="#Lambda_32">Lambda表达式</a></li><li><a href="#_44">函数指针</a></li><li><a href="#_62">类成员函数</a></li></ul></li><li><a href="#function_95">function的实战</a></li></ul></li><li><a href="#bind_182">bind</a></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>包装器可以对一个可调用对象进行包装<br>可调用对象包括</p><ul><li>lambda表达式</li><li>仿函数</li><li>函数指针</li></ul><p>使用包装器可以避免模板实例化出多份代码，可以提高效率</p><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="function的使用"><a href="#function的使用" class="headerlink" title="function的使用"></a>function的使用</h2><p>function可以使用构造函数进行初始化，也能用赋值进行初始化<br>function&lt; ( …)&gt;:function括号里面就是包装的函数的类型对应的参数类型，括号外面就是函数的返回值</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Functor</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span> i)</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> i / <span class="hljs-number">2</span>;<br>   &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> m=<span class="hljs-number">10.1</span>;<br>function&lt;<span class="hljs-type">double</span>(<span class="hljs-type">double</span>)&gt; f2 = <span class="hljs-built_in">Functor</span>(); <span class="hljs-comment">//仿函数对象</span><br>cout&lt;&lt;<span class="hljs-built_in">f2</span>(m)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> m=<span class="hljs-number">10.1</span>;<br>function&lt;<span class="hljs-type">double</span>(<span class="hljs-type">double</span>)&gt; f2 = [](<span class="hljs-type">double</span> i)&#123;<span class="hljs-keyword">return</span> i/<span class="hljs-number">2</span>;&#125;;<span class="hljs-comment">//Lambda表达式</span><br>cout&lt;&lt;<span class="hljs-built_in">f2</span>(m)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    x+=<span class="hljs-number">2</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;222&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">2</span>;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>&amp;)&gt; s=l;<br>    <span class="hljs-built_in">s</span>(x);<br>    cout&lt;&lt;x&lt;&lt;endl;<br>    <span class="hljs-comment">// cout&lt;&lt;ret&lt;&lt;endl;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plus</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">fI</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> x;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> i)</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> i / <span class="hljs-number">2</span>;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//只要是成员函数就要加&amp;</span><br>   function&lt;<span class="hljs-type">double</span>(<span class="hljs-type">double</span>)&gt; f3 = &amp;Plus::fI; <span class="hljs-comment">//静态的成员函数</span><br>   <span class="hljs-comment">//还可以包装成员函数</span><br>   cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">10</span>) &lt;&lt; endl;<br>   <span class="hljs-comment">//对于非静态的成员函数</span><br>   function&lt;<span class="hljs-type">double</span>(Plus, <span class="hljs-type">double</span>)&gt; ff = &amp;Plus::f; <span class="hljs-comment">//非静态的成员函数要多加一个Plus，因为有this指针</span><br>   cout &lt;&lt; <span class="hljs-built_in">ff</span>(<span class="hljs-built_in">Plus</span>(), <span class="hljs-number">123</span>) &lt;&lt; endl;<span class="hljs-comment">//使用的时候要多添加一个类对象（可以是匿名对象）</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="function的实战"><a href="#function的实战" class="headerlink" title="function的实战"></a>function的实战</h2><p>逆波兰表达式</p><blockquote><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、_、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>注意 两个整数之间的除法只保留整数部分。<br>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br>示例 1：<br>输入：tokens &#x3D; [“2”,“1”,“+”,“3”,”_“]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：<br>输入：tokens &#x3D; [“4”,“13”,“5”,”&#x2F;“,”+“]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：<br>输入：tokens &#x3D; [“10”,“6”,“9”,“3”,”+“,”-11”,“_“,”&#x2F;“,”_”,“17”,“+”,“5”,“+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>= ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>= ((10 * (6 &#x2F; -132)) + 17) + 5<br>= ((10 * 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p></blockquote><blockquote><p>题解：如果是操作数就入栈，如果是操作符，就把栈顶的两个数取出来进行处理</p></blockquote><blockquote><p>我们可以使用map，命令和函数可以进行映射，映射到的为function，因为function对于函数指针，lambda表达式，仿函数都可以包装，所以就可以了，一个命令对应一个函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt; &amp;tokens)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//使用列表初始化</span><br>        <span class="hljs-comment">//包装器，只要是可调用对象就行了,很方便</span><br>        <span class="hljs-comment">//使用包装器之后就能用函数映射了</span><br><br>        map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; opMapFunc; <span class="hljs-comment">//动作和函数映射的map</span><br><br>        <span class="hljs-comment">//命令增加了只需要加这个map这里,一个命令对应一个函数</span><br><br>        opMapFunc[<span class="hljs-string">&quot;+&quot;</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        &#123; <span class="hljs-keyword">return</span> a + b; &#125;; <span class="hljs-comment">//包装器，初始化用函数指针，仿函数，lambda表达式</span><br>        opMapFunc[<span class="hljs-string">&quot;-&quot;</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        &#123; <span class="hljs-keyword">return</span> a - b; &#125;; <span class="hljs-comment">//包装器，初始化用函数指针，仿函数，lambda表达式</span><br>        opMapFunc[<span class="hljs-string">&quot;*&quot;</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        &#123; <span class="hljs-keyword">return</span> a * b; &#125;; <span class="hljs-comment">//包装器，初始化用函数指针，仿函数，lambda表达式</span><br>        opMapFunc[<span class="hljs-string">&quot;/&quot;</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        &#123; <span class="hljs-keyword">return</span> a / b; &#125;; <span class="hljs-comment">//包装器，初始化用函数指针，仿函数，lambda表达式</span><br><br>        <span class="hljs-comment">//也可以用列表初始化</span><br><br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> top;<br>        <span class="hljs-comment">//逆波兰表达式，一个命令和一个函数的映射关系就可以用包装器来解决</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            string &amp;str = tokens[i]; <span class="hljs-comment">//用别名弄，减少了拷贝</span><br>            <span class="hljs-comment">// str为操作数</span><br>            <span class="hljs-comment">// map里面为操作数就找不到</span><br>            <span class="hljs-keyword">if</span> (opMapFunc.<span class="hljs-built_in">find</span>(str) == opMapFunc.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                <span class="hljs-comment">//说明就是操作数</span><br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(str)); <span class="hljs-comment">//入栈</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//这里就是操作符</span><br>                <span class="hljs-type">int</span> left = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> right = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//取出来了数据</span><br>                s.<span class="hljs-built_in">push</span>(opMapFunc[str](left, right));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><ol><li><pre><code class="hljs">bind可以对function绑定的函数调整参数的顺序</code></pre></li><li><pre><code class="hljs">bind可以调整参数的个数（比如将包装之后的函数固定一个参数为某个东西，就不需要我们再手动去添加）</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// bind也是一个函数包装器</span><br><span class="hljs-comment">//接收一个可调用对象，生成一个可调用对象</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">subber</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f = sub;<br>    cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br><br>    <span class="hljs-comment">//调整参数的顺序</span><br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f1 = <span class="hljs-built_in">bind</span>(sub,placeholders::_1,placeholders::_2);<span class="hljs-comment">//这个就是啥都没做</span><br>    cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f3 = <span class="hljs-built_in">bind</span>(sub,placeholders::_2,placeholders::_1);<span class="hljs-comment">//参数顺序调换了</span><br>    <span class="hljs-comment">//这里的_1就是把原来的第一个参数换到现在的位置,_2就是把原来的第2个参数换到现在的第一个</span><br><br>    <span class="hljs-comment">//这个就是可以把库里面的用的不习惯的函数，切换参数顺序</span><br><br>    <span class="hljs-comment">//主要是通过绑定来进行调整参数个数</span><br><br><br>    cout &lt;&lt; <span class="hljs-built_in">f3</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br>    function&lt;<span class="hljs-type">int</span>(subber,<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f4 = &amp;subber::Sub;<br>    cout &lt;&lt; <span class="hljs-built_in">f4</span>(<span class="hljs-built_in">subber</span>(),<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<span class="hljs-comment">//使用了用还要加一个对象</span><br>    <span class="hljs-comment">//每次都这样用很烦</span><br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f5 = <span class="hljs-built_in">bind</span>(&amp;subber::Sub,<span class="hljs-built_in">subber</span>(),placeholders::_1,placeholders::_2);<span class="hljs-comment">//这样子进行绑定，第一个参数就绑死了，使用的时候就不需要再去添加</span><br>    cout &lt;&lt; <span class="hljs-built_in">f5</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br><br>    <span class="hljs-comment">//假如说第一个参数都是一样的</span><br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; f6=<span class="hljs-built_in">bind</span>(&amp;subber::Sub,<span class="hljs-built_in">subber</span>(),<span class="hljs-number">100</span>,placeholders::_1);<span class="hljs-comment">//第一个参数都是100</span><br>    cout&lt;&lt;<span class="hljs-built_in">f6</span>(<span class="hljs-number">20</span>)&lt;&lt;endl;<br>    <span class="hljs-comment">//这里也能用auto进行接收</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><br><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()=<span class="hljs-keyword">default</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    x += <span class="hljs-number">2</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;222&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ll</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    x += <span class="hljs-number">2</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;222&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span> &amp;)&gt;&gt; lll = &#123;<br>        &#123;X, <span class="hljs-built_in">bind</span>(&amp;A::ll,<span class="hljs-built_in">A</span>(), placeholders::_1)&#125;,<br>        &#123;<span class="hljs-number">2</span>, <span class="hljs-built_in">bind</span>(&amp;A::l,<span class="hljs-built_in">A</span>() ,placeholders::_1)&#125;&#125;;<br>    lll[X](m);<span class="hljs-comment">//映射包装器与bind，可以使得我们在用的时候，对类立案的参数就不要写了</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ thread库</title>
    <link href="/2022/08/20/C++%20thread%E5%BA%93/"/>
    <url>/2022/08/20/C++%20thread%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#thread_3">thread</a></li><li><ul><li><a href="#_4">构造函数</a></li><li><ul><li><a href="#_20">函数指针</a></li><li><a href="#Lambda_44">Lambda表达式</a></li><li><a href="#_98">仿函数</a></li></ul></li><li><a href="#_115">拷贝构造</a></li><li><a href="#_121">赋值重载</a></li><li><a href="#id_150">获取id</a></li><li><a href="#sleep_169">sleep</a></li><li><a href="#joindetach_174">join和detach</a></li><li><a href="#_200">引用与传参</a></li></ul></li><li><a href="#atomic_231">atomic</a></li><li><a href="#mutex_290">mutex</a></li><li><ul><li><a href="#lock_guard_327">lock_guard</a></li><li><a href="#unique_lock_358">unique_lock</a></li></ul></li><li><a href="#cond_variable_427">cond_variable</a></li></ul><p>C++11中提供了thread线程库，它本质上和pthread库差不多，只不过被封装了,同时它还是可以跨平台的</p><h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">thread</span>() <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread</span> <span class="hljs-params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><ol><li>无参构造就只是开一个线程，但是不会工作,不会执行</li><li>thread的第一个元素是可调用对象</li></ol><ul><li>lambda表达式</li><li>函数指针</li><li>类对象的仿函数</li></ul><ol start="3"><li>后面的是可变参数列表，可以传入任意的参数</li><li>第一个参数是一个模板参数，所以它是万能引用，既可以传左值也可以传右值</li></ol></blockquote><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//线程函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;x&lt;&lt;y&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threads</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//线程库</span><br>    thread t1;<span class="hljs-comment">//这里可以创建一个无参的，即线程不执行</span><br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(print, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//第一个参数因为是模板，所以它是一个万能引用，func它不一定是一个函数，可调用对象就可以了，即可以传左值也可以传右值</span><br>    <span class="hljs-comment">//第二个参数是可变的模板参数，可以传0-n个参数</span><br>    <span class="hljs-comment">//第一个可以</span><br>    t2.<span class="hljs-built_in">join</span>();<span class="hljs-comment">//这和c的线程库也是一样的</span><br>    <br>    <span class="hljs-comment">//不像c语言要使用一个结构体传进去，</span><br>    <span class="hljs-comment">//原来在c语言我们是使用线程id来控制这些线程的</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">([]()&#123;cout&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>&lt;&lt;endl;&#125;)</span></span>;<span class="hljs-comment">//使用lambda表达式进行传参</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    mutex mtx;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br>    <span class="hljs-function">atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">costtime1</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]</span></span><br><span class="hljs-params"><span class="hljs-function">              &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> begin1 = clock();</span></span><br><span class="hljs-params"><span class="hljs-function">        mtx.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            x++;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        mtx.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> end1 = clock();</span></span><br><span class="hljs-params"><span class="hljs-function">        costtime1 += (end1 - begin1);</span></span><br><span class="hljs-params"><span class="hljs-function">        cout&lt;&lt;costtime1&lt;&lt;endl;&#125;)</span></span>;<span class="hljs-comment">//lambda表达式可以去处理一些小函数</span><br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; costtime1 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// costtime1就是调用花费的时间 &#125;); //这里用一个可调用对象就可以了，我们这里用lambda表达式，&amp;全部捕获 &#125;); &#125;);</span><br>    <span class="hljs-comment">//项目里面，我们还是用原子的，相对更好一点</span><br><br>    <span class="hljs-type">int</span> costtime2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]</span></span><br><span class="hljs-params"><span class="hljs-function">              &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> begin2 = clock();</span></span><br><span class="hljs-params"><span class="hljs-function">        mtx.lock();</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">                  &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                      x++;</span></span><br><span class="hljs-params"><span class="hljs-function">                  &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        mtx.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> end2 = clock();</span></span><br><span class="hljs-params"><span class="hljs-function">                  costtime2 = end2 - begin2; &#125;)</span></span>; <span class="hljs-comment">// costtime1就是调用花费的时间 &#125;);</span><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; costtime1 &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Func</span><br>&#123;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot;++x &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//获得对应的线程id，这里是一个结构体，因为它可以跨平台</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Func fc;<br><span class="hljs-function">thread <span class="hljs-title">ss</span><span class="hljs-params">(fc)</span></span>;<span class="hljs-comment">//使用类对象</span><br><span class="hljs-function">thread <span class="hljs-title">s</span><span class="hljs-params">((Func()))</span></span>;<span class="hljs-comment">//使用仿函数进行传参，就要这样弄，</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p>thread线程库不允许进行拷贝构造,所以直接把它给删除掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">thread</span> (<span class="hljs-type">const</span> thread&amp;) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><h2 id="赋值重载"><a href="#赋值重载" class="headerlink" title="赋值重载"></a>赋值重载</h2><p>不允许赋值一个左值对象，类比拷贝构造<br>但是可以用一个<strong>右值对象来赋值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">thread&amp; <span class="hljs-keyword">operator</span>= (thread&amp;&amp; rhs) <span class="hljs-keyword">noexcept</span>;<br>copy [deleted] (<span class="hljs-number">2</span>)<br>thread&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> thread&amp;) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;thread&gt; vthds;<br>    vthds.<span class="hljs-built_in">resize</span>(n);<span class="hljs-comment">//提前开好n个线程</span><br><br>    <span class="hljs-comment">//现在有任务来了，我们要让这些线程都跑起来</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : vthds)<br>    &#123;<br>        e = <span class="hljs-built_in">thread</span>(print,<span class="hljs-number">100</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//这里构造一个匿名对象赋值给它,这个地方又利用了一个移动赋值,把右边的这个临时</span><br>        <span class="hljs-comment">//对象传过去给e去执行,出了作用域就销毁了</span><br>        <span class="hljs-comment">//右边是一个右值</span><br>        <span class="hljs-comment">//这里的线程不支持拷贝构造，把一个线程拷贝给另一个线程，所以直接delete掉了</span><br>        <span class="hljs-comment">//线程也不支持赋值，但是可以支持移动赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取id"><a href="#获取id" class="headerlink" title="获取id"></a>获取id</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::this_thread::<span class="hljs-built_in">get_id</span>()<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Func</span><br>&#123;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot;++x &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//获得对应的线程id，这里是一个结构体，因为它可以跨平台</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">thread <span class="hljs-title">s</span><span class="hljs-params">((Func()))</span></span>;<span class="hljs-comment">//使用仿函数进行传参，就要这样弄，</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<span class="hljs-comment">//这里面是休眠的时间</span><br></code></pre></td></tr></table></figure><h2 id="join和detach"><a href="#join和detach" class="headerlink" title="join和detach"></a>join和detach</h2><ul><li>join :就是在一个线程还没处理完之前，主线程都要一直等着这个线程做，直到新线程处理完了，才会放开主线程，</li><li>detach: 就是会把主线程和新线程分离开来，新线程的事情不影响主线程做事，后台自动回收</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//线程函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;x&lt;&lt;y&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">thread <span class="hljs-title">s</span><span class="hljs-params">(print,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)</span></span>;<br>s.<span class="hljs-built_in">detach</span>();<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">joinable</span>())<span class="hljs-comment">//判断是否可以被join，如果detach和join之后就不能被join</span><br><br>s.<span class="hljs-built_in">join</span>();<br><br>cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//使用join要等新线程处理完才会打印</span><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用与传参"><a href="#引用与传参" class="headerlink" title="引用与传参"></a>引用与传参</h2><p>假如说我们在main函数里面定义了对象想要传到thread里面</p><ul><li>可以使用指针进行传参</li><li>不能用左值来进行接收，但是可以使用std::ref( ),之后就能用左值接收</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>* x)</span><span class="hljs-comment">//用指针肯定是可以的</span></span><br><span class="hljs-function"></span>&#123;<br>    *x+=<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x)</span> <span class="hljs-comment">//绝对不能传左值引用,但是下面传参是用std::ref()就能接收,因为正常thread里面都是拷贝</span></span><br><span class="hljs-function"></span>&#123;<br>    x += <span class="hljs-number">10</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 严格来说thread的参数不能是左值引用，</span><br>    <br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(func,&amp;n)</span></span>;<span class="hljs-comment">//这样子对n的加，不可以，传值拷贝</span><br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(func, std::ref(n))</span></span>; <span class="hljs-comment">//这样弄就可以了</span><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; n &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h1><p>为了解决内置类型传参过去的线程安全的问题</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">atomic&lt;T&gt; s<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">//这样对x的操作就变成了原子操作,不能用=</span><br>atomic_long m&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//这两者是一样的</span><br><span class="hljs-function">atomic&lt;<span class="hljs-type">long</span>&gt; <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>x++;<span class="hljs-comment">//因为这里的x是atomic原子变量，所以是线程安全的，</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">thread <span class="hljs-title">s</span><span class="hljs-params">(func)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">p</span><span class="hljs-params">(func)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadpool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//实现一个线程池</span><br>    <span class="hljs-function">atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">//我们实现一个n个线程都对它进行加m次</span><br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;thread&gt; vthds;<br>    vthds.<span class="hljs-built_in">resize</span>(n); <span class="hljs-comment">//我们直接就开n个线程，用thread的默认构造函数进行初始化，无参的，就不是不运行</span><br>    <span class="hljs-comment">//这里还有还可以用移动构造和移动赋值</span><br>    <span class="hljs-function">atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">costtime</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vthds.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        vthds[i] = <span class="hljs-built_in">thread</span>([m, &amp;x, &amp;costtime]()<br>                          &#123;<br>            <span class="hljs-type">int</span> begin=<span class="hljs-built_in">clock</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>            &#123;<br>                x++;<span class="hljs-comment">//这里的x是原子变量</span><br>            &#125;<br>            <span class="hljs-type">int</span> end=<span class="hljs-built_in">clock</span>();<br>            costtime+=(end-begin); &#125;); <span class="hljs-comment">//这里我们用了移动赋值，构造了一个线程对象，线程里面用的是lambda表达式</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e : vthds)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">joinable</span>()) <span class="hljs-comment">//判断是否可被join，</span><br>            e.<span class="hljs-built_in">join</span>();     <span class="hljs-comment">//这里必须要用&amp;，如果不用的话，就会去掉拷贝构造，这是不允许的</span><br>    &#125;<br>    cout &lt;&lt; x &lt;&lt; endl;<br>    cout &lt;&lt; costtime &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h1><p>线程安全里面的锁资源</p><ul><li>lock就把临界区锁住了</li><li>unlock可以把解锁</li><li>try_lock:如果这个锁已近被别人用了，就啥也不干直接返回，如果这个锁是空闲的，就把对应的线程给锁住</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>mutex mtx; <span class="hljs-comment">//定义一个锁出来</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//每个线程都有自己的栈，各自在执行自己的func，</span><br>    mtx.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">//不能放在里面，放在里面的话，每一次都要去竞争这个锁资源，</span><br>    <span class="hljs-comment">//加在外面变成了串行，运行，就没有意义了，理论上应该加在里面，这样就能交替并行运行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-comment">//放在这里锁的事情和释放也有消耗，</span><br>        <span class="hljs-comment">//对用户态的切换，要保存上下文</span><br><br>        cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot;++x &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">//获得对应的线程id，这里是一个结构体，因为它可以跨平台</span><br><br>        <span class="hljs-comment">//抢到锁的人执行的指令太少了，导致另一个人刚离开回去休息又回来了，而是在这里循环等待，一直问，好了我就进去执行，（自旋锁）</span><br>        ++x;<br>    &#125;<br>    mtx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">10</span>;<br><span class="hljs-function">thread <span class="hljs-title">th</span><span class="hljs-params">(Func,std::ref(n))</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><blockquote><p>我们使用锁会出现一种情况，一把锁锁住之后，但是里面就调用throw，抛异常之后，就会到catch里面，就把后续代码都跳过了，这个就会造成死锁的问题</p></blockquote><p>所以我们就可以用一个RAII机制的锁，在调用的时候构造，上锁，在析构的时候解锁</p><p>lock_guard 只能在作用域结束后才能解锁</p><p>模拟实现lock_guard</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockGuard</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    Lock&amp; _lock;<span class="hljs-comment">//&amp;,const,和没有默认构造函数的变量，都必须在初始化列表进行初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LockGuard</span>(Lock&amp; lock)<span class="hljs-comment">//在构造函数的时候就行加锁，但是互斥锁是不支持拷贝的，也要保持是同一把锁</span><br>    :_lock(lock)<span class="hljs-comment">//这里的_lock是mtx的别名</span><br>    &#123;<br>        _lock.<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">LockGuard</span>()<br>    &#123;<br>        _lock.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">//在析构函数的时候进行解锁</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>和lock_guard类似，但是可以支持在作用域结束之前解锁<br>所以更加推荐使用unique_lock</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;vt, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> base, mutex &amp;mtx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-comment">/* code */</span><br>        <span class="hljs-keyword">if</span> (base == <span class="hljs-number">200</span>)<br>        &#123;<br>            <span class="hljs-comment">//对应第一个线程就让他sleep一下</span><br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++)<br>        &#123;<br>            <span class="hljs-comment">//用IO把速度降下来</span><br>            <span class="hljs-comment">// mtx.lock(); //这样用锁有问题</span><br>            <span class="hljs-comment">// LockGuard&lt;mutex&gt; lock(mtx);//在这个里面就加锁，出了for作用域就解锁了，抛异常也算出了作用域，也解锁了,调用析构函数，生命周期到了</span><br><br>            <span class="hljs-comment">//lock_guard&lt;mutex&gt; lock(mtx);//这个是库里面提供的</span><br><br>            <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lockk</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//这个效果也是一样的,除了提供构造和析构，中途解一下锁</span><br><br>            <span class="hljs-comment">//这个push失败之后就会抛异常</span><br><br>            vt.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">//有线程安全的问题</span><br><br>            <span class="hljs-comment">//抛异常之后unlock就不会被执行了，这样可能在上面push里面开空间也会出现问题，所以我们这里的锁可以写一个对象锁</span><br>            <span class="hljs-keyword">if</span> (base == <span class="hljs-number">100</span> &amp;&amp; i == <span class="hljs-number">3</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>            <span class="hljs-comment">//这里就死锁了，</span><br>            <span class="hljs-comment">// mtx.unlock();</span><br><br>            <span class="hljs-comment">//会出现死锁，在</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-comment">//捕捉到异常之后，把锁释放掉</span><br>        <span class="hljs-comment">// mtx.unlock();</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    thread t1, t2;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vt;<br><br>    <span class="hljs-comment">//两个线程要用同一个锁</span><br>    mutex mtx;<br>    <span class="hljs-comment">//这里用的匿名对象，右值引用,线程要放在里面抛异常</span><br>    t1 = <span class="hljs-built_in">thread</span>(vfunc, std::<span class="hljs-built_in">ref</span>(vt), <span class="hljs-number">5</span>, <span class="hljs-number">100</span>, std::<span class="hljs-built_in">ref</span>(mtx));  <span class="hljs-comment">//这样是存在线程安全问题</span><br>    t2 = <span class="hljs-built_in">thread</span>(vfunc, std::<span class="hljs-built_in">ref</span>(vt), <span class="hljs-number">10</span>, <span class="hljs-number">200</span>, std::<span class="hljs-built_in">ref</span>(mtx)); <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//这种小程序用lambda就行了</span><br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : vt)<br>    &#123;<br>        cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="cond-variable"><a href="#cond-variable" class="headerlink" title="cond_variable"></a>cond_variable</h1><p>wait</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Predicate</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;<br></code></pre></td></tr></table></figure><p>wait后面的参数是可调用对象，同理，也是函数指针，lambda表达式，仿函数,当返回为true时，才会唤醒，否则一直阻塞着</p><p>notify_one:唤醒一个线程</p><p>实战<br>交替打印奇偶数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//两个线程交替打印，一个打印奇数，一个打印偶数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// t1打印奇数</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    mutex mtx;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    condition_variable cv;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]()</span></span><br><span class="hljs-params"><span class="hljs-function">              &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">while</span>(i&lt;n)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            </span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">//尽量不要单独用lock和unlock</span></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// lock_guard&lt;mutex&gt; lock(mtx);//这个是出了作用域才解锁</span></span></span><br><span class="hljs-params"><span class="hljs-function">            unique_lock&lt;mutex&gt; lock(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">//wait后面的是可调用对象，函数，lambda，仿函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// cv.wait(lock,[&amp;flag]()&#123;return flag;&#125;);//在里面如果是false，就会一直阻塞,直到变成true才会开始，唤醒之后flag为true，就打印，</span></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">//这里的wait是直到条件为真才会去执行任务</span></span></span><br><span class="hljs-params"><span class="hljs-function">            cv.wait(lock,[&amp;]()&#123;<span class="hljs-keyword">return</span> i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>;&#125;);</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">//唤醒和里面条件都会挡住它</span></span></span><br><span class="hljs-params"><span class="hljs-function">            cout&lt;&lt;this_thread::get_id()&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            i++;</span></span><br><span class="hljs-params"><span class="hljs-function">            flag=!flag;</span></span><br><span class="hljs-params"><span class="hljs-function">            cv.notify_one();<span class="hljs-comment">//唤醒一个</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">        &#125; &#125;)</span></span>;<br>    <span class="hljs-comment">// t2打印偶数</span><br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]()</span></span><br><span class="hljs-params"><span class="hljs-function">              &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">while</span>(i&lt;n)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            unique_lock&lt;mutex&gt; lock(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">//!flag是true，这里获取到不会阻塞，就会运行了</span></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// cv.wait(lock,[&amp;flag]()&#123;return !flag;&#125;);</span></span></span><br><span class="hljs-params"><span class="hljs-function">            cv.wait(lock,[&amp;]()&#123;<span class="hljs-keyword">return</span> i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;&#125;);</span></span><br><span class="hljs-params"><span class="hljs-function">            cout&lt;&lt;this_thread::get_id()&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;endl;;</span></span><br><span class="hljs-params"><span class="hljs-function">            i++;</span></span><br><span class="hljs-params"><span class="hljs-function">            flag=!flag;<span class="hljs-comment">//保证下一个自己不会打印</span></span></span><br><span class="hljs-params"><span class="hljs-function">            cv.notify_one();<span class="hljs-comment">//唤醒</span></span></span><br><span class="hljs-params"><span class="hljs-function">           &#125; &#125;)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层——UDP</title>
    <link href="/2022/08/18/%E4%BC%A0%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94UDP/"/>
    <url>/2022/08/18/%E4%BC%A0%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94UDP/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">再谈端口号</a></li><li><ul><li><a href="#_3">端口号的划分</a></li><li><a href="#_6">知名端口号</a></li></ul></li><li><a href="#_18">传输层命令</a></li><li><ul><li><a href="#pidof_19">pidof</a></li><li><a href="#netstat_23">netstat</a></li></ul></li><li><a href="#UDP_40">UDP</a></li><li><ul><li><a href="#UDP_42">UDP概述</a></li><li><ul><li><a href="#_56">主要特点</a></li><li><a href="#UDP__61">UDP 的缓冲区</a></li></ul></li><li><a href="#UDP_73">UDP报文格式</a></li><li><ul><li><a href="#_94">封装和解包</a></li></ul></li><li><a href="#UDP__104">使用UDP 的应用层协议</a></li></ul></li></ul><h1 id="再谈端口号"><a href="#再谈端口号" class="headerlink" title="再谈端口号"></a>再谈端口号</h1><p>端口号标识主机上特定的程序，如http的默认端口是80，我们就可以通过ip+port来找到对应的主机</p><h2 id="端口号的划分"><a href="#端口号的划分" class="headerlink" title="端口号的划分"></a>端口号的划分</h2><blockquote><ul><li>0-1023:知名端口号,HTTP,FTP,SSH等这些广为应用的协议，他们的端口号都是固定的</li><li>1024-65535：操作系统动态分配的端口号，客户端程序的端口号就是在这个范围内</li></ul></blockquote><h2 id="知名端口号"><a href="#知名端口号" class="headerlink" title="知名端口号"></a>知名端口号</h2><p>有些服务器是非常常用的，为了使用方便，人们约定一些常用的服务器，都是用以下的固定端口号</p><blockquote><ul><li>http :80</li><li>ssh:22</li><li>ftp: 21</li><li>https:443</li><li>telnet :23</li></ul></blockquote><p>执行这个命令可以查看知名端口号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cat /etc/services<br></code></pre></td></tr></table></figure><h1 id="传输层命令"><a href="#传输层命令" class="headerlink" title="传输层命令"></a>传输层命令</h1><h2 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h2><p>获得进程的pid<br>pidof [进程名]<br><img src="https://img-blog.csdnimg.cn/9b971bbe4e0741efadfa80910ba8188b.png" alt="在这里插入图片描述"></p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>用来查看网络状态<br>n：查看信息的时候，把全部东西都显示成数字,不带n就是按照文件名和主机名的形式来进行展示<br><img src="https://img-blog.csdnimg.cn/751b83e8ff26460080a0c11e02f7fe9e.png" alt="在这里插入图片描述"></p><p>l:查看监听状态，不带的话，就是查看普通状态的套接字<br><img src="https://img-blog.csdnimg.cn/454e2c5b9492478aab2a0116e372e0a7.png" alt="在这里插入图片描述"><br>t:代表的就是查看TCP的协议 ，同理u代表的就是UDP<br><img src="https://img-blog.csdnimg.cn/76ba41fa63cb480bb00172796678e56c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/566bf82039aa4a2695f50b121e343c9e.png" alt="在这里插入图片描述"><br>p：就是process进程，显示建立相关链接的程序名<br><img src="https://img-blog.csdnimg.cn/c3fe0b6801674344a5984d822ea3b6f2.png" alt="在这里插入图片描述"></p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p><strong>用户资料包协议</strong></p><h2 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h2><blockquote><p>UDP 作为传输层的协议，他规定了数据什么时候发送，发送多少的问题，交付给上层，是由目的端口号来完成的，有效载荷和数据进行分离的工作是由<strong>固定报文首部长度</strong>来实现的</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c91d2823347f4256b6117fe220e2f057.png" alt="在这里插入图片描述"></p><p>UDP过程分析</p><blockquote><p>当对端UDP 层获取到这个报文的时候，先识别8字节，然后就可以拿到这个报文的长度是多少，测试报文有没有出错，然后通过16为目的端口号，得知要标识交付给上一层的哪一个协议</p></blockquote><p><strong>一些特点</strong>:</p><ul><li>报文通过目的端口号进行报文的分用，通过定长找到对应的报文长度，字段进行获取有效载荷</li><li>UDP没有任何一个填充字段或者选项，说明他的内容很简单</li><li>UDP 支持一对一，一对多，多对一，和多对多的交互通信，UDP 可以提供全多工的服务，只不过不可靠</li></ul><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><strong>无连接</strong>，<strong>知道对端的IP和端口号就直接进行了传输</strong>，不需要建立连续</li><li><strong>不可靠</strong>，<strong>没有确认机制</strong>，<strong>没有重传机制</strong>，如果网络故障没有发送给对方，UDP协议层也不会发送给应用层错误信息</li><li><strong>面向数据包</strong>，应用层交给UDP多长的报文，UDP就会发送多少的报文，不会拆分也不会合并（不会出现粘包问题）,要么不收，要么全收</li></ol><h3 id="UDP-的缓冲区"><a href="#UDP-的缓冲区" class="headerlink" title="UDP 的缓冲区"></a>UDP 的缓冲区</h3><ul><li>UDP没有真正意义上的缓冲区，调用sendto之后，直接<strong>将数据交给内核</strong>，由内核将数据传给网络层协议进行后续的传输动作</li></ul><blockquote><p>像read，recv，write，send这些，与其说是收发函数，不如说是拷贝函数<br>像这些，拷贝之后到缓冲区里面，具体该数据，什么时候发送，发多少,完全由OS（传输层）控制,[<strong>提供传输数据的策略</strong>]</p></blockquote><ul><li>UDP具有接收缓冲区：<br>接收缓冲区不能保证收到的UDP 数据报顺序和发送顺序一致，如果缓冲区满了，再达到的UDP数据报就会被丢弃</li></ul><p>UDP全双工<br>（两个人在吵架的时候，你吵你的，它吵它的）<br>与之相比半双工（两个人聊天，你说完我说，这种交叉式的方式）</p><ol><li>sendto,recvfrom可以同时被调用</li></ol><h2 id="UDP报文格式"><a href="#UDP报文格式" class="headerlink" title="UDP报文格式"></a>UDP报文格式</h2><p><img src="https://img-blog.csdnimg.cn/e1aa9afd10f4422a83aed36add3cac48.png" alt="在这里插入图片描述"></p><ul><li><p>报头：是8个字节，是一个定长<br>数据在自下而上的传输过程，首先一开始通常是我们的客户端主动连接服务器的</p></li><li><p>既然如此，那么客户端肯定是知道服务器的端口号的，我们访问的服务器端口号肯定是<strong>众所周知</strong>的</p></li><li><p>长度：<strong>整个报文的长度</strong>，数据报的长度，最小为<strong>8字节</strong>（只要报头），最大为<strong>64K</strong>，如果传输的数据超过64K，需要在应用层手动的分包，多次发送，并在接收端手动拼接，最大是（2^16）</p></li><li><p>校验值：检测UDP数据报是否有错误，有错就丢弃,在这里计算报文，还需要加上12字节的一个伪头部进行计算，<strong>这里的校验更多是为了验证发给我的这个协议，IP的校验偏重是否有错</strong></p><ul><li>Linux Kernel是用C语言写的，请问如何看待UDP报头</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">udp_udr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint32_t</span> src_port:<span class="hljs-number">16</span>;<span class="hljs-comment">//使用的就是位段</span><br><span class="hljs-type">uint32_t</span> dst_port:<span class="hljs-number">16</span>;<br><span class="hljs-type">uint32_t</span> total:<span class="hljs-number">16</span>;<br><span class="hljs-type">uint32_t</span> check:<span class="hljs-number">16</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="封装和解包"><a href="#封装和解包" class="headerlink" title="封装和解包"></a>封装和解包</h3><ol><li><p>如何做到封装和解包</p><ul><li><strong>封装</strong>: 就是添加上定长报头(8字节)</li><li><strong>解包</strong> :就是把报头(8字节)和有效载荷进行分离，读取定长的报头,剩下的就是它的有效载荷</li></ul></li><li><p>如何做到向上交付</p><ul><li>a. 报头和有效载荷分离</li><li>b. 根据报头里面有16位目的端口号，获取之后就可以把有效载荷向上传递给对应的应用层协议</li></ul><blockquote><p>所以我们在写代码的时候，需要绑定端口号，这样底层会转发给对应的进程</p></blockquote><ul><li>端口号为什么是16位?：因为协议规定的</li></ul></li></ol><h2 id="使用UDP-的应用层协议"><a href="#使用UDP-的应用层协议" class="headerlink" title="使用UDP 的应用层协议"></a>使用UDP 的应用层协议</h2><p><img src="https://img-blog.csdnimg.cn/5816015328cb4dc1acb70d188e6655ec.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>udp 网络 tcp/ip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++异常</title>
    <link href="/2022/08/18/C++%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/08/18/C++%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#C_1">C语言的处理错误方式</a></li><li><a href="#C_6">C++异常概念</a></li><li><a href="#_56">异常的使用</a></li><li><ul><li><a href="#_57">异常的抛出和捕获</a></li></ul></li><li><a href="#_274">自定义异常体系</a></li><li><a href="#_429">异常安全</a></li><li><a href="#_437">异常规范</a></li><li><ul><li><a href="#C11noexcept_455">C++11的noexcept关键字</a></li></ul></li><li><a href="#_469">异常的优缺点</a></li><li><ul><li><a href="#_470">优点</a></li><li><a href="#_476">缺点</a></li></ul></li></ul><h1 id="C语言的处理错误方式"><a href="#C语言的处理错误方式" class="headerlink" title="C语言的处理错误方式"></a>C语言的处理错误方式</h1><ol><li><strong>错误码</strong>： 比如在很多C语言系统调用的时候，调用错误都会返回其对应的错误码，这个就很不好找，还要去查询这个错误码对应的意思</li><li><strong>终止程序</strong>: assert,但是内存错误，除0，之后直接就终止程序了</li></ol><h1 id="C-异常概念"><a href="#C-异常概念" class="headerlink" title="C++异常概念"></a>C++异常概念</h1><ul><li>throw:出现错误的时候，可以去抛出一个异常，抛出一个对象，（字符串，有更多的信息，整形，浮点型，自定义类型，这些对象都是可以的）</li><li>catch：处理错误的地方，可以去捕获</li><li>try：和catch进行搭配</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Division</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span><span class="hljs-string">&quot;division by zero condition&quot;</span>;<span class="hljs-comment">//b是0的话，就出现错误，不让程序终止掉</span><br>        <span class="hljs-comment">//抛一个字符串出来</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">return</span> ((<span class="hljs-type">double</span>)a/(<span class="hljs-type">double</span>)b);<span class="hljs-comment">//直接除，如果发生除0错误，就直接终止掉，我们不想</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len,time;<br>    cin&gt;&gt;len&gt;&gt;time;<br>    cout&lt;&lt;<span class="hljs-built_in">Division</span>(len,time)&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">func</span>();<br>        <span class="hljs-comment">//如果正常执行的话，下面的catch就不会执行</span><br>        <span class="hljs-comment">//如果有异常的话，就直接就跳到了catch的地方了</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* errmsg)<span class="hljs-comment">//捕获一下,和抛出的类型是要匹配的</span><br>    &#123;<br>        cout&lt;&lt;errmsg&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(...)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;unknown exception&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">demo1</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h1><h2 id="异常的抛出和捕获"><a href="#异常的抛出和捕获" class="headerlink" title="异常的抛出和捕获"></a>异常的抛出和捕获</h2><p>异常的抛出和匹配的原则</p><ol><li><pre><code class="hljs">异常是通过**throw抛出对象而引发**的，而该**对象的类型**决定了应该会激活哪一个**catch**处理代码</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Division</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span><span class="hljs-string">&quot;division by zero condition&quot;</span>;<span class="hljs-comment">//b是0的话，就出现错误，不让程序终止掉</span><br>        <span class="hljs-comment">//抛一个字符串出来</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">return</span> ((<span class="hljs-type">double</span>)a/(<span class="hljs-type">double</span>)b);<span class="hljs-comment">//直接除，如果发生除0错误，就直接终止掉，我们不想</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len,time;<br>    cin&gt;&gt;len&gt;&gt;time;<br>    cout&lt;&lt;<span class="hljs-built_in">Division</span>(len,time)&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len,time;<br>    cin&gt;&gt;len&gt;&gt;time;<br>    <span class="hljs-keyword">if</span>(time!=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//抛出一个int类型变量</span><br>    <span class="hljs-keyword">else</span><br>    cout&lt;&lt;len&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;time&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">func1</span>();<br>        <span class="hljs-comment">//如果正常执行的话，下面的catch就不会执行</span><br>        <br>        <span class="hljs-comment">//如果有异常的话，就直接就跳到了catch的地方了,</span><br>        <span class="hljs-built_in">func2</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* errmsg)<span class="hljs-comment">//捕获一下,和抛出的类型是要匹配的,抛出异常之后程序就终止了</span><br>    &#123;<br>        cout&lt;&lt;errmsg&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">int</span> errid)<span class="hljs-comment">//catch是可以有很多个</span><br>    &#123;<br>        cout&lt;&lt;errid&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(...)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;unknown exception&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><pre><code class="hljs">被**选择的处理代码**是调用链里面和**该对象类型匹配且抛出异常位置最近**的那个  </code></pre>如果离它近，不匹配也不会去调用<br><img src="https://img-blog.csdnimg.cn/34ce378671a6416a972427a2bc14888d.png" alt="在这里插入图片描述"></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Division</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span><span class="hljs-string">&quot;division by zero condition&quot;</span>;<span class="hljs-comment">//b是0的话，就出现错误，不让程序终止掉</span><br>        <span class="hljs-comment">//抛一个字符串出来</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">return</span> ((<span class="hljs-type">double</span>)a/(<span class="hljs-type">double</span>)b);<span class="hljs-comment">//直接除，如果发生除0错误，就直接终止掉，我们不想</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-type">int</span> len,time;<br>    cin&gt;&gt;len&gt;&gt;time;<br>    cout&lt;&lt;<span class="hljs-built_in">Division</span>(len,time)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* errmsg)<span class="hljs-comment">//这个地方近，就到这里，不到下面的catch</span><br>    &#123;<br>        cout&lt;&lt;errmsg&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">func1</span>();<br>        <span class="hljs-comment">//如果正常执行的话，下面的catch就不会执行</span><br>        <br>        <span class="hljs-comment">//如果有异常的话，就直接就跳到了catch的地方了,</span><br>        <span class="hljs-built_in">func2</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* errmsg)<span class="hljs-comment">//捕获一下,和抛出的类型是要匹配的,抛出异常之后程序就终止了</span><br>    &#123;<br>        cout&lt;&lt;errmsg&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">int</span> errid)<span class="hljs-comment">//catch是可以有很多个</span><br>    &#123;<br>        cout&lt;&lt;errid&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(...)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;unknown exception&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><pre><code class="hljs">抛出异常对象之后，会生成一个**异常对象的拷贝**，因为抛出的异常对象可能是一个**临时对象**，所以会生成一个拷贝对象（生命周期在catch之后就销毁了）</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Division</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-function">string <span class="hljs-title">errmsg</span><span class="hljs-params">(<span class="hljs-string">&quot;/0&quot;</span>)</span></span>;<br>        <span class="hljs-keyword">throw</span> errmsg;<span class="hljs-comment">//抛出这个errmsg,这个errmsg是一个临时对象，</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">return</span> ((<span class="hljs-type">double</span>)a/(<span class="hljs-type">double</span>)b);<span class="hljs-comment">//直接除，如果发生除0错误，就直接终止掉，我们不想</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-type">int</span> len,time;<br>    cin&gt;&gt;len&gt;&gt;time;<br>    cout&lt;&lt;<span class="hljs-built_in">Division</span>(len,time)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* errmsg)<span class="hljs-comment">//这个地方近，就到这里，不到下面的catch</span><br>    &#123;<br>        cout&lt;&lt;errmsg&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">func1</span>();<br>        <span class="hljs-comment">//如果正常执行的话，下面的catch就不会执行</span><br>    &#125;<br><br>    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> string&amp; errmsg)<span class="hljs-comment">//捕获一下,和抛出的类型是要匹配的,抛出异常之后程序就终止了</span><br>    &#123;<br>        <span class="hljs-comment">//有点像实际参数传给形参</span><br>        <span class="hljs-comment">//把对象进行拷贝捕获</span><br>        cout&lt;&lt;errmsg&lt;&lt;endl;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><pre><code class="hljs">catch\(…\)可以捕获任意类型的异常，但是不知道异常的错误是什么</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">catch</span>(...)<span class="hljs-comment">//这个就可以捕获上面我们没写的位置类型的异常，程序就不会终止了</span><br>   &#123;<br>       cout&lt;&lt;<span class="hljs-string">&quot;unknown exception&quot;</span>&lt;&lt;endl;<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>不管在哪里出现了错误，我们捕获都是统一在一层（最外层，网络层进行处理）,捕获记录日志,但是我们一般都不抛字符串，整形这些，而是抛出自定义类型,实际中抛出和捕获的匹配原则有个例外,并不都是类型完全匹配，可以<strong>抛出的派生类对象</strong>，用<strong>基类捕获</strong>，在实际非常实用</li></ol><blockquote><p>catch(const Exception&amp; e)&#x2F;&#x2F;用一个基类来进行捕获<br>{}<br>throw</p><blockquote><p>可以抛出Exception对象，或者Exception的子类对象</p></blockquote></blockquote><ol start="6"><li><pre><code class="hljs">如果异常被捕获，那么catch后面的语句会继续执行</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-type">int</span> len, time;<br>        cin &gt;&gt; len &gt;&gt; time;<br>        cout &lt;&lt; <span class="hljs-built_in">Division</span>(len, time) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> string &amp;errmsg) <span class="hljs-comment">//捕获一下,和抛出的类型是要匹配的,抛出异常之后程序就终止了</span><br>    &#123;<br>        <span class="hljs-comment">//有点像实际参数传给形参</span><br>        <span class="hljs-comment">//把对象进行拷贝捕获</span><br>        cout &lt;&lt; errmsg &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">func2</span>();<span class="hljs-comment">//会执行 </span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li><pre><code class="hljs">异常的重新抛出</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//可以用只能指针尝试处理</span><br>    <span class="hljs-type">int</span> len, time;<br>    cin &gt;&gt; len &gt;&gt; time;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">Division</span>(len, time) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> string &amp;errmsg) <span class="hljs-comment">//这里提前把他捕获了，后面也能正常运行</span><br>                                 <span class="hljs-comment">//拦截异常不是要处理异常，而是要正常释放资源</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;delete []&quot;</span> &lt;&lt; arr &lt;&lt; endl; <span class="hljs-comment">//这样就可以了,但是我们希望最外层进行处理</span><br>        <span class="hljs-keyword">delete</span>[] arr;<br>        <span class="hljs-keyword">throw</span> errmsg; <span class="hljs-comment">//重复抛出异常</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (...) <span class="hljs-comment">//这里提前把他捕获了，后面也能正常运行</span><br>                                 <span class="hljs-comment">//拦截异常不是要处理异常，而是要正常释放资源</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;delete []&quot;</span> &lt;&lt; arr &lt;&lt; endl; <span class="hljs-comment">//这样就可以了,但是我们希望最外层进行处理</span><br>        <span class="hljs-keyword">delete</span>[] arr;<br>        <span class="hljs-keyword">throw</span>; <span class="hljs-comment">//捕获到什么就抛出什么对象</span><br>    &#125;<br>    <span class="hljs-comment">//这个地方抛异常，后面的代码就不会执行了，就会出现内存泄露的问题</span><br>    <span class="hljs-comment">//异常安全的问题</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;delete []&quot;</span>&lt;&lt;arr&lt;&lt;endl;<span class="hljs-comment">//这样就可以了,但是我们希望最外层进行处理</span><br>    <span class="hljs-keyword">delete</span>[] arr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自定义异常体系"><a href="#自定义异常体系" class="headerlink" title="自定义异常体系"></a>自定义异常体系</h1><p>写一个基类异常对象<br>子类异常对象都去继承它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//异常的继承体系</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception</span> <span class="hljs-comment">//异常的基类对象</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Exception</span>(<span class="hljs-type">const</span> string &amp;errmsg, <span class="hljs-type">int</span> &amp;id)<br>        : _errmsg(errmsg), _id(id)<br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//多态</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> _errmsg;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    string _errmsg; <span class="hljs-comment">//错误的描述</span><br>    <span class="hljs-type">int</span> _id;        <span class="hljs-comment">//错误的编号,区分某种错误，对某种错误进行特殊处理</span><br>    <span class="hljs-comment">//比如假如说网络错误的话，我们不能直接反馈信息，而是要重复去尝试10次直到不行，才反馈，所以id就是表示错误的编号</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlException</span> : <span class="hljs-keyword">public</span> Exception<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SqlException</span>(<span class="hljs-type">const</span> string &amp;errmsg, <span class="hljs-type">int</span> id, <span class="hljs-type">const</span> string &amp;sql)<span class="hljs-comment">//记录一下sql语句</span><br>        : <span class="hljs-built_in">Exception</span>(errmsg, id), _sql(sql) <span class="hljs-comment">//调用父类的构造函数</span><br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//多态,子类重写了父类的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        string str = <span class="hljs-string">&quot;SqlException :&quot;</span>; <span class="hljs-comment">//前缀</span><br>        <br>        str += _errmsg;<br>        str+=<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        str += _sql;<br>        <span class="hljs-keyword">return</span> str; <span class="hljs-comment">//这样就行了</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string _sql; <span class="hljs-comment">//请求类型是什么</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheException</span> : <span class="hljs-keyword">public</span> Exception<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CacheException</span>(<span class="hljs-type">const</span> string &amp;errmsg, <span class="hljs-type">int</span> id)<br>        : <span class="hljs-built_in">Exception</span>(errmsg, id) <span class="hljs-comment">//调用父类的构造函数</span><br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//多态</span></span><br><span class="hljs-function">    </span>&#123;<br>        string str = <span class="hljs-string">&quot;CacheException :&quot;</span>; <span class="hljs-comment">//前缀</span><br>        str += _errmsg;<br>        <span class="hljs-keyword">return</span> str; <span class="hljs-comment">//这样就行了</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpException</span> : <span class="hljs-keyword">public</span> Exception<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HttpException</span>(<span class="hljs-type">const</span> string &amp;errmsg, <span class="hljs-type">int</span> id, <span class="hljs-type">const</span> string &amp;type)<br>        : <span class="hljs-built_in">Exception</span>(errmsg, id), _type(type) <span class="hljs-comment">//调用父类的构造函数</span><br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//多态,子类重写了父类的虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        string str = <span class="hljs-string">&quot;HttpException &quot;</span>; <span class="hljs-comment">//前缀</span><br>        str += _type;<br>        str += <span class="hljs-string">&quot;:&quot;</span>;<br>        str += _errmsg;<br>        <span class="hljs-keyword">return</span> str; <span class="hljs-comment">//这样就行了</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string _type; <span class="hljs-comment">//请求类型是什么</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SQLMgr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">9</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">SqlException</span>(<span class="hljs-string">&quot;权限不足&quot;</span>, <span class="hljs-number">100</span>,<span class="hljs-string">&quot;select * from name = &#x27;zhansang&#x27;&quot;</span>); <span class="hljs-comment">//但是我们怎么知道是谁的权限不足</span><br>    &#125;<br>    <span class="hljs-comment">//但是可能三者都会抛异常</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CacheMgr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">CacheException</span>(<span class="hljs-string">&quot;权限不足&quot;</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">//但是我们怎么知道是谁的权限不足</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">CacheException</span>(<span class="hljs-string">&quot;数据不存在&quot;</span>, <span class="hljs-number">101</span>);<br>    &#125;<br>    <span class="hljs-comment">//...缓存里面再查到数据库</span><br>    <span class="hljs-built_in">SQLMgr</span>();<br>&#125;<br><br><span class="hljs-comment">//我们可以抛任意类型的异常，但是必须要继承父类</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HttpServer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...数据来了网络先接收，走到缓存里面去</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">HttpException</span>(<span class="hljs-string">&quot;请求资源不在&quot;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;get&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">HttpException</span>(<span class="hljs-string">&quot;权限不足&quot;</span>, <span class="hljs-number">101</span>, <span class="hljs-string">&quot;post&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;xxxxxx&quot;</span>;<span class="hljs-comment">//未知异常，程序不会崩</span><br>    <span class="hljs-built_in">CacheMgr</span>();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ServerStart</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-built_in">HttpServer</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 这个下面就是异常的捕获</span><br>        <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> Exception &amp;e) <span class="hljs-comment">// const类型的this指针，里面的成员也都要在最后面加const</span><br>        &#123;<br>            <span class="hljs-comment">//我们可以用一个多态,</span><br>            <span class="hljs-comment">// 1.虚函数的重写  2. 父类的指针或引用去调用,</span><br><br>            <span class="hljs-comment">//这样就可以用了，把他们写到对应的日志库里面就行了</span><br>            std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl; <span class="hljs-comment">//捕获去调用这个对象就是多态</span><br>        &#125;<br>        <span class="hljs-built_in">catch</span> (...)<br>        &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;unknown Exception&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ServerStart</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h1><ul><li>资源泄露lock和unlock，malloc和free，new 和delete，fopen和fclose，有异常的话会跳过这些，就会造成内存泄漏</li><li><strong>构造函数和析构函数最好不要抛异常</strong>，没有初始化完整，没有释放完整</li></ul><h1 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h1><ol><li><pre><code class="hljs">网络规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些，可以在函数的后面接throw（类型），列出这个函数可能抛出的异常的所有类型</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这里表示这个函数会抛出A/B/C/D的某种类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(A,B,C,D)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2"><li><pre><code class="hljs">函数后面接throw（），表示这个函数不会抛异常</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不会抛出任何异常</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size,<span class="hljs-type">void</span>* ptr)</span><span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><ol start="3"><li><pre><code class="hljs">throw后面只有一个，说明只会抛出这个异常</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这里只会抛出bad_alloc的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br></code></pre></td></tr></table></figure><p>∗ ∗ 但是异常规范在实际中很难被执行 ∗ ∗ **但是异常规范在实际中很难被执行** ∗∗但是异常规范在实际中很难被执行∗∗</p><h2 id="C-11的noexcept关键字"><a href="#C-11的noexcept关键字" class="headerlink" title="C++11的noexcept关键字"></a>C++11的noexcept关键字</h2><p>在后面加上noexcept就说明不会抛异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">exception</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">exception</span> () <span class="hljs-keyword">noexcept</span>;<br>  <span class="hljs-built_in">exception</span> (<span class="hljs-type">const</span> exception&amp;) <span class="hljs-keyword">noexcept</span>;<br>  exception&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> exception&amp;) <span class="hljs-keyword">noexcept</span>;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">exception</span>();<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>可以更加清晰的表示错误，甚至可以包含堆栈调用信息，<strong>更容易去定位bug</strong>（只能靠日志去进行分析）</li><li>如果返回错误码的话，调用链很长的话，底层很难拿到对应的错误码</li><li>很多第三方库都包含异常，比如gtest，glog等等，所以我们使用的话也要使用异常</li><li>有的函数使用异常更好处理，而向返回值是int这种，返回的不知道是错误码还是正常的值</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><strong>执行流乱跳</strong>，很混乱，这对我们跟踪调试时以及分析程序时，比较困难</li><li>异常会有一些性能的开销，但是现在这个影响几乎忽略不计</li><li><strong>C++没有垃圾回收机制</strong>，资源要自己管理，有了异常很容易照成内存泄露，死锁等异常安全问题（RAII）（智能指针，lock_guard）,出作用域就掉析构函数,学习成本高</li><li>C++标准库的异常体系定义的不好，导致很多人各自定义异常体系</li><li>异常必须要规范，不然外层的用户就很难受（尽量抛子类对象，尽量对接口函数声明抛异常的规范）</li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#HTTP_1">HTTP协议</a></li><li><ul><li><a href="#URLURIURN_6">URL，URI,URN</a></li><li><ul><li><a href="#urlencodeurdecode_33">urlencode(转码)，urdecode（解码）</a></li></ul></li></ul></li><li><a href="#HTTP_44">HTTP协议格式</a></li><li><ul><li><a href="#sendfile_134">sendfile</a></li></ul></li><li><a href="#HTTP_174">HTTP详解</a></li><li><ul><li><a href="#HTTP__193">HTTP 的方法</a></li><li><ul><li><a href="#GETPOST_236">GET和POST</a></li></ul></li><li><a href="#HTTP_294">HTTP状态码</a></li><li><a href="#HTTP_329">HTTP常见的报头属性</a></li><li><a href="#CookieSession_346">Cookie与Session</a></li></ul></li><li><a href="#HTTPS_404">HTTPS</a></li><li><ul><li><a href="#_405">基本概念</a></li><li><a href="#_415">加密方式</a></li><li><a href="#HTTPS__449">HTTPS 的通信方式</a></li></ul></li></ul><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>虽然说，应用层协议是我们程序员自己定制的，但是实际上，已经有很多大佬定制了一些现成的，又很好用的应用层协议，可以让我们直接进行参考使用，HTTP（超文本传输协议）就是其中之一</p><p>HTTP协议支持cs模式（客户端服务器模式，也就是请求和响应模式）并且客户端需要以浏览器的方式访问服务器，</p><h2 id="URL，URI-URN"><a href="#URL，URI-URN" class="headerlink" title="URL，URI,URN"></a>URL，URI,URN</h2><p>Uniform Resource Locator<br>就是去确认哪一个资源在哪一个服务器上</p><ul><li>URN：统一资源名称：用民资标识资源</li><li>URI：统一资源标识符，用来标识资源的唯一性</li></ul><p><img src="https://img-blog.csdnimg.cn/86d89b1401de4633865826bf7564cbd7.png" alt="在这里插入图片描述"></p><blockquote><p>我们请求的图片，html，css，js，视频等这些都称为“资源”<br>服务器后台都是Linux做的<br>但是我们无法唯一的确认一个资源，公网IP地址是唯一确认一台主机的，而我们所谓的网络“资源”，都一定是存在于网络中的一台Linux机器上的，Linux或者传统的操作系统，保存资源的方式，都是以文件的方式来保存的，单Linux系统，标识一个唯一资源的方式，通过路径！</p><p>所以IP+Linux路径，就可以唯一确认一个网络资源<br>ip通常都是以域名的方式来呈现的，路径可以通过目录+&#x2F;来确认</p></blockquote><blockquote><p><a href="https://www.nba.com/summer-league/2022/vegas/schedule">https://www.nba.com/summer-league/2022/vegas/schedule</a><br>.com是ip后面跟的是linux服务器上的路径<br>http就是请求该资源的方法（使用的协议）<br>协议名和端口好是绑定在一起的，指明了协议名字就等于知道了端口号，如http端口号一定是80</p></blockquote><blockquote><p>URL:协议，ip 路径，？后面还可能有片段标识符</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4575e7862d8b44038138e89ad1d47b80.png" alt="在这里插入图片描述"></p><ul><li>#片段标识符，前面的内容不变，#后面发生改变，标识访问的页面的一个小分支</li></ul><h3 id="urlencode-转码-，urdecode（解码）"><a href="#urlencode-转码-，urdecode（解码）" class="headerlink" title="urlencode(转码)，urdecode（解码）"></a>urlencode(转码)，urdecode（解码）</h3><p>有些特殊符号需要特殊处理？&#x2F;+，中文字符和特殊字符会做编码，而数字字母连字符都不会做处理</p><blockquote><p>C++&#x3D;&#x3D;&#x3D;&gt;C%2B%2B，不想让这些特殊字符出现在URL里面</p></blockquote><p>转码规则<br>服务器接收的时候要进行转码</p><blockquote><p>将需要转码的字符转为16进制（ascill值），然后从右向左，取4位（不足4位的直接处理），没2位做1位，前面加上%，编码成为%XY的格式<br>两位做一位，前面加一个%做一位就可以了</p></blockquote><h1 id="HTTP协议格式"><a href="#HTTP协议格式" class="headerlink" title="HTTP协议格式"></a>HTTP协议格式</h1><ol><li>无论是请求还是响应，基本上http都是按照行（\n）为单位来构建请求或者响应的！</li></ol><blockquote><p>无论是请求还是响应，几乎都是由3或者4部分组成</p></blockquote><blockquote><p>如何理解一个普通用户的上网行为—-&gt;主要是为了简单</p><ol><li>从目标服务器拿到你要的资源（读取数据库）</li><li>向目标服务器上传你的数据（上传文件）<br>这就是IO的行为，</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/666aa5e989d94606a6792918118c5a29.png" alt="在这里插入图片描述"></p><p>如果请求正文里面的请求方法是post的话，请求报头会有<strong>Content-Length</strong>属性字段来标识请求正文的长度</p><p>http操作（http的底层实际上是TCP协议 ）</p><ol><li><p>我想看看报头</p></li><li><p>我想发送一个响应<br>我们可以直接在浏览器上面输入公网ip+端口号</p></li></ol><p>h t t p . c c http.cc http.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Sock.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 1024*10</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-type">void</span>* args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sockfd=*(<span class="hljs-type">int</span>*)args;<br>    <span class="hljs-keyword">delete</span> args;<br>    <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-comment">//服务器就从sockfd里面读取</span><br>    <span class="hljs-comment">//我们读取http请求</span><br>    <span class="hljs-type">char</span> buf[NUM];<br>    <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>    <span class="hljs-comment">//http当中面向字节流读取的就是recv,专门用来网络读取的</span><br>    <span class="hljs-type">ssize_t</span> s=<span class="hljs-built_in">recv</span>(sockfd,buf,<span class="hljs-built_in">sizeof</span>(buf),<span class="hljs-number">0</span>);<span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        buf[s]=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//原封不动的把http打印出来，这个就是http的请求格式! 看看请求的样子</span><br>        cout&lt;&lt;buf;<br>        <span class="hljs-comment">//读到了报头</span><br>        <span class="hljs-comment">//我们要返回响应</span><br>        <br>        string response=<span class="hljs-string">&quot;http/1.0 200 OK\n&quot;</span>;<span class="hljs-comment">//响应行，版本http/1.0 状态码200 状态码解释 OK</span><br>        response+=<span class="hljs-string">&quot;Content-Type: text/plain\n&quot;</span>;<span class="hljs-comment">//text/plain代表正文是普通文本，这个说明了后续的一些正文都是一些普通的文本文件</span><br>        response+=<span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//这个是报头结束的标志，空行，区分报头有效载荷</span><br>        response+=<span class="hljs-string">&quot;what are you doing \n&quot;</span>;<span class="hljs-comment">//这个就是正文的内容</span><br><br>        <span class="hljs-comment">//send也是针对TCP设计的接口</span><br>        <span class="hljs-built_in">send</span>(sockfd,response.<span class="hljs-built_in">c_str</span>(),response.<span class="hljs-built_in">size</span>(),<span class="hljs-number">0</span>);<span class="hljs-comment">//因为我们要写的是http响应,所以这里发送的完整的响应发送回去</span><br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;port&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">uint16_t</span> port=<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> sockfd=Sock::<span class="hljs-built_in">Socket</span>();<br>    Sock::<span class="hljs-built_in">Setoptsocket</span>(sockfd);<span class="hljs-comment">//设置端口复用</span><br>    Sock::<span class="hljs-built_in">Bind</span>(sockfd,port);<br>    Sock::<span class="hljs-built_in">Listen</span>(sockfd);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> newsock=Sock::<span class="hljs-built_in">Accept</span>(sockfd);<br>        <span class="hljs-keyword">if</span>(newsock&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">pthread_t</span> tid;<br>        <span class="hljs-type">int</span>* parm=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(newsock);<br>        <span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">nullptr</span>,handler,(<span class="hljs-type">void</span>*)parm);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d084ccc0a2af45499eb290051ed346b8.png" alt="在这里插入图片描述"><br>Content-Type（响应正文的类型）属于响应报头的属性之一</p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>我们可以使用sendfile接口来发送文本，该接口可以直接把一个文件的内容拷贝给另外一个文件，它是在内核里面完成的，效率都很高<br><strong>sendfile</strong></p><blockquote><p><strong>功能</strong>：把一个文件描述符里面的内容，拷贝给另外一个文件描述符，且都是在内核里面实现的，不会经过用户层，所以它的效率比read和write都要高</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-number">2.</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>outfd:要写到哪个文件描述符里面</li><li>infd：从哪个文件描述符里面写</li><li>offset：偏移量，可以记录读取文件的位置，如果为nullptr，则数据要从当前文件的偏移量取读取</li><li>count：要拷贝的文件的大小</li></ul><p>返回值：<br>成功返回成功读取到的大小，失败返回-1</p></blockquote><p><strong>stat</strong><br>获取文件的属性信息</p><blockquote><p>功能：获取文件的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> int stat(const char *pathname, struct stat *buf); </span><br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>pathname：文件的路径名</li><li>buf：获取到的结构体</li></ul><p>返回值：<br>成功返回0，失败返回-1</p></blockquote><p>我们可以通过stat获取到文件的大小，填充Content-Length字段，然后使用sendfile接口来发送html格式的文件到套接字里面</p><p>回答几个问题</p><ol><li>如何讲报头读取完毕</li></ol><blockquote><p>在读取报头时，将Content-Length属性字段读取下来（知道文件的大小），正文就读取Content-Length大小的内容，就代表将正文读取完毕</p></blockquote><h1 id="HTTP详解"><a href="#HTTP详解" class="headerlink" title="HTTP详解"></a>HTTP详解</h1><p>我们上面的代码服务端直接recv，缓冲区设置的1024*10是不合理的</p><ul><li>1.http它的请求可能不是一个一个发送的，可能是一次发送多个请求的</li><li>2.因为TCP是字节流的，我们上面缓冲区定义的10240，假如说发送过来的请求大小是1024，我们就可以读完，那么如果我们定义的缓冲区是1025，那么就会第一个请求读完之后，第二个请求还会读取1个字节</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">所以<br><span class="hljs-number">1.</span>保证每次读取都是一个完整的<span class="hljs-keyword">http</span> request<br><span class="hljs-number">2.</span>保证每次读取都不要将下一个<span class="hljs-keyword">http</span> request的一部分读到（残缺的报文）<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9f0d1517637e4f5e89bd4f8b67d13294.png" alt="在这里插入图片描述"></p><ol><li>我们如何判定我们将报头部分读完呢？</li></ol><blockquote><p>我们读取http响应都是按行读取的，读取到空行，说明报头读取完成</p></blockquote><ol start="2"><li>决定后面还有没有正文呢？</li></ol><blockquote><p>如果有正文，如何保证把正文全部读取完成呢？而且不要把下一个http的部分数据给读取到<br>我确实不知道要读取到，但是我们上面已近把报头读取完成了，这样我们就能够提取报头中的各种属性，请求的方法，URL,主机，以及Content-Length,正文长度，正文部分有多少个字节，这样就允许我们读取多少个len字节</p></blockquote><p>Content-Length:自描述字段,没有正文的时候，就不存在</p><h2 id="HTTP-的方法"><a href="#HTTP-的方法" class="headerlink" title="HTTP 的方法"></a>HTTP 的方法</h2><p>1.首行：[方法]+[url]+[http版本]<br>2. Header:请求的属性，冒号分割的简直对，每组属性之间用\n进行分割，遇到空行说明Header部分结束<br>3. Body：为正文，可以是空字符串，如果body存在，header里面就有一个content-length来标识字符串的长度</p><p>现在我们讲http1.0 1.0和1.1的主要区别是：是否支持长链接</p><table><thead><tr><th>方法</th><th>说明</th><th>支持的HTTP协议版本</th></tr></thead><tbody><tr><td>Get</td><td>获取资源内容</td><td>1.0&#x2F;1.1</td></tr><tr><td>POST</td><td>创输实体主体</td><td>1.0&#x2F;1.1</td></tr><tr><td>PUT</td><td>传输文件</td><td>1.0&#x2F;1.1</td></tr><tr><td>HEAD</td><td>获得报文首部</td><td>1.0&#x2F;1.1</td></tr><tr><td>DELETE</td><td>删除文件</td><td>1.0&#x2F;1.1</td></tr><tr><td>OPTION</td><td>询问支持的方法</td><td>1.1</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>1.1</td></tr></tbody></table><p><strong>说明：</strong></p><blockquote><p>HTTP&#x2F;1.1在HTTP&#x2F;1.0基础上增加了<strong>长连接</strong>和<strong>缓存处理</strong>等内容，</p><ol><li>HTTP&#x2F;1.0是基于请求和响应的，每次发送请求都需要重新建立连接，获得响应之后再关闭连接，当然这样频繁的申请套接字释放套接字，对于效率来说，太低了，</li></ol><blockquote><p>短链接：一个请求，一个响应，close socket,<br>一个请求就是请求一个资源，链接就自动关闭<br>原因</p><ol><li>网络不好，2.需求小 3.上网的人少，短链接就足够了</li></ol></blockquote><ol start="2"><li>而HTTP&#x2F;1.1是支持长连接的，客户端可以通过一个连接向服务器发起多个http请求，上层依次读取请求之后，还会继续保持连接，这样就不会因为建立连接而消耗时间了，在所有的数据全部发送完之后，在关闭连接</li></ol></blockquote><blockquote><p>长连接多使用在操作频繁，点对点的通信，连接数不能太多的情况，<br>而像一些WEB网站一般都是使用短链接，因为长连接对于服务器来说会消费一定的资源，向WEB服务器由成千上万的客户端连接，每个用户不是频繁的操作，所以使用短链接就可以了</p></blockquote><p>HEAD方法，可以获得响应的报头,只有报头，没有正文<br><img src="https://img-blog.csdnimg.cn/7f78cff2c2064bdaa99ae21a3686c658.png" alt="在这里插入图片描述"></p><p>GET就是除了获取报头，还有正文也会获得出来<br><img src="https://img-blog.csdnimg.cn/8e524cb5123847a091a8ef916ac18b93.png" alt="在这里插入图片描述"><br>OPTIONS:询问支持的方法，有可能用协议的人把它给关掉了</p><h3 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h3><p>我们要知道http请求的&#x2F;并不是根目录，而是叫做web根目录<br>如果我们访问一个web，后面不带路劲，默认访问的就是web的根目录，而这里我们显示的带了我们要访问的路径，这里就是我们要访问的路径</p><blockquote><p>&#x2F;：我们一般要请求的一定是一个具体的资源<br>如下面我们使用的，但是如果是&#x2F;，意味着，我们要请求该网站的首页<br>一般就是index.html or index.htm<br>所以我们所有的网站都要有首页信息</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0da3ae9d326e4b91addc31c2f3071cfa.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a899b8f7a6de4734815b3cd1df30316e.png" alt="在这里插入图片描述"></p><p>这里我们介绍两个方法：GET和POST</p><ol><li>GET可以直接获取资源，还可以上传数据，通过URL进行参数的传递（？a&#x3D;10&amp;b&#x3D;20）</li><li>POST上传数据，通过正文进行传参，包头中还会有携带Content-Length字段，说明正文内容大小，<br>用get的方法之后，路径后面就会夹带参数</li></ol><p><img src="https://img-blog.csdnimg.cn/08a3932d729b4e1ba04f0e7a9bf52497.png" alt="在这里插入图片描述"><br>?后面就是参数</p><p>GET方法：如果提交参数就是通过url方式进行提交的,拼接到路径的后面，让http服务器拿到这样的数据,这样前面的数据就被后端的代码拿到了,这样就能通过字符串分割获取到姓名和密码</p><p>POST方法<br><img src="https://img-blog.csdnimg.cn/55ba6424276e4ac7bd96f9d4d5125239.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/dba77f761d274719855b1eba7b0ead8c.png" alt="在这里插入图片描述"></p><p>POST：参数会跟到正文后面,通过正文进行提交参数的，</p><p>GET和POST方法</p><ol><li>第一批结论</li></ol><p>GET</p><blockquote><p>GET：方法叫做：获取，是最常用的方法，默认一般是获取所有的网页，都是GET方法，都是如果GET 要提交参数（）是通过URL进行参数拼接从而提交给server端</p></blockquote><p>POST</p><blockquote><p>POST：是提交参数比较常用的方法，但是如果提交参数，一般是通过正文部分进行提交的，但是不要忘记，Content-Length,表示参数的长度</p></blockquote><ol start="2"><li>第二批结论：区别</li></ol><p>安全就是要加密</p><p>参数提交的位置不同</p><blockquote><ol><li>post方法比较私密（！&#x3D;安全），因为不会回显到浏览器的url输入框里面，而get方法不私秘，会讲主要数据回显到url的输入框里面,增加了被盗取的风险</li><li>get是通过url进行传参的，而url是有大小限制的，和具体的浏览器有关,post是通过正文传参的，没有大小限制</li></ol></blockquote><ol start="3"><li>第三批结论：如何选择</li></ol><blockquote><ol><li>GET：如果提交的参数，不敏感，数量少，就可以使用GET</li><li>POST: 否则就用POST</li></ol></blockquote><p>HTTP协议处理，本质就是文本分析<br>所谓的文本分析：<br>1.http协议本身的字段<br>2.第一行拿出来，请求方法，<br>里面 kv值，<br>3.提取参数，get，post就是前后端交互的重要方式</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><blockquote><p>应用层是人参与的，人水平参差不齐，http的状态码很多的人根本就不清楚如何去使用,又因为浏览器种类太多了，有的浏览器也不会对这个状态码有处理，对浏览器没有正常的指导意义，就正常的显示你的网页（not found也是服务器给我们操作的），</p></blockquote><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>1XX Informational（信息性状态码） 接收的请求正在处理，服务器担心客户端因为太久没有接收到回应而关闭掉，就发送这个状态码，表示没有出错，只是需要时间执行（少见）</td><td></td></tr><tr><td>2XX Success（成功状态码） 请求正常处理完毕</td><td></td></tr><tr><td>3XX Redirection（重定向状态码） 需要进行附加操作完成请求</td><td></td></tr><tr><td>4XX Client Error（客户端错误状态码） 服务器无法处理器，客户端发送的服务器没找到</td><td></td></tr><tr><td>5XX Server Error（服务端错误状态码） 服务器处理请求出错，服务器出现问题了</td><td></td></tr></tbody></table><p>常见的状态码</p><ul><li><strong>200</strong>（OK）</li><li>301(临时重定向)</li><li>302</li><li>307（永久重定向）</li><li>403（Forbiden）：表示没有权限，如果不是vip登录一个需要回会员的视频，就会提示forbiden</li><li><strong>404</strong>(Not Found)：没有这份资源（如果是404，不能靠浏览器帮我们做什么，而是要我们自己对于404有所操作，构建一个响应告诉别人我这个资源不存在），这个属于客户端问题</li><li><strong>504,500,503</strong>(Bad Gateway)：服务器错误，如，创建线程错误,做字符串分析，程序崩溃，算法有问题，构建任务，与服务器逻辑出错了，就是服务器错误,等等</li></ul><p>3xx:重定向必须需要浏览器给我们提供支持的，浏览器必须要识别301，302，307这些状态码，server要告诉浏览器，我应该要去哪里Location：就是我们的新的地址</p><blockquote><p>这个状态码是有特殊含义的，主要是重定向，</p><ol><li>永久重定向：<strong>301</strong>，通常用来网站域名的更换，域名的替换</li><li>临时重定向：<strong>302 or 307</strong><br>重定向</li></ol><blockquote><p>：当我们在访问一个网站的时候，可能会跳转到另一个网址，—–》永久重定向<br>当我访问某种资源的时候，提示我登录，跳转到了登录页面，输入完毕密码，登录的时候，会自动跳转回来（登录，下单）—-》临时重定向</p></blockquote><ul><li>永久重定向—-》例如：一个网站已近被废弃了，但是老用户不知道，还去访问，那么就会跳转到新网站，新用户登录新网站不受影响，这个网站就是被永久重定向（一个客户端，访问的时候，服务器不提供服务，告诉新网站，重新发起请求，如果有收藏的话，这个网站也会被更新，直接就访问新的网站，）————-》通常用来网站域名的更换，域名的替换</li><li>临时重定向—-》</li></ul></blockquote><h2 id="HTTP常见的报头属性"><a href="#HTTP常见的报头属性" class="headerlink" title="HTTP常见的报头属性"></a>HTTP常见的报头属性</h2><ul><li><strong>Content-Type</strong>：数据的类型（常见的有text&#x2F;plain《普通的文本文件》，text&#x2F;html《html文件》）</li><li><strong>Content-Length</strong>：正文的长度，大小，我们可以使用stat来获得</li><li><strong>Host</strong>：客户端请求的资源再哪一台主机上的哪一个端口号</li><li><strong>User-Agent</strong>：声明用户的操作系统和浏览器版本信息</li><li><strong>Referer</strong>：当前页面是从哪一个页面跳转来的，例如我们要从a页面跳转到b页面，那这个referer就是a页面</li><li><strong>Location</strong>：告诉客户端接下来要访问哪里，搭配3xx状态进行使用</li><li><strong>Cookie</strong>：用于在客户端存储少量信息，通常用于实现会话（session）的功能</li><li><strong>Connection</strong>：keepalive表示长连接，表示请求网页的时候不会关闭套接字，只到我们关闭浏览器才关闭套接字，如果没有这个字段，或者是close就是短链接</li><li><strong>Accept</strong>：字段表示客户端所能解析的文件格式</li><li><strong>Set-Cookie</strong>:服务器向浏览器设置一个cookie，把后面的内容写到cookie文件里面，此后，每次访问都把这个信息带上</li></ul><p>长短连接</p><blockquote><p>一个大型的网页，是由非常多个资源组成的，每个资源访问都要发起一个http请求，就需要多次http请求，这个就是短链接的一个策略，每个资源都要请求，所以http&#x2F;1.0&#x3D;短链接,http&#x2F;1.1之后就是长连接，而http协议是基于tcp协议的，再得到一个资源后，里面又包含连接，还会自动取建立连接去获取资源<br>tcp通信（建立链接-传输数据-断开连接），每一次请求都要执行上述过程，很耗时，我们想要一个网页，网页里面有3个图片，就需要建立4次连接获得这个完整的网页，但是浏览器会帮我们自动执行，一个连接干一件事情<br>keep-alive，长连接。先建立一个请求和响应链接，这样每次访问的时候，都是复用原来的资源，通过减少频繁建立tcp连接，来达到提高效率的目的1一个连接干全部事情</p></blockquote><h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><p>我们介绍一下Cookie，我们知道，http的几个特性</p><ul><li>无连接：http发送的请求和响应是不用关心连接的，因为底层的TCP已近做好了连接</li><li>无状态：http不会记录对方的状态的，每次发起的http请求，不关心之前的请求和之后的请求，只关心当前的请求不记录上下文信息</li></ul><blockquote><p>经验中：<br>再网站，网站是认识我的，再各种页面跳转的时候，本质上都是建立各种http请求，网站照样认识我，<br>其实这个不是http本身要解决的问题，主要是用来解决网络资源获取的问题<br>http可以提供一些技术支持，来保证网站具有“会话保持”的功能</p></blockquote><blockquote><p>我们在浏览器登录一些网站的时候，要输入账号密码进行登录，由于HTTP是无状态，所以每次我们再访问这些网站的时候，我们还要重新再进行登录<br>但是如果每次都这样的话，就显得很麻烦，所以浏览器一般都会有一种Cookie和Session机制，它可以记录上一次请求的一些消息，这个机制是独立于HTTP的，用来保存用户的状态信息</p></blockquote><p>Cookie：主要做会话管理<br>登录一个网站，就叫做建立会话的过程</p><ul><li>cookie其实是一个文件，在浏览器中，文件里面保存的是用户的私密信息</li><li>http协议：一旦该网站对应有cookie，后续再发起任何请求的时候，在报头属性里面都会自动携带cookie信息（浏览器），这样服务器就认识了你</li></ul><ol><li><p>在登录一个网站的时候，用户第一次在浏览器输入账号密码并且提交到服务器发起认证请求，服务器就会核实数据库，认证成功之后，会设置Set-Cookie，然后将Set-Cookie响应给浏览器，浏览器会将Set-Cookie的值进行提取，然后保存在一个cookie文件（在登录成功之后生成的Cookie文件）里面，这样浏览器就可以保存了用户的登录认证信息</p></li><li><p>下一次再访问这个网站的时候，浏览器会自动将cookie文件里的内容进行提取，并填充到请求报头的cookie字段里面，这样服务器也就自动完成了认证，也就实现了免账号密码登录的功能.</p></li><li><p>Cookie文件分为内存级别和文件级别，前者是浏览器关闭，cookie就没了，浏览器就不认识我了，后者是保存在本地磁盘，可以永久保存</p></li></ol><p><img src="https://img-blog.csdnimg.cn/e984dd10091a4ab09b533fdc0af9cc2b.png" alt="在这里插入图片描述"><br>Set-Cookie<br><img src="https://img-blog.csdnimg.cn/a8fc8ed912d04d16ac848b0e125631b9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/013975a917a34e5f87a303e15a3729c3.png" alt="在这里插入图片描述"><br>后续的请求都把cookie信息加进去了,服务端每次都要对身份进行认证的</p><p><strong>Cookie带来的问题</strong><br>如果别人盗取了我的cookie文件，这样，1. 别人就能以我们的身份访问特定的资源，2. 如果保存的是用户名密码，就很糟糕了</p><p>cookie文件容易被任意恶意软件盗取，或者一些非法钓鱼网站获取，这样非法用户就可以拿着我们的Cookie文件登录我们登录过的网站了，这样就会造成信息泄露<br>有安全隐患</p><p><strong>cookie和session共同解决</strong><br>为了解决cookie文件泄露的问题，所以才又引进了一种机制Session,将cookie和session结合起来使用就可以减少信息泄露的可能性</p><p>核心：将用户的私密信息保存在服务端</p><blockquote><p>我们在上面cookie机制的基础上，增加了一个session机制，浏览器第一次想服务端发起的请求，</p><ul><li>服务器会创建一个Session将用户的信息进行保存，形成Session文件(比如叫123，每个人都要有唯一的文件)，保存在服务端的磁盘中，用来确认用户的身份，</li><li>后构建响应，设置Set-cookie: session_id&#x3D;123（文件名）,服务器会将这个Session ID进行返回，给浏览器，</li><li>浏览器会将Session ID保存在Cookie文件里面，</li><li>以后每次认证都是使用Session ID来进行的，之后每一次请求都携带这个session_id,之后的认证就是服务端通过session_id找到对饮的文件，就能找到信息进行认证，后续Server依旧能够认识client</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/25fb7348d5844834996f495097e26fb0.png" alt="在这里插入图片描述"></p><p>重新登录，旧的session_id 也就失效了<br>把session_id删除掉，也就下线了</p><blockquote><p>这样，Session通过服务器端记录的信息确认用户的身份，Cookie通过在客户端记录信息确认用户身份，当然Session也是有时间限制的，Cookie的文件大小也限制在4K，这样就可以比单纯的使用Cookie更安全</p></blockquote><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>现在浏览器默认都是https，安全性强</p><p>HTTPS是http的安全版本：也叫超文本传输协议，HTTPS会对要<strong>传输的数据进行加密</strong>，由SSL软件层来提供加密基础，这样HTTPS就比HTTP更加安全了，可以理解为</p><p>HTTPS&#x3D;http+SSL&#x2F;TSL《数据的加密解密层》,SSL和TSL选择一个，SSL(Secure Socket Layer )安全套接层协议，TLS（Transport Layer Security）安全传输层协议</p><p>在网络中走的时候，http的有效载荷全部都被加密了<br>原本的情况是http后直接经过系统调用就到了下面，现在是又加上了数据加密层，后才经过下面<br><img src="https://img-blog.csdnimg.cn/302ab6fdeac049d88d948b2bcef6369a.png" alt="在这里插入图片描述"></p><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><ol><li><pre><code class="hljs">对称加密：密钥（只有一个）X,使用**同一把密钥**进行解密  </code></pre>用一个X进行加密，也要用一个X进行解密<br>发送端，我们都有一个密钥</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> data=<span class="hljs-number">10</span>;<span class="hljs-comment">//这是我们实际的数据</span><br><span class="hljs-type">int</span> result=data^x;<span class="hljs-comment">//这个是我们加密之后的数据</span><br>send （result）;<br><br></code></pre></td></tr></table></figure><p>接收端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">recv(result)<br><span class="hljs-type">int</span> data=result^x<br><span class="hljs-comment">//这里的data就是解密后的数据</span><br></code></pre></td></tr></table></figure><ol start="2"><li>非对称加密:有一对密钥：公钥和私钥,（RSA）</li></ol><blockquote><p>可以用公钥加密，用私钥解密<br>用私钥加密，用公钥解密<br>一般而言，公钥是全世界公开的，而私钥是必须自己进行私有保存的</p></blockquote><ul><li>. 形成数字签名（一个文本唯一的标识符）<br><img src="https://img-blog.csdnimg.cn/4216e8d943ec4807a3e9160196400db6.png" alt="在这里插入图片描述"></li><li>. 发送，将文本和数字签名作为一个整体进行发送<br><img src="https://img-blog.csdnimg.cn/5d8505ba86324f84978fe0e2222867f4.png" alt="在这里插入图片描述"></li><li>校验<br>客户端检验：<br>分别将文本和数字签名拎出来<br>对文本采用相同的hash散列，形成一个数字摘要<br>对得到的数字签名进行解密，得到数字摘要<br>如果两者相同，则没有问题<br><img src="https://img-blog.csdnimg.cn/b61e6b667ce44a788bc1d1c24aaebe83.png" alt="在这里插入图片描述"></li></ul><h2 id="HTTPS-的通信方式"><a href="#HTTPS-的通信方式" class="headerlink" title="HTTPS 的通信方式"></a>HTTPS 的通信方式</h2><p>对称加密的弊端<br><img src="https://img-blog.csdnimg.cn/7f838ecb66e444fabc8df87c022de193.png" alt="在这里插入图片描述"><br>非对称加密的用处<br><img src="https://img-blog.csdnimg.cn/84c170afbdd64d44b1bc8262755d4978.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/56c2019dc8bf46fc949d482cfb1da82c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bed06e7bd19e43a9bce18e081491a406.png" alt="在这里插入图片描述"></p><p>但是这样在密钥协商阶段也是有安全隐患的<br><img src="https://img-blog.csdnimg.cn/bf06ea9e055f481ba6310c3e181d1d0a.png" alt="在这里插入图片描述"><br>本质问题：client不知道发来的密钥报文是不是合法的服务方发来的，这里就有一个证书机构</p><p>CA证书机构:只要一个服务商，经过权威机构认证，该机构就是合法的<br><img src="https://img-blog.csdnimg.cn/278f9a6124874c9b8c1889c76b42e819.png" alt="在这里插入图片描述"></p><p>什么叫做安全：<br>不是让别人拿不到就叫做安全，而是拿到了也无法处理</p><p>HTTP和HTTPS的区别</p><ul><li>HTTP使用明文传输数据，HTTPS使用密文传输数据，中间有一层SSL或TLS进行加密更安全</li><li>HTTP使用的端口号是80，HTTPS使用的端口号是443</li><li>HTTPS需要申请证书</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http 服务器 网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络计算器—————序列化与反序列化</title>
    <link href="/2022/07/12/%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/07/12/%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_3">序列化和反序列化</a></li><li><a href="#_41">网络计算器</a></li><li><ul><li><a href="#_43">没有使用组件</a></li><li><a href="#jsoncpp_72">jsoncpp组件的使用</a></li><li><ul><li><a href="#jsontest_96">jsontest</a></li><li><a href="#_160">网络在线计算器</a></li></ul></li></ul></li></ul><p>自顶向下去写，我们现在每次写的协议都是基于上一层的协议</p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>我们程序员写的一个一个程序，都是在应用层</p><p>我们发送的数据都是结构化的数据,这种结构话的数据就很好看也很好使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message</span></span><br><span class="hljs-class">&#123;</span><br>我的昵称：会跳的鹅<br>我的头像：唐老鸭.png<br>我的消息：在吗？<br>消息时间：<span class="hljs-number">2022</span><span class="hljs-number">-07</span><span class="hljs-number">-10</span> <span class="hljs-number">11</span>：<span class="hljs-number">31</span>：<span class="hljs-number">59</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是一个结构化的消息，我们要把这个结构化的数据转化成一个从“字符串”,我们要把这个结构化的数据<br>“{昵称：xxx，头像：xxx，消息：xxx}”，把它传送到网络里面，到对端之后，再把它解析出来，读取到对应的结构体里面</p><p><strong>序列化</strong>：把结构化的数据转化为字符串的过程就是序列化的过程，</p><p><strong>反序列化</strong>：把字符串转化为结构体信息就是反序列化的过程，因为结构化的数据，再网络里面不方便传输，字符串便于网络传输</p><p>为什么要进行序列化和反序列化</p><ol><li>为了应用层网络通信的方便</li><li>为了方便上层进行使用内部成员，将应用和网络进行解耦，我们只关心使用，不关心发送的过程</li></ol><blockquote><p>而我们之前使用的TCP和UDP是没有序列化的过程，我们必须要有结构化的数据<br>而这些序列化和反序列化的数据，它实际上就是协议的表现</p></blockquote><p>我们自己写一个实现序列化和反序列化<br>也可以直接使用别人写好的组件，java里面（json，xml，protobuff）</p><p>我们这里就使用<strong>jsoncpp</strong><br>jsoncpp的安装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sudo yum install -y jsoncpp-devel<br></code></pre></td></tr></table></figure><h1 id="网络计算器"><a href="#网络计算器" class="headerlink" title="网络计算器"></a>网络计算器</h1><p>我们这里自己定制协议</p><h2 id="没有使用组件"><a href="#没有使用组件" class="headerlink" title="没有使用组件"></a>没有使用组件</h2><blockquote><p>发送端口<br>伪代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string x=<span class="hljs-string">&quot;123&quot;</span>;<br>string opt=<span class="hljs-string">&quot;+&quot;</span>;<br>string y=<span class="hljs-string">&quot;321&quot;</span>;<br>string data=x+opt+y;<span class="hljs-comment">//</span><br><span class="hljs-built_in">send</span>(data);<span class="hljs-comment">//这个就是序列化的过程，转化成字符串再发送过去</span><br></code></pre></td></tr></table></figure><p>接收端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">recv</span>(data);<br>recv=<span class="hljs-string">&quot;123+321&quot;</span>;<br><span class="hljs-type">int</span> opt==recv.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;+&quot;</span>);<br>string x=recv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,opt);<span class="hljs-comment">//</span><br>string y=recv.<span class="hljs-built_in">substr</span>(opt);<br><span class="hljs-type">int</span> _x=<span class="hljs-built_in">to_int</span>(x);<br><span class="hljs-type">int</span> _y=<span class="hljs-built_in">to_int</span>(y);<br><span class="hljs-type">int</span> z=x+y;<br>string _z=<span class="hljs-built_in">to_string</span>(z)<br><span class="hljs-built_in">send</span>(z)<br><span class="hljs-comment">//这就是一个反序列化的过程,接收到了一个字符串，再把它弄成结构体</span><br><span class="hljs-comment">//最后还需要再序列化</span><br></code></pre></td></tr></table></figure><p>这个方案，我们是把数据分开了<br>我们发现这个过程实际上是非常麻烦的 ，都由我们自己做就很麻烦</p><h2 id="jsoncpp组件的使用"><a href="#jsoncpp组件的使用" class="headerlink" title="jsoncpp组件的使用"></a>jsoncpp组件的使用</h2><p>约定方案2</p><blockquote><ul><li><strong>定义结构体</strong>标识我们需要交互的信息</li><li>发送数据时将这个结构i体按照一个规则转化成字符串，接收数据的时候再按照相同的规则把字符串转化为结构体</li><li>这个过程就叫做“序列化”和“反序列化的过程”</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">request</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-type">char</span> op;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">request</span> req=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;+&quot;</span>&#125;;<br><span class="hljs-built_in">write</span>(sock,&amp;req,<span class="hljs-built_in">sizeof</span>(req));<span class="hljs-comment">//这样子发送的时候，实际上就是直接把序列化的数据发送过去了</span><br><br><br><span class="hljs-comment">//接收</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">request</span> req;<br><span class="hljs-built_in">read</span>(sock,&amp;req,<span class="hljs-built_in">sizeof</span>(req));<span class="hljs-comment">//这样的话就缺少了序列化的过程，不太推荐</span><br><br></code></pre></td></tr></table></figure><h3 id="jsontest"><a href="#jsontest" class="headerlink" title="jsontest"></a>jsontest</h3><p>测试json</p><p>t e s t . c p p test.cpp test.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;jsoncpp/json/json.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//仅仅是了解一下序列化和反序列化的过程</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">request_t</span><br>&#123;<br>    <span class="hljs-type">int</span> x;    <span class="hljs-comment">// 10</span><br>    <span class="hljs-type">int</span> y;    <span class="hljs-comment">// 0</span><br>    <span class="hljs-type">char</span> opt; <span class="hljs-comment">//我们协议上是支持  //</span><br>    <span class="hljs-built_in">request_t</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//生成默认的构造函数</span><br>&#125;; <span class="hljs-comment">//请求协议</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">request_t</span> req=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;*&#x27;</span>&#125;;<br>    <span class="hljs-comment">//现在我们有了这个结构化的数据,所以我们就需要把它进行序列化</span><br>    Json::Value root;<span class="hljs-comment">//可以承转任意对象,json是一种kv式的序列化方案</span><br>    <span class="hljs-comment">//要序列化的对象先装到一个value对象里面</span><br>    root[<span class="hljs-string">&quot;datax&quot;</span>]=req.x;<br>    root[<span class="hljs-string">&quot;datay&quot;</span>]=req.y;<br>    root[<span class="hljs-string">&quot;operator&quot;</span>]=req.opt;<br><br>    <span class="hljs-comment">//FastWriter StyledWriter   有这两种类型,这是一整行没有分层的</span><br>    <span class="hljs-comment">// Json::StyledWriter writer;//我们定义了一个json里面Writer类,writer对象,这个writer式一种分层的</span><br>    Json::FastWriter writer;<span class="hljs-comment">//我们定义了一个json里面Writer类,writer对象,这个writer式一种分层的</span><br>    <span class="hljs-comment">//而FastWriter 就是一种正常的字符串样子</span><br>    string json_string=writer.<span class="hljs-built_in">write</span>(root);<span class="hljs-comment">//这里的返回值是一个string类型的对象</span><br>    <span class="hljs-comment">//现在我们就完成了一个序列化的过程</span><br>    cout&lt;&lt;json_string&lt;&lt;endl;<br><span class="hljs-comment">//序列化之后就能发送给对端了</span><br><br><br>    <span class="hljs-comment">//接下来就需要反序列化</span><br><span class="hljs-comment">//假如说对端发送的是这个</span><br>    string jsontostruct=<span class="hljs-string">R&quot;(&#123;&quot;datax&quot;:10,&quot;datay&quot;:20,&quot;operator&quot;:42&#125;)&quot;</span>;<span class="hljs-comment">//R是把（）里面的东西当中最原始的东西来看待,避免对里面的&quot;&quot;做转义</span><br>    Json::Reader reader;<span class="hljs-comment">//调用里面的读取</span><br>    Json::Value rooter;<br>    <span class="hljs-comment">//将字符串翻译成结构化的数据</span><br>    reader.<span class="hljs-built_in">parse</span>(jsontostruct,rooter);<br>    <span class="hljs-type">request_t</span> reqr;<br>    reqr.x=rooter[<span class="hljs-string">&quot;datax&quot;</span>].<span class="hljs-built_in">asInt</span>();<span class="hljs-comment">//类似于map,我们定义的datax=x,把它当作一个整数来看待</span><br>    reqr.y=rooter[<span class="hljs-string">&quot;datay&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>    reqr.opt=(<span class="hljs-type">char</span>)root[<span class="hljs-string">&quot;operator&quot;</span>].<span class="hljs-built_in">asUInt</span>();<span class="hljs-comment">//这样就可以获得他的对应的东西了，强转成char类型</span><br>    cout&lt;&lt;reqr.opt&lt;&lt;endl;<br>    cout&lt;&lt;reqr.x&lt;&lt;reqr.opt&lt;&lt;reqr.y&lt;&lt;endl;<br>    <span class="hljs-comment">// cout&lt;&lt;jsontostruct&lt;&lt;endl;</span><br>    <span class="hljs-comment">//这样就读取到里面的内容了</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9af114c02fab415fbc353a9664baea35.png" alt="在这里插入图片描述"></p><h3 id="网络在线计算器"><a href="#网络在线计算器" class="headerlink" title="网络在线计算器"></a>网络在线计算器</h3><p>S o c k . h p p Sock.hpp Sock.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">//这些静态的套接字都是属于类而不属于对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sock</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span>  <span class="hljs-title">Socket</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sockfd=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(sockfd&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sockfd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(sockfd,<span class="hljs-number">5</span>)&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">4</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">uint16_t</span> port)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> local;<br>        <span class="hljs-built_in">memset</span>(&amp;local,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(local));<br>        local.sin_family=AF_INET;<br>        local.sin_addr.s_addr=INADDR_ANY;<br>        local.sin_port=<span class="hljs-built_in">htons</span>(port);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;local,<span class="hljs-built_in">sizeof</span>(local))&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">Accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> peer;<br>        <span class="hljs-built_in">bzero</span>(&amp;peer,<span class="hljs-number">0</span>);<br>        <span class="hljs-type">socklen_t</span> len=<span class="hljs-built_in">sizeof</span>(peer);<br>        <span class="hljs-type">int</span> fd=<span class="hljs-built_in">accept</span>(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;peer,&amp;len);<br>        <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,string ip,<span class="hljs-type">int</span> port)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> svr;<br>        <span class="hljs-built_in">memset</span>(&amp;svr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(svr));<br>        svr.sin_family=AF_INET;<br>        svr.sin_port=<span class="hljs-built_in">htons</span>(port);<br>        svr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(ip.<span class="hljs-built_in">c_str</span>());<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;svr,<span class="hljs-built_in">sizeof</span>(svr))&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">6</span>);<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>p r o t o c o l . h p p protocol.hpp protocol.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//我们在通信的时候要自己定制协议</span><br><span class="hljs-comment">//客户端和服务器要进行计算器的功能，我们要有请求有响应</span><br><span class="hljs-comment">//这个本质上是一个应用层网络服务</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jsoncpp/json/json.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定制协议的过程，目前就是定制结构化数据的过程</span><br><span class="hljs-comment">//请求格式</span><br><span class="hljs-comment">//但是向这种,如果面对的是老客户端,一旦有一个字节没有办法发送过来,就出现了错误</span><br><br><span class="hljs-comment">//我们需要序列化这个东西</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">request_t</span><br>&#123;<br>    <span class="hljs-type">int</span> x;    <span class="hljs-comment">// 10</span><br>    <span class="hljs-type">int</span> y;    <span class="hljs-comment">// 0</span><br>    <span class="hljs-type">char</span> opt; <span class="hljs-comment">//我们协议上是支持  //</span><br>    <span class="hljs-built_in">request_t</span>() = <span class="hljs-keyword">default</span>;<br>&#125;; <span class="hljs-comment">//请求协议</span><br><br><span class="hljs-comment">//这里我们写一个响应格式</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">response_t</span><br>&#123;<br>    <span class="hljs-type">int</span> code;   <span class="hljs-comment">//程序运算完毕的计算状态，code=0（success），code=-1（：\0）,code=-2(%0)，先检测code，得到result才有意义</span><br>    <span class="hljs-type">int</span> result; <span class="hljs-comment">//计算结果,能否区分是正常的计算结果，还是异常退出结果</span><br>&#125;;<br><br><span class="hljs-comment">//这里的话我们实现一个序列化请求的函数</span><br><span class="hljs-type">request_t</span> ----&gt;<span class="hljs-function">string</span><br><span class="hljs-function">string <span class="hljs-title">ReqSerialize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">request_t</span> &amp;req)</span></span><br><span class="hljs-function"></span>&#123;<br>    Json::Value root;<br>    root[<span class="hljs-string">&quot;one&quot;</span>] = req.x;<br>    root[<span class="hljs-string">&quot;two&quot;</span>] = req.y;<br>    root[<span class="hljs-string">&quot;operator&quot;</span>] = req.opt;<br>    Json::FastWriter writer;<br>    string sendwriter = writer.<span class="hljs-built_in">write</span>(root);<span class="hljs-comment">//调用write之后，就实现了序列化</span><br>    <span class="hljs-keyword">return</span> sendwriter; <span class="hljs-comment">//返回序列化之后的字符串</span><br>&#125;<br><br><span class="hljs-comment">//这里实现一个反序列化的函数</span><br><span class="hljs-comment">// string---&gt;request_t</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReqReSerialize</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;jsonstring, <span class="hljs-type">request_t</span> &amp;req)</span></span><br><span class="hljs-function"></span>&#123;<br>    Json::Reader reader;<br>    Json::Value  root;<br>    reader.<span class="hljs-built_in">parse</span>(jsonstring, root); <span class="hljs-comment">//解析进行反序列化</span><br>    req.x = root[<span class="hljs-string">&quot;one&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>    req.y = root[<span class="hljs-string">&quot;two&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>    req.opt =(<span class="hljs-type">char</span>) root[<span class="hljs-string">&quot;operator&quot;</span>].<span class="hljs-built_in">asUInt</span>();<br>&#125;<br><br><br><span class="hljs-comment">//序列化响应的函数</span><br><span class="hljs-type">response_t</span> -----&gt;<span class="hljs-function">string</span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">RespSerialize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">response_t</span> &amp;resp)</span></span><br><span class="hljs-function"></span>&#123;<br>    Json::Value root;<br>    root[<span class="hljs-string">&quot;code&quot;</span>]=resp.code;<br>    root[<span class="hljs-string">&quot;result&quot;</span>]=resp.result;<br>    Json::FastWriter writer;<br>    string sendwriter = writer.<span class="hljs-built_in">write</span>(root);<br>    <span class="hljs-keyword">return</span> sendwriter; <span class="hljs-comment">//返回序列化之后的字符串</span><br>&#125;<br><br><br><span class="hljs-comment">//这里实现一个反序列化响应的函数</span><br><span class="hljs-comment">// string---&gt;response_t</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RespReSerialize</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;jsonstring, <span class="hljs-type">response_t</span> &amp;resp)</span></span><br><span class="hljs-function"></span>&#123;<br>    Json::Reader reader;<br>    Json::Value  root;<br>    reader.<span class="hljs-built_in">parse</span>(jsonstring, root); <span class="hljs-comment">//解析进行反序列化</span><br>    resp.code = root[<span class="hljs-string">&quot;code&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>    resp.result = root[<span class="hljs-string">&quot;result&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>c l i e n t . c c client.cc client.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;protocol.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sock.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ip+port&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">uint16_t</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">int</span> sockfd = Sock::<span class="hljs-built_in">Socket</span>();<br>    Sock::<span class="hljs-built_in">Connect</span>(sockfd, argv[<span class="hljs-number">1</span>], port);<br>    <span class="hljs-type">request_t</span> req;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Please Enter Data One# &quot;</span>;<br>    cin &gt;&gt; req.x;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Please Enter Data Two# &quot;</span>;<br>    cin &gt;&gt; req.y;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Please Enter Data Opt# &quot;</span>;<br>    cin &gt;&gt; req.opt;<br>    string sendwriter=<span class="hljs-built_in">ReqSerialize</span>(req);<br>    <span class="hljs-built_in">write</span>(sockfd, sendwriter.<span class="hljs-built_in">c_str</span>(), sendwriter.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-comment">//这样就序列化成功了</span><br>    <span class="hljs-comment">//读取信息</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">ssize_t</span> s = <span class="hljs-built_in">read</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//对resp进行反序列化</span><br>    <span class="hljs-type">response_t</span> resp;<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        buf[s] = <span class="hljs-number">0</span>;<br>        string msg = buf;<br>        <span class="hljs-comment">// cout&lt;&lt;msg&lt;&lt;endl;</span><br>        <span class="hljs-comment">//对响应进行反序列化完成</span><br>        <span class="hljs-built_in">RespReSerialize</span>(msg, resp);<br>        cout &lt;&lt; <span class="hljs-string">&quot;code[0:success]: &quot;</span> &lt;&lt; resp.code;<br>        cout &lt;&lt; <span class="hljs-string">&quot;result &quot;</span> &lt;&lt; resp.result &lt;&lt; endl;<br>       <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>s e r v e r . c c server.cc server.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;protocol.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sock.hpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">HandlerRequest</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-type">int</span> sockfd = *(<span class="hljs-type">int</span> *)args;<br>    <span class="hljs-keyword">delete</span> args;<br><br>    <span class="hljs-comment">//业务逻辑，先读先要放序列化，然后计算，判断结果是否正确，正确返回，不正确异常</span><br>    <span class="hljs-comment">//做一个短服务，request -&gt; 分析处理  -&gt;构建response  -&gt;sent（response）---&gt;close(sock)</span><br><br>    <span class="hljs-comment">// verson1:没有明显的序列化和反序列化的过程</span><br>    <span class="hljs-comment">// 1.读取请求,但是这样的操作对于90%的情况是可以满足的,但是对于一些老的服务器就不可以使用了</span><br><br>    <span class="hljs-comment">//直接发的话缺少了一个序列化和放序列化的过程</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-type">ssize_t</span> s = <span class="hljs-built_in">read</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">close</span>(sockfd);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;client quit...&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">close</span>(sockfd);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//只要大于0就认为读取成功了</span><br>        buf[s] = <span class="hljs-number">0</span>;<br>        string msg = buf;<br>        <span class="hljs-type">request_t</span> req;<br>        <span class="hljs-comment">//进行对字符串的反序列化请求</span><br>        <span class="hljs-built_in">ReqReSerialize</span>(msg, req);<br><br>        <span class="hljs-comment">//读取过来要进行一个反序列化的过程</span><br><br>        <span class="hljs-comment">// if (s == sizeof(req)) //因为传送过来的是一个结构体,所以就是==</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//读取到了一个完整的请求,待定</span><br>        <span class="hljs-comment">// req.x,req.y,req.opt</span><br>        <span class="hljs-comment">// 2.分析请求</span><br>        <span class="hljs-comment">// 3.计算结果</span><br>        <span class="hljs-type">response_t</span> resp = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//响应,这里的默认响应结果我们都给他设置为0,默认都设置为0</span><br>        <span class="hljs-comment">// 4.构建响应,并进行返回</span><br>        <span class="hljs-keyword">switch</span> (req.opt)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            resp.result = req.x + req.y;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            resp.result = req.x - req.y;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            resp.result = req.x * req.y;<br><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">if</span> (req.y == <span class="hljs-number">0</span>)<br>                resp.code = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                resp.result = req.x / req.y;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>            <span class="hljs-keyword">if</span> (req.y == <span class="hljs-number">0</span>)<br>                resp.code = <span class="hljs-number">-2</span>;<br>            <span class="hljs-keyword">else</span><br>                resp.result = req.x % req.y;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            resp.code = <span class="hljs-number">-3</span>; <span class="hljs-comment">//代表我们的请求方法异常</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//处理完之后就要返回响应</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;request &quot;</span> &lt;&lt; req.x &lt;&lt; req.opt &lt;&lt; req.y &lt;&lt; endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;response &quot;</span>&lt;&lt;resp.result&lt;&lt;endl;<br>        <span class="hljs-comment">//这次我们要先对resp进行序列化</span><br>        string send_msg = <span class="hljs-built_in">RespSerialize</span>(resp);<br>        cout&lt;&lt;send_msg&lt;&lt;endl;<br>        <span class="hljs-built_in">write</span>(sockfd, send_msg.<span class="hljs-built_in">c_str</span>(), send_msg.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">//序列化之后再发送回去</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;server finish&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 5.关闭链接</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ip&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">uint16_t</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> sockfd = Sock::<span class="hljs-built_in">Socket</span>();<br>    Sock::<span class="hljs-built_in">Bind</span>(sockfd, port);<br>    Sock::<span class="hljs-built_in">Listen</span>(sockfd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> newsockfd = Sock::<span class="hljs-built_in">Accept</span>(sockfd);<br>        <span class="hljs-keyword">if</span> (newsockfd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">pthread_t</span> tid;<br>        <span class="hljs-type">int</span> *pram = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(newsockfd);<br>        <span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">nullptr</span>, HandlerRequest, (<span class="hljs-type">void</span> *)pram);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们刚刚写的cs模式的在线版本计算器，本质上是一个应用层网络服务</p><blockquote><ol><li>基本通信代码是我们自己写的————————（会话层：进行通信管理）</li><li>序列化和反序列化时我们使用组件完成的————（表示层：设备固有数据格式和网络标准数据格式的转换）</li><li>请求，结果格式，code含义，等约定是我们自己写的————（针对特定应用的协议）</li><li>业务逻辑（计算也是我们自己写的）</li></ol></blockquote><p>HTTP协议，本质上，在定位上和我们刚刚写的网络计算机，没有区别，都是应用层协议</p><ol><li>网络通信</li><li>序列化和反序列化</li><li>协议细节<br>http协议把这3点都实现了</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程</title>
    <link href="/2022/07/11/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/07/11/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_4">套接字预备知识</a></li><li><ul><li><a href="#ip_10">套接字，端口号，ip</a></li><li><a href="#PID_35">端口号和PID</a></li></ul></li><li><a href="#TCPUDP__52">TCP和UDP 协议的初识</a></li><li><a href="#_77">网络字节序</a></li><li><a href="#socket_116">socket编程</a></li><li><ul><li><a href="#socketAPI_120">socket的API</a></li><li><a href="#sockaddr__151">sockaddr 的结构</a></li></ul></li><li><a href="#_191">地址转换函数</a></li><li><a href="#UDP_236">UDP服务器</a></li><li><a href="#TCP_398">TCP服务器</a></li><li><a href="#_399">多进程模式</a></li><li><ul><li><a href="#_520">线程池模式</a></li><li><a href="#popen_834">popen</a></li><li><a href="#netstate_843">netstate</a></li></ul></li></ul><p>这篇博客一直写写停停拖了半个月才出来</p><h1 id="套接字预备知识"><a href="#套接字预备知识" class="headerlink" title="套接字预备知识"></a>套接字预备知识</h1><p>我们所写的程序都是在用户层进行开发，或者说是在应用层进行协议的创建和规定，所以我们所用到的接口都是传输层所用到的接口，也就是系统调用接口，也就是说，我们后面所学的套接字接口，所用的都是传输层的接口</p><p>两个主机之间的通信，是不是可以认为是两个主机硬件之间的通信，</p><blockquote><p>答案既可以是，也可以不是，实际上，硬件是承当两台主机进行通信的载体不错，但是，进行通信的是两台主机里面分别的进程，即两个进程之间进行通信，也即是软件层面上的</p></blockquote><h2 id="套接字，端口号，ip"><a href="#套接字，端口号，ip" class="headerlink" title="套接字，端口号，ip"></a>套接字，端口号，ip</h2><blockquote><p>IP地址（公网ip），唯一标识互联网中的一台主机<br>源IP，目的IP：对一个报文来说就是，从哪来到哪去，<br>这个最大的意义：就是指导一个报文进行路径选择，到哪里去：本质就是让我们根据目标进行路径进行路径选择的依据！<br>下一跳设备（mac地址的变化）</p></blockquote><p>我们今天，这里更加专业和准确的来说，套接字本质就是进程之间的通信（是指不同主机之间的进程）<br>而ip地址的主机的唯一性，但是在这个主机上有很多进程，那么我应该怎么去确定我应该给哪一台主机呢？<br>所以，我们还需要通过某种方式来去表示特定主机上的某种进程，而标识进程的方式，我们就叫做端口号</p><p>端口号我们就是可以去标识一台主机里面唯一的进程<br>而用ip和端口号我们就能标识全网范围内的唯一主机上面的唯一进程</p><p>套接字&#x3D;ip地址+端口号（端口号是一个16位的比特位）</p><p><img src="https://img-blog.csdnimg.cn/85e54d55879a41528ea4f3d82946ffdb.png" alt="在这里插入图片描述"></p><blockquote><p>我们学的网络通信，是站在人与人之间的通信<br>技术人员的视角：我们学到的网络通信，本质上是进程间的通信！！<br>(跨网络进行进程间通信)<br>比如：抖音的app客户端（进程）《-》抖音的服务器（也是一个进程）<br>IP仅仅知识解决了两台物理机器之间的通信<br>但是我们要考虑双方用户之间能够看到发送和接收数据，应用层上都有进程</p></blockquote><h2 id="端口号和PID"><a href="#端口号和PID" class="headerlink" title="端口号和PID"></a>端口号和PID</h2><blockquote><p>每个进程都会有PID，但是一个进程必须是要有网络进程才会有端口后<br>{注意：一个端口号只能由一个进程占用，但是一个进程可以有多个端口号}<br>（10086就相当于一个IP地址，（打过去之后叫了人工服务）而某一个人工就相当于是一个端口号，然后他的身份证就相当于是PID）</p></blockquote><p>为了解耦（如果操作系统对于进程的标识方法变化的话，所有东西都要变化，但是如果用端口号的话，它只在网络中使用，不影响其他地方）<br>总结：</p><blockquote><ol><li>端口号就是一个2字节16位的整数</li><li>端口号用来标识一个进程，告诉操作系统，当前这个数据是要交给哪一个进程来处理</li><li>一个端口用只能被一个进程占用</li><li>ip地址+端口号能够用来标识网络上某一台主机的某一个进程</li></ol></blockquote><p>互联网世界，是一个进程间通信的世界</p><blockquote><p>万物互联就是每一个机器上都有一个进程，每一个进程就可以收集各种进程间的消息，还可以和其他进程之间通信，这样就可以获得了</p></blockquote><h1 id="TCP和UDP-协议的初识"><a href="#TCP和UDP-协议的初识" class="headerlink" title="TCP和UDP 协议的初识"></a>TCP和UDP 协议的初识</h1><p>因为我们要在应用层上写程序，而离应用层最近的就是传输层，所以我们使用的就是传输层接口<br>TCP协议特点（初始）</p><blockquote><ul><li>传输层协议</li><li>有连接</li><li>可靠传输</li><li>面向字节流</li></ul></blockquote><p>UDP 协议特点（初始）</p><blockquote><ul><li>传输层协议</li><li>无连接</li><li>不可靠传输</li><li>面向数据报</li></ul></blockquote><blockquote><p>tcp的可靠和不可靠是一个中性词，在直播的时候，就是使用UDP，<br>标准：非用tcp不可的就是用tco，处于成本考虑，也可以使用UDP，实在不会的话就使用TCP，<br>TCP协议需要解决数据传错了怎么办，丢包了怎么办，对方来不及接收怎么办，网络堵塞了怎么办<br>就是说，他会把大量的问题都要很好的解决，这样也就直接决定了TCP 的特点（相对于UDP来说，会比较复杂）。放过来UDP就比较的简单高效</p></blockquote><p>为什么还需要不可靠的传输协议</p><blockquote><p>可靠意味着需要举行的更多的工作来保证可靠性，成本也会更加多，效率也会更低一点，不可靠协议的特点就是简单，高效，实际上，我们需要根据需求来选择不同的协议</p></blockquote><h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><p>小端法（pc本机） 大端法（网络）<br>我们现在的机器都是小端，但是有没有一种可能，我们这边是小端机器，但是对面的服务器是大端机呢，这样的化，我们按照小端字节序发出去的数据，到了对方的服务器上面使用大端的方式来接收，就会造成错乱<br>那么如何解决这个问题呢？</p><p>我们网络中规定：所有的网络中所跑到 数据都是打断的数据，如果是小端（数据的低位保存在内存的低地址中，高位保存在内存的高地址）机器，都是需要先转化成为大端（数据的地位保存在内存的高地址，高位保存在内存的低地址）之后，才能进行发送或者接收，然后先发送或者接收低地址的数据，再是高地址的数据</p><blockquote><p>总结来说，其</p><ol><li>发送主机通常把缓冲区的数据按照内存地址的从低到搞的顺序进行发出</li><li>接收主机把从网络上接到的字节一次保存再接收缓冲区里面，也是按照内存地址从低到高的顺序保存</li><li>因此，网络数据流的地址应该这样进行规定，先发出的数据是低地址，后发出的数据就是高地址</li><li>TCP&#x2F;IP协议规定，，网络数据流应该采用大端字节序，即低地址高字节</li><li>不管这台主机是大端机还是小端机，都会按照这个TCP&#x2F;IP规定的网络字节序来发送&#x2F;接收数据，如果当前发送的主机是小端机，就需要先将数据转化成为大端，否者就忽略们直接发就可以了</li></ol></blockquote><p>为什么要规定成大端呢</p><blockquote><p>因为这样，我们先就可以接收到低地址的数据，就是高位权重的数据<br>这样我们可以将高位放在高的位置，可以实现变实现边计算<br>同样，当我们接收字符串等待消息的时候，接收的信息就可以按照我们视觉中的从左万右出现，而不是先接收到最后一位，然后不断的头插操作<br>即：大端更加符合我们的阅读习惯</p></blockquote><p>为了使得网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能够正常的运行，可以调用以下库函数左网络字节序和主机字节序的转换<br><img src="https://img-blog.csdnimg.cn/715722d149e04ee09d8dfbe405478504.png" alt="在这里插入图片描述"><br>h标识host（主机）<br>n标识network（网络）<br>例如</p><blockquote><p>htonl表示将32位长整数从主机转化位网络字节序，例如将ip地址转化后准备发送（因为ip就是32位，4字节），ip协议<br>（192.168.0.102），这个是string我们想要使用的话，就要先把这个转化成为整数<br>如果主机是小端字节序。这些函数将参数左对应的大小端转换然后返回<br>如果是主机是大端字节序，就不用改变</p></blockquote><blockquote><p>htons将16位长整型数从主机转化成网络字节序，例如端口（port）<br>nthos，将16位长整数从网络转化为主机里面</p></blockquote><blockquote><p>string转到网络字节序如192.168.0.122<br>string-&gt;atoi-&gt;int-&gt;htol—&gt;网络字节序</p></blockquote><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>socket创建套接字的流程</p><h2 id="socket的API"><a href="#socket的API" class="headerlink" title="socket的API"></a>socket的API</h2><blockquote><p>#include&lt;sys&#x2F;type.h&gt;<br>#include&lt;sys&#x2F;socket.h&gt;</p><p>int socket(int domain,int type,int protocol);&#x2F;&#x2F;创建一个端点进行通信<br>返回的是socket的文件描述符，（TCP&#x2F;UDP,客户端和服务器）</p></blockquote><blockquote><p>int bind(int sockfd ，const struct sockaddr* address,socklen_t address_len);<br>绑定端口号（TCP&#x2F;UDP，服务器）</p></blockquote><blockquote><p>int listen(int socket ,int backlog)<br>;开始监听socket（tcp，服务器）<br>backlog：全连接队列的最大长度，如果有多个客户端发送过来请求，此时 没有被连接上的就会被放在一个链接队列李米娜，该传输表示的就是全连接队列的最大长度，一般不要设置太大，设置5.&#x2F;10即可<br>我们一开始创建的套接字并不是一个普通的套接字，而应该要叫做监听套接字，</p></blockquote><blockquote><p>int accept(int socket,struct sockaddr* address,socklen_t * address_len)’<br>接受请求</p></blockquote><blockquote><p>int connect (int sockfd,const struct sockaddr* addr,socklen_t addrlen)<br>建立连接</p></blockquote><p>调用accept函数获取连接时，是从监听套接字里面获取的，如果accept连接成功，就会返回接收到的套接字对应的文件描述符</p><p>监听套接字和accept函数返回的套接字的作用：</p><ul><li>监听套接字：用于获取客户端发来的请求，accpt函数会不断从监听套接字里面获取新的连接</li><li>accept函数防护的套接字，用于为本次accpet获取到的连接提供服务。监听套接字的任务知识不断的获取连接，真正为这些连接提供服务的是accpet函数套接字</li></ul><h2 id="sockaddr-的结构"><a href="#sockaddr-的结构" class="headerlink" title="sockaddr 的结构"></a>sockaddr 的结构</h2><blockquote><p>网络通信的标准又很多种,基于ip的网络通信,AF_INET,原始套接字,域间套接字<br>我们想让这些接口系统的统一化,sockaddr也就是一个通用结构<br><img src="https://img-blog.csdnimg.cn/adb38be5f01d4d6aa8f40c4fc177cbb8.png" alt="在这里插入图片描述"><br>struct sockaddr_in把里面的14个字节进行细分了一下，然后sockaddr就被废弃了，所以我们在实际定义的时候就是定义struct sockaddr_in,在调用这个函数的时候要进行强制类型转换</p></blockquote><p>#include&lt;netinet&#x2F;in.h&gt;</p><ul><li>sockaddr_in(inet) 是用来进行网络通信的，</li><li>sockaddr_un 是用来进行本地通信的 、</li><li>sockaddr_in结构体存储了协议类型，端口号，ip地址等信息，网络通信时可以通过这个结构体把自己的信息发送给对方，也可以通过这个结构体获取远端的信息</li><li>可以看出，着3个结构体的前面16位都是一样的，代表的就是协议家族，可以根据这个参数判断需要进行哪一种特性（本地和跨网络）</li><li>ipv4, ipv6的地址格式定义在netinet &#x2F;in.h中,ipv4地址用socketaddr_in,结构体表示，包括16位地址类型，16位端口号，32位ip地址</li><li>ipv4和ipv6地址类型分别定义为常数AF_INET,AF_INET6，只要取得某种socketaddr结构体的首地址，不需要知道具体是哪一种类型的结构体，就可以根据地址类型字段确定结构体中的内容</li><li>socket API可以都用struct sockaddr* 类型表示，在使用的时候需要强制转化成sockaddr，这样好处是程序的通用性，可以接收ipv4和ipv6以及unix domain socket各种类型的sockaddr结构体指针为参数，</li></ul><p>sockaddr_in的结构体：因为我们主要用到网络通信，所以这里主要介绍这个结构体，</p><p><img src="https://img-blog.csdnimg.cn/374b49e252ed41c2a7190c57d9642bc4.png" alt="在这里插入图片描述"><br>sin_family 代表的是地址类型，我们主要用的是AF_INET，<br>sin_port代表的是端口号，这个是网络字节序的端口号，用之前要先htons初始化<br>sin_addr代表的是网络地址（也就是ip地址），用一个结构体struct in_addr来进行描述（这里填充的是ipv4的地址，一个32位整数），还要使用htonl将string转化成为网络字节序，要用inet_pton<br>但是这里的ip地址的类型是struct in_addr{uint32_t s_addr}</p><p>我们使用的时候就要用这个东西进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span><br>addr.sin_family=AF_INET;<br>add.sin_port=htos(port);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int dst;</span><br><span class="hljs-comment">inet_pton(AF,INET,&quot;192.233.1.200&quot;,(void*)dst)</span><br><span class="hljs-comment">addr.sin_addr.s_addr=dst;//</span><br><span class="hljs-comment">*/</span><br>addr.sin_addr.s_addr=htonl(INADDR_ANY)<span class="hljs-comment">//取出系统中有效的任意ip地址</span><br>bind((<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr,size);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h1><p>ip地址可以用点分十进制的字符串如127.0.0.1，也可以用一个32整数来表示，其中就涉及到二者之间 的转换一下是两者相互转化的库函数<br>字符串转in_addr(32位整数)</p><blockquote><p>#include&lt;arpa&#x2F;inet.h&gt;<br>int inet_aton(const char* cp,struct in_addr* inp);<br>in_addr_t inet_addr(const char* cp);</p></blockquote><blockquote><p>int inet_pton(int af,const char* src,void* dst);p即ip，n就是网络，将ip中的string转化成为网络字节序，所以返回值是int<br>这里的af就是ip地址家族，ip协议类型（只能是AF_INET，或者AF_INET6）<br>src就是我们要转的ip地址（点分是10进制的）</p><p>dst就是传出参数，就是转化后的网络字节序的ip地址，<br>返回值：成功返回1，如果返回0说明src里面的字符串并不代表一个有效的ip地址，-1的话就是我们输入的af并非AF_INET,或者说AF_INET6,错误码设置成EAFNOSUPPORT</p></blockquote><blockquote><p>const char* inet_ntop(int af,const void* src,char* dst,socklen_t size);&#x2F;&#x2F;将网络字节序转化位ip地址，所以返回值是string<br>af就是ip协议，<br>src就是我们要转化的整数，网络字节序中的ip地址<br>dst就是转换后位字符串的ip地址<br>socklen_t size就是dst的大小<br>返回值，成功返回非空字符串指向dst，失败返回null，<br>errno里面可以查看错误的原因</p></blockquote><p>字符串转整数的函数<br>inet_addr</p><blockquote><p>函数原型</p><blockquote><p>in_addr_t inet_addr(const char* cp)<br>参数:</p></blockquote><ul><li>cp点分10进制的字符串ip</li></ul><p>返回值:整数ip</p></blockquote><p>整数转字符串的函数</p><p>in_addr转字符串的函数</p><blockquote><p>char * inet_ntoa(struct in_addr in)<br>in 是描述ip地址的结构体<br>返回值:字符串IP</p></blockquote><p>const char* inet_ntop(int af,const void* src,char* dst,socklen_t size);&#x2F;&#x2F;</p><h1 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h1><p>server.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cerrno&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;port&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 1.创建套接字，打开网络文件，作为一个服务器，要让客户知道对应的服务器的地址，不然就不会访问了</span><br>    <span class="hljs-comment">//服务器的socket消息，必须得被客户知道，一般的服务器的port，必须是众所周知的（人，app，），而且轻易不能被改变，</span><br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;socket create error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.要给服务器绑定服务器的ip和端口号</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> local;<br>    local.sin_family = AF_INET;<br>    local.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>])); <span class="hljs-comment">//这里面使用的都必须是主机序列</span><br>    <span class="hljs-comment">//云服务器不能允许用户直接绑定公网ip，实际正常写的时候，也不会直接指明ip</span><br>    <span class="hljs-comment">// local.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);//将字符串序列的点分十进制的风格转化为主机序列</span><br>    local.sin_addr.s_addr = INADDR_ANY; <span class="hljs-comment">//如果bind是确定的ip（主机），意味着，只有发到该ip主机上的数据，才会交给你的网络进程，但是，一般服务器可能有多张网卡，配置多个ip，我们需要的是所有发送到该主机</span><br>    <span class="hljs-comment">//该端口的数据，我不关心这个数据是从哪个ip上的，只要绑定我这个端口，全部数据我都要，一般我们都是用这个</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;local, <span class="hljs-built_in">sizeof</span>(local)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;bind cerror &quot;</span> &lt;&lt; errno &lt;&lt; endl; <span class="hljs-comment">//把错误码也加上</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// UDP服务器就写完了</span><br>    <span class="hljs-comment">// 3.接下来就是提供服务</span><br>    <span class="hljs-type">bool</span> quit = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!quit)<br>    &#123;<br>        <span class="hljs-comment">//和普通文件的读取有差别</span><br>        <span class="hljs-comment">//在udp里面读取数据就要使用recvfrom</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> peer;<br>        <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(peer);<br>        <span class="hljs-comment">//注意，我们在同行的时候双方是互相发送字符串的，（但是对于文件来说，\0是c，c++的标准），不认为发送字符串</span><br>        <span class="hljs-type">ssize_t</span> s = <span class="hljs-built_in">recvfrom</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;peer, &amp;len); <span class="hljs-comment">//这里面会返回客户端的消息,-1是为了把它当作字符串看待，</span><br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//在网络通信中，只有报文大小，或者是字节流中字节的个数，没有c/c++字符串这样的概念，（后续我们可以自己处理）</span><br>            buf[s] = <span class="hljs-number">0</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;client # &quot;</span> &lt;&lt; buf &lt;&lt; endl;<br>            <span class="hljs-comment">//我们接收的可能是一个命令，服务器执行这个命令，在客户端上面跑</span><br>            FILE* fp=<span class="hljs-built_in">popen</span>(buf,<span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-comment">//把这个命令传进去,我们实现了一个命令行解释器</span><br>            <span class="hljs-comment">//读文件</span><br>            <span class="hljs-type">char</span> t[<span class="hljs-number">1024</span>];<br>            string ech;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fgets</span>(t,<span class="hljs-built_in">sizeof</span>(t),fp))<span class="hljs-comment">//读到空就结束</span><br>            &#123;<br>                ech+=t;<span class="hljs-comment">//里面就是各种内容</span><br>            &#125;<br>            <span class="hljs-built_in">pclose</span>(fp);<br><br>            ech += <span class="hljs-string">&quot;.....&quot;</span>;<br>            <span class="hljs-comment">//如果我写的udp无法通信，云服务器开放服务，首先需要开放端口，默认的云平台是没有开发特定的端口的，需要所有者，再网络后开放端口</span><br>            <span class="hljs-built_in">sendto</span>(sockfd, ech.<span class="hljs-built_in">c_str</span>(), ech.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;peer, len);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>client.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-comment">//要知道server对应的ip和port</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ip+port&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;socket error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//这里就不需要再继续绑定了，直接发送数据过去就可以了，不需要显示的bind</span><br>    <span class="hljs-comment">// 1.首先客户端也必须要有ip和port</span><br>    <span class="hljs-comment">// 2，但是客户端不需要显示bind，一旦显示bind，就必须明确，client和哪一个port进行关联，那么有可能会出现冲突</span><br>    <span class="hljs-comment">//有可能被占用，就会导致客户端无法使用，服务器用的是port必须明确，而且不变但client只要有就可以了</span><br>    <span class="hljs-comment">//一般是操作系统自动绑定的，就是client正常发送数据的时候，操作系统就会自动绑定</span><br><br>    <span class="hljs-comment">//使用服务</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//发送数据</span><br>        <span class="hljs-comment">//数据从哪里来，要给谁发送</span><br>        string msg;<br>        <span class="hljs-comment">// cin &gt;&gt; msg;</span><br>        <span class="hljs-comment">// getline(cin,msg);</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;Myshell$ &quot;</span>;<br>        <span class="hljs-type">char</span> line[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">fgets</span>(line,<span class="hljs-built_in">sizeof</span>(line),stdin);<span class="hljs-comment">//从键盘里面读取</span><br><br>        <span class="hljs-comment">//因为我们要发送的是命令，所以是一整行</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server;<br>        server.sin_family = AF_INET;<br>        server.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br>        server.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(argv[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">sendto</span>(sockfd, line, <span class="hljs-built_in">strlen</span>(line), <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-built_in">sizeof</span>(server));<span class="hljs-comment">//发送的大小是不包含\0</span><br><br>        <span class="hljs-comment">//接收</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> tmp;<br>        <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(tmp);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">ssize_t</span> s = <span class="hljs-built_in">recvfrom</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;tmp, &amp;len); <span class="hljs-comment">// tmp就是一个占位符的概念，里面没有什么用</span><br>        <span class="hljs-comment">//会接收到接收的字节数</span><br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//假如说发送的是hello，5个字节</span><br>            <span class="hljs-comment">//我们接收端把它当作字符串，就要在最后一个位置加上\0</span><br>            buf[s] = <span class="hljs-number">0</span>;<br>            cout &lt;&lt; buf &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cerr&lt;&lt;<span class="hljs-string">&quot;recvfrom error&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h1><h1 id="多进程模式"><a href="#多进程模式" class="headerlink" title="多进程模式"></a>多进程模式</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serverio</span><span class="hljs-params">(<span class="hljs-type">int</span> newsockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//因为TCP 是面向字节流的,就如同文件一样,就可以进行正常的读写</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-type">ssize_t</span> s = <span class="hljs-built_in">read</span>(newsockfd, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            buf[s] = <span class="hljs-number">0</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;client # &quot;</span> &lt;&lt; buf &lt;&lt; endl;<br>            string echo = <span class="hljs-string">&quot;server send &quot;</span>;<br>            echo += buf;<br>            <span class="hljs-built_in">write</span>(newsockfd, echo.<span class="hljs-built_in">c_str</span>(), echo.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;client quit&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//客户端ctrl c之后就断开了连接</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cerr &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;socket error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> local;<br>    <span class="hljs-built_in">memset</span>(&amp;local, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(local));<br>    local.sin_family = AF_INET;<br>    local.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8080</span>);<br>    local.sin_addr.s_addr = INADDR_ANY;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;local, <span class="hljs-built_in">sizeof</span>(local)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;bind error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3.因为tcp是面向连接的,在通信的时候要建立连接,</span><br>    <span class="hljs-comment">// a在通信钱,需要建立连接,b:然后才能通信</span><br>    <span class="hljs-comment">//一般客户端来建立连接,服务器是被动接收连接</span><br>    <span class="hljs-comment">//我们当前写的是一个server,周而复始的不间断的等待客户到来</span><br>    <span class="hljs-comment">//我们要不断的给用户提供一个建立连接的功能</span><br>    <span class="hljs-comment">//设置套接字为listen状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//设置为被连接状态,这样别人就可以连接到我了</span><br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;listen error&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// signal(SIGCHLD,SIG_IGN);//子进程退出的时候会给父进程发送信号，这里我们去忽略一下子进程发送的信号,子进程会自动退出释放资源</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> peer;<br>        <span class="hljs-built_in">memset</span>(&amp;peer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(peer));<br>        <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(peer);<br>        <span class="hljs-type">int</span> newsockfd = <span class="hljs-built_in">accept</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;peer, &amp;len);<br>        <span class="hljs-keyword">if</span> (newsockfd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//连接失败就继续连接</span><br>        &#125;<br>        <span class="hljs-comment">//我们这里现在是一个单进程，一次只能允许一个人使用</span><br>        <span class="hljs-comment">//我们使用多进程来操作一下</span><br>        <span class="hljs-type">uint16_t</span> cli_port=<span class="hljs-built_in">ntohs</span>(peer.sin_port);<span class="hljs-comment">//保证代码的可移植性</span><br>        string ip=<span class="hljs-built_in">inet_ntoa</span>(peer.sin_addr);<span class="hljs-comment">//</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;get a link -&gt; : &quot;</span>&lt;&lt;cli_port&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;newsockfd&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ip&lt;&lt;endl;<span class="hljs-comment">//我们发现每一个都是4</span><br>        <span class="hljs-type">pid_t</span> id = fork();<br>        <span class="hljs-keyword">if</span> (id &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//曾经被父进程打开的fd，是否会被子进程继承？无论父子进程的哪一个，强烈建议关闭不需要的fd，监听描述符也会被子进程看到，</span><br>        <span class="hljs-comment">//我们在子进程这边把监听描述符关闭</span><br>        &#123;<br>            <span class="hljs-comment">// child</span><br>            <span class="hljs-built_in">close</span>(sockfd);<span class="hljs-comment">//只是会继承下来但是，关闭不影响其他进程</span><br>            <span class="hljs-keyword">if</span>(fork()&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//这个叫做退出的是子进程，向后走的进程是孙子进程</span><br><br>            <span class="hljs-comment">//因为父进程一进来就挂掉了，所以孙子进程就变成了孤儿进程，后会被操作系统给回收掉，</span><br>            <span class="hljs-built_in">serverio</span>(newsockfd);<br>            <span class="hljs-comment">//如果不关闭文件描述符，就会导致文件描述符泄露的问题</span><br>            <span class="hljs-built_in">close</span>(newsockfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//子进程执行完了，父进程就要等</span><br>            <span class="hljs-comment">//子进程和父进程的文件描述符是共享的，退出后要关闭文件描述符</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//do nothing ,因为父进程忽略了，所以就不需要去wait，父进程不断的建立连接，子进程不断的提供服务</span><br>            <span class="hljs-comment">//阻塞等待不需要等待，耗时间很大，所以使用忽略sigchild信号，</span><br>            <span class="hljs-built_in">waitpid</span>(id,<span class="hljs-literal">nullptr</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//这里等待的时候会不被阻塞等待太长时间，因为它子进程刚一创建出来就退出了孙子进程执行完之后就被OS给回收了</span><br>            <span class="hljs-built_in">close</span>(newsockfd);<span class="hljs-comment">//fork已经返回了</span><br>        &#125;<br>        <span class="hljs-comment">//提供服务</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池模式"><a href="#线程池模式" class="headerlink" title="线程池模式"></a>线程池模式</h2><p>serverpthread.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;threadpool.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Task.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_task;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_threadpool;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;socket error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> local;<br>    <span class="hljs-built_in">memset</span>(&amp;local, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(local));<br>    local.sin_family = AF_INET;<br>    local.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8080</span>);<br>    local.sin_addr.s_addr = INADDR_ANY;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;local, <span class="hljs-built_in">sizeof</span>(local)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;bind error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3.因为tcp是面向连接的,在通信的时候要建立连接,</span><br>    <span class="hljs-comment">// a在通信钱,需要建立连接,b:然后才能通信</span><br>    <span class="hljs-comment">//一般客户端来建立连接,服务器是被动接收连接</span><br>    <span class="hljs-comment">//我们当前写的是一个server,周而复始的不间断的等待客户到来</span><br>    <span class="hljs-comment">//我们要不断的给用户提供一个建立连接的功能</span><br>    <span class="hljs-comment">//设置套接字为listen状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//设置为被连接状态,这样别人就可以连接到我了</span><br>    &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;listen error&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// signal(SIGCHLD,SIG_IGN);//子进程退出的时候会给父进程发送信号，这里我们去忽略一下子进程发送的信号,子进程会自动退出释放资源</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> peer;<br>        <span class="hljs-built_in">memset</span>(&amp;peer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(peer));<br>        <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(peer);<br>        <span class="hljs-type">int</span> newsockfd = <span class="hljs-built_in">accept</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;peer, &amp;len);<br>        <span class="hljs-keyword">if</span> (newsockfd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//连接失败就继续连接</span><br>        &#125;<br>        <span class="hljs-comment">//我们这里现在是一个单进程，一次只能允许一个人使用</span><br>        <span class="hljs-comment">//我们使用多进程来操作一下</span><br>        <span class="hljs-type">uint16_t</span> cli_port = <span class="hljs-built_in">ntohs</span>(peer.sin_port);                                          <span class="hljs-comment">//保证代码的可移植性</span><br>        string ip = <span class="hljs-built_in">inet_ntoa</span>(peer.sin_addr);                                              <span class="hljs-comment">//</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;get a link -&gt; : &quot;</span> &lt;&lt; cli_port &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; newsockfd &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ip &lt;&lt; endl; <span class="hljs-comment">//我们发现每一个都是4</span><br>        <span class="hljs-comment">//先构建一个任务</span><br>        <span class="hljs-function">Task <span class="hljs-title">t</span><span class="hljs-params">(newsockfd)</span></span>;<br>        <span class="hljs-comment">// 2.将任务push到后端的线程池就可以了</span><br>        ThreadPool&lt;Task&gt;::<span class="hljs-built_in">GetInstance</span>()-&gt;<span class="hljs-built_in">PushTask</span>(t); <span class="hljs-comment">//这样就完了//同样这是懒汉模式</span><br><br>        <span class="hljs-comment">//这样使用的话，线程是不会增多的，退出的时候，线程池也不会再变化，这就不会有线程问题</span><br><br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//但是这样去写有两个问题</span><br><span class="hljs-comment">// 1，创建进程和线程没有上限，进程和线程越多，进程切换就有消耗，时间也就更久了，系统运行的也就特别的慢了，当客户连接来了才给客户创建进程/线程</span><br><span class="hljs-comment">//进程或者线程池版本，就可以直接用之前的线程池用进去,这里我们结合单例模式</span><br></code></pre></td></tr></table></figure><p>threadpool.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-comment">// #cludine&quot;Task.hpp&quot;</span><br><span class="hljs-comment">// using namespace ns_task;</span><br><span class="hljs-keyword">namespace</span> ns_threadpool<br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> <span class="hljs-comment">//线程池</span><br>    &#123;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num_;                  <span class="hljs-comment">//一个线程池里面有多少个任务</span><br>        std::queue&lt;T&gt; task_queue_; <span class="hljs-comment">//任务队列,临界资源</span><br>        <span class="hljs-type">pthread_mutex_t</span> mtx_;<br>        <span class="hljs-type">pthread_cond_t</span> cond_;<br>        <span class="hljs-type">static</span> ThreadPool&lt;T&gt; *ins; <span class="hljs-comment">//静态成员在所有的对象里面只有一个静态成员，必须要通过静态变量来获取对象</span><br>        <span class="hljs-comment">//保存内存的可见性</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">//单例的话，就不能让构造函数暴露在外面，否则，只有有构造函数，就能初始化</span><br>        <span class="hljs-comment">//构造函数必须得实现，当时必须得私有</span><br>        <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> num = g_num) : <span class="hljs-built_in">num_</span>(num)<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mtx_, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;cond_, <span class="hljs-literal">nullptr</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">const</span> ThreadPool &amp;tp) = <span class="hljs-keyword">delete</span>;<br>        <span class="hljs-comment">// c++11的新特性</span><br>        <span class="hljs-comment">//静止编译器生成拷贝构造，</span><br>        <span class="hljs-comment">//=delete就是禁止调用这个函数，在私有里面</span><br><br>        ThreadPool <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadPool &amp;tp) = <span class="hljs-keyword">delete</span>;<br>        <span class="hljs-comment">//把赋值运算符也禁止掉，这也就可以避免创建多个对象</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> ThreadPool&lt;T&gt; *<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> <span class="hljs-comment">//这个必须是使用静态的，非静态函数都是有对象的，静态函数才是没对象的</span></span><br><span class="hljs-function">        </span>&#123;<br><br>            <span class="hljs-type">static</span> <span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER; <span class="hljs-comment">//使用静态的初始化</span><br><br>            <span class="hljs-keyword">if</span> (ins == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//双判定，减少锁的争用，提高单例获取的效率，</span><br>            <span class="hljs-comment">//假如说有的线程进来发现不为空，就可以直接走了，如果同时为nullptr的化，那么再把他们放进来争抢锁资源、</span><br><br>            &#123;<br><br>                <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;lock); <span class="hljs-comment">//争抢锁的过程就是一个串行化的过程，成本很高</span><br><br>                <span class="hljs-comment">//当前的单例对象还没有被创建</span><br>                <span class="hljs-keyword">if</span> (ins == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-comment">//假如是在多线程的情况下，那么多个线程执行的时候，都是nullptr，都创建了对象，那么就出现了线程安全</span><br>                &#123;<br>                    <span class="hljs-comment">//就创建它</span><br>                    ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadPool</span>&lt;T&gt;(); <span class="hljs-comment">//创建一个，使用构造函数</span><br>                    <span class="hljs-comment">//创建出来了一个单例之后，就直接给他初始化一个池就行了</span><br>                    ins-&gt;<span class="hljs-built_in">InitThreadPool</span>();<br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;首次加载对象&quot;</span> &lt;&lt; std::endl;<br>                &#125;<br>                <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;lock);<br>            &#125;<br>            <span class="hljs-keyword">return</span> ins;<br>        &#125;<br><br>        ~<span class="hljs-built_in">ThreadPool</span>()<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mtx_);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond_);<br>        &#125;<br><br>        <span class="hljs-comment">//在类中，要让</span><br><br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">Rountine</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//也不能访问类里面非static成员</span></span><br><span class="hljs-function">        </span>&#123;<br><br>            <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>()); <span class="hljs-comment">//实现线程分离就不要再去join等待了</span><br>            ThreadPool&lt;T&gt; *tp = (ThreadPool&lt;T&gt; *)args;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-comment">//从任务队列里面去拿一个任务</span><br>                <span class="hljs-comment">//执行任务，要先把这个任务队列锁主</span><br><br>                <span class="hljs-comment">//每个线程他跟放任务的线程一样，都是竞争式的去拿一个任务</span><br>                tp-&gt;<span class="hljs-built_in">Lock</span>();<br>                <span class="hljs-comment">//先检测任务队列是否有一个任务</span><br>                <span class="hljs-keyword">while</span> (tp-&gt;<span class="hljs-built_in">IsEmpty</span>())<br>                &#123;<br>                    <span class="hljs-comment">//检测到任务队列为空</span><br>                    <span class="hljs-comment">//此时线程就挂起等待</span><br>                    tp-&gt;<span class="hljs-built_in">Wait</span>();<br>                &#125;<br>                <span class="hljs-comment">//该任务队列里面一定有任务了</span><br>                T t;<br>                tp-&gt;<span class="hljs-built_in">PopTask</span>(&amp;t);<br>                <span class="hljs-comment">//任务就拿到了</span><br>                tp-&gt;<span class="hljs-built_in">UnLock</span>();<br>                t.<span class="hljs-built_in">Run</span>(); <span class="hljs-comment">//可能有多个线程在处理任务,</span><br><br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitThreadPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//初始化一批线程，</span><br>            <span class="hljs-comment">//这样就不要每次用都要去开辟线程了</span><br>            <span class="hljs-type">pthread_t</span> tid; <span class="hljs-comment">//一次创建一批线程</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_; i++)<br>            &#123;<br>                <span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">nullptr</span>, Rountine, (<span class="hljs-type">void</span> *)<span class="hljs-keyword">this</span>);<br>                <span class="hljs-comment">//在类中不能执行线程的方法，因为他都有隐藏的this指针</span><br>                <span class="hljs-comment">//所以我们需要使用静态的函数，就没有了this指针</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PopTask</span><span class="hljs-params">(T *out)</span></span><br><span class="hljs-function">        </span>&#123;<br>            *out = task_queue_.<span class="hljs-built_in">front</span>();<br>            task_queue_.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> task_queue_.<span class="hljs-built_in">empty</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnLock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushTask</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;in)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//塞任务，就相当于一个生产者，生产者之间要进行互斥访问</span><br>            <span class="hljs-built_in">Lock</span>();<br>            task_queue_.<span class="hljs-built_in">push</span>(in);<br>            <span class="hljs-built_in">UnLock</span>();<br>            <span class="hljs-built_in">Wakeup</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//万一任务队列里面一个任务都没有的话，那么线程池里面的每一个线程就要处于休眠状态，挂起等待</span><br>    &#125;;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-comment">//静态成员变量的初始化必须要在类外面初始化</span><br>    ThreadPool&lt;T&gt; *ThreadPool&lt;T&gt;::ins = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//将threadpool里面的ins进行初始化，返回值是指针，给它初始化为空，说明没有被创建出来</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>Task.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;unistd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> ns_task<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> _sockfd;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Task</span>() <span class="hljs-comment">//无参构造，为了拿任务，不需要参数列表</span><br>            : _sockfd(<span class="hljs-number">-1</span>)<br>        &#123;<br>        &#125;<br>        <span class="hljs-comment">//进行函数重载</span><br>        <span class="hljs-built_in">Task</span>(<span class="hljs-type">int</span> sockfd)<br>            : _sockfd(sockfd)<br>        &#123;<br>        &#125;<br><br>        ~<span class="hljs-built_in">Task</span>()<br>        &#123;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span><span class="hljs-comment">//执行任务</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-comment">//因为TCP 是面向字节流的,就如同文件一样,就可以进行正常的读写</span><br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf));<br>                <span class="hljs-type">ssize_t</span> s = <span class="hljs-built_in">read</span>(_sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    buf[s] = <span class="hljs-number">0</span>;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;client # &quot;</span> &lt;&lt; buf &lt;&lt; endl;<br>                    string echo = <span class="hljs-string">&quot;server send &quot;</span>;<br>                    echo += buf;<br>                    <span class="hljs-built_in">write</span>(_sockfd, echo.<span class="hljs-built_in">c_str</span>(), echo.<span class="hljs-built_in">size</span>());<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>)<br>                &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;client quit&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//客户端ctrl c之后就断开了连接</span><br>                    <span class="hljs-built_in">close</span>(_sockfd);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    cerr &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-built_in">close</span>(_sockfd);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// close(_sockfd);//跑完了就把套接字关掉就可以了</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-comment">//重载一个函数</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Run</span>();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h2><p><img src="https://img-blog.csdnimg.cn/cbd645efe47a404ca8c1fc77b12799e6.png" alt="在这里插入图片描述"><br>执行这个command，后以文件的方式来操作，读还是写操作<br>执行的结果在FILE* 这个文件指针里面，可以用一个字符串读取里面的内容接收，返回给客户端<br>执行完关闭<br>底层是管道，fork，文件方案拿到的</p><h2 id="netstate"><a href="#netstate" class="headerlink" title="netstate"></a>netstate</h2><p>netstate -nltp<br>-t是tcp业务<br>-p是process进程</p><p><img src="https://img-blog.csdnimg.cn/899cd86c0e214b789b06ea9cce5afb1f.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络 服务器 linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多路IO转接——前导</title>
    <link href="/2022/07/01/%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/"/>
    <url>/2022/07/01/%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#IO_1">IO的概念</a></li><li><ul><li><a href="#_13">但是操作系统是怎么知道当前网卡当中是有数据：</a></li><li><ul><li><a href="#__24">中断.中断向量 中断向量表</a></li></ul></li><li><a href="#_33">底层数据到达时操作系统做了啥：</a></li><li><ul><li><a href="#___36">硬中断 软中断</a></li></ul></li><li><a href="#_37">软中断</a></li><li><a href="#_44">硬中断</a></li><li><a href="#_51">中断</a></li></ul></li><li><a href="#IO_57">高级IO为何高效</a></li><li><ul><li><a href="#IO_63">高级IO的本质</a></li><li><a href="#IO_66">五种IO模型</a></li><li><a href="#IO_68">我们使用一个例子来讲解五种IO模型</a></li><li><a href="#IO__86">高效IO 的本质</a></li><li><a href="#IO_vs_IO_96">同步IO vs 异步IO</a></li><li><a href="#_105">为什么是内核收到数据</a></li><li><a href="#IO_108">多路IO转接高效的原因</a></li></ul></li><li><a href="#fcntl_118">fcntl</a></li></ul><h1 id="IO的概念"><a href="#IO的概念" class="headerlink" title="IO的概念"></a>IO的概念</h1><p><img src="https://img-blog.csdnimg.cn/68c890cee50e443a9a702a5f70855f66.png" alt="在这里插入图片描述"><br>在网络中通过网课设备向另外一段的输入设备进行输入，<br>IO&#x3D;我们一定会因为一些条件而无法立即发送&#x2F;无法立即接收(等也是IO的基本环节)+拷贝数据</p><p>高效的IO&#x3D;拷贝数据(不等待),减少单位时间内等待的比重<br>IO 的话题</p><ol><li>改变等待的方式</li><li>减少等的比重</li></ol><h2 id="但是操作系统是怎么知道当前网卡当中是有数据："><a href="#但是操作系统是怎么知道当前网卡当中是有数据：" class="headerlink" title="但是操作系统是怎么知道当前网卡当中是有数据："></a>但是操作系统是怎么知道当前网卡当中是有数据：</h2><hr><ol><li>操作系统定期的<strong>轮询</strong>，</li><li>当中<strong>数据</strong>来到的时候，通过<strong>驱动</strong>提醒<strong>操作系统</strong></li></ol><blockquote><p>我们的计算机是通过<strong>中断</strong>程序来做到的，8259，<strong>中断组件</strong>来实现的，等到外来设备来的时候，就会像CPU里面直接发送消息（数据不会发送，只是通过<strong>控制信号</strong>可以直接<strong>通知</strong>CPU）<br>CPU通过<strong>中断向量表</strong>，通过其中的方法进行对应的操作，而当网卡有数据，就是通知CPU去将数据从网卡里面 搬运到内存里面</p></blockquote><h3 id="中断-中断向量-中断向量表"><a href="#中断-中断向量-中断向量表" class="headerlink" title="中断.中断向量 中断向量表"></a>中断.中断向量 中断向量表</h3><p>首先我们先介绍一下中断</p><blockquote><p>中断：所谓的中断就是指CPU 在正常运行程序的过程中由于内部&#x2F;外部的事件的触发或因为程序预先的安排，引起CPU暂时的中断当前正在运行的程序，而转而去执行内部&#x2F;外部事件，或者程序预先安排的事件的服务子程序，待中断服务子程序执行完毕之后，CPU 在返回被暂时中断的地方，（CPU接收到了信号暂时离开执行其他事情，完了之后再回来执行原本要执行的事情）</p></blockquote><blockquote><p>中断向量：<strong>中断服务程序的入口地址</strong></p></blockquote><blockquote><p>中断向量表：把系统中所有的<strong>中断类型码及其对应的中断向量</strong>按照一定规律存放在一个区域内，这个区域就叫做中断向量表</p></blockquote><h2 id="底层数据到达时操作系统做了啥："><a href="#底层数据到达时操作系统做了啥：" class="headerlink" title="底层数据到达时操作系统做了啥："></a>底层数据到达时操作系统做了啥：</h2><hr><p>底层网卡有数据到达时候，此时<strong>硬中断</strong>通知操作系统，操作系统生成<strong>软中断</strong>对数据进行拷贝工作</p><h3 id="硬中断-软中断"><a href="#硬中断-软中断" class="headerlink" title="硬中断 软中断"></a>硬中断 软中断</h3><h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><ol><li><strong>编程时出现的异常</strong>称为软中断（中断指令发出的）</li><li>软中断是通信之间用来<strong>模拟硬中断</strong>的一种信号通信方式</li><li>中断源发出中断请求或中断信号后，CPU或接收进程在适当的时机再自动进行中断处理或者完成软中断信号对应的功能</li><li><strong>软中断</strong>是<strong>软件实现的中断</strong>，也就是程序运行时<strong>其他程序对他的中断</strong>，而硬中断时硬件实现的中断，是程序运行时<strong>设备</strong>对他的中断</li></ol><h2 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h2><ol start="5"><li>硬中断是<strong>外部事件</strong>引起的，具有<strong>随机性</strong>和<strong>突发性</strong>，</li><li>硬中断的中断响应周期，cpu需要发出中断回合信号，软中断的中断响应周期，不需要发送中断回合信号</li><li>硬中断是可以被屏蔽的，软中断无法被屏蔽掉</li><li>硬中断是的中断信号由中断控制器提供的，软中断的中断信号是直接发送的，无需用到中断控制器</li></ol><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>通常引入中断都是外设，系统当中数据准备就绪，需要拷贝到内存里面，需要硬件层面上的中断来完成</p><p>waitpid并没有使用中断<br>：本身就是一个软件，父子进程有直接的关系，子进程在退出的时候，可以根据PCB 找到父进程</p><h1 id="高级IO为何高效"><a href="#高级IO为何高效" class="headerlink" title="高级IO为何高效"></a>高级IO为何高效</h1><blockquote><p>谈及高级IO为何高效，来讨论一下为何read和write低效</p></blockquote><p>在之前的网络套接字代码编写的时候，我们可能使用的是read和write进行操作，使用这个还是的时候，我们在写入或者读取的时候进程都是阻塞的，此时这个就称为IO，尤其是在套接字的场景当中读取数据时候，不知道会被阻塞多久，一个进程没读完就不能进行其他的操作，我们因为只等待一个文件描述符，就在那里一直等待，所以就非常的低效率<br>如：read,write,recv,send,recvfrom,sendto,fopen,fread cin,cout,scanf,printf</p><h2 id="高级IO的本质"><a href="#高级IO的本质" class="headerlink" title="高级IO的本质"></a>高级IO的本质</h2><p>因为调用了select poll,epoll进行等待的时候就可以等待批量的文件描述符，等待的事件重叠了，一次可以处理多个事情，所以就高效了</p><h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><h2 id="我们使用一个例子来讲解五种IO模型"><a href="#我们使用一个例子来讲解五种IO模型" class="headerlink" title="我们使用一个例子来讲解五种IO模型"></a>我们使用一个例子来讲解五种IO模型</h2><p>现在我们将钓鱼简化，过程可以分为等和钓两个步骤<br>钓鱼大佬们是怎么提高效率调到更多的鱼呢？</p><blockquote><p>看看下面5个人的做法，谁最有可能调到最多的鱼儿<br>张三：阻塞式的钓鱼<br>李四：一边玩手机，时不时看看鱼鳔<br>王五：鱼竿带一个铃铛，忙自己的事情，等到铃铛响的时候再去钓鱼<br>赵六：用一大堆鱼竿，在岸边进行轮询检测，只要有一个鱼咬住钩就行了<br>田七：派人去钓鱼，调到了鱼就给田七打电话，钓鱼的桶就相当于一个缓冲区</p></blockquote><p>答案是：赵六</p><ul><li>张三的做法就是<code>阻塞</code>：类似我们之前调用recv，flags设置为0，直接就是阻塞式的等待，进程放入文件描述符中的等待队列，状态被设置为！R，一直到底部有数据，且高于低水位线，操作系统才将进程的状态设置为R，放入到运行队列中,等+拷贝</li><li>李四的做法是<code>非阻塞的检测轮询检测</code>，这个对CPU的消耗比较大,改变等待方式</li><li>王五的做法是<code>信号驱动IO</code>，当有IO 的时候就会发送SIGIO，这个做法很高效，王五只需要做自己的事情，在有信号时，才去处理，但是信号并不是当前立即就去处理，29号信号是一个普通信号，可能会发送很多次，但是王五只处理一次，所以在比较小型的同行才会使用</li><li>赵六：<code>多路转接式钓鱼</code>，每个鱼竿有反应的概率相同的情况，增加鱼竿的数目能让赵六将等待的事件叠加起来，很高效（select poll）,鱼竿&#x3D;&#x3D;fd</li><li>田七：<code>异步IO</code>的思想，叫别人来帮忙钓鱼，不关系这个人怎么调到鱼的，但是帮助钓鱼的人可以采用前面的那些人的方法</li></ul><h2 id="高效IO-的本质"><a href="#高效IO-的本质" class="headerlink" title="高效IO 的本质"></a>高效IO 的本质</h2><p>低效IO：在等待过程特别长的通信过程中，让等的时间占比特别高，此时IO大部分的时间都是在等待，所以效率就会很低，<br>高效IO：在一次IO中让等待的时间占比小，recv读不是立马有数据就去读取的，还要等数据超过低水位线，或者对端给我发送PSH字段才会通知上层将数据从内核拷贝数据到用户</p><p>我们的做法就是让一个中介，这个中介去执行等待，服务器只对其负责，当有客户端发起连接时，先告诉中介，中介将消息告诉服务器，服务器再执行操作，所以就不需要服务器去做无意义的等待，只要让这个中介去等待就行了</p><p>如何使用信号驱动IO</p><blockquote><p>操作系统收到数据的时候，会给进程发送SIGIO，默认处理动作是忽略，我们可以注册SIGIO 的处理方法，当底层好了给我们发送信号，我们再一次调用read接收就可以了，简单IO用的多，复杂IO用的少，因为它是普通信号，只会记录一个信号，信号可能会丢失</p></blockquote><h2 id="同步IO-vs-异步IO"><a href="#同步IO-vs-异步IO" class="headerlink" title="同步IO vs 异步IO"></a>同步IO vs 异步IO</h2><p>同步IO和异步IO 的本质就是在数据拷贝的过程中，异步IO不关心数据的拷贝，只提供一个缓冲区，让OS在合适的时候拷贝到缓冲区里面，即拷贝的过程都是由OS来完成的，数据就绪的通知方案是由信号所决定的<br>类比：<br>家里来了客人，母亲在做菜，此时我是负责端菜的，我可以以同步IO的方式进行端菜，但时对于客人来说，不需要帮忙，对于客人来说就是异步的</p><p>总结<br>：同步IO需要用户在调用recv&#x2F;read将数据拷贝到缓冲区，但是异步IO需要用户提前告知缓冲区，OS会选择合适的时机进行拷贝数据</p><h2 id="为什么是内核收到数据"><a href="#为什么是内核收到数据" class="headerlink" title="为什么是内核收到数据"></a>为什么是内核收到数据</h2><p>因为协议栈是自底向上收的，所以操作系统先收到，硬件，驱动，操作系统，用户，这个问题虽然简单，但是很关键，通常是我们硬件设备网卡检测到有数据的时候，然后中断拷贝到系统的缓冲区里面</p><h2 id="多路IO转接高效的原因"><a href="#多路IO转接高效的原因" class="headerlink" title="多路IO转接高效的原因"></a>多路IO转接高效的原因</h2><p>如select，select的时候阻塞等待了多个文件描述符就绪，只要有一个准备好了，就会调用recv将数据读取上来，recv一次只能等待一个，因为它的参数只有一个，但是select后能保证recv不会被阻塞住了，<br><strong>select只负责等待的环节，后续的recv就不会被阻塞了，因为数据已经就绪了，</strong><br><strong>但是细节还有很多，比如数据就绪我能够疯狂进行读取吗，或者我能读取一部分就不读了吗，下一次它还会送来给我读取吗</strong></p><p>其<img src="https://img-blog.csdnimg.cn/9617ce6805d54fe880330c88eeacfa02.png" alt="在这里插入图片描述"><br>阻塞vs非阻塞</p><ul><li>但进程阻塞接口直观看到进程<strong>卡住了</strong>，等待着某个事件就绪</li><li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</li></ul><h1 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h1><p>fcntl函数主要是用来操作文件描述符的</p><p>一个文件描述符，默认都是阻塞IO，fcntl可以让文件描述符为非阻塞的<br>但是骑士除了fcntl的方式，还有好几种方法，如open的时候，可以设置第二个参数为O_NONBLOCK，可以让打开的文件描述符就是非阻塞的，或者调用recv等接口的时候，设置flags 为O_NONBLOCK</p><blockquote></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span></span>;<br></code></pre></td></tr></table></figure><p>传入的cmd值不同，后面追加的参数也不一样，fcntl函数有5个功能<br>复制一个现有的描述符（cmd&#x3D;F_DUPFD）.<br>获得&#x2F;设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD).<br>获得&#x2F;设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL).<br>获得&#x2F;设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN).<br>获得&#x2F;设置记录锁(cmd&#x3D;F_GETLK,F_SETLK或F_SETLKW).<br>我们此处只是用<strong>第三种功能</strong> 获取&#x2F;设置文件状态标记, 就可以将一个文件描述符设置为非阻塞.</p><p>接口测试：</p><blockquote><p>测试代码：默认read读取为非阻塞，每次往标准输入里面读取一个数据，默认缓冲区为空，便会卡住让我们输入数据</p></blockquote><p>非阻塞等待</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetNonBlock</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取之前文件的状态</span><br>    <span class="hljs-type">int</span> fl=<span class="hljs-built_in">fcntl</span>(fd,F_GETFD);<br>    <span class="hljs-keyword">if</span>(fl&lt;<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>    <span class="hljs-comment">//把文件描述符设置为非阻塞,设计标记 </span><br>    <span class="hljs-built_in">fcntl</span>(fd,F_SETFL,fl|O_NONBLOCK);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//观察标准输入阻塞和非阻塞状态读取数据</span><br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">SetNonBlock</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//给0设置为非阻塞</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ssize_t</span> s = <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, &amp;ch, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, ch); <span class="hljs-comment">//读取成功</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&lt;<span class="hljs-number">0</span>&amp;&amp;(errno==EAGAIN||errno==EWOULDBLOCK))<span class="hljs-comment">//EAGIN和EWOULDBLOCK是一样的</span><br>        &#123;<br>            <span class="hljs-comment">//非阻塞读取，底层的数据没有就位 </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数据没有就绪\n&quot;</span>);<br>            cout&lt;&lt;<span class="hljs-string">&quot;continue&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(errno==EINTR&amp;&amp;s&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//读取被信号中断了,这个地方就是失败了</span><br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-comment">// cout &lt;&lt; ch &lt;&lt; endl;</span><br>            cout&lt;&lt;s&lt;&lt;endl;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;.............&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//当我们不输入的时候，就会卡住等待我们进行输入</span><br><span class="hljs-comment">//设置为非阻塞，当缓冲区里面没有数据的时候，read直接返回失败，ssize_t 是一个有符号整数，-1代表底层数据没有就绪，</span><br><span class="hljs-comment">//读取数据不算错误，而是一种通知，并且会设置errno为EAGAIN,(try again)表示底层数据没有准备好，下次再来的话，EWOULDBLOCK也同样的效果</span><br><span class="hljs-comment">//如果错误码是EINT表示阻塞等待时候被信号给阻塞掉了</span><br></code></pre></td></tr></table></figure><p>在非阻塞的情况下,我们读取数据,如果数据没有就绪,系统是以出错的形式返回的(不是错误)</p><p>没有就绪和真正的错处,使用同样的方式标识的,如何进一步区分呢?errno&#x3D;11()<br>EAGAIN(EWOULDBLOCK):给非阻塞用的,这两个是一样的,errno&#x3D;11,底层没有就绪,try again</p><p>什么叫做等事件就绪,<br>IO事件就绪</p><ol><li>读事件就绪,读缓冲区里面有数据,为了减少用户态内核态的过度切换,就让一次读取的数据足够多,水位线(低于就发)</li><li>写事件就绪,发送的缓冲区有足够的空间进行拷贝</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议 tcp/ip udp 网络 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++右值引用</title>
    <link href="/2022/06/24/c++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2022/06/24/c++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-type">int</span> _x;<br>    <span class="hljs-type">int</span> _y;<br>    <span class="hljs-comment">/*explicit*/</span> <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)<br>        : _x(x), _y(y) &#123; cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">        : _a(a) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">//单参数类型支持隐式类型转换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">aa</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//单参数的类型，可以使用正常的方式</span><br>    <span class="hljs-comment">// A b=2;//也可以使用这种隐式类型的转换</span><br>    <span class="hljs-comment">// 2拷贝构造一个A，在进行拷贝构造成b</span><br>    <span class="hljs-comment">//加一个explicit，就不能这样了</span><br>    string s1 = <span class="hljs-string">&quot;hjs&quot;</span>; <span class="hljs-comment">// string的构造函数没有加explicit</span><br>    vector&lt;string&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;hjk&quot;</span>); <span class="hljs-comment">//这也是隐式类型转换</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//以前</span><br>    Point p = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;             <span class="hljs-comment">// c语言是使用这种方式来初始化</span><br>    <span class="hljs-type">int</span> brr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//使用这种大括号进行初始化</span><br><br>    <br>    <span class="hljs-comment">//现在s</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b = &#123;<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//现在还可以这样进行初始化,=也省略了</span><br>    <span class="hljs-type">int</span> c&#123;<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    Point k&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;             <span class="hljs-comment">//初始化了前3个值，后面的值全都是0</span><br>    Point *ptrd = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">2</span>]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;&#125;; <span class="hljs-comment">//现在还可以这样进行初始化,里面必须要又两个&#123;&#125;</span><br>    <span class="hljs-comment">// new要去调用他的构造函数</span><br><br>    <span class="hljs-comment">//正常调用point</span><br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//调用构造函数</span><br><br>    <span class="hljs-comment">// c++11支持的多参数的构造函数</span><br>    Point p2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    Point p3&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//都是因为支持initializer_list的构造函数</span><br><br>    <span class="hljs-comment">//以前的vector初始化</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-comment">//现在vector也可以这样初始化, 掉的就是initializer list进行初始化</span><br><br>    initializer_list&lt;<span class="hljs-type">int</span>&gt; lt = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;                         <span class="hljs-comment">//</span><br>    list&lt;<span class="hljs-type">int</span>&gt; l = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;                                      <span class="hljs-comment">//链表也可以这样初始化</span><br>    map&lt;string, string&gt; dic = &#123;&#123;<span class="hljs-string">&quot;dasd&quot;</span>, <span class="hljs-string">&quot;dsa&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;dsada&quot;</span>, <span class="hljs-string">&quot;fd&quot;</span>&#125;&#125;; <span class="hljs-comment">// map也可以</span><br>    v2 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;                                            <span class="hljs-comment">//也可以用赋值，不是构造，在赋值运算符重载那里使用了initialzer_list</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : v2)<br>    &#123;<br>        cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">typeid</span>(x).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//获得x的类型名字</span><br>    <span class="hljs-keyword">decltype</span>(x) z = <span class="hljs-number">2</span>;                <span class="hljs-comment">//获得x的类型名，来初始化另一个变量</span><br>    <span class="hljs-type">double</span> y = <span class="hljs-number">2.2</span>;<br>    <span class="hljs-keyword">decltype</span>(x * y) ret; <span class="hljs-comment">// ret类型为double</span><br>    <span class="hljs-keyword">decltype</span>(&amp;x) p;      <span class="hljs-comment">// p类型为int*</span><br><br>    <span class="hljs-built_in">int</span> (*func)(<span class="hljs-type">int</span>) = func;      <span class="hljs-comment">//函数指针</span><br>    <span class="hljs-keyword">auto</span> pfunc = func;            <span class="hljs-comment">//直接用auto也可以</span><br>    <span class="hljs-keyword">decltype</span>(pfunc) pfun3 = func; <span class="hljs-comment">//定义一个变量</span><br>    map&lt;string, string&gt; dict = &#123;&#123;<span class="hljs-string">&quot;sort&quot;</span>, <span class="hljs-string">&quot;排序&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;插入&quot;</span>&#125;&#125;;<br>    <span class="hljs-keyword">auto</span> it = dict.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> cpit = it;<br>    <span class="hljs-comment">//但是不能把auto作为模板参数</span><br>    vector&lt;<span class="hljs-keyword">decltype</span>(it)&gt; v; <span class="hljs-comment">//这样就很方便</span><br>    v.<span class="hljs-built_in">push_back</span>(it);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-type">int</span>, 10&gt; a; <span class="hljs-comment">//静态数组</span><br>    a[<span class="hljs-number">11</span>];            <span class="hljs-comment">//可以支持对越界的检查</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">// forward_list//单链表,很少用，也是基类，只不过和list比较，每一个节点少了一个指针</span><br>    <span class="hljs-comment">// unordered_map</span><br>    <span class="hljs-comment">// unordered_set</span><br>    <span class="hljs-comment">// cbegin()返回的就是const的begin，</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        已有容器新增的函数接口</span><br><span class="hljs-comment">        1. 列表初始化</span><br><span class="hljs-comment">        2. cbegin</span><br><span class="hljs-comment">        3. 移动构造，移动赋值</span><br><span class="hljs-comment">        4. 右值引用版本的插入接口</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        vector(vector&amp;&amp; x)</span><br><span class="hljs-comment">        void push_back(value_type&amp;&amp; val)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        emplace</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        emplace_back</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    右值引用和移动语义</span><br><span class="hljs-comment">    左值引用：给左值取别名</span><br><span class="hljs-comment">    右值引用：给右值取别名</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    左值是一个表达式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;r1 = a; <span class="hljs-comment">//左值引用,在这里a，&amp;a，*p都是左值</span><br>    <span class="hljs-type">int</span> *p = &amp;a;<br>    <span class="hljs-type">int</span> &amp;e2 = *p;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;  <span class="hljs-comment">//这个b不能对他进行赋值，但是也是一个左值</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = b; <span class="hljs-comment">//可以这样对左值进行引用</span><br><br>    <span class="hljs-comment">//左值可以是一个表示数据的表达式（如变量名或者解引用的指针），特点：可以获取他的地址，也可以对他赋值</span><br>    <span class="hljs-comment">//左值可以出现在=的左边，但是右值不能出现在=的左边，所以=左边只能出现左值</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        什么是右值</span><br><span class="hljs-comment">        右值也是一个表示数据的表达式，如：字面常量，表达式返回值，传值返回函数的返回值（）</span><br><span class="hljs-comment">        右值不能取地址，不能出现在=的左边，只能出现在=的右边，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        （不能取地址的对象就是右值）</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">//这几个都是常见的右值</span><br>    <span class="hljs-number">10</span>;<br>    <span class="hljs-type">double</span> x = <span class="hljs-number">1.1</span>, y = <span class="hljs-number">2.2</span>;<br>    <span class="hljs-built_in">min</span>(x, y);<br>    <span class="hljs-comment">//这几个都不能&amp;</span><br><br>    <span class="hljs-type">int</span> &amp;&amp;r0 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">double</span> &amp;&amp;l = x + y;<br>    <span class="hljs-comment">// double &amp;&amp;r3 = min(x, y);</span><br><br>    <span class="hljs-comment">//左值引用不能引用右值----不能直接引用，但是可以加const，左值引用</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> &amp;e22 = x + y;<br>    <span class="hljs-comment">// void pushback(const T &amp; x)像直接传进去数字这样的右值，引用也可以实现</span><br><br>    <span class="hljs-comment">//右值引用不能引用左值，那么也是引用move 后的左值</span><br>    <span class="hljs-type">int</span> &amp;&amp;r = <span class="hljs-built_in">move</span>(a);<br><br>    <span class="hljs-comment">//所以是可以交叉引用的</span><br>    <span class="hljs-comment">//需要注意的是，右值不能取地址，给右值取别名之后，又变成了左值,因为在特定的地方把他存起来了，</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-comment">//右值引用的产生是为了弥补左值引用的不足</span><br><br><span class="hljs-keyword">namespace</span> bit<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *iterator;<br>        <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str;<br>        &#125;<br>        <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str + _size;<br>        &#125;<br>        <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;&quot;</span>)<br>            : _size(<span class="hljs-built_in">strlen</span>(str)), _capacity(_size)<br>        &#123;<br>            <span class="hljs-comment">// cout &lt;&lt; &quot;string(char* str)&quot; &lt;&lt; endl;</span><br>            _str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_capacity + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(_str, str);<br>        &#125;<br>        <span class="hljs-comment">// s1.swap(s2)</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function">        </span>&#123;<br>            ::<span class="hljs-built_in">swap</span>(_str, s._str);<br>            ::<span class="hljs-built_in">swap</span>(_size, s._size);<br>            ::<span class="hljs-built_in">swap</span>(_capacity, s._capacity);<br>        &#125;<br>        <span class="hljs-comment">// 拷贝构造</span><br>        <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string &amp;s) <span class="hljs-comment">//编译器会判定，如果是左值就会到这里来</span><br>            : _str(<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;string(const string&amp; s) -- 深拷贝&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s._str)</span></span>;<br>            <span class="hljs-built_in">swap</span>(tmp);<br>        &#125;<br>        <span class="hljs-comment">// 赋值重载</span><br>        string &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> string &amp;s)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;string&amp; operator=(string s) -- 深拷贝&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s)</span></span>;<br>            <span class="hljs-built_in">swap</span>(tmp);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-comment">// 移动构造</span><br>        <span class="hljs-comment">// 移动构造，如果是右值就会到这里来</span><br>        <span class="hljs-comment">//这种将亡值资源析构了很可惜，直接给我把</span><br>        <span class="hljs-comment">//将资源移动了，移动到新对象上面，并且将原来对象的资源置空，解决拷贝构造代价的问题</span><br>        <span class="hljs-built_in">string</span>(string &amp;&amp;s) <span class="hljs-comment">//要开始移动资源,c++11中，将右值分为1.纯右值（10，x+t，min（x，y）），2.将亡值(自定义对象)</span><br>            : _str(<span class="hljs-literal">nullptr</span>), _size(<span class="hljs-number">0</span>), _capacity(<span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;string(string&amp;&amp; s) -- 移动构造&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">swap</span>(s);<br>        &#125;<br>        <span class="hljs-comment">// 移动赋值，移动赋值和移动构造类似，</span><br>        string &amp;<span class="hljs-keyword">operator</span>=(string &amp;&amp;s)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;string&amp; operator=(string&amp;&amp; s) -- 移动赋值&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">swap</span>(s); <span class="hljs-comment">//把里面的东西全都交换了</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这里返回交换之后的东西就可以了，</span><br>        &#125;<br>        ~<span class="hljs-built_in">string</span>()<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] _str;<br>            _str = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos)<br>        &#123;<br>            <span class="hljs-built_in">assert</span>(pos &lt; _size);<br>            <span class="hljs-keyword">return</span> _str[pos];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (n &gt; _capacity)<br>            &#123;<br>                <span class="hljs-type">char</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>];<br>                <span class="hljs-built_in">strcpy</span>(tmp, _str);<br>                <span class="hljs-keyword">delete</span>[] _str;<br>                _str = tmp;<br>                _capacity = n;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (_size &gt;= _capacity)<br>            &#123;<br>                <span class="hljs-type">size_t</span> newcapacity = _capacity == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span> : _capacity * <span class="hljs-number">2</span>;<br>                <span class="hljs-built_in">reserve</span>(newcapacity);<br>            &#125;<br><br>            <span class="hljs-comment">// 左值引用的使用场景：</span><br>            <span class="hljs-comment">// 做参数和做返回值都可以提高效率。</span><br>            <span class="hljs-comment">// 左值引用的短板：</span><br>            <span class="hljs-comment">// 但是当函数返回对象是一个局部变量，出了函数作用域就不存在了，就不能使用左值引用返回，</span><br>            <span class="hljs-comment">// 只能传值返回。例如：bit::string to_string(int value)函数中可以看到，这里只能使用传值返回，</span><br>            <span class="hljs-comment">// 传值返回会导致至少1次拷贝构造(如果是一些旧一点的编译器可能是两次拷贝构造)。</span><br>            _str[_size] = ch;<br>            ++_size;<br>            _str[_size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">// string operator+=(char ch)</span><br>        string &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> ch)<br>        &#123;<br>            <span class="hljs-built_in">push_back</span>(ch);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        string <span class="hljs-keyword">operator</span>+(<span class="hljs-type">char</span> ch)<br>        &#123;<br>            <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>            <span class="hljs-built_in">push_back</span>(ch);<br>            <span class="hljs-comment">//把他的资源直接转移走，销毁了是空</span><br>            <span class="hljs-keyword">return</span> tmp; <span class="hljs-comment">//这个东西出了作用域就销毁了，</span><br>                        <span class="hljs-comment">//不能用左值返回，这里的tmp是一个右值</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span> *_str;<br>        <span class="hljs-type">size_t</span> _size;<br>        <span class="hljs-type">size_t</span> _capacity; <span class="hljs-comment">// 不包含最后做标识的\0</span><br>    &#125;;<br>    <span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        string ret;<br>        <span class="hljs-keyword">while</span> (value)<br>        &#123;<br>            <span class="hljs-type">int</span> val = value % <span class="hljs-number">10</span>;<br>            ret += (<span class="hljs-string">&#x27;0&#x27;</span> + val);<br>            value /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">//这里返回的时候会调用一次拷贝构造，因为这里的ret是左值</span><br>        <span class="hljs-comment">//这里会先拷贝再析构是一种资源浪费，移动构造将x识别为右值，直接调用移动构造转移资源，提高效率</span><br>        <span class="hljs-comment">//在栈帧结束之前，就拷贝构造一个临时对象，没有任何价值</span><br>        <span class="hljs-comment">//现在编译器优化了</span><br>        <span class="hljs-comment">//函数快结束是，返回前，直接用str去构造ret，</span><br><br>        <span class="hljs-comment">//如果不用一个变量来接收的时候，就不会进行优化了，只能有一个临时对象了，没有优化的空间</span><br><br>        <span class="hljs-comment">//现在直接识别为右值，移动构造到下面的ret上面去</span><br>        <span class="hljs-comment">//把资源直接转移够要弄的临时对象，代价就很小，并没有</span><br>        <span class="hljs-comment">//这里也就不需要调用析构函数了</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//引用是为了减少拷贝，提高效率</span><br><br><span class="hljs-comment">// 1。左值引用左参数，可以完美的解决所有的问题</span><br><span class="hljs-comment">// 2.左值引用做返回值，只能解决部分问题(出了作用域还在，没有进行拷贝)</span><br><br><span class="hljs-comment">//右值引用如何解决operator+的拷贝函数</span><br><span class="hljs-comment">//现在提高了一个移动构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(bit::string s)</span> <span class="hljs-comment">//这个会发生拷贝构造</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">const</span> bit::string &amp;s)</span> <span class="hljs-comment">//使用const的引用，既可以传递左值，也可以传递右值</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">bit::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;dsa&quot;</span>)</span></span>;<br>    s + <span class="hljs-string">&#x27;d&#x27;</span>; <span class="hljs-comment">//会拷贝，左值引用只能解决+=，但是解决不了+，</span><br>    <span class="hljs-comment">//这种传值返回的函数对象，右值，将亡值，</span><br>&#125;<br><span class="hljs-function">bit::string <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">bit::string <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">&quot;dasd&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-comment">//完美转发</span><br><span class="hljs-comment">//模板中的&amp;&amp;不代表有值引用，而是万能引用，既可以接收左值也能接收右值</span><br><span class="hljs-comment">//模板的万能引用只是提供了能够同时接受左值引用和右值引用的能力</span><br><span class="hljs-comment">//但是 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;X)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;左值引用&quot;</span>&lt;&lt;endl;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span>  <span class="hljs-type">int</span> &amp;X)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;const 左值引用&quot;</span>&lt;&lt;endl;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;X)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;右值引用&quot;</span>&lt;&lt;endl;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;X)</span></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;const 右值引用&quot;</span>&lt;&lt;endl;&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perfectforward</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//这里完美的t是一个右值，但是到这里它就会开一块空间，保存t，t就变成了一个左值</span><br>    <span class="hljs-comment">//属性发生了变化，所以全部都到左值引用上面去了</span><br><br><br>    <span class="hljs-comment">//完美转发就是可以保存它的属性，</span><br>    <span class="hljs-built_in">fun</span>(forward&lt;T&gt;(t));<span class="hljs-comment">//t原来是右值，现在还是右值，所以如果是右值，接下来还要调用这个右值作为函数的参数的话，前面就是加入forward,完美转发</span><br>    <span class="hljs-comment">//只要用到这个参数的话，需要加forward，一旦右用到右值的话，就要加一个forward</span><br><br>    <span class="hljs-comment">// fun(t);//这里t变成左值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">perfectforward</span>(<span class="hljs-number">10</span>);             <span class="hljs-comment">//右值</span><br><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">perfectforward</span>(a);              <span class="hljs-comment">//左值</span><br>    <span class="hljs-built_in">perfectforward</span>(<span class="hljs-built_in">move</span>(a));        <span class="hljs-comment">//右值</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> b=<span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">perfectforward</span>(b);              <span class="hljs-comment">//const左值，模板会推导出来const</span><br>    <span class="hljs-built_in">perfectforward</span>(<span class="hljs-built_in">move</span>(b));        <span class="hljs-comment">//const右值</span><br>    <br>    <span class="hljs-comment">//但是都被匹配到左值上面去了，</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int main()</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    test1();</span><br><span class="hljs-comment">    test2();</span><br><span class="hljs-comment">    test3();</span><br><span class="hljs-comment">    test4();</span><br><span class="hljs-comment">    test8();</span><br><span class="hljs-comment">    func();</span><br><span class="hljs-comment">    bit::string s(&quot;dasd&quot;);</span><br><span class="hljs-comment">    bit::string s1 = s;       // s是一个左值，这个就是调用左值引用,调用左值引用</span><br><span class="hljs-comment">    bit::string s2 = move(s); // move以后的左值就是右值了,之后得到的对象在进行移动构造，后的值赋给s2，move之后把s里面的值都清理出去了，转移走</span><br><span class="hljs-comment">    //把move后的值，给别人就会有问题</span><br><span class="hljs-comment">    bit::string ss = bit::to_string(1234); //返回之后会发生一次移动构造，接收这个函数的返回值也会发生一次移动构造,会发生两次拷贝构造</span><br><span class="hljs-comment">    //接收函数就是右值，调用移动构造，如果编译器只拷贝构造一次，那么就直接把ret认为右值</span><br><span class="hljs-comment">    //ss接收了转移到资源，地址什么的也都转移给了ss</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    //除了有移动构造，还有移动赋值</span><br><span class="hljs-comment">    // bit::string s1(&quot;sdafll&quot;);</span><br><span class="hljs-comment">    // bit::string s2(&quot;dsa&quot;);</span><br><span class="hljs-comment">    // s1=s2;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    bit::string ret;</span><br><span class="hljs-comment">    ret=bit::to_string(1234);//先移动构造给临时对象，临时对象再移动赋值给ret，</span><br><span class="hljs-comment">    //容器的插入版本都会提供一个右值引用的版本，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    list&lt;bit::string&gt; lt;</span><br><span class="hljs-comment">    bit::string aaa(&quot;dasdasd&quot;);//这里的s就是一个标准的左值</span><br><span class="hljs-comment">    lt.push_back(aaa);//这里的aaa没有被转移 </span><br><span class="hljs-comment">    cout&lt;&lt;endl;</span><br><span class="hljs-comment">    lt.push_back(&quot;2222&quot;);//这里面的这个就是一个右值、</span><br><span class="hljs-comment">    cout&lt;&lt;endl;</span><br><span class="hljs-comment">    lt.push_back(bit::to_string(1234));//这里就是一个移动构造，效率就提高了，所有的插入接口都涉及移动构造</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    //</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    return 0;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏的运用接续符\</title>
    <link href="/2022/06/22/%E5%AE%8F%E7%9A%84%E8%BF%90%E7%94%A8%E6%8E%A5%E7%BB%AD%E7%AC%A6/"/>
    <url>/2022/06/22/%E5%AE%8F%E7%9A%84%E8%BF%90%E7%94%A8%E6%8E%A5%E7%BB%AD%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>接续符\就是让一行代码可以在在多行上写，在宏的使用上的时候，可以提高代码的可读性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-comment">//定义宏的时候，下一行之前是可以有空格的，但是\之后最好也不要有空格,</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> swap(a,b)\</span><br><span class="hljs-meta">&#123;         \</span><br><span class="hljs-meta">  int t=a;\</span><br><span class="hljs-meta">  a=b; \</span><br><span class="hljs-meta">  b=t;\</span><br><span class="hljs-meta">&#125;         \</span><br><span class="hljs-meta"></span><br><br><span class="hljs-comment">//定义函数宏的时候必须要加上&#123;&#125;，或者采用do-while(0)的结构，推荐使用do while形式</span><br><span class="hljs-comment">//#define 指令只能卸载一行，不管用不用&#123;&#125;。都是这样的，要写到多行，必须用\，将所有的内容拼接到一行中</span><br><span class="hljs-comment">//虽然也可以不用\，但是这样可读性很差</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  pri\<br>ntf(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">//\后面不能有空格，下一行前面也不能有空格i,</span><br>  <span class="hljs-comment">//对于连续单词（函数名，关键字，变量时候）</span><br>  <br>  <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>;<br>  swap(a,b);<br><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP客户端服务器代码</title>
    <link href="/2022/06/18/TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/06/18/TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>此TCP服务器客户端使用</p><ol><li>使用了线程池</li><li>解决了粘包问题</li><li>使用了任务类</li><li>使用了方法类</li></ol><p><a href="https://github.com/zevin02/NetWork/tree/master/prelearn/tcpsocket/tcp">TCPcode</a></p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>server.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;server.hpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;wrong command,please type again&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    TCPSERVER* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TCPSERVER</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    p-&gt;<span class="hljs-built_in">InitServer</span>();<br>    p-&gt;<span class="hljs-built_in">StartTcp</span>();<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>server.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;threadpool.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_threadpool;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFUALTPORT 8081</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BACKLOG 20</span><br><br><span class="hljs-comment">//因为我们要获取里面的东西，所以定义称struct类型的就可以了</span><br><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Param</span><br>&#123;<br>    <span class="hljs-type">int</span> _sockfd;<br>    string _ip;<br>    <span class="hljs-type">int</span> _port;<br>    <span class="hljs-built_in">Param</span>(<span class="hljs-type">int</span> sockfd, string ip, <span class="hljs-type">int</span> port)<br>        : _sockfd(sockfd), _ip(ip), _port(port)<br>    &#123;<br>    &#125;<br>    ~<span class="hljs-built_in">Param</span>()<br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//我们在服务端引入了线程池，在服务类里面增加一个线程池的指针成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPSERVER</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _sockfd; <span class="hljs-comment">//监听套接字</span><br>    <span class="hljs-type">int</span> _port;   <span class="hljs-comment">//服务端的端口号</span><br>    ThreadPool&lt;Task&gt; *tp;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *error)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">perror</span>(error);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">TCPSERVER</span>(<span class="hljs-type">int</span> port = DEFUALTPORT)<br>        : _port(port), _sockfd(<span class="hljs-number">-1</span>)<br>    &#123;<br>    &#125;<br>    ~<span class="hljs-built_in">TCPSERVER</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_sockfd &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">close</span>(_sockfd);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitServer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">signal</span>(SIGCHLD, SIG_IGN); <span class="hljs-comment">//忽略子进程退出后，给父进程发送的信号</span><br>        _sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (_sockfd &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">err</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> local;<br>        <span class="hljs-built_in">memset</span>(&amp;local, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(local));<br>        local.sin_port = <span class="hljs-built_in">htons</span>(_port);<br>        local.sin_family = AF_INET;<br>        local.sin_addr.s_addr = INADDR_ANY;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(_sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;local, <span class="hljs-built_in">sizeof</span>(local)) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">err</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(_sockfd, BACKLOG) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">err</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        &#125;<br>        tp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadPool</span>&lt;Task&gt;(); <span class="hljs-comment">//先动态开辟一个线程池对象</span><br>    &#125;<br>    <span class="hljs-comment">// static void *Routine(void *args) //因为在类里面，所以不要this指针</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     Param sock = *(Param *)args;</span><br>    <span class="hljs-comment">//     delete args;</span><br>    <span class="hljs-comment">//     pthread_detach(pthread_self()); //线程分离就不需要再去join了</span><br>    <span class="hljs-comment">//     cout &lt;&lt; &quot;create a new pthread for IO&quot; &lt;&lt; endl;</span><br>    <span class="hljs-comment">//     char buff[MAX];</span><br>    <span class="hljs-comment">//     while (true)</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         //读取数据</span><br>    <span class="hljs-comment">//         struct sockaddr_in peer;</span><br>    <span class="hljs-comment">//         socklen_t len = sizeof(peer);</span><br>    <span class="hljs-comment">//         ssize_t s = recvfrom(sock._sockfd, buff, sizeof(buff) - 1, 0, (struct sockaddr *)&amp;peer, &amp;len); // peer里面就是远程的数据了</span><br>    <span class="hljs-comment">//         if (s &gt; 0)</span><br>    <span class="hljs-comment">//         &#123;</span><br>    <span class="hljs-comment">//             buff[s] = 0;</span><br>    <span class="hljs-comment">//             fflush(stdout);</span><br>    <span class="hljs-comment">//             cout &lt;&lt; &quot;#client:&quot; &lt;&lt; buff &lt;&lt; endl;</span><br>    <span class="hljs-comment">//             string msg = &quot;#client &quot;;</span><br>    <span class="hljs-comment">//             msg += buff;</span><br>    <span class="hljs-comment">//             sendto(sock._sockfd, msg.c_str(), msg.size(), 0, (struct sockaddr *)&amp;peer, len);</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//         else</span><br>    <span class="hljs-comment">//         &#123;</span><br>    <span class="hljs-comment">//             cout &lt;&lt; &quot;error data&quot; &lt;&lt; endl;</span><br>    <span class="hljs-comment">//             break;</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartTcp</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        tp-&gt;<span class="hljs-built_in">InitThreadPool</span>(); <span class="hljs-comment">//初始化线程池</span><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            sockaddr_in endpoint;<br>            <span class="hljs-built_in">memset</span>(&amp;endpoint, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in">sizeof</span>(endpoint));<br>            <span class="hljs-comment">//处理任务</span><br>            <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(endpoint);<br>            <span class="hljs-type">int</span> sock = <span class="hljs-built_in">accept</span>(_sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;endpoint, &amp;len); <span class="hljs-comment">//这个sock就是用来和客户端进行通信的，</span><br>            <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            string cli_ip = <span class="hljs-built_in">inet_ntoa</span>(endpoint.sin_addr);<br>            <span class="hljs-function">string <span class="hljs-title">ip</span><span class="hljs-params">(cli_ip)</span></span>;<br>            <span class="hljs-type">int</span> port = <span class="hljs-built_in">ntohs</span>(endpoint.sin_port);<br>            cli_ip += <span class="hljs-string">&quot;:&quot;</span>;<br>            cli_ip += <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">ntohs</span>(endpoint.sin_port));<br>            cout &lt;&lt; <span class="hljs-string">&quot;get a link-&gt;&quot;</span> &lt;&lt;sock&lt;&lt; cli_ip &lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;port&lt;&lt; endl;<br>            <span class="hljs-comment">// pthread_t tid;</span><br>            <span class="hljs-comment">//但是调用server函数的时候我们需要的是socket ip port，创建线程的时候只能传一个参数，所以我们需要定义一个结构体存储这些信息</span><br>            <span class="hljs-comment">// Param *p = new Param(sock, ip, port); //这样就把数据都初始化传进去了，三个数据都有了</span><br><br>            <span class="hljs-comment">//对于主线程accept上来的文件描述符，不能由主线程来close，应该让操作这个sockfd的线程进行关闭</span><br>            <span class="hljs-comment">//同样，新线程也不能对监听sockfd进行关闭</span><br>            <span class="hljs-comment">// pthread_create(&amp;tid, nullptr, Routine, (void *)p); //在这里执行操作，所以这个地方就要传入套接字</span><br><br>            <span class="hljs-comment">//构造一个任务</span><br>            <span class="hljs-function">Task <span class="hljs-title">task</span><span class="hljs-params">(sock,ip,port)</span></span>;<br>            <span class="hljs-comment">//把这个任务放到线程池的任务队列里面取</span><br>            tp-&gt;<span class="hljs-built_in">PushTask</span>(task);<br><br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                各个线程共享一个文件描述符表，因此当主线程调用accept的时候，其他创建的新线程是可以直接访问到这个文件描述符的</span><br><span class="hljs-comment">                由于此时新线程并不知道它要服务的客户端所要对应的是哪一个文件描述符，所以此时主线程要告诉新线程应该要去访问的文件描述符的值</span><br><span class="hljs-comment">                就是要操作哪一个套接字</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            当前多线程版本的服务器存在的问题是，每次有新的链接来的话，就会为客户端创建为它服务的新线程，在服务结束之后就会把他进行销毁，</span><br><span class="hljs-comment">            这样不仅有麻烦，效率还很低下</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            如果有大量的客户端进行连接请求，此时服务端要为每一个客户端创建对应的服务线程，计算机中的线程越多，CPU 的压力也就越大，CPU要在</span><br><span class="hljs-comment">            这些线程里面不断的来回切换，此时CPU 在调度线程的时候，线程和线程之间的切换成本就很高，线程如果很多的话，被调度的周期也就很长，</span><br><span class="hljs-comment">            这样客户端也会迟迟得不到应答</span><br><span class="hljs-comment">            */</span><br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            解决方案</span><br><span class="hljs-comment">            * 可以先在服务端创建一些线程，当有客户端请求连接的时候 就让这些线程提供服务，此时客户端一来就有线程来替他们服务，而不是客户端请求了才创建线程</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            * 当某个线程为客户端提供完服务之后，不要让该线程退出，而是让该线程继续为下一个客户端提供服务，如果当前没有客户端连接请求，则可以让线程先休眠</span><br><span class="hljs-comment">            当有客户端到来的时候再把该线程唤醒</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            * 服务端创建的这一批线程不能太多，此时CPU 的压力也就不会太大，如果此时客户端连接到来，此时一批线程都在进行工作，那么此时服务端不应该再创建线程</span><br><span class="hljs-comment">            而是让这个新来的线程再连接队列里面排队，等服务端这些线程有空闲的就替它提供服务</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            此时就引入了线程池再服务端里面，因为线程池的存在就是为了避免处理短时间任务创建和销毁线程的代价，此时线程池还能够保证内核充分利用，避免过分调度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            其中线程池里面有一个任务队列，当有新的任务来的时候，就把任务push到线程池里面，再线程池里面我们默认创建了5个线程，如果线程池里面没有那么多任务，就休眠</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            */</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>threadpool.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;IO.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//设计一个handler类，在handler类里面对（）操作符进行重载，将（）操作符的执行动作重载为执行server函数的代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Handler</span>()<br>    &#123;<br>    &#125;<br>    ~<span class="hljs-built_in">Handler</span>()<br>    &#123;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, string cliip, <span class="hljs-type">int</span> cliport)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//执行server函数的代码</span><br>        <span class="hljs-comment">// char buff[1024];</span><br>        <span class="hljs-comment">// while (true)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     ssize_t size = read(sock, buff, sizeof(buff) - 1);</span><br>        <span class="hljs-comment">//     if (size &gt; 0) //读取成功</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         buff[size] = &#x27;\0&#x27;;</span><br>        <span class="hljs-comment">//         cout &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; &quot;#&quot; &lt;&lt; buff &lt;&lt; endl;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//     else if (size == 0) //对端关闭了</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         cout &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliip &lt;&lt; &quot; close!&quot; &lt;&lt; endl;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//     else</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         //读取失败</span><br>        <span class="hljs-comment">//         cerr &lt;&lt; sock &lt;&lt; &quot; read error!&quot; &lt;&lt; endl;</span><br>        <span class="hljs-comment">//         break; //读取失败的化就关闭</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-type">char</span> *buff; <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-comment">//读取数据</span><br>            <span class="hljs-comment">// struct sockaddr_in peer;</span><br>            <span class="hljs-comment">// socklen_t len = sizeof(peer);</span><br>            <span class="hljs-comment">// ssize_t s = recvfrom(sock, buff, sizeof(buff) - 1, 0, (struct sockaddr *)&amp;peer, &amp;len); // peer里面就是远程的数据了</span><br><br>            <span class="hljs-comment">//使用新的解决粘包问题的读取数据的方法</span><br>            <span class="hljs-type">int</span> s = <span class="hljs-built_in">RecvMsg</span>(sock, &amp;buff); <span class="hljs-comment">//读取数据</span><br>            <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                buff[s] = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">fflush</span>(stdout);<br>                cout &lt;&lt; <span class="hljs-string">&quot;#client:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br>                string msg = <span class="hljs-string">&quot;#client &quot;</span>;<br>                msg += buff;<br>                <span class="hljs-comment">//发送回客户端</span><br>                <span class="hljs-built_in">sendmsg</span>(sock, msg.<span class="hljs-built_in">c_str</span>(), msg.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">//发送数据</span><br>                <span class="hljs-comment">// sendto(sock, msg.c_str(), msg.size(), 0, (struct sockaddr *)&amp;peer, len);</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;error data&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">close</span>(sock); <span class="hljs-comment">//这个线程用完了就要把这个文件描述符关掉</span><br>        cout &lt;&lt; cliip &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; cliport &lt;&lt; <span class="hljs-string">&quot; service done!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-comment">//任务</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _sockfd;<br>    string _cliip;<br>    <span class="hljs-type">int</span> _cliport;<br>    Handler _handler; <span class="hljs-comment">//处理方法</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Task</span>() <span class="hljs-comment">//无参数，就是为了线程池取任务出来执行</span><br>    &#123;<br>    &#125;<br>    <span class="hljs-built_in">Task</span>(<span class="hljs-type">int</span> sock, string ip, <span class="hljs-type">int</span> port) <span class="hljs-comment">//构造函数里面放任务</span><br>        : _sockfd(sock), _cliip(ip), _cliport(port)<br>    &#123;<br>    &#125;<br>    ~<span class="hljs-built_in">Task</span>()<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//处理任务的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        _handler(_sockfd, _cliip, _cliport); <span class="hljs-comment">//调用仿函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">namespace</span> ns_threadpool<br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> <span class="hljs-comment">//线程池</span><br>    &#123;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num_;                  <span class="hljs-comment">//一个线程池里面有多少个任务</span><br>        std::queue&lt;T&gt; task_queue_; <span class="hljs-comment">//任务队列,临界资源</span><br>        <span class="hljs-type">pthread_mutex_t</span> mtx_;<br>        <span class="hljs-type">pthread_cond_t</span> cond_;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> num = g_num) : <span class="hljs-built_in">num_</span>(num)<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mtx_, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;cond_, <span class="hljs-literal">nullptr</span>);<br>        &#125;<br><br>        ~<span class="hljs-built_in">ThreadPool</span>()<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mtx_);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond_);<br>        &#125;<br><br>        <span class="hljs-comment">//在类中，要让</span><br><br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">Rountine</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//也不能访问类里面非static成员</span></span><br><span class="hljs-function">        </span>&#123;<br><br>            <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>()); <span class="hljs-comment">//实现线程分离就不要再去join等待了</span><br>            ThreadPool&lt;T&gt; *tp = (ThreadPool&lt;T&gt; *)args;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-comment">//从任务队列里面去拿一个任务</span><br>                <span class="hljs-comment">//执行任务，要先把这个任务队列锁主</span><br><br>                <span class="hljs-comment">//每个线程他跟放任务的线程一样，都是竞争式的去拿一个任务</span><br>                tp-&gt;<span class="hljs-built_in">Lock</span>();<br>                <span class="hljs-comment">//先检测任务队列是否有一个任务</span><br>                <span class="hljs-keyword">while</span> (tp-&gt;<span class="hljs-built_in">IsEmpty</span>())<br>                &#123;<br>                    <span class="hljs-comment">//检测到任务队列为空</span><br>                    <span class="hljs-comment">//此时线程就挂起等待</span><br>                    tp-&gt;<span class="hljs-built_in">Wait</span>();<br>                &#125;<br>                <span class="hljs-comment">//该任务队列里面一定有任务了</span><br>                T t;<br>                tp-&gt;<span class="hljs-built_in">PopTask</span>(&amp;t);<br>                <span class="hljs-comment">//任务就拿到了</span><br>                tp-&gt;<span class="hljs-built_in">UnLock</span>();<br>                t.<span class="hljs-built_in">Run</span>(); <span class="hljs-comment">//可能有多个线程在处理任务,</span><br><br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitThreadPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//初始化一批线程，</span><br>            <span class="hljs-comment">//这样就不要每次用都要去开辟线程了</span><br>            <span class="hljs-type">pthread_t</span> tid; <span class="hljs-comment">//一次创建一批线程</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_; i++)<br>            &#123;<br>                <span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">nullptr</span>, Rountine, (<span class="hljs-type">void</span> *)<span class="hljs-keyword">this</span>);<br>                <span class="hljs-comment">//在类中不能执行线程的方法，因为他都有隐藏的this指针</span><br>                <span class="hljs-comment">//所以我们需要使用静态的函数，就没有了this指针</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PopTask</span><span class="hljs-params">(T *out)</span></span><br><span class="hljs-function">        </span>&#123;<br>            *out = task_queue_.<span class="hljs-built_in">front</span>();<br>            task_queue_.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> task_queue_.<span class="hljs-built_in">empty</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnLock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushTask</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;in)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//塞任务，就相当于一个生产者，生产者之间要进行互斥访问</span><br>            <span class="hljs-built_in">Lock</span>();<br>            task_queue_.<span class="hljs-built_in">push</span>(in);<br>            <span class="hljs-built_in">UnLock</span>();<br>            <span class="hljs-built_in">Wakeup</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//万一任务队列里面一个任务都没有的话，那么线程池里面的每一个线程就要处于休眠状态，挂起等待</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>IO.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">writen</span><span class="hljs-params">(<span class="hljs-type">int</span> _sockfd,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg, <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf = msg; <span class="hljs-comment">//指向它的地址，发送出去</span><br>    <span class="hljs-type">int</span> count = size;      <span class="hljs-comment">//剩余需要发送的字节数</span><br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">send</span>(_sockfd, buf, count, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">//发送失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//没发送出去，再发送一次</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//发送成功</span><br>            buf += len;<br>            count -= len;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> size; <span class="hljs-comment">//发送成功，发送完成</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> _sockfd,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//先申请包头</span><br>    <span class="hljs-type">char</span> *data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (len + <span class="hljs-number">4</span>)); <span class="hljs-comment">//多加的4是为了数据的长度</span><br>    <span class="hljs-type">int</span> biglen = <span class="hljs-built_in">htonl</span>(len);<br>    <span class="hljs-built_in">memcpy</span>(data, &amp;biglen, <span class="hljs-number">4</span>);        <span class="hljs-comment">//拷贝4个字节过去</span><br>    <span class="hljs-built_in">memcpy</span>(data + <span class="hljs-number">4</span>, msg, len);      <span class="hljs-comment">//拷贝len个长度过去</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">writen</span>(_sockfd,data, len + <span class="hljs-number">4</span>); <span class="hljs-comment">//真正的传输数据</span><br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-comment">//发送失败</span><br>        <span class="hljs-built_in">free</span>(data); <span class="hljs-comment">//把data的内存销毁掉</span><br>        <span class="hljs-built_in">close</span>(_sockfd);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">free</span>(data);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readn</span><span class="hljs-params">(<span class="hljs-type">int</span> _sockfd,<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> *pt = buf;<br>    <span class="hljs-type">int</span> count = size;<br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">recv</span>(_sockfd, pt, count, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">//读取失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> size - count;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pt += len;<br>            count -= len;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RecvMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> _sockfd,<span class="hljs-type">char</span> **buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//解包</span><br><br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">readn</span>(_sockfd,(<span class="hljs-type">char</span> *)&amp;len, <span class="hljs-number">4</span>);<br>    len = <span class="hljs-built_in">htonl</span>(len);<br>    <span class="hljs-type">char</span> *msg = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * (len + <span class="hljs-number">1</span>));<br>    <span class="hljs-type">int</span> size = <span class="hljs-built_in">readn</span>(_sockfd,msg, len);<br>    <span class="hljs-keyword">if</span> (size != len)<br>    &#123;<br>        <span class="hljs-built_in">close</span>(_sockfd);<br>        <span class="hljs-built_in">free</span>(msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    msg[size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    *buf = msg;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>client.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;client.hpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">3</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;please type again&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    TcpClient* cl=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TcpClient</span>(argv[<span class="hljs-number">1</span>],<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br>    cl-&gt;<span class="hljs-built_in">InitClient</span>();<br>    cl-&gt;<span class="hljs-built_in">StartClient</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>client.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;IO.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpClient</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    string _ip;<span class="hljs-comment">//服务器的ip地址</span><br>    <span class="hljs-type">int</span> _port;<span class="hljs-comment">//这里的端口就是服务器的端口</span><br>    <span class="hljs-type">int</span> _sockfd;<span class="hljs-comment">//创建socket连接到服务器上面</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TcpClient</span>(string ip=<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-type">int</span> port=<span class="hljs-number">8081</span>)<br>    :_ip(ip),_port(port)<br>    &#123;&#125;    <br>    ~<span class="hljs-built_in">TcpClient</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(_sockfd&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">close</span>(_sockfd);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitClient</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        _sockfd=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(_sockfd&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> svr;<span class="hljs-comment">//连接到远程服务器上</span><br>        svr.sin_port=<span class="hljs-built_in">htons</span>(_port);<br>        svr.sin_family=AF_INET;<br>        svr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(_ip.<span class="hljs-built_in">c_str</span>());<span class="hljs-comment">//将string转化成为网络字节序</span><br>        <span class="hljs-type">socklen_t</span> len=<span class="hljs-built_in">sizeof</span>(svr);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(_sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;svr,len)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br><br><br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartClient</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <br>      <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            string msg;<br>            <span class="hljs-built_in">getline</span>(cin,msg);<br>            <span class="hljs-comment">//这样发送会出现丢包问题,所以我们要进行修改</span><br>            <span class="hljs-built_in">sendmsg</span>(_sockfd,msg.<span class="hljs-built_in">c_str</span>(),msg.<span class="hljs-built_in">size</span>());<span class="hljs-comment">//将msg的数据和大小都发送过去</span><br>            <br>            <span class="hljs-comment">//发送完之后就要接收数据</span><br>            <span class="hljs-type">char</span>* buf;<span class="hljs-comment">//用来接收数据</span><br>            <span class="hljs-type">int</span> ss=<span class="hljs-built_in">RecvMsg</span>(_sockfd,&amp;buf);      <br>            <span class="hljs-keyword">if</span>(ss&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                buf[ss]=<span class="hljs-number">0</span>;<br>                cout&lt;&lt;<span class="hljs-string">&quot;server echo &quot;</span>&lt;&lt;buf&lt;&lt;endl;<br>            &#125;<br>            <br>            <span class="hljs-comment">//发送数据</span><br><br><br><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp/ip 服务器 c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粘包问题</title>
    <link href="/2022/06/18/%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/06/18/%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>TCP是一个面向连接的，可靠的，安全的流式协议</p><h1 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h1><p>粘包是指的是数据和数据之间没有没有明确的分界线，导致不能够正确的传输数据（只有TCP会粘包 UDP 永远不会粘包），粘包问题只针对于<strong>一切字节流</strong>的协议</p><p>TCP也可以称为流式协议，UDP称为数据报式协议</p><p>对于流式协议：发送端可以1K1K的发送数据，接收端可以2k2k的提取数据，也可以3K4K的提取数据，所以对于接收端应用程序中看到的数据就是一个整体，“数据流”，一条消息里面有多少字节应用程序是看不见的，所以TCP协议面向字节流，就会出现粘包问题，而UDP这种面向消息的协议，每个UDP段都是一条消息，接收方必须以消息为单位进行提取数据，不能一次提取任意字节的数据</p><p>所谓的粘包问题就是接收方不知道消息和消息之间的边界，不知道一次提取多少个字节导致的</p><h1 id="粘包问题出现的具体原因"><a href="#粘包问题出现的具体原因" class="headerlink" title="粘包问题出现的具体原因"></a>粘包问题出现的具体原因</h1><p>应用程序无法直接操作硬件，应用程序想要操作数据必须要将数据交给操作系统，OS会为应用提供数据传输的服务，所以OS不会立刻把数据发出去，会为应用程序提供一个缓冲区，存在临时的数据，<br>发送方：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">当应用程序调用<span class="hljs-built_in">send</span>函数时候，应用程序会将数据从应用程序拷贝到操作系统缓存里面，再由OS从缓冲区里面读数据，把数据发出去<br></code></pre></td></tr></table></figure><p>接收方：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">对方计算机收到的数据也是OS先收到的，至于应用程序如何处理这些数据，OS不知道，所以同样需要将数据先存储到OS 的缓冲区里面，当应用程序调用<span class="hljs-keyword">recv</span>的时候，实际上是将OS缓冲区里面的数据拷贝到应用程序的过程<br></code></pre></td></tr></table></figure><h1 id="粘包问题的解决"><a href="#粘包问题的解决" class="headerlink" title="粘包问题的解决"></a>粘包问题的解决</h1><p>服务端如果想要保证每次都能接收到客户端发来的不定长度的数据包，程序员应该如何来解决这个问题呢？</p><ol><li>使用应用层协议（http,https）来封装要传输的不定长的数据包</li><li>再每个数据的后面添加一些特殊字符，如果遇到特殊字符，说明这条数据接收完毕了</li></ol><ul><li>每接收一个字符就要对这些字符进行判定，判定是不是特殊的字符串，效率很低</li></ul><ol start="3"><li>在发送数据快之前，在数据块之前添加一个固定大小的包头：数据头+数据块</li></ol><ul><li>数据头：存储当前<strong>数据包的总字节数</strong>，接收端先接收数据头，然后再根据数据头接收对应的大小</li><li>数据块：当前数据包的内容</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果使用TCP进行套接字通信，如果发送的数据包连在了一块，导致接收端无法解析，我们通常使用<strong>添加包头</strong>的方式来轻松解决这个问题，包头的大小为<strong>4个字节</strong>(一个int类型)，<strong>存储当前数据块的总字节数</strong><br><img src="https://img-blog.csdnimg.cn/c1f3caef6a3c4b32ab03fb916ad95a6a.png" alt="在这里插入图片描述"></p><h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><ol><li><pre><code class="hljs">根据发送的**数据长度N\*\*\*\*动态申请**一个固定大小的内存：N+4（4是包头占用的字节数）</code></pre></li><li><pre><code class="hljs">将待发送的**数据的总长度**写入申请的内存的前4个字节\(memcpy前4个字节\)，此处应该先将其转化为网络字节序（大端），再写入</code></pre></li><li><pre><code class="hljs">将待**发送的数据拷贝到包头后面的地址空间**中，将完整的数据包发送出去（字符串没有字节序问题）</code></pre></li><li><pre><code class="hljs">用一个函数来进行发送,把所有的字节全部发送出去</code></pre></li><li><pre><code class="hljs">释放申请的**堆内存空间**</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//发送指定长度的字符串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,<span class="hljs-type">int</span> size)</span><span class="hljs-comment">//发送，避免粘包，丢包</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * buf=msg;<span class="hljs-comment">//buf指向的是msg的首地址</span><br>    <span class="hljs-type">int</span> count=size;<span class="hljs-comment">//剩余的长度没有被发送出去的字节数</span><br>    <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//不停的进行数据发送</span><br>        <span class="hljs-type">int</span> len=<span class="hljs-built_in">send</span>(fd,buf,count,<span class="hljs-number">0</span>);<span class="hljs-comment">//send成功返回发送出去的字节数，否则失败返回-1，fd为向哪一个文件描述符里面发送</span><br>        <span class="hljs-comment">//buf是发送的数据</span><br>        <span class="hljs-comment">//count是数据的长度</span><br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">//发送失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//一个字节都没有发送出去</span><br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//再发送一次</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            buf+=len;<span class="hljs-comment">//buf这个指针往后移动，后面buf就全部发送了出去</span><br>            count-=len;<span class="hljs-comment">//count为剩余的字节数，变成0的话就发送完成了</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<span class="hljs-comment">//发送成功</span><br><br>&#125;<br><br><br><span class="hljs-comment">//这个加包头的操作就是这样了，其他客户端该怎么发还是怎么发送</span><br><span class="hljs-comment">//发送数据</span><br><span class="hljs-comment">//len为数据的大小 </span><br><span class="hljs-comment">//msg为发送的数据 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> cfd,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(cfd&lt;<span class="hljs-number">0</span>||msg==<span class="hljs-literal">nullptr</span>||len&lt;=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> * data=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(len+<span class="hljs-number">4</span>));<span class="hljs-comment">//先动态申请一些内存，+4是为了存数据头</span><br>    <span class="hljs-type">int</span> biglen=<span class="hljs-built_in">htonl</span>(len);<span class="hljs-comment">//把要发送的数据的长度先转化成网络字节序</span><br>    <span class="hljs-built_in">memcpy</span>(data,&amp;biglen,<span class="hljs-number">4</span>);<span class="hljs-comment">//把biglen的浅4个字节拷贝到data里面</span><br>    <span class="hljs-comment">//把我们需要的数据也拷贝到这一个内存里面去</span><br>    <span class="hljs-built_in">memcpy</span>(data+<span class="hljs-number">4</span>,msg,len);<br>    <span class="hljs-comment">//数据拷贝完之后就要发送数据了</span><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">writen</span>(cfd,data,len+<span class="hljs-number">4</span>);<span class="hljs-comment">//+4是因为要加上这个数据的包头,把data传过去发送，连通它的头</span><br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">close</span>(cfd);<span class="hljs-comment">//函数调用失败,把文件描述符关掉</span><br>    &#125;<br>    <span class="hljs-comment">//发送完之后再把内存给释放掉</span><br>    <span class="hljs-built_in">free</span>(data);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><ol><li><pre><code class="hljs">首先**先接收4个字节**（包头，记录了**接收的数据的长度**），并将它从网络字节序转化为主机字节序，这样就可以获得这些数据的总长度了</code></pre></li><li></li><li><pre><code class="hljs">根据得到的数据块长度**申请固定大小的堆内存**，用于**存储待接收**的信息</code></pre></li><li><pre><code class="hljs">处理接收的数据</code></pre></li><li><pre><code class="hljs">释放存储数据的堆内存</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//接收端</span><br><span class="hljs-comment">//接收指定字节个数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">char</span>* buf,<span class="hljs-type">int</span> size)</span><span class="hljs-comment">//buf里面就是我们要把数据读取到的地方</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//我们需要往buf这个内存地址里面写数据了，所以不能加const</span><br>    <span class="hljs-comment">//我们需要记录还需要读取多少个字节，以及读取到的位置</span><br>    <span class="hljs-type">char</span>* pt=buf;<br>    <span class="hljs-type">int</span> count=size;<span class="hljs-comment">//我们剩余要接收的字节数</span><br>    <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-built_in">recv</span>(fd,pt,count,<span class="hljs-number">0</span>);<span class="hljs-comment">//pt我们需要读取的地址，count就是我们需要读取的字节数，len就是实际读取到的长度</span><br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">//读取失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//发送端已经断开了连接</span><br>            <span class="hljs-keyword">return</span> size-count;<span class="hljs-comment">//我们就返回收到的字节数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//正常的读取了</span><br>            pt+=len;<br>            count-=len;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<span class="hljs-comment">//成功返回</span><br>&#125;<br><br><br><span class="hljs-comment">//接收函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">char</span>** msg)</span><span class="hljs-comment">//这里的msg是一个输出型参数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//我们需要先把数据头给读出来，看它的数据是有多少的数据</span><br>    <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">readn</span>(fd,(<span class="hljs-type">char</span>*)&amp;len,<span class="hljs-number">4</span>);<span class="hljs-comment">//我们把数据读取到len里面</span><br>    <span class="hljs-comment">//现在还是网络字节序，我们需要将它转化为主机字节序</span><br>    len=<span class="hljs-built_in">ntohl</span>(len);<br>    cout&lt;&lt;<span class="hljs-string">&quot;要接收到的数据块的长度为&quot;</span>&lt;&lt;len&lt;&lt;endl;<br>    <span class="hljs-comment">//根据我们读取到的长度len（有效数据的大小）来分配长度</span><br>    <span class="hljs-type">char</span>* data=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(len+<span class="hljs-number">1</span>));<span class="hljs-comment">//+1是‘\0’,字符串结束的标志</span><br>    <span class="hljs-comment">//再去调用这个函数</span><br>    <span class="hljs-type">int</span> length=<span class="hljs-built_in">readn</span>(fd,data,len);<span class="hljs-comment">//我们要接收的数据长度是len</span><br>    <span class="hljs-keyword">if</span>(length==len)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;读取成功&quot;</span>&lt;&lt;endl;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//接收数据失败了</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;接收数据失败了&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">close</span>(fd);<br>        <span class="hljs-built_in">free</span>(data);<span class="hljs-comment">//因为接收失败了，所以这块内存就没有意义了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    data[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>    *msg=data;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>udp 网络 tcp/ip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP基础（1）</title>
    <link href="/2022/06/13/TCP%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
    <url>/2022/06/13/TCP%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#TCPUDP_5">TCP和UDP</a></li><li><a href="#TCPIP__9">为什么要有TCP&#x2F;IP 协议</a></li><li><a href="#TCP_23">TCP（传输控制协议）</a></li><li><ul><li><a href="#TCP__32">TCP 报文格式</a></li><li><a href="#_88">确认应答机制</a></li><li><a href="#_104">缓冲区</a></li></ul></li></ul><p>TCP和UDP协议发生在传输层<br>传输层主要处理：端到端的连接</p><h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><blockquote><p>UDP 是一个人面向无连接的，可类比成写信，UDP发送写信到邮箱之后，对方不能够立即就可以收到，先后发送的信件也不一定是按照顺序接收，甚至里面信的内容有可能也不会完整<br>而TCP可以类比成电话，我们拨打电话到对方接通，互相通话，结束后挂断，这些都能够完成，并且能够确认对方是否能够接收到数据，</p></blockquote><h1 id="为什么要有TCP-x2F-IP-协议"><a href="#为什么要有TCP-x2F-IP-协议" class="headerlink" title="为什么要有TCP&#x2F;IP 协议"></a>为什么要有TCP&#x2F;IP 协议</h1><p>数据的IO操作，硬件的数据到另外一个硬件上面也是需要有协议的，在冯诺依曼体系中，也是设计一个硬件和一个硬件之间都是相互独立的，硬件之间的通信也都是需要协议（因为有“线”）<br>总线就是用来解决通信的问题</p><p>一个单处理器系统中的总线有三种</p><blockquote><ol><li>CPU 内部连接各个<strong>寄存器</strong>及其<strong>运算部件</strong>之间的总线，称为内部总线</li><li>CPU 同计算机系统的其他高速功能部件（存储器，通道等互相连接的总线），称为系统总线</li><li>中，低速度IO设备之间互相连通的总线位，IO 总线</li></ol></blockquote><p>结论</p><blockquote><ul><li>在网络中的各个设备，各个电脑之间也是直接或者间接使用“线”来进行连接的</li><li>只不过网络中，“线”变的更长了，可以通信的距离变遥远了</li><li>因此一旦传输距离变长的话，就需要一些协议来保证数据可以可靠的到达</li></ul></blockquote><h1 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h1><p>TCP在两个端点（应用程序之间提供了可靠的，面向连接的，双向字节流通信信道）<br>TCP端点：表示TCP连接一端的内核所维护的信息（通常会进一步对这个术语进行缩写），“一个TCP端点”或者“客户端TCP”来表示“客户端应用程序所维护的TCP端点”</p><p><strong>TCP 实现有效的载荷和首部分离是通过</strong>4位首部<strong>实现的</strong><br>TCP实现交付给上层工作是由16位目的端口号**</p><p>假设首部长度为6，说明选项有4字节，这样就可以完整的读取报头数据，然后数据的读取可以根据数据的协议做处理，</p><h2 id="TCP-报文格式"><a href="#TCP-报文格式" class="headerlink" title="TCP 报文格式"></a>TCP 报文格式</h2><p>1行就是4个字节<br>TCP 标准长度20个字节<br>4位首部长度[0000,1111]<br><img src="https://img-blog.csdnimg.cn/0d2a148db5474570b52a83571741c9b3.png" alt="在这里插入图片描述"></p><p>序列号 : 序列号: 序列号:<br>TCP 连接中发送的每一个字节都是按照顺序编号<br>在建立连接的时候，设置整个要传送的字节流的其实序号为计算机生成的随机数<br>序列号则是本报文段发送的第一个字节的序号，<br><img src="https://img-blog.csdnimg.cn/ab25d026d86b443a8a2377e27256d137.png" alt="在这里插入图片描述"></p><p>确认号 确认号 确认号<br>是对历史确认报文的序号+1，是期望收到对方下一个报文段的序列号，而且确认号为N，表示前N-1为止的数据 都已经正确收到了</p><p>首部长度 首部长度 首部长度<br>里面记录的是报头长度<br>基本单位是4字节，如果首部长度是1，那么实际长度就是1 * 4&#x3D;4，表示TCP 头部有多少个32为bit（有多少个4字节），因为是4位所以TCP头部最大长度是（1111）15*4&#x3D;60<br>最小是固定20个字节,我们一般都是长度都是20，所以20&#x2F;4&#x3D;5，填充的是0101</p><blockquote><p>所以当我们读取到一个完成的TCP报文，提取到前20个字节（标准长度），从里面分析到报文长度，确认报文是20个字节，剩余的就是有效载荷，提取，</p></blockquote><p>窗口大小 窗口大小 窗口大小<br>表示自己接收缓冲区剩余的空间大小，要求对方发送数据的时候要考虑到这一点，这个值通常是变化的（16位）</p><p>校验和 校验和 校验和<br>校验的范围包括首部和数据<br>发送端填充CRC 校验，接收端校验不通过，则认为数据有问题</p><p>紧急指针 紧急指针 紧急指针<br>指出了紧急数据的末尾在报文段中的位置,和URG搭配使用，<br>因为TCP都是按序到达的，每一个报文，什么时候被上层读到都是确定的，<br>如果想让一个数据尽快的被上层读取，可以设置URG：表明该报文<strong>携带</strong>了紧急数据，需要优先读取<br>16位紧急指针就会指向对应的地址<br><strong>tcp的紧急指针只能传输1个字节</strong></p><p>六位标志位 六位标志位 六位标志位</p><blockquote><p>server首先要面对的是，有大量的TCP报文，如何区分报文的类别<br>例如送外卖，普通外卖，美团，饿了吗怎么区分，不同的人有不同的策略</p></blockquote><p>这些标志位可以用来区分不同种类的TCP报文<br>每个标志位都是一个bit，要么是0，要么是1</p><p>URG(urgent):为1代表了紧急指针有效,和16位紧急指针搭配使用<br>ACK:为1代表有效，连接建立后所有的报文ACK都是1，<strong>确认报文</strong>，几乎所有的TCP报文都会设置ACK<br>PSH(push)：<strong>告知对方尽快的将数据向上交付</strong>，避免缓冲区被打满了，发送方无法发送<br>RST(reset)：表明出现了严重差错，必须释放连接重新建立，<strong>重置异常连接</strong><br>SYN：为1代表了这是一个连接请求，<strong>链接请求报文</strong><br>FIN：通知对方，本端要关闭了，我们称携带FIN 表示的为结束报文段，<strong>断开连接报文</strong></p><p>选项 选项 选项<br>选项的首部-标长<br>60-20&#x3D;40,选项的最大长度</p><h2 id="确认应答机制"><a href="#确认应答机制" class="headerlink" title="确认应答机制"></a>确认应答机制</h2><p>tcp并不是百分之百可靠的！因为总会遇到一条消息没有被应答,但是只要一条消息有应答，我们就能确认该消息被对方100%收到了,世界上不存在100%可靠的，因为不能确认它丢了还是被应答了</p><p>TCP可靠性的核心机制：确认应答机制，按序到达</p><ol><li>发送的数据对方收到并发送确认就保证了数据是发送成功的</li><li>为了避免发送的数据出现混乱，使用序列号</li><li>确认序号保证之前发送的数据发送成功，按序到达，确认是哪一个报文发送成功</li><li>无论是数据还是应答，本质上都是：一个完整的tcp报文，可以不携带数据，但是一定是一个完整的tcp报文，源端口目的端口，这些都要有</li><li>一个报文为什么既有序号又有确认号<blockquote><p>因为tcp是一个全双工的通信协议（我给你发消息的同时，你也可以给我发送消息），你在给我确认的时候，我也可以给你确认<br>有可能是既有自己要发送的报文的序号，也同时有对对方报文的确认</p></blockquote></li></ol><p>通过确认应答机制能够保证我的<strong>历史数据</strong>被收到了</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>TCP协议，是自带发送和接收缓冲区的！<br>（TCP malloc2段内存空间）</p><ul><li>write&#x2F;send:与其叫做发送接口，不如理解成拷贝函数，send是把数据拷贝到TCP的发送缓冲区里面，接下来TCP 就把发送缓冲区里面的数据，直接发送给对方的接收缓冲区里面</li><li>read&#x2F;recv:与其叫做接收窗口，不如叫做拷贝函数，recv是把数据从TCP 的接收缓冲区里面拷贝到本地,有的时候会阻塞住，是因为缓冲区里面没数据，不是网络里面没数据</li></ul><p><strong>为什么要有缓冲区？</strong></p><ul><li>提高应用层效率：应用层把数据拷贝到缓冲区里面，就可以直接返回了,至于什么时候发送，怎么发送，我不关心</li><li>只有操作系统的TCP 协议可以知道网络及对方的状态信息，所以也就只有TCP协议，知道如何发，什么时候发，发多少，出错了怎么办？（传输控fa制协议）发送的细节应用层就不用管了</li><li>缓冲区的存在可以做到应用层和TCP进行解耦，各自做好各自的事即可</li></ul><p><img src="https://img-blog.csdnimg.cn/9a0f354014c74a0e9dc6c2e026f248b5.png" alt="在这里插入图片描述"></p><p>在第一次发送SYN 的时候{SYN，1000-》（标号）（0-》数据的大小） &lt;mass 1460 （传输文件的大小上限）&gt;}</p><ol><li>确认号+1 是因为在原来的序列号还要加上SYN这个标志位的大小</li><li>三次握手完成在代码层面上的体现就是：accept（）和connect()成功执行返回，所以accept（）执行发出错误信号出来，或者connect都是没有建立成功</li><li>普通报文不携带数据，不消耗序列号，所以后面再在传输的时候不会加上标志位，该多大就多大</li><li>假如说客户端先发起关闭，第一次挥手断开连接（半关闭，有一端关了，另一端没有关闭第一次挥手），客户端如果还有数据就不能再发送了，相当于socket内部的写缓冲区关闭了，但是读缓冲区还留着</li><li>后面服务器也要发起关闭，也要有两次挥手（半关闭是导致4次挥手的原因）</li><li>半关闭并非是关套接字，而是关里面的写缓冲区，读缓冲区还没有关闭，</li><li>数据会被分成段，如果一个段在到达时是存在错误的，这个段就会被丢弃，确认信息也不会发送，发送者在发送每一个段的时候，都会开启一个定时器，如果定时器超时之前没有收到确认，就会重传这个段，</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>udp tcp/ip 网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读者写者模型</title>
    <link href="/2022/06/05/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/06/05/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_3">读者写者模型</a></li><li><ul><li><a href="#vs%0A_13">生产消费vs读者写者 根本原因：读者不会取走资源，而消费者会拿走数据</a></li></ul></li><li><a href="#_34">接口</a></li><li><a href="#_97">自旋锁</a></li></ul><p>🤔水文🤢</p><h1 id="读者写者模型"><a href="#读者写者模型" class="headerlink" title="读者写者模型"></a>读者写者模型</h1><ol><li>对数据，大部分的操作是读取，少量的操作是写入</li><li>判断依据就是进行数据读取（消费的一段），是否会将数据取走，如果不去走就可以考虑读者写者模型</li></ol><blockquote><p>出黑板报，一个人在写，多个人在读<br>写者和写者：竞争互斥关系<br>读者和写者：互斥关系（要保证写完我才能来读，避免没有写完读的数据不准确，我在看的时候，你擦了不可以），<br>同步关系（我们写完了就可以让读者来读，读完了让写者来写）<br>读者和读者之间：没有关系</p></blockquote><h2 id="生产消费vs读者写者"><a href="#生产消费vs读者写者" class="headerlink" title="生产消费vs读者写者"></a>生产消费vs读者写者</h2><p>根本原因：读者不会取走资源，而消费者会拿走数据</p><p>使用代码完成读者写者模型：使用锁来维护上面三种关系，又线程承担</p><p>321原则<br>3：三种关系</p><blockquote><p>读者和读者<br>读者和写着<br>写者和写者</p></blockquote><p>2：两种角色</p><blockquote><p>读者和写者</p></blockquote><p>3:一个交易场所</p><blockquote><p>提供一段缓冲区（我们自己申请的，还是stl）</p></blockquote><p>示例</p><blockquote><ol><li>新闻发布（我们写的博客，也适合）</li></ol></blockquote><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_rwlock_t</span>  rwlock                                            <span class="hljs-comment">//数据类型</span><br><br><span class="hljs-built_in">pthread_rwlock_init</span>(<span class="hljs-type">pthread_rwlock_t</span>*rwlock,<span class="hljs-type">pthread_rwlock_t</span>* attr);          <span class="hljs-comment">//初始化</span><br><br><br><span class="hljs-built_in">pthread_rwlock_rdlock</span>(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)               <span class="hljs-comment">//以读者的身份加锁</span><br><span class="hljs-built_in">pthread_rwlock_tryrdlock</span>(<span class="hljs-type">pthread_rwlock_t</span> * rwlock)<br><br><span class="hljs-comment">//以写者方式加锁</span><br><span class="hljs-built_in">pthread_rwlock_wrlock</span>(<span class="hljs-type">pthread_rwlock_t</span>* rwlock)<br><br><span class="hljs-comment">//释放都是一样的</span><br><span class="hljs-built_in">pthread_rwlock_unlock</span>(<span class="hljs-type">pthread_rwlock_t</span>* rwlock)<br><br><br></code></pre></td></tr></table></figure><p>如何理解伪代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">写者                           <span class="hljs-type">int</span> readers=<span class="hljs-number">0</span>                                              <br><br>mtx1.<span class="hljs-built_in">lock</span>()<span class="hljs-comment">//写者先加锁</span><br><span class="hljs-keyword">while</span>(readers&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//读者大于0</span><br>&#123;<br><span class="hljs-comment">//</span><br><span class="hljs-built_in">wait</span>(mtx1,)<span class="hljs-comment">//等待</span><br>&#125;<br>写者<br><br><span class="hljs-comment">//读者和写者竞争一把锁，进来发现为0，就解锁</span><br><br>mtx1.<span class="hljs-built_in">unlock</span>()<br><br><span class="hljs-comment">//待补充</span><br>进入临界区<br><br>读者<br>mtx1.<span class="hljs-built_in">lock</span>()<br>readers++;<br>mtx1.<span class="hljs-built_in">unlock</span>()<br><br><br><br>mtx1.<span class="hljs-built_in">lock</span>()<br>readers--;<br>mtx1.<span class="hljs-built_in">unlock</span>()<br></code></pre></td></tr></table></figure><p>优先级：</p><p>读者优先：让我们的读者和写者同时到来的时候，让读者先进入访问，</p><p>写者优先：当读者和写者同时到来的时候，比当前写者晚来的所有的读者都不要进入临界区访问了，等临界区中没有读者的时候，让写先写入，</p><p>但是这样，（读者多，写者少），所以会出现写饥饿问题（中性词），当我们的数据都被读完之后再给修改，</p><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>挂起等待特性的锁vs自旋锁<br>挂起等待的锁：<br><img src="https://img-blog.csdnimg.cn/5ed9ecc0d7ea415eb5dc6813cb1d0a54.png" alt="在这里插入图片描述"><br>挂起等待：就是时间等待的久<br>自旋：就是等待的时间不多，就一会一会就询问情况</p><p>多个线程访问一个临界资源<br>一开始就是加锁，后面解锁<br>线程访问临界资源，花费的时长问题？？</p><ol><li>如果访问花费的时间很长，就适合挂起等待锁</li><li>如果花费的时间很短，那么就适合自旋锁<br>线程如何得知，自己会再临界资源里面待多长时间呢？</li></ol><blockquote><p>线程不知道！程序员知道！</p></blockquote><p>等待的时间短，就使用这个自旋锁<br><img src="https://img-blog.csdnimg.cn/23d849c1434f4c91a58ade94b6a8992f.png" alt="在这里插入图片描述"></p><p>pthread_spin_t 和其他锁都一样，</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11(1)</title>
    <link href="/2022/06/04/C++11(1)/"/>
    <url>/2022/06/04/C++11(1)/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">统一的列表初始化</a></li><li><a href="#initializer_list_74">initializer_list</a></li><li><a href="#_128">声明</a></li><li><ul><li><a href="#auto_129">auto</a></li><li><a href="#decltype_132">decltype</a></li><li><a href="#nullptr_164">nullptr</a></li></ul></li></ul><h1 id="统一的列表初始化"><a href="#统一的列表初始化" class="headerlink" title="统一的列表初始化"></a>统一的列表初始化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-type">int</span> _x;<br>    <span class="hljs-type">int</span> _y;<br>   <span class="hljs-comment">/*explicit*/</span> <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)<br>    :_x(x),_y(y)&#123;cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;&#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    :_a(a)&#123;</span>&#125;<br><br>&#125;;<br><br><br>    <span class="hljs-comment">//单参数类型支持隐式类型转换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">aa</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//单参数的类型，可以使用正常的方式</span><br>    <span class="hljs-comment">//A b=2;//也可以使用这种隐式类型的转换</span><br>    <span class="hljs-comment">//2拷贝构造一个A，在进行拷贝构造成b</span><br>    <span class="hljs-comment">//加一个explicit，就不能这样了</span><br>    string s1=<span class="hljs-string">&quot;hjs&quot;</span>;<span class="hljs-comment">//string的构造函数没有加explicit</span><br>    vector&lt;string&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;hjk&quot;</span>);<span class="hljs-comment">//这也是隐式类型转换</span><br><br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//以前</span><br>    Point p=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//c语言是使用这种方式来初始化</span><br>    <span class="hljs-type">int</span> brr[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//使用这种大括号进行初始化</span><br><br>    <br>    <span class="hljs-comment">//现在s</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b=&#123;<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//现在还可以这样进行初始化,=也省略了</span><br>    <span class="hljs-type">int</span> c&#123;<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    Point k&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> * ptr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//初始化了前3个值，后面的值全都是0</span><br>    Point* ptrd=<span class="hljs-keyword">new</span> Point[<span class="hljs-number">2</span>]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;&#125;;<span class="hljs-comment">//现在还可以这样进行初始化,里面必须要又两个&#123;&#125;</span><br>    <span class="hljs-comment">//new要去调用他的构造函数</span><br><br><br><br>    <span class="hljs-comment">//正常调用point</span><br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//调用构造函数</span><br>    <br>    <span class="hljs-comment">//c++11支持的多参数的构造函数</span><br>    Point p2=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    Point p3&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">auto</span> il=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//都是因为支持initializer_list的构造函数</span><br><br>    <span class="hljs-comment">//以前的vector初始化</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//现在vector也可以这样初始化, 掉的就是initializer list进行初始化</span><br><br>    initializer_list&lt;<span class="hljs-type">int</span>&gt; lt=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//</span><br>    list&lt;<span class="hljs-type">int</span>&gt; l=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//链表也可以这样初始化</span><br>    map&lt;string,string&gt; dic=&#123;&#123;<span class="hljs-string">&quot;dasd&quot;</span>,<span class="hljs-string">&quot;dsa&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;dsada&quot;</span>,<span class="hljs-string">&quot;fd&quot;</span>&#125;&#125;;<span class="hljs-comment">//map也可以</span><br>    v2=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<span class="hljs-comment">//也可以用赋值，不是构造，在赋值运算符重载那里使用了initialzer_list </span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:v2)<br>    &#123;<br>        cout&lt;&lt;e&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">List</span>(initializer_list&lt;T&gt; ilt) <span class="hljs-comment">//使用initializer_list进行初始化</span><br>      &#123;<br>          _head = <span class="hljs-keyword">new</span> Node;     <span class="hljs-comment">//无参构造</span><br>          _head-&gt;_next = _head; <span class="hljs-comment">//因为是双向链表</span><br>          _head-&gt;_prev = _head;<br><br>          <span class="hljs-keyword">typename</span> initializer_list&lt;T&gt;::iterator it=ilt.<span class="hljs-built_in">begin</span>();<br>          <span class="hljs-keyword">while</span>(it!=ilt.<span class="hljs-built_in">end</span>())<br>          &#123;<br>              <span class="hljs-built_in">PushBack</span>(*it);<br>              it++;<br>          &#125;<br>      &#125;<br><br></code></pre></td></tr></table></figure><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>自动推导类型，范围for</p><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>推导对象的类型,可以作为模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">typeid</span>(x).<span class="hljs-built_in">name</span>()&lt;&lt;endl;<span class="hljs-comment">//获得x的类型名字</span><br>    <span class="hljs-keyword">decltype</span>(x) z=<span class="hljs-number">2</span>;<span class="hljs-comment">//获得x的类型名，来初始化另一个变量</span><br>    <span class="hljs-type">double</span> y=<span class="hljs-number">2.2</span>;<br>    <span class="hljs-keyword">decltype</span>(x*y) ret;<span class="hljs-comment">//ret类型为double</span><br>    <span class="hljs-keyword">decltype</span>(&amp;x) p;<span class="hljs-comment">//p类型为int*</span><br><br>    <span class="hljs-built_in">int</span>(*func)(<span class="hljs-type">int</span>)=func;<span class="hljs-comment">//函数指针</span><br>    <span class="hljs-keyword">auto</span> pfunc=func;<span class="hljs-comment">//直接用auto也可以</span><br>    <span class="hljs-keyword">decltype</span>(pfunc) pfun3=func;<span class="hljs-comment">//定义一个变量</span><br>    map&lt;string,string&gt; dict=&#123;&#123;<span class="hljs-string">&quot;sort&quot;</span>,<span class="hljs-string">&quot;排序&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;insert&quot;</span>,<span class="hljs-string">&quot;插入&quot;</span>&#125;&#125;;<br>    <span class="hljs-keyword">auto</span> it=dict.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> cpit=it;<br>    <span class="hljs-comment">//但是不能把auto作为模板参数</span><br>    vector&lt;<span class="hljs-keyword">decltype</span>(it)&gt; v;<span class="hljs-comment">//这样就很方便</span><br>    v.<span class="hljs-built_in">push_back</span>(it);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>避免了NULL 定义为0</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产者消费者模型----基于互斥与同步</title>
    <link href="/2022/06/03/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B----%E5%9F%BA%E4%BA%8E%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/06/03/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B----%E5%9F%BA%E4%BA%8E%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://img-blog.csdnimg.cn/2bbab7fd2fd54e1c98d96349376c8e84.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8e36fcf487de4eb382f9d7b7298537e0.png" alt="在这里插入图片描述"><br>我们的生产者和消费者，传输数据只是第一步</p><ol><li>数据怎么来的，耗时吗</li><li>数据怎么处理，耗时吗</li></ol><p>我们还需要对获得的数据添加一个场景 即对他就行任务处理</p><p>如生产者放进去了一个任务（x，y±* &#x2F;）<br>消费者拿到了这个任务，就要对这些任务进行处理</p><p>BlockQueue.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//.hpp 是 c++里面 在开源软件里面使用，声明和定义都可以放在一个文件里面</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">namespace</span> ns_blockqueue<span class="hljs-comment">//使用一个自己的命名空间</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> default_cap = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-comment">//定义一个类模板</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        std::queue&lt;T&gt; _bq;    <span class="hljs-comment">//队列,使用了一个类模板</span><br>        <span class="hljs-type">int</span> _cap;               <span class="hljs-comment">//队列的元素上限</span><br>        <span class="hljs-type">pthread_mutex_t</span> _mutex; <span class="hljs-comment">//保证数据安全</span><br>        <span class="hljs-comment">//当生产满了的时候，就不要生产了，不要生产锁了，让消费者来消费</span><br>        <span class="hljs-comment">//当消费空了，就不要消费了，让生产了</span><br>        <span class="hljs-comment">//这就要有两个条件变量</span><br>        <span class="hljs-type">pthread_cond_t</span> _full;  <span class="hljs-comment">//_bq满的，就要让消费者来消费，空了就要在这个条件变量等待</span><br>        <span class="hljs-type">pthread_cond_t</span> _empty; <span class="hljs-comment">//_bq空了，要让生产者来生产，生产者在该条件变量进行等待</span><br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _bq.<span class="hljs-built_in">size</span>() == _cap;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LockQueue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;_mutex);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnLockQueue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;_mutex);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WaitProduct</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//因为条件变量和互斥锁都搭配使用，我们进入临界资源，我们就是持有锁的</span><br>            <span class="hljs-comment">// 1.调用的时候，会首先自动释放锁资源</span><br>            <span class="hljs-comment">// 2.然后再挂起自己，这样别人就可以去申请锁</span><br>            <span class="hljs-comment">// 3.返回的时候，会首先竞争锁，获取到锁之后，才能返回</span><br><br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;_full, &amp;_mutex);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _bq.<span class="hljs-built_in">empty</span>();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WaitConsume</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//如果一直抱着锁被挂起的话，就会被永远挂起，死锁</span><br><br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;_empty, &amp;_mutex);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WakeupConsumer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_signal</span>(&amp;_empty);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WakeupProducer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_signal</span>(&amp;_full);<br>        &#125;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">BlockQueue</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> cap = default_cap) <span class="hljs-comment">//带一个缺省参数</span><br>            : _cap(cap)<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_init</span>(&amp;_mutex, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;_full, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;_empty, <span class="hljs-literal">nullptr</span>);<br>        &#125;<br>        ~<span class="hljs-built_in">BlockQueue</span>()<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;_mutex);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;_full);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;_empty);<br>        &#125;<br>        <span class="hljs-comment">// const &amp; 输入型参数</span><br>        <span class="hljs-comment">//* 输出型参数</span><br>        <span class="hljs-comment">//&amp; 输入输出型参数</span><br><br>        <span class="hljs-comment">//只有消费者知道，生产者什么时候可以生产</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;in)</span> <span class="hljs-comment">//向我们的队列中放数据</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//在访问临界资源的时候，就应该把数据锁住</span><br>            <span class="hljs-built_in">LockQueue</span>();<br>            <span class="hljs-comment">//因为生产者消费者之间都是看同一个队列，所以这一把锁就已经够用了</span><br><br><br><br>            <span class="hljs-comment">//临界区</span><br>            <span class="hljs-comment">// if (IsFull())</span><br>            <span class="hljs-comment">//我们需要进行条件检测的时候，这里需要使用循环的方式</span><br>            <span class="hljs-comment">//来保证退出循环一定是条件不满足导致的</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">IsFull</span>())<br>            &#123;<br>                <span class="hljs-comment">//等待，把线程挂起，我们当前是持有锁的，</span><br>                <span class="hljs-comment">//如果队列是空的话就不应该生产了，而是在那里等待</span><br><br>                <span class="hljs-comment">//1. 如果我挂起失败呢，因为函数调用有成功有失败</span><br>                <span class="hljs-comment">//函数调用失败</span><br><br><br>                <span class="hljs-comment">//2. 如果我被伪唤醒呢（条件还没有就绪）</span><br>                <span class="hljs-comment">//如果是多核多CPU的，很多线程都在条件变量下等待</span><br><br><br><br>                <span class="hljs-built_in">WaitProduct</span>();<br>                <span class="hljs-comment">//我醒来之后要再进行一次判断，判断是否为满，判断成功就往下走，</span><br>            &#125;<br>            <span class="hljs-comment">//用if判断，有可能当前队列还是满的，再向下走的话，就会插入一个不应该插入的数据</span><br><br>            <span class="hljs-comment">//生产函数</span><br>            _bq.<span class="hljs-built_in">push</span>(in);<br><br>            <span class="hljs-comment">//唤醒消费者,这里我们制定的策略是，有一个就唤醒一个</span><br>            <span class="hljs-keyword">if</span>(_bq.<span class="hljs-built_in">size</span>()&gt;_cap/<span class="hljs-number">2</span>)<span class="hljs-comment">//改变策略</span><br>            <span class="hljs-built_in">WakeupConsumer</span>();<br><br>            <span class="hljs-built_in">UnLockQueue</span>(); <span class="hljs-comment">//解锁</span><br>        &#125;<br>        <span class="hljs-comment">//只有生产者知道，消费者什么时候可以生产</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">(T *out)</span> <span class="hljs-comment">//向队列里面拿数据</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">LockQueue</span>();<br>            <span class="hljs-comment">// if(IsEmpty())</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">IsEmpty</span>())<br>            &#123;<br>                <span class="hljs-comment">//无法消费</span><br>                <span class="hljs-built_in">WaitConsume</span>();<br>            &#125;<br>            <span class="hljs-comment">//消费函数</span><br>            *out = _bq.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//拿到队头的元素</span><br>            _bq.<span class="hljs-built_in">pop</span>();          <span class="hljs-comment">//删除数据</span><br>            <span class="hljs-keyword">if</span>(_bq.<span class="hljs-built_in">size</span>()&lt;_cap/<span class="hljs-number">2</span>)<br>            <span class="hljs-built_in">WakeupProducer</span>();<span class="hljs-comment">//唤醒生产者,这里的wakeup放在里面和外面都是可以的</span><br>            <span class="hljs-built_in">UnLockQueue</span>();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>Task.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> ns_task<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> _x;<br>        <span class="hljs-type">int</span> _y;<br>        <span class="hljs-type">char</span> _op; <span class="hljs-comment">//表示+-*/%</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Task</span>() <span class="hljs-comment">//无参构造，为了拿任务，不需要参数列表</span><br>        &#123;<br>        &#125;<br>        <span class="hljs-comment">//进行函数重载</span><br>        <span class="hljs-built_in">Task</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">char</span> op) <span class="hljs-comment">//有参构造，制造任务</span><br>            : _x(x), _y(y), _op(op)<br>        &#123;<br>        &#125;<br>        ~<span class="hljs-built_in">Task</span>()<br>        &#123;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">switch</span> (_op)<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                res = _x + _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                res = _x - _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                res = _x * _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                res = _x / _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>                res = _x % _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;bug?&quot;</span> &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;当前任务正在被：&quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; <span class="hljs-string">&quot;处理:&quot;</span> &lt;&lt; _x &lt;&lt; _op &lt;&lt; _y &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; res &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Task <span class="hljs-keyword">operator</span>=(Task &amp;s)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)<br>            &#123;<br>                _x = s._x;<br>                _y = s._y;<br>                _op = s._op;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span><span class="hljs-comment">//重载一个函数</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Run</span>();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>PC.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;BlockQueue.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Task.hpp&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_blockqueue;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_task;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//两个角色已经是有了</span><br>    BlockQueue&lt;Task&gt;* bq=(BlockQueue&lt;Task&gt;*)args;<span class="hljs-comment">//拿到了了阻塞队列</span><br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">// sleep(2);</span><br>        <span class="hljs-comment">// int data=0;//我们想把数据拿出来</span><br>        <span class="hljs-comment">// bq-&gt;Pop(&amp;data);</span><br>        <span class="hljs-comment">// //data就是一个输出型参数</span><br>        <span class="hljs-comment">// std::cout&lt;&lt;&quot;消费者消费了一个数据：&quot;&lt;&lt;data&lt;&lt;std::endl;</span><br><br>        <span class="hljs-comment">//消费者这里需要获得任务，无参构造就行了</span><br>        Task t;<br>        bq-&gt;<span class="hljs-built_in">Pop</span>(&amp;t);<span class="hljs-comment">//任务拿出来了，消费的第一步</span><br>        <span class="hljs-comment">//拿出来之后我们就要对任务进行处理 </span><br>        <span class="hljs-comment">// t.Run();</span><br>        <span class="hljs-built_in">t</span>();<span class="hljs-comment">//拿到任务，直接返回,消费的第二步</span><br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* args)</span></span><br><span class="hljs-function"></span>&#123;<br>    BlockQueue&lt;Task&gt;* bq=(BlockQueue&lt;Task&gt;*)args;<span class="hljs-comment">//拿到了了阻塞队列</span><br>    std::string ops=<span class="hljs-string">&quot;+-*/%&quot;</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">// sleep(2);//按照生产者的节奏来走</span><br>        <span class="hljs-comment">//我生产一条他消费一条</span><br>        <span class="hljs-comment">//制造数据</span><br><br>        <span class="hljs-comment">//生产者的数据（task）哪里来呢</span><br>        <span class="hljs-comment">// int data=rand()%20+1;</span><br>        <span class="hljs-comment">// std::cout&lt;&lt;&quot;生产者生产数据：&quot;&lt;&lt;data&lt;&lt;std::endl;</span><br>        <span class="hljs-comment">// bq-&gt;Push(data);</span><br>        <br>        <span class="hljs-comment">//1. 生产一个任务</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">20</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> y=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">10</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">char</span> op=ops[<span class="hljs-built_in">rand</span>()%<span class="hljs-number">5</span>];<span class="hljs-comment">//0-4之间,进行操作运算</span><br>        <span class="hljs-function">Task <span class="hljs-title">t</span><span class="hljs-params">(x,y,op)</span></span>;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;生产派发了一个任务&quot;</span>&lt;&lt;x&lt;&lt;op&lt;&lt;y&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;<span class="hljs-string">&quot;?&quot;</span>&lt;&lt;std::endl;<br>        <br>        <span class="hljs-comment">//2.把数据放到队列里面</span><br>        <br>        bq-&gt;<span class="hljs-built_in">Push</span>(t);<span class="hljs-comment">//把任务塞进去了</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<span class="hljs-comment">//种了一个随机数种子</span><br>    BlockQueue&lt;Task&gt;* bq=<span class="hljs-keyword">new</span> <span class="hljs-built_in">BlockQueue</span>&lt;Task&gt;(<span class="hljs-number">6</span>);<span class="hljs-comment">//我们动态开辟的一个空间，因为引入了模板，所以这里我们对他进行实例化一下顺便初始化一下</span><br>    <span class="hljs-type">pthread_t</span> c,p;<br>    <span class="hljs-type">pthread_t</span> c1,c2,c3,c4;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;c,<span class="hljs-literal">nullptr</span>,consumer,(<span class="hljs-type">void</span>*)bq);<span class="hljs-comment">//把阻塞队列传进去就可以看到同一个阻塞队列了</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;c1,<span class="hljs-literal">nullptr</span>,consumer,(<span class="hljs-type">void</span>*)bq);<span class="hljs-comment">//把阻塞队列传进去就可以看到同一个阻塞队列了</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;c2,<span class="hljs-literal">nullptr</span>,consumer,(<span class="hljs-type">void</span>*)bq);<span class="hljs-comment">//把阻塞队列传进去就可以看到同一个阻塞队列了</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;c3,<span class="hljs-literal">nullptr</span>,consumer,(<span class="hljs-type">void</span>*)bq);<span class="hljs-comment">//把阻塞队列传进去就可以看到同一个阻塞队列了</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;c4,<span class="hljs-literal">nullptr</span>,consumer,(<span class="hljs-type">void</span>*)bq);<span class="hljs-comment">//把阻塞队列传进去就可以看到同一个阻塞队列了</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;p,<span class="hljs-literal">nullptr</span>,producer,(<span class="hljs-type">void</span>*)bq);<br>    <span class="hljs-built_in">pthread_join</span>(c,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">pthread_join</span>(p,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">delete</span> bq;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/06/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/06/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式就是一种“经典的，常用的，常考的” 设计模式</p><h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>大佬对于一些常见的场景，给定了一个特定对应的解决方案，这个就是设计模式，这个是可以被推广使用的</p><h1 id="单例模式的特定"><a href="#单例模式的特定" class="headerlink" title="单例模式的特定"></a>单例模式的特定</h1><p>某些类，只应该需要又一个对象（实例），就称为单例</p><p>例如：一个男人只能取一个老婆</p><blockquote><p>类 对象</p><p>threadpool tp</p><p>定义一个对象：开辟空间+给空间写入初始值（本质上就是将对象加载到内存里面）</p><p>只让该对象在内存中存在一份，加载一次</p></blockquote><p>一般而言，我们的对象被设计称单例模式</p><blockquote><ol><li>语意上，我们只需要一个</li><li>该对象内部存在有大量的空间，保存了大量的数据，如果允许该对象存在多份的话，或者允许发生各自拷贝，内存中存在冗余数据</li></ol><p>这一般情况下，我们都可以设计成为单例模式</p></blockquote><p>那么什么时候创建呢？</p><h2 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h2><blockquote><p>吃完饭，立刻洗碗，因为这样，吃下一顿的时候立刻就能把饭拿到手里</p></blockquote><p><strong>饿汉模式实现单例模式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">singleton</span>&#123;<br>    <span class="hljs-type">static</span> T data;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> T* <span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;data;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>只通过singleton这个包装类来使用T 对象，则一个进程中只有一个T 对象的实例</p><p>像这种静态成员，只要创建了一个对象这个静态成员立刻就开辟了，这就叫做饿汉模式</p><h2 id="2-懒汉模式"><a href="#2-懒汉模式" class="headerlink" title="2. 懒汉模式"></a>2. 懒汉模式</h2><blockquote><p>吃完饭，先把碗放下来，等到下一次要吃饭的时候再去洗这个碗</p></blockquote><p>（延迟加载），在用的时候再加载，</p><blockquote><p>写时拷贝（在用的时候，再拷贝），申请空间（不需要的时候就不用再做），优化服务器的启动速度</p></blockquote><p>懒汉模式创建单例模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">singleton</span><br>&#123;<br>    <span class="hljs-type">static</span> T* inst;<span class="hljs-comment">//创建了一个类型指针，这个静态成员变量要在外面初始化为nullptr</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> T*<span class="hljs-title">getinstance</span><span class="hljs-params">()</span><span class="hljs-comment">//如果我们创建了一个类，当时很长时间都不调用这个，就不会创建</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(inst==<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            inst=<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<span class="hljs-comment">//发现为空，外面就创建，否则就直接返回，只创建一个对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> inst;<span class="hljs-comment">//以后每次使用就直接返回他的地址</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>智能指针是线程安全的</p><h3 id="单例模式实现线程池"><a href="#单例模式实现线程池" class="headerlink" title="单例模式实现线程池"></a>单例模式实现线程池</h3><h4 id="task"><a href="#task" class="headerlink" title="task"></a>task</h4><p>task.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> ns_task<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> _x;<br>        <span class="hljs-type">int</span> _y;<br>        <span class="hljs-type">char</span> _op; <span class="hljs-comment">//表示+-*/%</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Task</span>() <span class="hljs-comment">//无参构造，为了拿任务，不需要参数列表</span><br>        &#123;<br>        &#125;<br>        <span class="hljs-comment">//进行函数重载</span><br>        <span class="hljs-built_in">Task</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">char</span> op) <span class="hljs-comment">//有参构造，制造任务</span><br>            : _x(x), _y(y), _op(op)<br>        &#123;<br>        &#125;<br>        ~<span class="hljs-built_in">Task</span>()<br>        &#123;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">switch</span> (_op)<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                res = _x + _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                res = _x - _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                res = _x * _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                res = _x / _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>                res = _x % _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;bug?&quot;</span> &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;当前任务正在被：&quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; <span class="hljs-string">&quot;处理:&quot;</span> &lt;&lt; _x &lt;&lt; _op &lt;&lt; _y &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; res &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Task <span class="hljs-keyword">operator</span>=(Task &amp;s)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)<br>            &#123;<br>                _x = s._x;<br>                _y = s._y;<br>                _op = s._op;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span><span class="hljs-comment">//重载一个函数</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Run</span>();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h4><p>threadpool.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-comment">// #cludine&quot;Task.hpp&quot;</span><br><span class="hljs-comment">// using namespace ns_task;</span><br><span class="hljs-keyword">namespace</span> ns_threadpool<br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> <span class="hljs-comment">//线程池</span><br>    &#123;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num_;                  <span class="hljs-comment">//一个线程池里面有多少个任务</span><br>        std::queue&lt;T&gt; task_queue_; <span class="hljs-comment">//任务队列,临界资源</span><br>        <span class="hljs-type">pthread_mutex_t</span> mtx_;<br>        <span class="hljs-type">pthread_cond_t</span> cond_;<br>        <span class="hljs-type">static</span> ThreadPool&lt;T&gt; *ins; <span class="hljs-comment">//静态成员在所有的对象里面只有一个静态成员，必须要通过静态变量来获取对象</span><br>        <span class="hljs-comment">//保存内存的可见性</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">//单例的话，就不能让构造函数暴露在外面，否则，只有有构造函数，就能初始化</span><br>        <span class="hljs-comment">//构造函数必须得实现，当时必须得私有</span><br>        <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> num = g_num) : <span class="hljs-built_in">num_</span>(num)<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mtx_, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;cond_, <span class="hljs-literal">nullptr</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">const</span> ThreadPool &amp;tp) = <span class="hljs-keyword">delete</span>;<br>        <span class="hljs-comment">// c++11的新特性</span><br>        <span class="hljs-comment">//静止编译器生成拷贝构造，</span><br>        <span class="hljs-comment">//=delete就是禁止调用这个函数，在私有里面</span><br><br>        ThreadPool <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadPool &amp;tp) = <span class="hljs-keyword">delete</span>;<br>        <span class="hljs-comment">//把赋值运算符也禁止掉，这也就可以避免创建多个对象</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> ThreadPool&lt;T&gt; *<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> <span class="hljs-comment">//这个必须是使用静态的，非静态函数都是有对象的，静态函数才是没对象的</span></span><br><span class="hljs-function">        </span>&#123;<br><br>            <span class="hljs-type">static</span> <span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER; <span class="hljs-comment">//使用静态的初始化</span><br><br>            <span class="hljs-keyword">if</span> (ins == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//双判定，减少锁的争用，提高单例获取的效率，</span><br>            <span class="hljs-comment">//假如说有的线程进来发现不为空，就可以直接走了，如果同时为nullptr的化，那么再把他们放进来争抢锁资源、</span><br><br>            &#123;<br><br>                <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;lock); <span class="hljs-comment">//争抢锁的过程就是一个串行化的过程，成本很高</span><br><br>                <span class="hljs-comment">//当前的单例对象还没有被创建</span><br>                <span class="hljs-keyword">if</span> (ins == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-comment">//假如是在多线程的情况下，那么多个线程执行的时候，都是nullptr，都创建了对象，那么就出现了线程安全</span><br>                &#123;<br>                    <span class="hljs-comment">//就创建它</span><br>                    ins = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadPool</span>&lt;T&gt;(); <span class="hljs-comment">//创建一个，使用构造函数</span><br>                    <span class="hljs-comment">//创建出来了一个单例之后，就直接给他初始化一个池就行了</span><br>                    ins-&gt;<span class="hljs-built_in">InitThreadPool</span>();<br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;首次加载对象&quot;</span> &lt;&lt; std::endl;<br>                &#125;<br>                <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;lock);<br>            &#125;<br>            <span class="hljs-keyword">return</span> ins;<br>        &#125;<br><br>        ~<span class="hljs-built_in">ThreadPool</span>()<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mtx_);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond_);<br>        &#125;<br><br>        <span class="hljs-comment">//在类中，要让</span><br><br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">Rountine</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//也不能访问类里面非static成员</span></span><br><span class="hljs-function">        </span>&#123;<br><br>            <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>()); <span class="hljs-comment">//实现线程分离就不要再去join等待了</span><br>            ThreadPool&lt;T&gt; *tp = (ThreadPool&lt;T&gt; *)args;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-comment">//从任务队列里面去拿一个任务</span><br>                <span class="hljs-comment">//执行任务，要先把这个任务队列锁主</span><br><br>                <span class="hljs-comment">//每个线程他跟放任务的线程一样，都是竞争式的去拿一个任务</span><br>                tp-&gt;<span class="hljs-built_in">Lock</span>();<br>                <span class="hljs-comment">//先检测任务队列是否有一个任务</span><br>                <span class="hljs-keyword">while</span> (tp-&gt;<span class="hljs-built_in">IsEmpty</span>())<br>                &#123;<br>                    <span class="hljs-comment">//检测到任务队列为空</span><br>                    <span class="hljs-comment">//此时线程就挂起等待</span><br>                    tp-&gt;<span class="hljs-built_in">Wait</span>();<br>                &#125;<br>                <span class="hljs-comment">//该任务队列里面一定有任务了</span><br>                T t;<br>                tp-&gt;<span class="hljs-built_in">PopTask</span>(&amp;t);<br>                <span class="hljs-comment">//任务就拿到了</span><br>                tp-&gt;<span class="hljs-built_in">UnLock</span>();<br>                t.<span class="hljs-built_in">Run</span>(); <span class="hljs-comment">//可能有多个线程在处理任务,</span><br><br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitThreadPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//初始化一批线程，</span><br>            <span class="hljs-comment">//这样就不要每次用都要去开辟线程了</span><br>            <span class="hljs-type">pthread_t</span> tid; <span class="hljs-comment">//一次创建一批线程</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_; i++)<br>            &#123;<br>                <span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">nullptr</span>, Rountine, (<span class="hljs-type">void</span> *)<span class="hljs-keyword">this</span>);<br>                <span class="hljs-comment">//在类中不能执行线程的方法，因为他都有隐藏的this指针</span><br>                <span class="hljs-comment">//所以我们需要使用静态的函数，就没有了this指针</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PopTask</span><span class="hljs-params">(T *out)</span></span><br><span class="hljs-function">        </span>&#123;<br>            *out = task_queue_.<span class="hljs-built_in">front</span>();<br>            task_queue_.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> task_queue_.<span class="hljs-built_in">empty</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnLock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushTask</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;in)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//塞任务，就相当于一个生产者，生产者之间要进行互斥访问</span><br>            <span class="hljs-built_in">Lock</span>();<br>            task_queue_.<span class="hljs-built_in">push</span>(in);<br>            <span class="hljs-built_in">UnLock</span>();<br>            <span class="hljs-built_in">Wakeup</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//万一任务队列里面一个任务都没有的话，那么线程池里面的每一个线程就要处于休眠状态，挂起等待</span><br>    &#125;;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-comment">//静态成员变量的初始化必须要在类外面初始化</span><br>    ThreadPool&lt;T&gt; *ThreadPool&lt;T&gt;::ins = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//将threadpool里面的ins进行初始化，返回值是指针，给它初始化为空，说明没有被创建出来</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;threadpool.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Task.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_task;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_threadpool;<br><br><span class="hljs-comment">//线程池就是一个单例模式，只有一个线程池就够了</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前正在执行我的进程其他代码......&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前正在执行我的进程其他代码......&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前正在执行我的进程其他代码......&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前正在执行我的进程其他代码......&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前正在执行我的进程其他代码......&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//前5秒是没有这个单例的</span><br>    <span class="hljs-comment">//我们希望是主线程不断的向线程池里面push任务，线程池里面竞争任务，处理这些任务</span><br>    <span class="hljs-comment">//外部可能存在一个或者多个线程向里面塞任务</span><br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//以后就是从网络里面来</span><br>        <span class="hljs-comment">//主线程就是把任务放到线程池里面去</span><br><br>        <span class="hljs-comment">//有的时候访问网站，挂掉了，OS受不了了，杀掉</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-function">Task <span class="hljs-title">t</span><span class="hljs-params">(rand() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>, rand() % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;+-*/%&quot;</span>[rand() % <span class="hljs-number">5</span>])</span></span>;<br>        ThreadPool&lt;Task&gt;::<span class="hljs-built_in">GetInstance</span>()-&gt;<span class="hljs-built_in">PushTask</span>(t); <span class="hljs-comment">//在这里获得单例</span><br>        <span class="hljs-comment">//即使是死循环入数据，也就只有一个对象，因为是静态的</span><br>        <span class="hljs-comment">//只会调用一次</span><br>        <span class="hljs-comment">//Getinstance</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/06/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/06/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">原理</a></li><li><a href="#_13">实现</a></li><li><ul><li><a href="#Taskhpp_14">Task.hpp</a></li><li><a href="#threadpoolhpp_91">threadpool.hpp</a></li><li><a href="#maincc_221">main.cc</a></li></ul></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="https://img-blog.csdnimg.cn/7258dd8752714782bbf323e950c50b7e.png" alt="在这里插入图片描述"></p><p>如我们每次动态开辟一个变量空间的时候，都会有效率的损失，如果有一个内存池，需要的化直接在里面取就行了，这就大大的提高了效率</p><p>当我们创建任务的时候再去申请线程，就相当于我们需要malloc的时候再去申请空间，创建线程也是有成本的，</p><p>请求来了，线程要提前准备好，任务来了，就指派给他<br>提前准备好的线程，原来随时处理任务就叫做线程池<br>（提高效率）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Task-hpp"><a href="#Task-hpp" class="headerlink" title="Task.hpp"></a>Task.hpp</h2><p>使用这个Task类，将此作为里面的类型</p><p>Task.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> ns_task<br><span class="hljs-comment">//使用命名空间，提高代码的安全性</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> _x;<br>        <span class="hljs-type">int</span> _y;<br>        <span class="hljs-type">char</span> _op; <span class="hljs-comment">//表示+-*/%</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Task</span>() <span class="hljs-comment">//无参构造，为了拿任务，不需要参数列表</span><br>        &#123;<br>        &#125;<br>        <span class="hljs-comment">//进行函数重载</span><br>        <span class="hljs-built_in">Task</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">char</span> op) <span class="hljs-comment">//有参构造，制造任务</span><br>            : _x(x), _y(y), _op(op)<br>        &#123;        &#125;<br>        ~<span class="hljs-built_in">Task</span>()<span class="hljs-comment">//析构函数其实也不需要我们来实现，因为没有变量需要销毁</span><br>        &#123;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span><span class="hljs-comment">//task类，处理任务</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">switch</span> (_op)<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                res = _x + _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                res = _x - _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                res = _x * _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                res = _x / _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>                res = _x % _y;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;bug?&quot;</span> &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;当前任务正在被：&quot;</span> &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; <span class="hljs-string">&quot;处理:&quot;</span> &lt;&lt; _x &lt;&lt; _op &lt;&lt; _y &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; res &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Task <span class="hljs-keyword">operator</span>=(Task &amp;s)<span class="hljs-comment">//赋值运算符重载</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)<br>            &#123;<br>                _x = s._x;<br>                _y = s._y;<br>                _op = s._op;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//Task t;</span><br>        <span class="hljs-comment">//t()//</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span><span class="hljs-comment">//将（）重载，仿函数</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Run</span>();<span class="hljs-comment">//（）使用run（）</span><br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="threadpool-hpp"><a href="#threadpool-hpp" class="headerlink" title="threadpool.hpp"></a>threadpool.hpp</h2><p>实现线程池类,高封装性，将所有的对于线程的操作都放在这个类里面是实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-comment">// #cludine&quot;Task.hpp&quot;</span><br><span class="hljs-comment">// using namespace ns_task;</span><br><span class="hljs-keyword">namespace</span> ns_threadpool<br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> g_num=<span class="hljs-number">5</span>;<span class="hljs-comment">//使用一个全局变量，作为我们需要创建的线程的个数</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-comment">//使用模板，可以实现泛型编程，多个类型都可以使用</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> <span class="hljs-comment">//线程池</span><br>    &#123;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num_;                  <span class="hljs-comment">//一个线程池里面有多少个任务</span><br>        std::queue&lt;T&gt; task_queue_; <span class="hljs-comment">//任务队列,临界资源</span><br>        <span class="hljs-type">pthread_mutex_t</span> mtx_;<span class="hljs-comment">//锁</span><br>        <span class="hljs-type">pthread_cond_t</span> cond_;<span class="hljs-comment">//条件变量</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> num=g_num) :<span class="hljs-built_in">num_</span>(num)<span class="hljs-comment">//初始化构造函数</span><br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_init</span>(&amp;mtx_,<span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">pthread_cond_init</span>(&amp;cond_,<span class="hljs-literal">nullptr</span>);<br>        &#125;<br>        <br>        <br>        ~<span class="hljs-built_in">ThreadPool</span>()<br>        &#123;<br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mtx_);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond_);<br>        &#125;<br><br>        <span class="hljs-comment">//在类中，要让</span><br><br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">Rountine</span><span class="hljs-params">(<span class="hljs-type">void</span>* args)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//主线程里面往里面塞任务，而线程里面主要就是在里面处理任务</span></span><br><span class="hljs-function">        <span class="hljs-comment">//也不能访问类里面非static成员</span></span><br><span class="hljs-function">        </span>&#123;<br><br>            <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<span class="hljs-comment">//实现线程分离就不要再去join等待了</span><br>            ThreadPool&lt;T&gt;* tp=(ThreadPool&lt;T&gt;*)args;<span class="hljs-comment">//类型转换</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-comment">//从任务队列里面去拿一个任务</span><br>                <span class="hljs-comment">//执行任务，要先把这个任务队列锁主</span><br><br>                <span class="hljs-comment">//每个线程他跟放任务的线程一样，都是竞争式的去拿一个任务</span><br>                tp-&gt;<span class="hljs-built_in">Lock</span>();<br>                <span class="hljs-comment">//先检测任务队列是否有一个任务</span><br>                <span class="hljs-keyword">while</span>(tp-&gt;<span class="hljs-built_in">IsEmpty</span>())<br>                &#123;<br>                    <span class="hljs-comment">//检测到任务队列为空</span><br>                    <span class="hljs-comment">//此时线程就挂起等待</span><br>                    tp-&gt;<span class="hljs-built_in">Wait</span>();<br>                &#125;<br>                <span class="hljs-comment">//该任务队列里面一定有任务了</span><br>                T t;<br>                tp-&gt;<span class="hljs-built_in">PopTask</span>(&amp;t);<br>                <span class="hljs-comment">//任务就拿到了</span><br>                tp-&gt;<span class="hljs-built_in">UnLock</span>();<br>                t.<span class="hljs-built_in">Run</span>();<span class="hljs-comment">//可能有多个线程在处理任务,</span><br><br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br><span class="hljs-comment">//我们定义了一个线程池的变量，就需要首先先进行初始化</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitThreadPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//初始化一批线程，</span><br>            <span class="hljs-comment">//这样就不要每次用都要去开辟线程了</span><br>            <span class="hljs-type">pthread_t</span> tid;<span class="hljs-comment">//一次创建一批线程</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num_;i++)<br>            &#123;<br>                <span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">nullptr</span>,Rountine,(<span class="hljs-type">void</span>*)<span class="hljs-keyword">this</span>);<span class="hljs-comment">//在create里面实现函数，所以我们需要在类里面实现这个函数</span><br>                <span class="hljs-comment">//在类中不能执行线程的方法，因为他都有隐藏的this指针</span><br>                <span class="hljs-comment">//所以我们需要使用静态的函数，就没有了this指针</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PopTask</span><span class="hljs-params">(T* out)</span><span class="hljs-comment">//头删，在线程池里面取出任务</span></span><br><span class="hljs-function">        </span>&#123;<br>            *out=task_queue_.<span class="hljs-built_in">front</span>();<br>            task_queue_.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_,&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> task_queue_.<span class="hljs-built_in">empty</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnLock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mtx_);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_);<br>        &#125;<br>        <br><span class="hljs-comment">//我们定义了一个变量之后，初始化之后，就要向里面放任务，然后里面的线程，通过里面的队列，争抢任务</span><br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushTask</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; in)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//塞任务，就相当于一个生产者，生产者之间要进行互斥访问</span><br>            <span class="hljs-built_in">Lock</span>();<br>            task_queue_.<span class="hljs-built_in">push</span>(in);<br>            <span class="hljs-built_in">UnLock</span>();<br>            <span class="hljs-built_in">Wakeup</span>();<span class="hljs-comment">//塞完任务之后，就要唤醒里面的队列，来取任务</span><br>        &#125;<br><br>        <span class="hljs-comment">//万一任务队列里面一个任务都没有的话，那么线程池里面的每一个线程就要处于休眠状态，挂起等待</span><br>        <br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main-cc"><a href="#main-cc" class="headerlink" title="main.cc"></a>main.cc</h2><p>非单例模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;threadpool.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Task.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_task;<span class="hljs-comment">//使用我们写的两个命名空间，提高了代码的封装性</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns_threadpool;<br><br><span class="hljs-comment">//线程池就是一个单例模式，只有一个线程池就够了</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ThreadPool&lt;Task&gt;* tp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadPool</span>&lt;Task&gt;();<span class="hljs-comment">//我们一开始就创建一个线程池类型，线程池类型我们只需要一个就行了，</span><br>    tp-&gt;<span class="hljs-built_in">InitThreadPool</span>();<br>    <span class="hljs-comment">//我们希望是主线程不断的向线程池里面push任务，线程池里面竞争任务，处理这些任务</span><br>    <span class="hljs-comment">//外部可能存在一个或者多个线程向里面塞任务</span><br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//以后就是从网络里面来</span><br>        <span class="hljs-comment">//主线程就是把任务放到线程池里面去</span><br>        <br>        <span class="hljs-comment">//有的时候访问网站，挂掉了，OS受不了了，杀掉</span><br><br>        <span class="hljs-function">Task <span class="hljs-title">t</span><span class="hljs-params">(rand()%<span class="hljs-number">20</span>+<span class="hljs-number">1</span>,rand()%<span class="hljs-number">10</span>+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;+-*/%&quot;</span>[rand()%<span class="hljs-number">5</span>])</span></span>;<br>        tp-&gt;<span class="hljs-built_in">PushTask</span>(t);<span class="hljs-comment">//放进去让他进行处理工作</span><br>        <br><br>        <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细代码可以查看<br><a href="https://github.com/zevin02/Linuxstudy/tree/master/pthread/pthread/threadpool">ThreadPool</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统编程 c++ visual studio 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础背景入门</title>
    <link href="/2022/05/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E8%83%8C%E6%99%AF%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E8%83%8C%E6%99%AF%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">计算机网络背景</a></li><li><ul><li><a href="#_2">网络发展</a></li><li><a href="#_21">网络在哪里</a></li><li><a href="#_25">认识“协议”</a></li><li><a href="#_43">协议分层</a></li><li><a href="#OSITCPIP_60">OSI七层模型与TCP&#x2F;IP四层模型</a></li><li><a href="#TCPIP_90">我们从实际角度上介绍一下TCP&#x2F;IP模型每一层都做些什么</a></li><li><ul><li><a href="#_100">局域网</a></li><li><a href="#_114">报头</a></li><li><a href="#_151">跨网络</a></li></ul></li><li><a href="#_167">令牌环</a></li><li><a href="#mac_172">mac地址</a></li><li><a href="#_190">网络中的地址管理</a></li><li><ul><li><a href="#IP_191">认识IP地址</a></li><li><a href="#MAC_198">认识MAC地址</a></li></ul></li><li><a href="#_205">理解</a></li></ul></li></ul><h1 id="计算机网络背景"><a href="#计算机网络背景" class="headerlink" title="计算机网络背景"></a>计算机网络背景</h1><h2 id="网络发展"><a href="#网络发展" class="headerlink" title="网络发展"></a>网络发展</h2><p>现有计算机再有OS，原来没有OS之前使用计算机的成本是很高的，只有科学家才可以使用，在有了OS之后，计算机的使用成本就降低了，之后计算机进入到高校里面，<br>在有了OS之后再有网络<br>我们做实验产生了数据，这个时候数据需要交给别人</p><blockquote><p>当企业里面有3个人A,B,C。<br>A处理完数据后把数据传送给B，B在A处理完之前都在等待<br>B处理完数据之后把数据传给C，C在AB都处理完之前在等待<br>数据在来回传导</p></blockquote><p>高校内部有数据研究和沟通的需求，<strong>就需要产生网络（就是为了提高效率）</strong></p><blockquote><p>如以前没有网络，我们想给一个人传递消息，就需要骑马到他那边告诉他</p></blockquote><p><img src="https://img-blog.csdnimg.cn/861e1a4560ad46c092ecc346af567e9a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6d314f582e0843288d1ccd1833b69543.png" alt="在这里插入图片描述"><br>局域网(LAN)：在同一个网段里面，这一个一个小的模块就是局域网，局域网和局域网之间可以用路由器来连接，实现跨网络传送</p><p>广域网（WAN）:局域网多了就变成了广域网，但是广域网没有一个清晰的概念，一般只要存在路由器的，就是广域网或者城域网，</p><h2 id="网络在哪里"><a href="#网络在哪里" class="headerlink" title="网络在哪里"></a>网络在哪里</h2><p>这里的网络，指的是网络协议栈，他是一个软件，贯穿体系结构的，尤其TCP&#x2F;IP他就是OS的一部分，</p><p><img src="https://img-blog.csdnimg.cn/1601334c7277499092e3b4a9075c96df.png" alt="在这里插入图片描述"></p><h2 id="认识“协议”"><a href="#认识“协议”" class="headerlink" title="认识“协议”"></a>认识“协议”</h2><p>协议：</p><blockquote><p>假如说我上学在外，电话费很贵<br>我就和父亲做了一个约定</p><blockquote><p>1.我给家里打电话，响了一声，就挂掉，说明我是平安的<br>2. 我给家里打电话，响了两声，就挂掉，说明我没钱了<br>3. 我给家里打电话，响了三声，就挂掉，说明我想要和他们聊天</p></blockquote></blockquote><p>而这个约定其实就是协议<br>所谓的计算机协议，本质就是约定，而这个约定是由编码的程序员自己根据标准的文档，或者自己的喜好定义的协议<br>如我们在计算机中发送不同的东西，则计算机就根据这些东西由协议规定，做出特定的响应</p><blockquote><p>但是两台主机之间，约定好协议就可以了吗</p></blockquote><blockquote><p>世界上的计算机生产商特别多，OS类型也很多，计算机的硬件也由很多<br>虽然都遵守了协议，但是没有办法，<br>所以我们就需要一个共同的标准，这就是<strong>网络协议</strong></p></blockquote><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>举个例子：</p><blockquote><p>在语言层上有两个人用汉语交流，通过通信设备层的电话机来进行交互，现在下层的逻辑不变，上层变成了说英文，但是不影响交流，仅在语言层发生了变更，但是如果底层使用的是手机，同样也可以实现相同的内容</p></blockquote><p>软件分层的好处：</p><blockquote><p>可以通过分层完成了一个<strong>解耦</strong>的操作，一旦解耦之后，任何一层，我们想要进行替换，就可以直接进行替换，<strong>而不会影响另一层</strong>，即便有一层当中有bug，我们只需要把问题聚焦在这一层就可以，而不影响其他层</p></blockquote><p>软件分层，<br>无外乎就是<br>[<strong>代码</strong>（逻辑层面的分层）和<strong>数据</strong>（数据层面的分层，数据在不同层上面流动）]</p><p>例如：<br>1.一切皆文件，在linux系统管理对象的时候，肯定是先描述再组织，里面的东西都被当作文件对待了，所有的文件公共的方法，<br>2. 如果我又想把所有的东西都当作文件来看，所以要抽象出一个文件结构，这个文件结构的结构就是文件的结构，方法就是包含了一堆的函数指针，这个函数指针里面指向的是具体的底层的对应的方法，这取决于我们底层是什么样子，这个就是一切皆文件的软件结构</p><p><strong>分层最大的好处在于“封装”，面向对象例子</strong></p><h2 id="OSI七层模型与TCP-x2F-IP四层模型"><a href="#OSI七层模型与TCP-x2F-IP四层模型" class="headerlink" title="OSI七层模型与TCP&#x2F;IP四层模型"></a>OSI七层模型与TCP&#x2F;IP四层模型</h2><blockquote><ul><li>OSI（开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范。<br>（逻辑上就是<strong>没有真实存在</strong>，而是用代码或者其他的方式抽象模拟出来的，例如进程的<strong>虚拟地址空间</strong>，在进程角度，它认为它拥有这么多的空间，而实际上是操作系统模拟出来的）<br>这个<strong>实际</strong>上就是：硬件上不实现，通过软件上来实现，软件上实现，就是增加一些软件层，来实现，mm_struct (虚拟地址空间)，一切皆文件里面的很多函数调用方法，它实际上也是软件层面上的实现</li></ul></blockquote><blockquote><ul><li>物理层：<strong>负责光电信号</strong>，<br>（计算机软件怎么通信，设计的再怎么绚丽，我们都要在现实当中跑的，例如我们打游戏的时候，一些英雄人物技能多么的酷，这在底层实际上都是一些2进制数据，要么传输，要么展示，要么计算，反正都是2进制数据，在硬件层面上，我根本就不知道这些0，1序列是什么意思，你只需要告诉我，要传多少的光电信号，好比我今天进到公司里面，你帮我把这个功能实现一下，可是我不知道这个函数这个功能在公司整个业务层面上代表了什么呢，我也不关心，在公司方面，每个人结构就是层状结构，）</li></ul><hr><p>传多少光电信号，什么时候传，我只需要照做就可以了，不需要多问，光电信号传的距离够不够远呀，信号够不够呀，就是纯硬件的，2进制序列是以什么样的形式传过去，是以<strong>模拟信号</strong>还是<strong>数字信号</strong>，无线wifi，波形，区段，频率应该选择什么样子的，那么这个就是<strong>物理层</strong>：<br>决定的就是通信过程中的一些物理层面的东西，比如最大传播速率，传输距离，信号抗干扰性，<br><strong>集线器</strong>（Hub）【光电信号开始的时候有自己的初始能量，传输距离有限，能量会衰减，相隔千里之外也能听清楚，把信号衰减又把他放大，这叫做集线器】</p></blockquote><blockquote><ul><li>数据链路层：<strong>就是特定硬件匹配的驱动模块，设备和设备之间的识别</strong>：<br>例如网卡的设备驱动，帧同步（从网线上检测到什么信号算作新帧的开始），冲突检测（如果检测到冲突就重发），数据的校验；有以太网，令牌环网，无线LAN,交换机（switch）工作在<strong>链路层</strong>，软件工作（和硬件强相关）</li><li>网络层：<strong>负责地址管理和网络管理和路由选择的</strong>，IP协议中，通过路由表的方式规划处两台主机之间的数据传输线路（路由），路由器（router）</li><li>传输层：负责两台主机之间<strong>数据的传输</strong>，TCP,UDP</li><li>应用层：负责<strong>应用程序之间的沟通</strong>（http，ftp）</li></ul></blockquote><p>一般而言：</p><blockquote><ul><li>对于一台主机，其操作系统的内核实现了从传输层到物理层之间的内容</li><li>对于一台路由器，它实现了从网络层到物理层之间的内容</li><li>对于一台交换机，它实现了从数据链路层到物理层之间的内容</li><li>对于一台集线器，它实现了物理层的内容</li></ul></blockquote><p>越上层的应用它所包含的层就越复杂，越多</p><h2 id="我们从实际角度上介绍一下TCP-x2F-IP模型每一层都做些什么"><a href="#我们从实际角度上介绍一下TCP-x2F-IP模型每一层都做些什么" class="headerlink" title="我们从实际角度上介绍一下TCP&#x2F;IP模型每一层都做些什么"></a>我们从实际角度上介绍一下TCP&#x2F;IP模型每一层都做些什么</h2><blockquote><p>例如我们在网购买东西，下单之后，卖家下楼把货物进行包装（这个就是封装），再之后，就填写快递单号（相当于给数据添加报头），这发送出去之后，这个快递卖家就不管了（每一个层只需要处理自己的事情，不需要去处理别的层做的事情），之后就都是快递公司的事情了，快递一个一个发送给下一个（数据链路层决定的，数据链路层决定下一跳要去哪里），走山东云南，福建（这个就是网络层决定的，路径规划）。快递丢了的话，我们就重新给你发一封（传输层，保证可靠性，传输控制），</p></blockquote><blockquote><p><strong>有一个误区</strong>：数据传送给对端，事情就结束了，但是对于数据的使用，才是最终的目的，如何分析和使用传输过来的数据，下三层是处理怎么拿到数据，应用层是处理怎么处理这些数据，</p></blockquote><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p><img src="https://img-blog.csdnimg.cn/b2fd581b6afd4e46a49ff7e3a610e1aa.png" alt="在这里插入图片描述"><br>每一层都认为自己发送的数据都是对端层直接收到的</p><p>这个图重点讨论的是局域网通信的TCP&#x2F;IP属于OS，链路层是在网卡驱动层面上的，下三层解决通信细节，用户并不关心这些东西，应用层主要处理应用程序的细节，（如我是应用层，我收到了快递盒子，用小刀把快递盒子切开，我们里面的洗面奶一次用多少，这是我对洗面奶这个应用处理的细节）</p><p>局域网中的两台主机能直接通信吗？</p><p>在局域网中数据必须贯彻四层，到最底层的以太网，通过以太网驱动程序，以太网协议到达对端的数据链路层，从以太网里面回到服务器上面</p><p>而对于同等的层，它会得到同样的报头加报文，所以在每一层看来，每一层都认为，我发什么数据对方就收什么数据，这个就是左侧封装的过程，右边叫做解耦的过程，这也是一种逻辑上的概念，这叫做在应用层是同等层，只要我们有网络，我们都是直接沟通，技术上就是封装</p><h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p>如何理解报头：<br>(什么是报头，为什么要有报头)</p><blockquote><p>所有的快递盒子上面都有快递单，这个是贴在盒子上的，发货人谁，收货人是谁，重要的是格式和数据，单子类似于快递的报头，因为如果没有的话，就不知道谁发的，也不知到发给谁，无法得知该快递该如何派发，指导我们来进行派发</p></blockquote><blockquote><p>需要报头中的数据来<strong>指导当前层进行我们的某种协议决策</strong>，如何处理这些报文，传输层报头指导如何进行数据传输，网络层指导如何进行下一个路径，链路层报头指导如何进行下一跳，实际上我们根本不需要这些快递单，我只需要物件，这叫做<strong>解包的过程</strong>，我发货物，填上单子，指导我们进行某种协议决策的，</p></blockquote><p>在OS中如何理解报头和数据呢<br>如何理解报头和有效载荷</p><blockquote><ol><li><pre><code class="hljs">在当前层中，报头叫报头，报头的后面叫做这个报文的有效载荷，</code></pre></li><li><pre><code class="hljs">报头是数据吗，是一种结构化的数据，既然大家都是数据呢</code></pre></li><li><pre><code class="hljs">centos OS 如何理解封装和解封，linux OS是C写的，站在语言角度，如何理解封装和解包呢？  </code></pre>我们随便定义一个报头<br>这就叫做位段，网络里面就是位段类型</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_hdr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> src:<span class="hljs-number">16</span>;<span class="hljs-comment">//占16个比特位</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dst:<span class="hljs-number">16</span>;<span class="hljs-comment">//目的地址</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type:<span class="hljs-number">8</span>;<span class="hljs-comment">//报文的类型</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len:<span class="hljs-number">24</span>;<span class="hljs-comment">//报头的长度</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_hdr</span> <span class="hljs-title">my</span>;</span><span class="hljs-comment">//定义一个位段变量，定义了一个报头，要开空间，结构化的数据</span><br>my.src=<span class="hljs-number">0x1</span>;<br>my.dst=<span class="hljs-number">0x2</span>;<br>my.type=<span class="hljs-number">0x3</span>;<br>my.len=<span class="hljs-number">0x4</span>;<br></code></pre></td></tr></table></figure><p>添加报头，这些位段都写好了之后，我们有一个数据（你好，把这个位段拷贝到你好这个空间的前面就可以了，把一个位段拷贝进一个缓冲区，可以采用memcpy或者memmove2进制拷贝，把一个变量拷贝进一个数据当中，这就是报文，其他报头也是类似的，这就是封装的过程）<br>4. 如何理解解包<br>我们可以定义一个指针指向这个报头的头部，例如void* ptr,我们要拿这个报头，只要把这个 ptr强转成(struct my_hdr*),即可,就能够访问里面的内容数据了，(（struct my_hdr*）ptr)++,就能够去掉报头了，后面就是有效载荷</p><ol start="5"><li>几乎每一层协议的包头中，都要包含两种字段：</li></ol><ul><li>当前报头的有效载荷要交付给上层的哪一个协议（分用的过程，解包分用）</li><li>几乎每个报头都要有一个属性，明确报头和有效载荷的边界，解包的时候，不能多解和少解，是我们学习所有的协议的共性，</li></ul></blockquote><h3 id="跨网络"><a href="#跨网络" class="headerlink" title="跨网络"></a>跨网络</h3><p><img src="https://img-blog.csdnimg.cn/c9dfabb0c2bb43ceb3e901417f261cb3.png" alt="在这里插入图片描述"><br>以太网</p><blockquote><p>左右两个主机因为是经过路由器连接，所以两个主机并不在同一个局域网，并不在同一个网段，但是主机A和路由器，主机B和路由器，彼此之间是在一个网段的，就相当于中间的话事人，这样就能让A和B进行沟通，</p></blockquote><p>局域网（以太网）基于碰撞检测的方式</p><blockquote><p>同一个局域网之间为什么能通信：<br>原理类似于上课，局域网中的<strong>网络资源被大家共享</strong>的，发送的消息所有人都能收到，但是里面有地址，mac地址，标识对应 的人物，对比的时候发现不是我的，就直接舍弃，只有接收者收到这个信息在，这就像发数据的过程，</p></blockquote><blockquote><p>如果同时发送，可能发生数据碰撞的问题，这样的话就同时往公共资源里面发消息，只能说的是判断有没有发生碰撞，每台主机都要有碰撞检测的能力，还要能够正常通信，每台主机都要有碰撞避免算法，等一等，动态调整，这样就可以几乎只有一个主机发送，这里面都在数据链路层帮我们做：局域网中任何一个时刻都只能有一台主机发送消息</p></blockquote><p>可以将网络资源理解为临界资源，网络系统也是有互斥的机制的</p><blockquote><p>如果我想攻击这个网络，就一直往局域网发送数据，占用临界资源，造成了其他主机的饥饿问题</p></blockquote><h2 id="令牌环"><a href="#令牌环" class="headerlink" title="令牌环"></a>令牌环</h2><blockquote><p>相当于每个主机要进行传导数据，只有传导数据的人才可以获得令牌，发完之后，再把令牌给下一个人，这就相当于互斥锁里面的锁</p></blockquote><h2 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h2><blockquote><p>全球内唯一的网卡中的序列号，48位的mac地址更多做局域网标识，<br>每台主机都有其Mac地址，路由器也是一个主机，也有Mac地址</p></blockquote><p>如何理解IP：</p><blockquote><ol><li>从哪里来到哪里去（几乎一直不会变化的地址）:IP地址</li><li>上一站从哪里来，下一站要去哪里（一直在变化的地址）：Mac地址<br>所以我们在传输数据的时候，目的IP一直不变的，而Mac地址一直都在变化，在数据链路层，经过路由器，一直在进行解包和重新封装，<br>inet是内网地址<br>我们站在IP网的角度，发送的有效载荷都是一样的 因为有ip网络，所以它帮我们屏蔽了底层网络的差异（因为有路由器的存在，看不到底层路由器的差异），IP就是局域网中的一个虚拟化技术，跨网络传送的技术，</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/c36496e00885434084a1368fd8aa04d3.png" alt="在这里插入图片描述"></p><h2 id="网络中的地址管理"><a href="#网络中的地址管理" class="headerlink" title="网络中的地址管理"></a>网络中的地址管理</h2><h3 id="认识IP地址"><a href="#认识IP地址" class="headerlink" title="认识IP地址"></a>认识IP地址</h3><p>IP协议中有两个版本，IPV4和ipv6，我们现在所提到的IP协议，没有特殊说名的都是ipv4</p><blockquote><ul><li>ip地址是在ip协议中，用来标识网络中不同主机的地址</li><li>对于IPV4来说，IP地址是一个4字节，32位的整数</li><li>我们通常也是用“点分十进制的方式”来表示IP地址，如192.168.0.122，每一个点都是分割一个字节，范围在0-255之间</li></ul></blockquote><h3 id="认识MAC地址"><a href="#认识MAC地址" class="headerlink" title="认识MAC地址"></a>认识MAC地址</h3><blockquote><ul><li>MAC地址用来识别数据链路层中的相连的节点</li><li>长度是48个字节，6个字节，一般用16进制加上冒号形式表示（08：00：27：35：11：12）</li><li>网卡在出厂的时候就已经确定了，不能修改，mac地址是唯一的（虚拟机里面 的mac地址就不是真实的了）</li></ul></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><img src="https://img-blog.csdnimg.cn/38724388395e45edb182d5157a6c5001.png" alt="在这里插入图片描述"></p><blockquote><p>可以这么理解假如说主机A 是一个学生要去找主机B是另一个学生都住在4楼，它要给b寄送东西，路由器相当于另一个楼，2楼里面有保安，A要送东西，要下楼，找到路由器1，上楼2楼，找保安，保安称不知道，又下楼，继续找路由器2，上楼下楼，最后到路由器3保安才知道b的地址，我继续下楼，到b的地方，上楼到4楼，把东西给它</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程 网络 网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++多态</title>
    <link href="/2022/05/18/c++%E5%A4%9A%E6%80%81/"/>
    <url>/2022/05/18/c++%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">引言</a></li><li><a href="#_8">动态的多态</a></li><li><ul><li><a href="#%0A_12">举个例子： 买票这个行为，对于不同的人价格不同，普通人去买价格低，而有钱人买价格高</a></li></ul></li><li><a href="#_18">虚函数</a></li><li><a href="#_51">析构函数的重写（析构函数）</a></li><li><a href="#C11_override_final_121">C++11 override 和final</a></li><li><ul><li><a href="#final_123">final</a></li><li><a href="#override_210">override</a></li></ul></li><li><a href="#_242">重载，覆盖，隐藏的对比</a></li><li><a href="#_256">抽象类</a></li><li><a href="#_262">底层剖析</a></li><li><a href="#_292">多继承中的虚表</a></li><li><a href="#_294">打印虚表</a></li></ul><p>多态感觉真挺难的，这篇就水一水了</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>多态：多种形态<br>静态的多态：函数重载，同一个函数看起来调用同一个函数有不同的行为<br>动态的多态：<br>静态：是在编译的时候实现的</p><h1 id="动态的多态"><a href="#动态的多态" class="headerlink" title="动态的多态"></a>动态的多态</h1><p>一个父类的引用或指针去调用同一个函数，如果传递不同的对象，会调用不同的函数<br>动态：运行时实现的</p><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h2><p>买票这个行为，对于不同的人价格不同，普通人去买价格低，而有钱人买价格高</p><p>扫红包：也是一种多态行为，根据行为去分类，鼓励新用户用，给的红包就多，</p><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>子类中满足三同<br><strong>函数名，参数，返回值相同</strong>的虚函数，就叫做重写（覆盖），只有虚函数<br>本质就是不同的人去做同一件事情，结果不同<br>virtual（只能是类的非静态的成员函数才能是虚函数）：其他函数不能称为虚函数<br>：在最前面加一个virtual</p><p>静态成员函数不能加virtual</p><p>否则就是隐藏的关系</p><p>多态的构成条件（少一个都不行）</p><ol><li>必须通过<strong>基类</strong>的<strong>指针或者引用</strong>调用<strong>虚函数</strong></li><li>被调用的函数必须是<strong>虚函数</strong>，且派生类必须对<strong>基类的虚函数进行重写</strong></li></ol><blockquote><p>重写要求返回值相同，有一个例外：协变：<strong>要求返回值是父子关系的指针或者引用</strong>(基本不会见到)</p></blockquote><p>class A<br>class B</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Person p)</span><span class="hljs-comment">//我们没有用父类的指针和引用，而是用对象,就不能实现多态</span></span><br><span class="hljs-function"></span>&#123;<br>    p.<span class="hljs-built_in">BuyTicket</span>();<br>&#125;<br><span class="hljs-built_in">func</span>(st);<span class="hljs-comment">//正常来说因为我们是父类的引用，所以的对父类使用，一定是没有问题的，但是这个对子类也是可以使用的</span><br>    <span class="hljs-built_in">func</span>(ps);<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h1 id="析构函数的重写（析构函数）"><a href="#析构函数的重写（析构函数）" class="headerlink" title="析构函数的重写（析构函数）"></a>析构函数的重写（析构函数）</h1><p>析构函数也可以是虚函数，构成重写（函数名，返回值，参数，virtual）都相同<br>把析构函数都被特殊处理成destructor,<br>完成重写，构成多态，那么才能正确调用析构函数<br><strong>只有动态申请的对象给了父类指针管理才可以，那么就需要定义成虚函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>()<span class="hljs-comment">//析构的名字都被特殊处理过了，差个虚函数的条件，这样就能够实现多态了</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;person&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Student</span>() <span class="hljs-comment">//</span><br><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;student&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//析构函数是否是虚函数都正常调用了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    Person p;</span><br><span class="hljs-comment">    Student s;//person也会被析构，但是没加virtual也没有关系，</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-comment">//</span><br>    Person *p1 = <span class="hljs-keyword">new</span> Person; <span class="hljs-comment">// new 是开空间+构造函数</span><br>    Person *p2 = <span class="hljs-keyword">new</span> Student;<span class="hljs-comment">//这里是基类的指针，这里是父类的指针，就需要多态了</span><br>    Student *p3 = <span class="hljs-keyword">new</span> Student;<span class="hljs-comment">//这里是基类的指针,z这里不需要多态</span><br><br><br>    <span class="hljs-comment">//p1-&gt;destructor()</span><br>    <span class="hljs-comment">//p2-&gt;destructor()</span><br>    <br><br><br>    <span class="hljs-comment">//多态申请的对象如果给了父类指针管理，那么需要析构函数是虚函数（我们直接全部都）</span><br>    <span class="hljs-keyword">delete</span> p1;<span class="hljs-comment">//析构函数+释放空间</span><br>    <span class="hljs-comment">//我期望p1这里调用父类的析构函数</span><br>    <span class="hljs-keyword">delete</span> p2;<span class="hljs-comment">//指向student就掉student，又会掉person</span><br>    <span class="hljs-keyword">delete</span> p3;<br>    <span class="hljs-comment">//这里调用子类的析构函数</span><br>    <span class="hljs-comment">//这里不构成多态，都指向person，因为p2也是person</span><br>    <span class="hljs-comment">//构成多态才可以</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚函数的重写允许<br>：两个都是虚函数，或者父类是虚函数，再满足三同就构成重写<br>虽然子类没有写virtual<br>是因为他继承了父类的virtual的属性，也完成了重写（是因为析构函数，父类析构函数加上virtual，就不存在不构成多态的了，没钓到子类析构函数，内存泄漏的）<br>：在public：private也是可以的</p><p>一般来说父类是别人写的，子类是我们写的，只要父类加了virtual，子类就不用加virtual<br>我们建议都写上</p><h1 id="C-11-override-和final"><a href="#C-11-override-和final" class="headerlink" title="C++11 override 和final"></a>C++11 override 和final</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>设计一个不能被继承的类<br>c++ 98的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//设计一个无法被继承的基类，只能让基类的构造函数变成私有，因为初始化子类对象的时候要去调用其父类的构造函数，但是没法使用,间接限制</span><br><span class="hljs-comment">//c++ 98的方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>)<br>        : _a(a)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//因为如果是一个成员函数，返回A 他必须是一个对象，但是他没有对象，加了一个静态就可以使用了</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> A <span class="hljs-title">createobj</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>)</span> <span class="hljs-comment">//调用这个函数就可以使用了，获得父类的构造函数，如果是成员函数</span></span><br><span class="hljs-function">    <span class="hljs-comment">//静态的成员函数，没有this指针，只能访问静态的成员变量，和成员函数，不能访问_a 这些成员变量</span></span><br><span class="hljs-function">    </span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(a);<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> _a;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123;<br><br>&#125;;<br><span class="hljs-comment">//子类继承了父类，但是构造函数被变成私有的了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//因为我们把A 类型的构造函数变成一个私有的构造函数，所以他没有办法被使用，但是我们写了一个静态的成员函数就可以获得这个东西</span><br>    A aa=A::<span class="hljs-built_in">createobj</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//就可以这样把对象创建出来了</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>c++ 11</p><ol><li><pre><code class="hljs">使用final 这个类就无法被继承</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">final</span><span class="hljs-comment">//不希望A 被继承</span><br><br>&#123;<br>    <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><pre><code class="hljs">使用final这个函数就无法被重写，放在父类中</code></pre></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span><span class="hljs-comment">// 我不想他被重写</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;hello &quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> :<span class="hljs-keyword">public</span> C<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-comment">//重写</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;world&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>同样也是放在类的后面<br>放在子类重写的虚函数的后面，检查是否完成重写，如果没有完成重写就会报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span> <br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">drive</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br><br>   &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">benz</span>: <span class="hljs-keyword">public</span> car<br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">drive</span><span class="hljs-params">()</span>  <span class="hljs-keyword">override</span></span><br><span class="hljs-function">   </span>&#123;<br><br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/af33f3922c8046ff8f33016214177cb4.png" alt="在这里插入图片描述"><br>没加之后的报错</p><h1 id="重载，覆盖，隐藏的对比"><a href="#重载，覆盖，隐藏的对比" class="headerlink" title="重载，覆盖，隐藏的对比"></a>重载，覆盖，隐藏的对比</h1><p>重载：</p><ol><li>两个函数在同一个作用域</li><li>函数名相同，参数不同，返回值没有要求</li></ol><p>覆盖：<br>3. 两个函数分别在基类和派生类中的作用域中<br>4. 函数名&#x2F;参数&#x2F;返回值，都相同（协变除外）<br>5. 两个函数必须是虚函数</p><p>重定义（隐藏）<br>6. 一个在基类一个在派生类<br>7. 函数名相同<br>8. 不构成重写就是隐藏</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在虚函数的后面加上&#x3D;0，这个函数就叫做纯虚函数，<br>包含纯虚函数的类就叫做抽象类，不能实例化出对象，<br>派生类继承以后，也不能实例化出对象，只有子类<strong>重写这个虚函数，才能实例化出对象</strong>，</p><h1 id="底层剖析"><a href="#底层剖析" class="headerlink" title="底层剖析"></a>底层剖析</h1><p><img src="https://img-blog.csdnimg.cn/aca761f897d74d40b4d69913988ae253.png" alt="在这里插入图片描述"><br>我们会发现子类和父类是不一样的虚表，下面继承的是重写的虚函数（覆盖）<br>父类对象是父类对象的虚函数，子类对象是子类对象的虚函数<br>重写是语法层面，覆盖是原理上<br>覆盖成我重写的虚函数，</p><p>多态为什么必须是指针和引用呢？<br>指针和引用，虚表就是各自的，而用对象，那么虚表都是父类的，无法调用子类的，切片没有办法把虚表指针拷过去</p><p>多态的原理：<br>基类的指针&#x2F;引用，指向谁就去谁的虚函数表中找到对应的虚函数进行调用，在父类里面找到父类的虚函数，在子类里面找到子类的虚函数，</p><p>同类型的对象，他的虚表指针是一样的，指向同一张虚表，都是指向它的<br><img src="https://img-blog.csdnimg.cn/af74a865727743beb23968ad704ea26c.png" alt="在这里插入图片描述"><br>普通函数和虚函数都存储在代码段，只不过虚函数要把地址存一份到虚表，方便实现多态，</p><p>多态就算是私有的也可以调用，因为它是从虚表里面去找的，所以没有影响，有了虚函数这一个，私有也都是可以调用的，</p><p>总结：</p><blockquote><ol><li>派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员</li><li>基类b对象，和派生类d对象虚表是不一样的，这里我们发现func完成了重写，覆盖是指虚表中虚函数的覆盖，重写是语法上的 叫法，覆盖是原理层的叫法</li><li>子类继承下来没有重写的一部分，地址还是和父类的虚函数一样</li><li>子类也写了虚函数，这个虚函数也会在需表里面，只不过我们不好看</li></ol></blockquote><p>虚函数表在代码端（OS）&#x2F;常量区（c语言）里面<br>虚表里面存的地址不是函数真正的地址，而是要跳几次才可以跳到目的函数</p><h1 id="多继承中的虚表"><a href="#多继承中的虚表" class="headerlink" title="多继承中的虚表"></a>多继承中的虚表</h1><h1 id="打印虚表"><a href="#打印虚表" class="headerlink" title="打印虚表"></a>打印虚表</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;base1::func1&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;base1::func2&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">driver</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;driver func1&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;deriver func3&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;derive func4&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*vfptr)</span><span class="hljs-params">()</span> </span>;<span class="hljs-comment">//函数指针的typedef方式不一样，把名字定义在中间，重命名为vfptr</span><br><span class="hljs-comment">//对函数指针进行重命名</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printvftable</span><span class="hljs-params">(vfptr table[])</span><span class="hljs-comment">//函数指针数组</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;table[i]!=<span class="hljs-literal">nullptr</span>;i++)<span class="hljs-comment">//在windows下虚表最后一个元素是空</span><br>    &#123;   <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vft[%d] :%p\n&quot;</span>,i,table[i]);<br>        <span class="hljs-comment">//我们有了一个函数地址，那么就可以调用它</span><br>        vfptr f=table[i];<span class="hljs-comment">//f指向了函数指针的地址</span><br>        <span class="hljs-built_in">f</span>();<span class="hljs-comment">//调用了这个函数</span><br>        <span class="hljs-comment">//我们发现这个是可以调用的</span><br>        <span class="hljs-comment">//就算是私有的我们也可以调用到，因为我们这里不是通过直接调用，而是通过取出来了虚函数的地址，</span><br>        <span class="hljs-comment">//这里不是通过对象调的</span><br>        <span class="hljs-comment">//有了虚表就会有一些安全隐患</span><br><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person mike;<br>    student jason;<br>    <span class="hljs-built_in">func</span>(mike);  <span class="hljs-comment">//到mike里面找到虚函数指针，在虚函数指针里面找到对应的虚函数，然后调用它</span><br>    <span class="hljs-built_in">func</span>(jason); <span class="hljs-comment">//如果是子类，就会发生切割（切片），</span><br>    person &amp;r1 = jason;<br>    person r2 = jason;<br>    student s1;<br>    student s2;<br><br>    derive d; <span class="hljs-comment">//多继承之后，就有两个虚表，</span><br>    <span class="hljs-comment">//子类里面有两张虚表，它自己的虚函数只放一个虚表，放在第一个继承的虚表里面</span><br>    <span class="hljs-comment">// base1和base2里面都有func1，但是发现他们的地址不一样，只是jump指令，最后会jump到一个地方去了</span><br><br>    Base b;<span class="hljs-comment">//虚表的指针在初始化列表（构造函数）里面处理，内置类型不处理，自定义类型调用自己的构造函数处理</span><br>    <span class="hljs-comment">//vfptr(virtual function table pointer )</span><br><br>    <span class="hljs-built_in">printvftable</span>((vfptr*)(*(<span class="hljs-type">void</span>**)&amp;b));<span class="hljs-comment">//取虚表数组的首元素地址，在这个地方的头4个字节, 先转化成int* 再解引用就变成int了可以获得头4个字节了，但是类型不匹配, 所以还得再强转一下</span><br>    <span class="hljs-comment">//取一个对象里面的虚表（虚函数指针数组）</span><br>    <span class="hljs-comment">//这样就弄出来了虚表里面的两个函数</span><br>    <span class="hljs-comment">//不能直接转化的，不是所有类型都可以强制类型转化的（不相关的类型是不可以直接转化的，相关类型之间才可以直接转），要先取出来对应的地址</span><br>    driver s;<br>    <span class="hljs-built_in">printvftable</span>((vfptr*)(*(<span class="hljs-type">void</span>**)&amp;s));<span class="hljs-comment">//取虚表数组的首元素地址，在这个地方的头4个字节, 先转化成int* 再解引用就变成int了可以获得头4个字节了，但是类型不匹配, 所以还得再强转一下</span><br><br>    <span class="hljs-comment">//重写的func1，拷贝下来的func2，还有自己的func3</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7064d2c4ccb24bf5aeea1b2d18644c6c.png" alt="在这里插入图片描述"><br>打印成功<br><img src="https://img-blog.csdnimg.cn/063f4159687649fb905d06a26ec3800a.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号（2)</title>
    <link href="/2022/05/14/%E4%BF%A1%E5%8F%B7%EF%BC%882)/"/>
    <url>/2022/05/14/%E4%BF%A1%E5%8F%B7%EF%BC%882)/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">递达-阻塞-未决</a></li><li><a href="#_24">信号表</a></li><li><a href="#sigset_t_71">sigset_t</a></li><li><a href="#sig_74">sig函数</a></li><li><ul><li><a href="#sigprocmask_83">sigprocmask</a></li></ul></li><li><a href="#sigpending_140">sigpending</a></li><li><a href="#_237">信号发送后</a></li><li><ul><li><a href="#sigaction_266">sigaction</a></li></ul></li><li><a href="#volatile_324">volatile</a></li></ul><h1 id="递达-阻塞-未决"><a href="#递达-阻塞-未决" class="headerlink" title="递达-阻塞-未决"></a>递达-阻塞-未决</h1><ul><li>实际执行信号的处理动作叫做信号递达（delivery）</li></ul><blockquote><p>信号处理方式</p><ol><li>自定义</li><li>默认</li><li>忽略</li></ol></blockquote><ul><li>信号从产生到递达之间的状态叫做信号未决（pending）</li></ul><blockquote><p>本质上就是这个信号被暂存在task_struct 信号位图里面，未决<br>我先不知道咋搞，先保存着</p></blockquote><ul><li>进程可以阻塞（block）某个信号</li></ul><blockquote><p>本质是OS允许进程暂时<strong>屏蔽</strong>指定的信号，<br>阻塞过程中</p><ol><li>该信号依旧是未决的</li><li>该信号不会被递达，直到解除阻塞，才可以递达</li></ol></blockquote><p>忽略和阻塞有区别吗？</p><blockquote><p>区别特别大，忽略是递达的一种方式<br>阻塞是没有被递达，一个独立状态，解除阻塞后可以被忽略、</p></blockquote><h1 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h1><p>在信号当中是有3张表格的<br>分别是handler，pending，block</p><p>pending表:确认一个进程是否收到信号<br>handler表</p><blockquote><p>void (*handler[32])(int):函数指针数组，里面放的就是一个一个的函数指针</p></blockquote><ul><li><p>pending ：比特位的位置代表是哪一个信号，比特位位置的0，1代表是否收到了信号<br>1代表收到了信号但处于未决状态(还未递达)，0代表没收到信号，或者已经递达了</p></li><li><p>block表：本质上也是叫做位图结构，uint32_t block:（也叫做<strong>信号屏蔽字</strong>），比特位的位置代表信号的编号，比特位的内容代表信号是否被屏蔽阻塞，阻塞的信号无法被递达，</p></li></ul><p>伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ishandler</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br><span class="hljs-keyword">if</span>(block&amp;sig)<br>&#123;<br><span class="hljs-comment">//根本就不看是否收到该型号</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//该信号没有被block</span><br><span class="hljs-keyword">if</span>(signo&amp;pending)<br>&#123;<br><span class="hljs-comment">//说明没有被 blockl，而且已经收到了，可以调用这个型号了</span><br>handler_arr[signo](signo);<span class="hljs-comment">//执行对应的回调方法</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>进程通过这三张表是可以识别信号的，<br><img src="https://img-blog.csdnimg.cn/690f0d03dab44bc2ac22c2a0f4b84238.png" alt="在这里插入图片描述"></p><p>不要认为只有接口才可以算是system call 的接口<br>我们也要意识到，OS 也会给用户提供数据类型，</p><h1 id="sigset-t"><a href="#sigset-t" class="headerlink" title="sigset_t"></a>sigset_t</h1><p>信号集，未决和阻塞标志可以使用相同的数据类型<strong>sigset_t</strong> 来存储，这个类型可以标识每个信号状态处于何种状态（阻塞还是未决），阻塞信号集也叫当前进程的信号屏蔽字，这里的屏蔽应该是阻塞而不是忽略</p><h1 id="sig函数"><a href="#sig函数" class="headerlink" title="sig函数"></a>sig函数</h1><blockquote><p>int sigemptyset(sigset_t * set); 把所有的比特位全部置0，<br>int sigfillset(sigset_t * set)把所有的比特位全部置1<br>int sigaddset(sigset_t* set,int signo )把特定的信号加入到位图当中<br>int sigdelset(sigset_t *set,int signo)把特定的信号在位图当中去掉<br>int sigismember(const sigset_t *set,int signo)检查在位图当中是否有这个信号（成功放回1，失败放回0）</p></blockquote><h2 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask"></a>sigprocmask</h2><p>统一修改的是block位图</p><blockquote><p>int sigprocmask(int how,sigset* set,sigset* oset)<br>成功返回0，失败返回-1</p></blockquote><blockquote><p>set是一个输入型参数（把我们要的数据传进去），我们自己设置好的<br>oset是一个输出型参数（返回老的信号屏蔽字—block位图），没有修改之前的屏蔽字</p></blockquote><p>how(修改的方法)：</p><ul><li>SIG_UNBLOCK：set里面包含了我们希望当前信号屏蔽字中解除的信号，相当于mask&#x3D;mask&amp;~set</li><li>SIG_BLOCK:set里面包含了我们希望添加到信号屏蔽字中的信号</li><li>SIG_SETMASK:设置当前信号屏蔽字为set所指向的值，相当于mask&#x3D;set</li></ul><p>9号信号没有被屏蔽掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//虽然sigset_t  是一个位图结构，但是不同的OS 实现是不一样的，不能让用户使用直接修改该变量，</span><br>    <span class="hljs-comment">//需要使用特定的函数，</span><br><br>    <span class="hljs-comment">//这里的set是一个变量，所以这个set在哪里保存着呢</span><br>    <span class="hljs-comment">//set是一个变量，也是在栈空间保存着</span><br>    <span class="hljs-comment">//用户栈上保存（地址空间）    </span><br>    <span class="hljs-type">sigset_t</span> iset,oset;<span class="hljs-comment">//有了这个类型</span><br>    <span class="hljs-comment">// set | =1;</span><br>    <span class="hljs-comment">//外面必须使用set对应的接口函数</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;iset);<span class="hljs-comment">//清空</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;oset);<br><br>    <span class="hljs-comment">//外面想对2，5，6三个信号做屏蔽</span><br>    <span class="hljs-built_in">sigaddset</span>(&amp;iset,<span class="hljs-number">2</span>);<span class="hljs-comment">//把2号信号添加进去</span><br>    <span class="hljs-built_in">sigaddset</span>(&amp;iset,<span class="hljs-number">9</span>);<span class="hljs-comment">//把2号信号添加进去,9号信号无法被屏蔽掉的</span><br><br>    <span class="hljs-comment">//设置当前信号的屏蔽字</span><br>    <span class="hljs-comment">//获取当前进程老的屏蔽字</span><br>    <span class="hljs-comment">// sigprocmask(SIG_SETMASK,&amp;iset,&amp;oset);//把2号信号给屏蔽掉了</span><br>    <span class="hljs-built_in">sigprocmask</span>(SIG_UNBLOCK,&amp;iset,&amp;oset);<span class="hljs-comment">//把2号信号给屏蔽掉了</span><br>    <span class="hljs-built_in">sigprocmask</span>(SIG_BLOCK,&amp;iset,&amp;oset);<span class="hljs-comment">//把2号信号给屏蔽掉了</span><br>    <span class="hljs-comment">//ctrl c 给屏蔽掉了，不会被递达的</span><br>     <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h1><p>int sigpending(set_t *set)<br>,输出型参数<br>不对pending位图进行修改，而只是单纯的获得pending位图<br>（类似waitpid里的status）<br>pendind位图不是让我们修改的，而是OS，我们只需要获取就可以了</p><p>如果我们的进程先屏蔽掉2号信号，再不断的获取当前进程的pending表，然后手动发送2号信号，因为2号信号不会被递达，所以，不会的获取当前进程的pending位图，打印出（00000010），发送后不能被递达就会永远保留再pending位图里面</p><p>signal就是修改handler表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showpend</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span>&amp; pending)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//检测一下信号是否存在在里面</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">32</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sigismember</span>(&amp;pending,i))<span class="hljs-comment">//成功放回1，失败放回0，</span><br>        &#123;<br>            <span class="hljs-comment">//检查信号是否存在pending位图里面</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;2号信号被递达了，已经完成了处理 &quot;</span>&lt;&lt;signo&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//虽然sigset_t  是一个位图结构，但是不同的OS 实现是不一样的，不能让用户使用直接修改该变量，</span><br>    <span class="hljs-comment">//需要使用特定的函数，</span><br><br>    <span class="hljs-comment">//这里的set是一个变量，所以这个set在哪里保存着呢</span><br>    <span class="hljs-comment">//set是一个变量，也是在栈空间保存着</span><br>    <span class="hljs-comment">//用户栈上保存（地址空间）  </span><br><br><br>    <span class="hljs-built_in">signal</span>(<span class="hljs-number">2</span>,handler);<span class="hljs-comment">//捕捉一下2号信号  </span><br>    <span class="hljs-type">sigset_t</span> iset,oset;<span class="hljs-comment">//有了这个类型</span><br>    <span class="hljs-comment">// set | =1;</span><br>    <span class="hljs-comment">//外面必须使用set对应的接口函数</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;iset);<span class="hljs-comment">//清空</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;oset);<br><br>    <span class="hljs-comment">//外面想对2，5，6三个信号做屏蔽</span><br>    <span class="hljs-built_in">sigaddset</span>(&amp;iset,<span class="hljs-number">2</span>);<span class="hljs-comment">//把2号信号添加进去</span><br>    <span class="hljs-comment">// sigaddset(&amp;iset,9);//把2号信号添加进去,9号信号无法被屏蔽掉的</span><br><br>    <span class="hljs-comment">//设置当前信号的屏蔽字</span><br>    <span class="hljs-comment">//获取当前进程老的屏蔽字</span><br>    <span class="hljs-built_in">sigprocmask</span>(SIG_SETMASK,&amp;iset,&amp;oset);<span class="hljs-comment">//把2号信号给屏蔽掉了</span><br>    <span class="hljs-comment">// sigprocmask(SIG_UNBLOCK,&amp;iset,&amp;oset);//把2号信号给解除屏蔽了</span><br>    <span class="hljs-comment">// sigprocmask(SIG_BLOCK,&amp;iset,&amp;oset);//把2号信号给屏蔽掉了</span><br>    <span class="hljs-comment">//ctrl c 给屏蔽掉了，不会被递达的</span><br>    <span class="hljs-type">sigset_t</span> pending;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <br>        <span class="hljs-built_in">sigemptyset</span>(&amp;pending);<span class="hljs-comment">//把他里面的数据都给他清空一下</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">sigpending</span>(&amp;pending);<span class="hljs-comment">//获取了pending位图</span><br>        <span class="hljs-built_in">showpend</span>(pending);<br>        cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;endl;<br>        cnt++;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-comment">//把2号信号解除屏蔽</span><br>            <span class="hljs-comment">//老的屏蔽字没有对2号进行屏蔽</span><br>            <span class="hljs-comment">//在这之前2号信号都已经被屏蔽掉了，所以前面用ctrl c是没什么用的</span><br>            <span class="hljs-built_in">sigprocmask</span>(SIG_SETMASK,&amp;oset,<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//在这里之后才可以有用的</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;恢复对2号屏蔽字的使用,可以被递达了&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-comment">//被递达了之后，又会,我们无法看到恢复屏蔽，2号信号的默认动作是终止进程，所以看不到现象</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="信号发送后"><a href="#信号发送后" class="headerlink" title="信号发送后"></a>信号发送后</h1><p>信号是在合适的时候处理，因为信号的产生是异步的，也就意味着当前进程可能正在做更重要的事情，<br>信号可以延时处理（取决于OS和进程）</p><p>什么是”合适“的时候，因为信号是保存在进程的PCB中，pending位图里面，检测，处理（检测，忽略，自定义）<br>当进程从<strong>内核态</strong>放回到<strong>用户态</strong>的时候，进行上面的检测并处理工作</p><blockquote><ul><li>内核态：执行OS 的代码和数据时候，计算机所处于的状态就叫做内核态，OS的代码的执行全部都是在内核态</li><li>用户态：用户代码和数据被访问或者执行的时候，所处于的状态，我们自己写的代码全部都是在用户态中执行的，</li></ul></blockquote><p>主要是权限大小的区别</p><p>我们很经常在用户态调到内核态，再从内核态转移到用户态：系统调用（open），从普通用户变成了一个<br>用户调用系统函数的时候，除了进入函数，还有身份的变化，从用户的身份变成内核的身份。</p><p><img src="https://img-blog.csdnimg.cn/7bc83271c5b14863a28d7fc7e505d919.png" alt="在这里插入图片描述"><br>死循环：也有可能进入内核态，因为死循环太久了，就被OS 给回收了，这个之后就执行了进程替换，一定会有用户到内核，内核到用户<br>信号的处理流程</p><p><img src="https://img-blog.csdnimg.cn/60d23978367647a3b92a6a0446a91097.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e90a37ac0c5043aa827423806b9392b8.png" alt="在这里插入图片描述"></p><p>为何一定要切换成为用户态，才能执行信号捕捉方法，<br>OS 是可以执行用户的代码，但是OS 不相信任何人，轻易不执行别人的代码，身份特殊，不能直接执行用户的代码<br>（用户做了不合理的动作，那OS 也能搞它的代码，很危险）</p><h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h2><p>和signal差不多<br>修改的是handler函数指针数组（handler表）<br>信号捕捉，注册信号，对特定的信号进行处理</p><blockquote><p>#include&lt;signal.h&gt;<br>int sigaction(int signo,const struct sigaction* act,struct sigaction* oact)</p></blockquote><p>act 是一个输入型参数（把动作方法填到这里面）<br>oact是一个输出型参数（带回老的信号，不想要的设置位nullptr）</p><blockquote><p>struct sigaction {<!-- --><br>void (*sa_handler)(int);&#x2F;&#x2F;方法<br><del>void (*sa_sigaction)(int, siginfo_t *, void *);&#x2F;&#x2F;实时信号</del><br>sigset_t sa_mask;<br><del>int sa_flags;&#x2F;&#x2F;选项</del><br><del>void (*sa_restorer)(void);&#x2F;&#x2F;实时信号</del><br>};</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//信号捕捉动作</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;signo=&quot;</span>&lt;&lt;signo&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;<span class="hljs-comment">//定义了一个sigaction类型</span><br>    <span class="hljs-built_in">memset</span>(&amp;act,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(act));<br>    act.sa_handler=handler;<br>    <span class="hljs-built_in">sigaction</span>(<span class="hljs-number">2</span>,&amp;act,<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//对2号信号进行注册了</span><br>    <span class="hljs-comment">//本质是修改当前进程的handler函数指针数组特定的内容</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;hello &quot;</span>&lt;&lt;endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b3de7266a24746c8b61b00e2ae573c12.png" alt="在这里插入图片描述"><br>信号捕捉特性</p><blockquote><ol><li>当我们处理某一个函数调用的时候，首先要把要执行的信号先加到屏蔽字里面，当信号处理函数返回的时候就自动恢复原来的信号屏蔽字，这样就保证了再处理信号时，如果这种信号再次产生，它就会被阻塞到处理完为止。（<strong>如果我们收到一个信号但是不屏蔽它，再信号处理函数内部，再收到信号，handler方法就会被不断的被调用，处理完才能处理下一个</strong>）</li><li>如果再调用信号处理函数时，除了当前信号被自动屏蔽之外，<strong>还希望自动屏蔽另外的一些信号</strong>，则用sa_mask字段说明这些需要额外屏蔽的信号，当信号处理函数返回时，会自动恢复</li></ol></blockquote><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>gcc volatile.c -O3( 编译器优化 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//内存里面读取flag，来检测flag</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>    flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;change flag 0 to 1\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    signal(<span class="hljs-number">2</span>,handler);<br>    <span class="hljs-keyword">while</span>(!flag);<span class="hljs-comment">//发送2号信号之后就会停止循环</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这个进程是正常退出的\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器优化之后，直接把flag放到了cpu寄存器上面，不在内存里面了<br>但是在signal调用函数的时候修改了flag，这个是对内存当中的flag修改<br>cpu检测都不是内存，所以我们无论怎么ctrl c都不会退出<br>cpu访问内存就被屏蔽掉了</p><p>而我们加入volatile之后，<br>作用：告诉编译器，不要对我这个变量做任何优化，读取必须是贯穿模式的从内存到cpu，不要读取中间缓冲区寄存器中的数据，永远都能看到内存，<br>保持内存的可见性</p><p><img src="https://img-blog.csdnimg.cn/23bc5eaa8b7e4324981e7b4fc69047d6.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络 linux c语言 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++继承</title>
    <link href="/2022/05/05/C++%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/05/05/C++%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">引言</a></li><li><a href="#_5">继承的概念与定义</a></li><li><ul><li><a href="#_101">继承的定义</a></li></ul></li><li><a href="#_138">基类和派生类对象赋值转换</a></li><li><a href="#_174">继承中的作用域</a></li><li><a href="#_205">派生类的默认成员函数</a></li><li><a href="#_343">复杂的菱形继承与</a></li><li><a href="#_401">继承的总结和反思</a></li><li><ul><li><a href="#_407">继承和组合</a></li></ul></li></ul><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这篇博客本来在上个月就应该发出来，但是中间由于各种原因，而一拖再拖，今天也终于完成了这篇博客，<br>各位看官请好好欣赏吧</p><h1 id="继承的概念与定义"><a href="#继承的概念与定义" class="headerlink" title="继承的概念与定义"></a>继承的概念与定义</h1><p>继承是对代码进行复用，是类设计层次的复用，让我们的子类可以使用父类的代码，减少代码的冗余提高效率</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">strudent</span><br>&#123;<br>string name;<br>string id;<br>string address;<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//独自有的</span><br><span class="hljs-comment">//学院，专业，宿舍楼</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">teacher</span><br>&#123;<br>string name;<br>string id;<br>string address;<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//独自有的</span><br><span class="hljs-comment">//职称，科目</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们会发现这虽然这是两种不同的类，但是有很多信息是重复冗余的<br>所以我们完全可以定义个父类，来保存共有的信息</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>string name;<br>string id;<br>string address;<br>&#125;<br>继承person的<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>:<span class="hljs-keyword">public</span> person<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//学院，专业，宿舍楼</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">teacher</span>:<span class="hljs-keyword">public</span> person<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//职称，科目</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; _name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;age:&quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br>string _name = <span class="hljs-string">&quot;peter&quot;</span>; <span class="hljs-comment">// 姓名</span><br><span class="hljs-type">int</span> _age = <span class="hljs-number">18</span>; <span class="hljs-comment">// 年龄</span><br>&#125;;<br><span class="hljs-comment">// 继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。这里体现出了Student和</span><br><span class="hljs-comment">//Teacher复用了Person的成员。下面我们使用监视窗口查看Student和Teacher对象，可以看到变量的复用。</span><br><span class="hljs-comment">//调用Print可以看到成员函数的复用。</span><br><span class="hljs-comment">//Person里的成员变量和成员函数都被包含了进去</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person<br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> _stuid; <span class="hljs-comment">// 学号</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> : <span class="hljs-keyword">public</span> Person<br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> _jobid; <span class="hljs-comment">// 工号</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student s;<br>Teacher t;<br>s.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//因为没有二义性，所以这里的print就是父类的</span><br>t.<span class="hljs-built_in">Print</span>();<span class="hljs-comment">//如果有二义性，只会是用子类的，否则要显示调用父类</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> :<span class="hljs-keyword">public</span> person<br></code></pre></td></tr></table></figure><h2 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h2><p>class默认是公有继承(但是我们最好把继承方式写上)</p><ol><li>格式<br>class student :public person<br>student是派生类，public是继承方式，person是基类</li><li>继承关系与访问限定符<br>继承方式<br>：public继承，protect继承，private继承<br>访问限定符<br>：public访问，protect访问，private访问</li></ol><p><img src="https://img-blog.csdnimg.cn/d80852d32b5042dfb39d3a91de0de73a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>基类的private成员在派生类中无论以什么方式继承都是不可以见到的</li></ol><blockquote><p>数据继承下来了，在那个地方但是用不上，不可以见的意思是<br>：继承下来之后，不管是在类的里面还是在类的外面都不可以访问他<br>继承：简单粗暴，直接全部继承下来，但是无论如何都永不上这个成员的</p></blockquote><p>不想给子类用就定义成private，想给子类用就定义成public或者protected</p><ol start="2"><li><p>取访问限定符和访问方式中的小的那一个<br>public&gt;protect&gt;private</p></li><li><p>public和protect和private的区别<br>public想让别人可以直接使用<br>protect不想要让别人直接使用，但是想要让子类能够使用<br>private不想让任何人使用，包括子类</p></li></ol><p>保护和私有在父类中没有区别</p><p>4.在实际使用的过程中，一般都是public继承，几乎很少private和protect，不提倡private和protect继承，<br>在类里面基本都使用protect和public，几乎不使用private</p><p>常见的继承<br>父类成员：公有和保护<br>子类继承方式：公有继承</p><h1 id="基类和派生类对象赋值转换"><a href="#基类和派生类对象赋值转换" class="headerlink" title="基类和派生类对象赋值转换"></a>基类和派生类对象赋值转换</h1><p>（赋值兼容规则）<br>我们以前学过，如果是同一种类型就可以直接进行赋值，如果不是同一种类型可以实现显示类型访问，</p><p>如果我们想要子类给父类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>string _sex;<br>string _name;<br><span class="hljs-type">int</span> _age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> : <span class="hljs-keyword">public</span> person<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> _no;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br>student s;<br><span class="hljs-comment">//父类=子类赋值兼任-》切割，切片</span><br><span class="hljs-comment">//只有public继承可以</span><br><span class="hljs-comment">//把子类里面父类的那一部分切割过去，给父类</span><br><span class="hljs-comment">//父类的指针和父类的引用</span><br><span class="hljs-comment">//这里不存在类型转换，是语法天然支持的行为</span><br>p=s;<br><span class="hljs-comment">//父类不能给子类，因为</span><br>person*ptr=&amp;s;<span class="hljs-comment">//指针只能得到其中的父类的部分</span><br>person&amp; ref=s;<span class="hljs-comment">//变成子类对象当中父类对象的别名</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h1><ol><li>在继承体系中基类和派生类偶有独立的作用域</li></ol><blockquote><p>子类和父类出现同名成员：隐藏&#x2F;重定义，子类会<strong>隐藏</strong>父类的同名成员<br>如果有同一名字的话，并不是构成函数重载（重载是在同一个作用域里面才可以称之为重载）<br>只要<strong>函数名相同</strong>就构成隐藏，<strong>参数的相同与否无所谓</strong>，不影响<br>最好不用定义同名的成员函数和同名成员</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> : <span class="hljs-keyword">public</span> person<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> _no = <span class="hljs-number">1</span>; <span class="hljs-comment">//ton</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; _no; <span class="hljs-comment">//默认访问自己的</span><br><span class="hljs-comment">//现在想要访问父类的</span><br>cout &lt;&lt; person::_no &lt;&lt; endl; <span class="hljs-comment">//访问了父亲的</span><br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br>student s;<br>s.<span class="hljs-built_in">Print</span>();   <span class="hljs-comment">//同名变量就近原则，会打印出Student</span><br>s.person::<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">//指定调用person类域的,这样就可以用了</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-comment">//父类</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name <span class="hljs-comment">/*=&quot;peter&quot;*/</span>) <span class="hljs-comment">//构造函数</span><br>        : _name(name)                     <span class="hljs-comment">//初始化列表，对值进行初始化</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;person()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;s) <span class="hljs-comment">//拷贝构造</span><br>        : _name(s._name)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;person(const person&amp; s)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    Person &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Person &amp;s) <span class="hljs-comment">//赋值相等</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person=&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)<br>        &#123;<br>            _name = s._name;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Person()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    string _name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person <span class="hljs-comment">//公有继承，子类</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//父类没有默认构造函数，我们自己写</span><br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;zhans&quot;</span>, <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>)<span class="hljs-comment">//给一个缺省值</span><br>        : <span class="hljs-built_in">Person</span>(s) <span class="hljs-comment">//调用默认构造，父类也是我们调用，不同于析构</span><br>          ,<br>          _num(num)<br>    &#123;&#125;<br><br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> Student &amp;s)<br>        <span class="hljs-comment">//把s当中父类的那一部分取出来</span><br>        : <span class="hljs-built_in">Person</span>(s) <span class="hljs-comment">//我们可以直接传，他会切片，所以不用担心，这是一个天然的部分</span><br>                    <span class="hljs-comment">//这个之后会变成父类当中的别名</span><br>          ,<br>          _num(s._num)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// s2=s1;</span><br>    Student &amp;<span class="hljs-keyword">operator</span>=(Student &amp;s)<br>    &#123;<br>        <span class="hljs-comment">//赋值和拷贝构造类似，只不过他们是已经存在的对象进行赋值</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)<br>        &#123;<br>            _num = s._num;<br><br>            <span class="hljs-comment">// operator=(s);//调用父类的赋值运算，所以这里父类切的就是父类的那一部分，没有什么问题</span><br>            <span class="hljs-comment">//上面的操作会无限递归下去，死循环</span><br>            Person::<span class="hljs-keyword">operator</span>=(s); <span class="hljs-comment">//我们指定一下就可以了</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//析构函数的名字，会被统一处理成destructor（）（至于为什么会这样，多态的时候我们就会讲解）</span><br>    <span class="hljs-comment">//所以就会被构成隐藏</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    <span class="hljs-comment">//这段代码在vscode里面无法通过</span><br>    ~<span class="hljs-built_in">Student</span>()<br>    &#123;<br>        <span class="hljs-comment">//Person::~Person();//这里要指定作用域才可以调用，，</span><br>        <span class="hljs-comment">//我们指定了父类</span><br>        <span class="hljs-comment">//调用父类的</span><br>        <span class="hljs-comment">//delete[] p;</span><br>        <span class="hljs-comment">//我们这里会发现调用两次析构，</span><br>        <span class="hljs-comment">//我们子类先执行</span><br>    &#125;<br>    <span class="hljs-comment">//子类的析构函数不需要我们去显示调用，因为会在子类析构的时候自动调用父类的析构</span><br>    <span class="hljs-comment">//我们初始化的时候，父类先构造，子类再构造，析构的时候子类先析构，父类再析构</span><br>    <span class="hljs-comment">//所以我们实现子类析构函数的时候，不需要显示调用父类的析构函数，</span><br><br><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _num = <span class="hljs-number">1</span>; <span class="hljs-comment">//这里不是初始化，只是给了一个缺省值</span><br>    <span class="hljs-comment">// string _s=&quot;dasd&quot;;</span><br>    <span class="hljs-comment">// int *p=new int[10];</span><br>&#125;;<br><br><span class="hljs-comment">//派生类的重点4个默认成员函数，我们不写，编译器会默认生成会干些什么呢</span><br><span class="hljs-comment">//如果我们要写，要做些什么呢</span><br><br><span class="hljs-comment">// 我们不写，默认生成的派生类的构造和析构</span><br><span class="hljs-comment">// a。父类继承下来的 （调用父类的默认构造和析构处理） b。自己的（内置类型和自定义类型成员）(跟普通类是一样的)</span><br><br><span class="hljs-comment">//我们不写默认生成的拷贝构造和operator =</span><br><span class="hljs-comment">// a。父类继承下来的（调用父类的拷贝构造和operator=），完成值拷贝和浅拷贝    b。自己的（内置类型和自定义类型成员）(跟普通类是一样的)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总结：</span><br><span class="hljs-comment">继承下来的调用父类处理，自己的按普通类基本规则</span><br><span class="hljs-comment">如果要我们自己处理呢，该如何去写，什么情况要自己写</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">父类的成员调用父类的对应构造，拷贝构造，operator=和析构处理</span><br><span class="hljs-comment">自己的成员按需求处理（普通类处理）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1.父类没有默认构造,我们要自己写</span><br><span class="hljs-comment">2.如果自己的子类有资源要进行释放，就需要我们自己写析构</span><br><span class="hljs-comment">3.如果子类有存在深拷贝问题，就需要我们自己实现拷贝构造和赋值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4.友元关系不能继承，父类的朋友，不一定是子类的朋友，所以不能访问他的私有成员，</span><br><span class="hljs-comment">5.继承与静态成员，静态成员无论继承怎么样，静态成员都是一样的，static count,继承都是一样样的，地址也是一样的，只有一份，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//一个类如果我们不写，我们会不会自动生成一个</span><br>    Student s;<br>    <span class="hljs-comment">// Student s1(s); //拷贝构造</span><br>    <span class="hljs-comment">// Student s3(&quot;jack&quot;, 18);</span><br>    <span class="hljs-comment">// s1 = s3;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂的菱形继承与"><a href="#复杂的菱形继承与" class="headerlink" title="复杂的菱形继承与"></a>复杂的菱形继承与</h1><p>多继承就是一个坑，</p><p>单继承：一个类只有一个直接父类</p><p>多继承，一个类有多个直接父类<br><img src="https://img-blog.csdnimg.cn/e920dc410f334c64b8e5bd08bd30829c.png" alt="在这里插入图片描述"><br>菱形继承是多继承的一种特殊情况，多继承没问题，只不过要避免菱形继承<br><img src="https://img-blog.csdnimg.cn/73201f0e27a9459ca78b9c946c52fffd.png" alt="在这里插入图片描述"><br>存在数据冗余和二义性<br>里面有两份person</p><p>先继承前面的，再继承后面的</p><p><img src="https://img-blog.csdnimg.cn/c5214119506d41b7ac2b5d3bbae5cb2c.png" alt="在这里插入图片描述"><br>A一般叫做虚基类<br>再D里面，A放到一个公共的位置，那么有时候B需要找A，C 需要找A，就需要通过虚基表中的偏移量进行计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> :<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> :<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _c;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _d;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D d;<br>    d.B::_a = <span class="hljs-number">1</span>;<span class="hljs-comment">//虚继承就弄成一起的地方了，</span><br>    d.C::_a = <span class="hljs-number">2</span>;<br>    d._b = <span class="hljs-number">4</span>;<br>    d._c = <span class="hljs-number">5</span>;<br>    d._d = <span class="hljs-number">6</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们尽量不要定义出菱形继承，虚继承</p><h1 id="继承的总结和反思"><a href="#继承的总结和反思" class="headerlink" title="继承的总结和反思"></a>继承的总结和反思</h1><p>c++的缺陷</p><ol><li>没有垃圾回收器</li><li>多继承</li></ol><h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//继承</span><br><span class="hljs-comment">//继承是为了复用代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span><br>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">b</span>:<span class="hljs-keyword">public</span> a<br>&#123;&#125;<br><span class="hljs-comment">//组合</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">c</span><br>&#123;<br>int_c <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">d</span> <br>&#123;<br>C _obj;<span class="hljs-comment">//这样也是一种复用，开一个C类型的变量</span><br><span class="hljs-type">int</span> _d <br>&#125;<br></code></pre></td></tr></table></figure><ol><li>public继承是一种is_a 的关系，也就是说每个派生类的对象都是一种基类对象，b就是一个a</li></ol><blockquote><p>Student 和Person的关系就适合用继承 ,Student is Person</p></blockquote><ol start="2"><li>组合是一种has_a的关系，b组合了A，那么就是说b里面有一个a对象</li></ol><blockquote><p>眼睛和头的关系，就适合用组合，头上有眼睛<br>车和轮胎的关系，车上有轮胎</p></blockquote><ol start="3"><li>如果它既是is_a 又可以是has_a,<strong>那么优先使用has_a</strong>（组合）</li></ol><blockquote><p>继承是白箱服用（能看到它的实现细节），组合是黑箱服用（看不见它的实现细节），所以黑盒测试<br>除了父类的私有成员，其他子类都是可以进行使用的，这样会破坏基类的封装，子类可能会调用父类的公有成员和保护成员，D只能用C 的公有，不能</p></blockquote><blockquote><p>类和类之间：低耦合，高内聚（跟我没关系的东西，不要设计进来），<br>类和类之间 的依赖程序低，方便我们维护，所以组合的耦合程度低，<br>组合下来，保护的成员也是无法使用的</p></blockquote><p>组合关系之间依赖关系小，关联程度低，修改很方便，可维护性强</p><p>切割和切片就是继承的好处<br>而多态就是建立在继承的基础之上，</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 visual studio 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号产生前</title>
    <link href="/2022/05/02/%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E5%89%8D/"/>
    <url>/2022/05/02/%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E5%89%8D/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_3">信号入门</a></li><li><a href="#_32">信号产生的各种方式（信号产生前）</a></li><li><ul><li><a href="#demo_33">demo</a></li><li><a href="#signal_43">signal</a></li><li><a href="#_87">信号处理方式概述</a></li><li><a href="#_119">信号产生的方式</a></li><li><ul><li><a href="#1_120">1</a></li><li><a href="#2_124">2</a></li><li><ul><li><a href="#11SIGSEGV_154">11号信号SIGSEGV</a></li><li><a href="#8SIGFPE_176">8号信号SIGFPE</a></li></ul></li><li><a href="#3_195">3</a></li><li><ul><li><a href="#kill_196">kill</a></li><li><a href="#raise_232">raise</a></li></ul></li><li><a href="#4_243">4</a></li></ul></li></ul></li></ul><p><strong>信号与信号量完全没有任何关系</strong></p><h1 id="信号入门"><a href="#信号入门" class="headerlink" title="信号入门"></a>信号入门</h1><p>生活中还有没有信号的场景呢？<br>：闹钟，烽火台的烽火，鸡鸣声。。。—》都是给人看的<br>当我们面对这些场景的时候，我们就立马能够想到某些东西的时候，这些都是信号<br>信号的产生就代表上面的场景触发，<br>信号的产生—》信号是要给进程发的—》进程要在合适的时候，要执行对应的动作</p><blockquote><p>但是，并不是这些场景真正放在我面前的时候，我才知道应该怎么做，这些场景是否被触发，没有直接的关系<br>因为对于信号的处理动作，我们早就知道了，甚至远远早于信号的产生<br>如：听的铃声响了，我们就知道下课了</p></blockquote><blockquote><p>我们怎么做到 呢？<br>我们对特定事件的反应，这是被教育的结果（本质是：我们这些都记住了）</p></blockquote><ol><li>所以进程在没有收到信号的时候，进程知道如何识别是什么信号，怎么处理这些信号<br>而之前在写OS 的时候，程序员就已经设置好了<br>进程具有识别信号并且处理信号的能力，远远早于信号的产生</li></ol><p>在生活当中，我们收到某种信号的时候，并不一定被立即处理（因为信号随时都能产生，但是我当前可能做着更重要的事情，不去处理）</p><ol start="2"><li><p>进程收到某种信号的时候，并不是立即处理的，而是在合适的时候才去处理，</p></li><li><p>进程收到信号之后，需要先将信号<strong>保存</strong>起来，以供在合适的时候进行对信号的处理<br>我们把这个信号放在进程 的PCB 里面，所以信号本质也是<strong>数据</strong><br>信号的发送—&gt;往进程task_struct 里面写数据</p></li><li><p>task_struct 是一个内核数据结构，定义进程对象，内核不相信任何人，只相信自己！只有OS 可以往task_struct 里面写入数据（无论我们的信号如何发送，本质上都是在底层通过 OS.进行传输的）</p></li></ol><h1 id="信号产生的各种方式（信号产生前）"><a href="#信号产生的各种方式（信号产生前）" class="headerlink" title="信号产生的各种方式（信号产生前）"></a>信号产生的各种方式（信号产生前）</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p><img src="https://img-blog.csdnimg.cn/2d049b003e4847639720e47dca6eb207.png" alt="在这里插入图片描述"><br>kill -l可以查看信号列表<br><img src="https://img-blog.csdnimg.cn/1a9e7c16636b4556bd2a3b5c6a30d6ed.png" alt="在这里插入图片描述"></p><blockquote><p>前31个信号是常规信号，后31个是实时信号</p></blockquote><p>键盘ctrl+c的时候，本质上就是我们向进程里面发送2号信号SIGINT</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p><img src="https://img-blog.csdnimg.cn/238782ffbc78424f9327d5d0edb3c530.png" alt="在这里插入图片描述"><br>signal:可以修改进程对信号的默认处理工作<br>第一个参数就是我们的信号对应的宏值，我们既可以使用kill -l信号前面的数字，也可以使用宏</p><blockquote><p>typedef void (*sighandler_t)(int);<br>函数指针，返回值为void，参数为int</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><span class="hljs-comment">//函数名就是我们目标函数的地址，这里的signo对应的就是信号数值</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get a signal: signo:%d\n,pid:%d\n&quot;</span>,signo,getpid());<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">//我们可以通过signal注册对2号信号（终止）处理动作，改成我们自定义的动作</span><br>  signal(<span class="hljs-number">2</span>,handler);<span class="hljs-comment">//我们对2号信号进行处理</span><br>  <span class="hljs-comment">//注册的时候，并不会调用这个函数，只有当信号到来的时候，这个函数才会被调用</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n,pid: %d\n&quot;</span>,getpid());<br>    sleep(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c83a0ff4ea644d0186ddf5dd28989a03.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bedad3dda0b74ac7bb417ffe421ca9d7.png" alt="在这里插入图片描述"><br>我们发现我们ctrl c 或者kill 2 的话都会处理我们自己对信号的处理</p><p><strong>我们发现信号的产生方式其中一种是通过键盘产生的</strong><br><img src="https://img-blog.csdnimg.cn/f538420087184ab1a5288e9365fda0f0.png" alt="在这里插入图片描述"><br>但是键盘产生的信号只能终止前台进程，不能处理后台进程，只能杀掉前台进程<br>但是我们可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">kill <span class="hljs-number">-9</span> pid<br></code></pre></td></tr></table></figure><p>杀掉后台进程</p><h2 id="信号处理方式概述"><a href="#信号处理方式概述" class="headerlink" title="信号处理方式概述"></a>信号处理方式概述</h2><p><strong>总结：</strong><br>一般而言，收到信号的处理方式有3种</p><ol><li><pre><code class="hljs">默认动作：终止自己（ctrl c）暂停（ctrl z）等</code></pre></li><li><pre><code class="hljs">忽略动作：是一种信号处理的方式，只不过动作就是什么也不干，</code></pre></li><li><pre><code class="hljs">（信号的捕捉）自定义动作：类似我们刚刚用signal方法，就是在修改信号的处理动作，有：默认–》 自定义动作，我们可以对不同的信号设置不同的响应动作</code></pre></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><span class="hljs-comment">//函数名就是我们目标函数的地址</span><br>&#123;<br>  <span class="hljs-keyword">switch</span>(signo)<br>  &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello bite %d&quot;</span>,signo);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world %d&quot;</span>,signo);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;quit&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">//printf(&quot;get a signal: signo:%d\n,pid:%d\n&quot;,signo,getpid());</span><br>  <span class="hljs-comment">//exit(1);</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5f464db7b503493f86622033d44ec1ac.png" alt="在这里插入图片描述"></p><p>9号信号无法被捕捉</p><h2 id="信号产生的方式"><a href="#信号产生的方式" class="headerlink" title="信号产生的方式"></a>信号产生的方式</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>我们通过<strong>键盘</strong>对进程发送信号<br>ctrl c ，ctrl d， ctrl z</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><strong>程序中存在异常问题</strong>，导致我们收到信号退出</p><p>进程崩溃的时候我们最想知道什么</p><blockquote><p>当然是崩溃的原因，我收到了信号，waitpid（），status可以获取退出信号</p></blockquote><p>我要解决他<br>崩溃的话就可以用这个方法去运行</p><blockquote><p>我们得知道在<strong>哪一行</strong>崩溃了</p></blockquote><ol><li>在linux中当一个进程退出的时候，他的退出码和退出信号都会被设置（正常情况下）</li><li>当一个进程异常退出的时候，进程的退出信号会被设置，表面当前进程退出的原因</li><li>如果必要，OS 会设置退出消息中的<strong>core dump</strong>标志位，并将进程在内存中的数据传输到磁盘当中，<strong>方便后续调试</strong></li></ol><p>默认情况下在云服务器上core dump是被关掉的<br><img src="https://img-blog.csdnimg.cn/2b991352d03b44dd9dd7725677129f64.png" alt="在这里插入图片描述"><br>我们这个core dump放开<br>ulimit -c 10240</p><p><img src="https://img-blog.csdnimg.cn/a12eb2bf87634636939e4a3a180bbe19.png" alt="在这里插入图片描述"><br>放开之后会产生core dump文件</p><p><img src="https://img-blog.csdnimg.cn/37e4aef8454d47c69107f73583be1016.png" alt="在这里插入图片描述"></p><blockquote><p>如果进程异常退出的时候，被core dump设置为1</p></blockquote><p>不一定是所有信号都会被core dump</p><h4 id="11号信号SIGSEGV"><a href="#11号信号SIGSEGV" class="headerlink" title="11号信号SIGSEGV"></a>11号信号SIGSEGV</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sigtest</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-literal">NULL</span>;<br>    p=(<span class="hljs-type">int</span>*)<span class="hljs-number">100</span>;<br>    *p=<span class="hljs-number">100</span>;<span class="hljs-comment">//对指针解引用，指向空间为NULL，我们是不可以写入的,进程的崩溃</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d609c156cbe4488f845c4f67d4893a4f.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b10505c3189441479b43ff4a6e5892c9.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/17cfd6d213f4484ab7b3280a7b1533a5.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/407dd1d6e29c4895be5375747e9de39d.png" alt="在这里插入图片描述"></p><p>SIGSEGV段错误—-》进程崩溃是因为接收到了11号信号而崩溃的，</p><h4 id="8号信号SIGFPE"><a href="#8号信号SIGFPE" class="headerlink" title="8号信号SIGFPE"></a>8号信号SIGFPE</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br> <span class="hljs-comment">// int *p=NULL;</span><br> <span class="hljs-comment">// p=(int*)100;</span><br> <span class="hljs-comment">// *p=100;//对指针解引用，指向空间为NULL，我们是不可以写入的,进程的崩溃</span><br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>a/=<span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>浮点数错误<br><img src="https://img-blog.csdnimg.cn/9ff3328ca20640f8a74a626a1a536001.png" alt="在这里插入图片描述"><br>在win or linux下进程崩溃的本质是进程收到了对应的信号，然后进程处理信号的默认动作（杀死进程）<br>但是为什么会收到信号呢？</p><p><img src="https://img-blog.csdnimg.cn/502f6ff26bb042d8867162c099d5c6d1.png" alt="在这里插入图片描述"></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p><strong>给别人发信号</strong><br>通过系统调用产生信号<br><img src="https://img-blog.csdnimg.cn/7a7095df38e44825aa45b88fc950f08e.png" alt="在这里插入图片描述"><br>可以向特定进程发送特定信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* proc)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n \t,%s,sign who\n&quot;</span>,proc);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">3</span>)<br>  &#123;<br>    usage(argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> signo=atoi(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-type">int</span> who=atoi(argv[<span class="hljs-number">2</span>]);<br>  kill(who,signo);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,signo,who);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6cf11883c81147a1b5209b076149de09.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6a423fffa1b04166bb21a748f9411802.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/31638602b2924d43b232c14cc47e1a21.png" alt="在这里插入图片描述"></p><h4 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h4><p>给自己发信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>  sleep(<span class="hljs-number">3</span>);<br>  raise(<span class="hljs-number">8</span>);<span class="hljs-comment">//给自己发一个8号信号</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/18bd1ad56f844734a48be5f0a78f3c2e.png" alt="在这里插入图片描述"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>通过软件条件，也能产生信号<br>alarm相当于一个闹钟</p><p><img src="https://img-blog.csdnimg.cn/7237ced8f8d44d238393378b3e58da6a.png" alt="在这里插入图片描述"><br>在seconds秒之后给我们发送一个14号信号<br><img src="https://img-blog.csdnimg.cn/2d1a0fdf2d474381848dac7cb895bae3.png" alt="在这里插入图片描述"><br>返回值为0，或剩余的秒数</p><p><img src="https://img-blog.csdnimg.cn/ce59364d707d4a03a5b5290d2e39b3b9.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//统计一下1s，我们的server可以对int递增到多少</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">HandAlarm</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,count);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  signal(SIGALRM,HandAlarm);<span class="hljs-comment">//我们对14号信号进行注册一下</span><br>  <span class="hljs-comment">//设置闹钟</span><br>  alarm(<span class="hljs-number">1</span>);<span class="hljs-comment">//我们没有设置alarm信号的捕捉动作（没有自定义调用signal函数），执行默认动作</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>    count++;<br>    <span class="hljs-comment">//printf(&quot;hello %d\n&quot;,count++);</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>永远都是操作系统发送的信号</p><p>那么我们怎么理解OS给进程发送数据，task_struct -—-&gt;本质是，OS向执行进程的task_struct 中的信号位图写入比特位1，即完成了信号的发送–&gt;信号的写入<br><img src="https://img-blog.csdnimg.cn/7814c017c74846979a7ae479a837ca0a.png"></p><p>信号的编号是有规律的[1,31]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">//进程的各种属性</span><br><span class="hljs-comment">//进程内部一定要有对应的数据变量，来保存是否收到了对应的信号，</span><br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们用什么数据变量来标识是否收到了信号，<br>uint32_t sigs:一定会存在位图结构<br>0000 0000 0000 0000 0000 0000 0000 0000<br>我们认为左大，右边第一个是第一个比特位，<br>所谓的比特位的位置（第几个），代表的就是哪一个信号，比特位的内容（0，1）代表的就是是否收到了信号<br>0000 0000 0000 0000 0000 0000 0000 0101<br>当前进程收到了1号信号，3 号信号，</p></blockquote><blockquote><p>在进程中采用位图，来标识该进程是否收到信号，</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言 stm32 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命名管道于System V</title>
    <link href="/2022/04/29/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E4%BA%8ESystem%20V/"/>
    <url>/2022/04/29/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E4%BA%8ESystem%20V/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">管道的回顾</a></li><li><a href="#_7">命名管道</a></li><li><ul><li><a href="#_10">命令行</a></li><li><a href="#_27">代码中的使用</a></li></ul></li><li><a href="#System_V_155">System V标准进行通信方式</a></li><li><ul><li><a href="#_169">共享内存</a></li><li><ul><li><a href="#shmget_181">shmget</a></li><li><a href="#ipc_205">ipc</a></li><li><ul><li><a href="#ipcs_206">ipcs</a></li><li><a href="#ipcrm_213">ipcrm</a></li><li><a href="#ftok_225">ftok</a></li></ul></li><li><a href="#shmctl_239">shmctl</a></li><li><a href="#shmat_shmdt_257">shmat shmdt</a></li><li><ul><li><a href="#struct_shmid_ds_276">struct shmid_ds</a></li></ul></li></ul></li><li><a href="#_298">信号量</a></li><li><ul><li><a href="#_299">临界资源</a></li><li><a href="#_310">临界区</a></li><li><a href="#_316">原子性</a></li><li><a href="#_335">互斥</a></li><li><a href="#_348">什么是信号量</a></li></ul></li></ul></li></ul><h1 id="管道的回顾"><a href="#管道的回顾" class="headerlink" title="管道的回顾"></a>管道的回顾</h1><p>进程是具有独立性的—&gt;进程通信的成本比较高—&gt;必须先解决一个问题—&gt;<strong>要让不同的进程看到同一份资源</strong>(内存文件，内存，队列)【一定是需要OS提供的】—-&gt; pipe的本质：是通过子进程继承父进程资源的特性，达到一个目的让不同的进程看到同一份资源</p><p>我们通常标识一个文件：路径+文件名（具有唯一性）</p><h1 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h1><p>为了解决匿名管道只能在父子通信，我们就引入了命名管道<br>命名管道可以在命令行里面弄，也可以在程序里面弄</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mkfifo filename<br></code></pre></td></tr></table></figure><p>创建<strong>管道文件</strong><br><img src="https://img-blog.csdnimg.cn/aaac9a54f73c469798599311fafc6489.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/dbe26d407cf94a1d98cc7f8de796dde8.png" alt="在这里插入图片描述"><br>测试<br>：我们虽然在是同一个文件，但是在不同的进程当中<br>一个进程中的数据通过管道文件传递到另一个进程<br><img src="https://img-blog.csdnimg.cn/273f5c98c11248328cbf96dd920d3bce.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6e8b9c3856d3483990d20dd29f3a5291.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1846b1ae953a4c22a26c9138616b584a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0ab69727872e4f579a28859ce24ab88a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b7a9b6b49a6f43a4ac8025e55cd69787.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="代码中的使用"><a href="#代码中的使用" class="headerlink" title="代码中的使用"></a>代码中的使用</h2><p><img src="https://img-blog.csdnimg.cn/bb7d2d7ecc5540b8bf626ffb145c2779.png" alt="在这里插入图片描述"><br>失败返回-1</p><p>在进程中创建一个命名管道文件，他的权限要和掩码进行按位&amp;，我们标准情况下的掩码都是002</p><ul><li>umask（0）</li></ul><blockquote><p>可以将掩码设置成0</p></blockquote><p>我们发现一方发的信息直接就被另一方给收到了</p><p><img src="https://img-blog.csdnimg.cn/3a7ffc3de4b94b768fee5f323d285e0f.png" alt="在这里插入图片描述"></p><blockquote><p>因为命名管道是基于字节流的，所以实际上信息传递的时候，是需要通信双方定制”协议“的，到网络的时候就可以了解 了，今天我们就单纯的进行字符串通信即可</p></blockquote><p>进程间通信的目的：一个进程去控制另一个进程<br>命名管道的数据不会刷新到磁盘，为了效率</p><p><img src="https://img-blog.csdnimg.cn/08068b85ecd54a4f93730ffea734b75a.png" alt="在这里插入图片描述"><br>命名管道为什么一定要有名字</p><blockquote><p>为了保证不同进程看到同一个文件（通过文件名来操作）所以命名管道<br>而匿名管道是通过父子进程的方式，看到同一份资源，所以就不需要名字，来标识同一个资源</p></blockquote><p><img src="https://img-blog.csdnimg.cn/72e1da8b29644cd3831b096ce960c7f7.png" alt="在这里插入图片描述"></p><blockquote><p>client.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-type">int</span>  <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">//因为fifo已经创建好了，所以我们不用再创建，直接用就行了</span><br>  <span class="hljs-type">int</span> fd=open(MY_FIFO,O_WRONLY);<br>  <span class="hljs-comment">//把文件打开</span><br>  <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<br>  &#123;<br>    perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-comment">//业务逻辑，我们再这里进行写入</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入： &quot;</span>);<span class="hljs-comment">//因为没有+\n,为了避免缓冲区的问题</span><br>    fflush(<span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//刷新一下缓冲区</span><br><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">ssize_t</span> s=read(<span class="hljs-number">0</span>,buffer,<span class="hljs-keyword">sizeof</span>(buffer));<span class="hljs-comment">//我们要处理掉最后的回车键</span><br>    <span class="hljs-comment">//我们从命令行中获取输入，输入到buffer里面</span><br>    <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>      buffer[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//把最后的\0给吃掉</span><br>      buffer[s<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buffer);<span class="hljs-comment">//读一条就发一下文件里面的内容</span><br>      write(fd,buffer,<span class="hljs-built_in">strlen</span>(buffer));<span class="hljs-comment">//传给server  </span><br>    &#125;<br>  &#125;<br>  close(fd);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>server.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-type">int</span>  <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  umask(<span class="hljs-number">0</span>);<span class="hljs-comment">//把掩码设置为1</span><br>  <span class="hljs-keyword">if</span>(mkfifo(MY_FIFO,<span class="hljs-number">0666</span>)&lt;<span class="hljs-number">0</span>)<br>  &#123;<br>    perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-comment">//对于管道文件，我们只需要进行文件操作即可</span><br>  <span class="hljs-type">int</span> fd=open(MY_FIFO,O_RDONLY,<span class="hljs-number">0666</span>);<br>  <span class="hljs-comment">//我们让他执行读操作</span><br>  <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<br>  &#123;<br>    perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">//执行业务逻辑</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//我们每个5秒才从缓冲区里面读进来</span><br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">ssize_t</span> s=read(fd,buffer,<span class="hljs-keyword">sizeof</span>(buffer));<span class="hljs-comment">//我们对fd文件进行读取,client通过管道对fd这个文件进行写入，我们在通过这个进行读取</span><br>    <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-comment">//读取结束了，buffer里面就是我们需要的字符串,我们用client去控制server让他去进行操作</span><br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(buffer,<span class="hljs-string">&quot;show&quot;</span>)==<span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-comment">//子进程</span><br>          execlp(<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>,<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//程序替换</span><br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//如果执行失败我们就可以把退出码设置为1</span><br>        &#125;<br>        waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//父进程执行等待</span><br>      &#125;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(buffer,<span class="hljs-string">&quot;sl&quot;</span>)==<span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-comment">//子进程</span><br>          execlp(<span class="hljs-string">&quot;sl&quot;</span>,<span class="hljs-string">&quot;sl&quot;</span>,<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//程序替换</span><br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//如果执行失败我们就可以把退出码设置为1</span><br>        &#125;<br>        waitpid(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//父进程执行等待</span><br>      &#125;<br>      buffer[s]=<span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client# %s\n&quot;</span>,buffer);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-number">0</span>)<span class="hljs-comment">//我们发现client的结束的时候，文件读写结束了，就会被不断的刷屏了</span><br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client quit....\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>      perror(<span class="hljs-string">&quot;read&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="System-V标准进行通信方式"><a href="#System-V标准进行通信方式" class="headerlink" title="System V标准进行通信方式"></a>System V标准进行通信方式</h1><p>在<strong>OS层面</strong>上，专门为进程间通信设计的<strong>一个方案</strong>，要不要给用户用，以什么方式给用户用？<br>肯定要给用户用，<br>OS不相信任何用户，给用户提供功能的时候，采用系统调用！<br>System V进程间通信，一定会存在专门原来通信的接口（system call）</p><p>所以就需要有个人组织机构来定制标准,就要有人来定制标准，在同一主机上的通信方案： system V</p><p>system V</p><ol><li>共享内存</li><li>消息队列</li><li>信号量</li></ol><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p><img src="https://img-blog.csdnimg.cn/3f71689270f4497e94b4d12947bfa880.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/565d561d21f04a39b5efd72e4bcc1b2f.png" alt="在这里插入图片描述"></p><p>准备工作：</p><ol><li>OS 内存可不可能存在多个进程，同时使用不同的共享内存来通信？？<br>可能—&gt; 共享内存在系统中你可能有多份！—》操作系统也要管理这些共享内存，—》如何管理这些共享内存呢？—》先描述再组织(一定要有内核数据结构)</li><li>怎么保证两个或两个以上的进程会看到同一个共享内存，（共享内存一定要有一定的标识唯一的ID），方便让不同的进程就能识别同一个共享内存的资源！！<br>这个ID在哪里呢，这个id就在描述的结构体里面</li><li></li></ol><h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><p><img src="https://img-blog.csdnimg.cn/aadbfde2e33e4eb2b6bc536f05e96174.png" alt="在这里插入图片描述"><br><strong>失败返回-1</strong></p><p>创建共享内存段</p><ul><li>size：创建这共享内存的大小（我们一般建议是4KB的整数倍），共享内存在内核当中申请的基本单位是页，内存页（4KB）</li></ul><blockquote><p>如果我申请来了4097个字节&gt;4KB,所以内核会向上取整，变成8KB，我们就给你4097，但是操作系统是按照4096*2的方式给你的</p></blockquote><ul><li>shmflg：标记选项</li></ul><p><img src="https://img-blog.csdnimg.cn/8a4e048129534829aa750f20b6dd6a40.png" alt="在这里插入图片描述"></p><ul><li><p>IPC_CREAT:创建一个新的共享内存段，如果单独使用IPC_CREAT,或者flag为0，创建一个共享内存，如果创建的共享内存已经存在，则直接返回当前已经存在的共享内存（不存在则创建，存在就获取一个），（基本不会空手而归）</p></li><li><p>IPC_EXCL:一般不会单独使用的，IPC_CREAT|IPC_EXCL这两个单独使用的才有意义<br>如果不存在共享内存则创建，如果已经存在了共享内存，则返回出错！（意义在于，如果调用成功，得到的一定是一个最新的，没有被人使用的共享内存！）</p></li><li><p>key：为了保证看到的是唯一的标识符，目的是为了让不同的进程来识别的，本质是可以用这标识符让不同的进程看到同一份资源：先让不同的进程看到同一个ID，<br>用ftok来操作</p></li></ul><hr><p><img src="https://img-blog.csdnimg.cn/b841713df9f643dd9e84ab634c39daf9.png" alt="在这里插入图片描述"><br>.&#x2F;server进程执行结束,该进程曾经创建的共享内存没有被释放，<br>第二次运行的时候发现他说文件已经存在（创建共享内存失败）</p><blockquote><p>system V 的IPC 资源，生命周期是<strong>随内核</strong>的（只能通过程序员使用命令或者系统调用来释放，或者OS 重启）<br>于文件不同：文件只要和他相关的进程退出的话，那么这个文件所对应的资源也都全部被释放掉</p></blockquote><h3 id="ipc"><a href="#ipc" class="headerlink" title="ipc"></a>ipc</h3><h4 id="ipcs"><a href="#ipcs" class="headerlink" title="ipcs"></a>ipcs</h4><p>命令行中可以查看共享内存，消息队列，信号量<br><img src="https://img-blog.csdnimg.cn/a6e13ad0a6dc4452805d6fcaf48d6d2e.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ipcs -m<span class="hljs-comment">//只查看共享内存</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3f1a8b923c014aaab80c2e72321fc208.png" alt="在这里插入图片描述"></p><h4 id="ipcrm"><a href="#ipcrm" class="headerlink" title="ipcrm"></a>ipcrm</h4><p>把共享空间给删除掉<br>ipcrm -m shmid<br><img src="https://img-blog.csdnimg.cn/d93eac199bd444ac895fac5a04d8df9f.png" alt="在这里插入图片描述"></p><blockquote><p>key和shmid</p><ul><li>key:只是用来在系统层面进行标识唯一性的，不能原来管理共享内存</li><li>shmid:是OS 给用户返回的id，用来在用户层对共享内存进行管理</li></ul><p>shmid相当于fd，而key相当于文件的地址</p></blockquote><blockquote><p>命令行是属于用户层：所以肯定是使用shmid</p></blockquote><h4 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h4><p>先调用ftok，获得key值，传给shmget<br><img src="https://img-blog.csdnimg.cn/7bc7c6137e6f45c9ac47fac901e35c57.png" alt="在这里插入图片描述"><br>pathname ：我们自定义的路径名<br>proj_id：我们自定义的项目id<br>失败了就返回-1</p><blockquote><p>如我们的路径名“.&#x2F;temp”<br>项目id：0行66<br>这数字是什么不重要，只要保证唯一性就可以了</p></blockquote><blockquote><p>怎么保证不同的进程看到的是同一个共享内存？只要我们形成key的算法+原始数据是一样 的，。形成同一个id</p></blockquote><blockquote><p>这里的key就是会设置进内核的关于shm的内核中的数据结构中</p></blockquote><h3 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h3><p><img src="https://img-blog.csdnimg.cn/dd910b1288f943c5925c3808b49e172f.png" alt="在这里插入图片描述"><br>成功返回0，<br>shmid:就是我们shmget里面创建获得的id<br>cmd:IPC_RMID，把这段给销毁掉<br><img src="https://img-blog.csdnimg.cn/f3c5d13c96f14b1e8a5fe0aeb14a08b3.png" alt="在这里插入图片描述"><br>buf:<br>struct shmid_ds,共享内存的结构体<br><img src="https://img-blog.csdnimg.cn/f4aca93fc65447ebb7b21aa11f3691e5.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a32fba37ba2b472ba2a15167e7ffcf7a.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b93158c0aa294b278062e0c94edfcf06.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a5e157662ed74290a4e763c449cf63f5.png" alt="在这里插入图片描述"><br>shmid也是数组下标<br>控制共享内存（我们只了解删除）</p><h3 id="shmat-shmdt"><a href="#shmat-shmdt" class="headerlink" title="shmat shmdt"></a>shmat shmdt</h3><p><img src="https://img-blog.csdnimg.cn/5de487b14ba9406490252730b118e6d8.png" alt="在这里插入图片描述"></p><blockquote><p>return：成功就返回那个共享空间段的地址（虚拟地址：我们程序员看到的地址都是虚拟地址，不可以看到物理地址），失败的话就返回-1<br>如malloc，返回的空间也都是虚拟的，相当于平白无故多了一个空间</p></blockquote><p><img src="https://img-blog.csdnimg.cn/9a4aaa03835840299f39bf7affa63c5b.png" alt="在这里插入图片描述"></p><p>attach：把我们调用的继承和共享内存关联起来<br>关联和去关联</p><ul><li>shmid：来表示一个共享内存，</li><li>shmaddr：我们要挂接的时候，我们想要把它挂接到我的地址空间的什么地方去，但是我们一般不关心不清楚，所以我们就直接设置为NULL，就可以了</li><li>shmflag：我们也直接设置为0就可以了</li></ul><p>shmdt：去关联，并不是释放共享内存，而是取消当前进程和共享内存的关系，（和页表构建映射关系的页表项删掉）返回值不重要<br>参数是我们关联后的返回值</p><h4 id="struct-shmid-ds"><a href="#struct-shmid-ds" class="headerlink" title="struct shmid_ds"></a>struct shmid_ds</h4><p><img src="https://img-blog.csdnimg.cn/77f9c22ae53a4303977811f9ee2a7c9c.png" alt="在这里插入图片描述"><br>shmid_ds:权限，内存段的大小,上一次挂接的时间，上一次取消挂接的时间，创建者的pid，一共有多少个挂接<br>ipc_perm里面还有很多的uid，，同时还有key，我们可以根据key值找到对应的消息队列<br>消息队列和这个也是类似的，</p><blockquote><ol><li>我们会发现消息队列，信号量，共享内存，的接口类似</li><li>数据结构的第一个结构类型是完全一样的(struct ipc_perm)</li></ol><p><strong>结论</strong>：所有的ipc资源都是通过数组组织起来的，</p><blockquote><p>所有的System V 标准的IPC 资源，XXid_ds结构体的第一个成员都是ipc_perm(这个是一样的，)</p></blockquote></blockquote><p><img src="https://img-blog.csdnimg.cn/ec0f6412ab8548fd9e1816c54c434766.png" alt="在这里插入图片描述"><br>这些数组可以给我们指向不同的结构体，<strong>使用数组的下标</strong><br>指向一个一个IPC资源的结构体指针</p><blockquote><p>struct ipc_perm* ipc_id_arry[64]<br>ipc_id_arry[0]&#x3D;(ipc_perm)&amp;shmid_ds;我们通过强转，<br>当我们需要使用第一个资源的时候不需要强转，当我们使用其他资源的时候就需要强转<br>(shmid_ds*)ipc_id_arry[0]-&gt;shmid_ds的其他属性<br>相当于c++的切片功能</p></blockquote><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>所有可以被多个执行流同时访问的资源就是临界资源，<br>例如:<br>多进程启动后同时向显示器打印，这个<strong>显示器</strong>就是所谓的临界资源<br>而我们在学习进程间通信的时候，<strong>管道，共享内存，消息队列等</strong>，不同的进程能够同时访问<br>共享内存是最典型的共享资源</p><p>所以凡是进程间通信，必定需要引入可以被多个进程看见的资源（通信需要），这一份资源就变成了临界资源，同时，也引入一个新的问题：临界资源的问题</p><p>但是我们在进程中定义一个全局变量，之后fork子进程，但是这个全局变量不是临界资源，因为子进程如果对这个数据进程修改的话，会发生写实拷贝</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>进程的代码可以很多的，其中<strong>用来访问临界资源的代码叫做临界区</strong><br><img src="https://img-blog.csdnimg.cn/9cdf38d12a694193823cc91e0c930817.png" alt="在这里插入图片描述"><br>类似显示器：<br>显示器叫做临界资源，在显示器中printf叫做临界区</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一件事情要么不做，要么就做完，没有中间态，就叫做原子性<br>非原子性：有中间过程</p><blockquote><p>比如学习，要么啥也不学，要么就考第一名，</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在多进程中，定义了一个全局变量</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">cout</span>=<span class="hljs-number">100</span>;<span class="hljs-comment">//</span><br><span class="hljs-comment">//多进程=父+子</span><br><span class="hljs-built_in">cout</span>--； <span class="hljs-built_in">cout</span>--；<span class="hljs-comment">//父子都-</span><br><br></code></pre></td></tr></table></figure><p>父和子对于cout处理不同<br>这里的cout不是原子的，cout是为了保护临界资源的<br>每个人想要进入电影院，必须要先看到cout，<br>cout本身就是也是临界资源的<br>所以信号本身就是临界资源的，</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>在任意时刻只能允许一个执行流进入临界资源，执行他的临界区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">sem=<span class="hljs-number">1</span><span class="hljs-comment">//临界资源只有一份</span><br><span class="hljs-keyword">if</span>(sem&gt;<span class="hljs-number">0</span>)<br>sem--;<span class="hljs-comment">//进入--</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sem&lt;=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//等待，进入临界区执行</span><br>&#125;<br>sem++;<span class="hljs-comment">//出去++</span><br></code></pre></td></tr></table></figure><p>只有0和1就叫做2元信号量</p><h3 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h3><p>管道，匿名or命名，共享内存，消息队列，都是以传输数据为目的的！<br>信号量不是以传输数据为目的的！通过共享内存“资源的方式”，来达到多个进程的同步和互斥的目的!<br>信号量的本质：</p><blockquote><p><strong>是一个计数器，类似 int count :衡量临界资源的中资源的数目的</strong></p><blockquote><ul><li>在电影院的某一个放映厅也是一个临界资源！可以被不同的人访问，我们在进去的时候别人也可以进去，</li><li>并不是我们坐在这个位置上，这个位置才属于我们，在外面买到票的时候，这座位就已经属于我们了，</li><li>而买票的本质：<strong>对临界资源的预定机制</strong></li></ul></blockquote><p>一个放映厅最怕什么？一共有100个座位，卖了110张票，所以最多只能买100张票，———用信号量来约束这行为</p></blockquote><p>信号量本身一个临界资源<br>所以信号量的p操作和delete操作就是必须保证是原子的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count=<span class="hljs-number">100</span>;<br><span class="hljs-built_in">cout</span>--;<span class="hljs-comment">//一个人买走了一张票</span><br><span class="hljs-comment">//愉快的看电影</span><br><span class="hljs-built_in">cout</span>++;<span class="hljs-comment">//访问电影院的人出去了，</span><br><br><br></code></pre></td></tr></table></figure><p>信号量的伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">cout</span>&gt;<span class="hljs-number">0</span>)<br><span class="hljs-built_in">cout</span>--;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//等待</span><br>&#125;<br><span class="hljs-built_in">cout</span>++;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器 linux 运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信---匿名管道</title>
    <link href="/2022/04/25/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1---%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    <url>/2022/04/25/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1---%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">为什么要通信</a></li><li><a href="#_14">通信的宏观理解</a></li><li><a href="#_30">进程间通信分类</a></li><li><a href="#_40">管道</a></li><li><ul><li><a href="#_41">匿名管道</a></li></ul></li></ul><h1 id="为什么要通信"><a href="#为什么要通信" class="headerlink" title="为什么要通信"></a>为什么要通信</h1><blockquote><p>我们需要不同进程之间相互协同，<strong>进程之间的协同</strong>本质上是<strong>程序员之间的协同</strong>，有可能为要从<strong>数据库中拿数据</strong>，你要从数据库中将数据格式化，写成特定的格式，我要根据特定的<strong>格式做数据统计</strong>，这一件事情，有一个无法实现这个事情就无法完成,</p></blockquote><blockquote><ol><li>我们可以将这一件事情拆分成3个事情：一个进程专门<strong>从数据库中拿数据</strong>，一个进程专门做<strong>数据格式化</strong>，还有一个进程专门<strong>做数据统计</strong></li><li>第一个处理完<strong>之后交给</strong>第二个，第二个处理完之后<strong>交给</strong>第三个</li><li>这样我们就可以实现业务上的通信，这样就增加了代码的可维护性，这样我们就找专门的进程处理特定的问题</li></ol></blockquote><p>如：<br>管道<br><img src="https://img-blog.csdnimg.cn/7e3e1b0deacb4f459e2fb3364df604cc.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/010e0629eeca461d9357f35810fbf7e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="通信的宏观理解"><a href="#通信的宏观理解" class="headerlink" title="通信的宏观理解"></a>通信的宏观理解</h1><p>进程之间可能会存在特定的协同工作的场景-—–&gt; 一个进程要把自己的数据交付给了一个进程，让其处理———-&gt;这就叫做进程间通信-—–&gt; 但是进程具有独立性，交互数据，成本一定很高，<br>(所以这一定需要操作系统进行协同，参与通信)<br>因为一个进程是看不到另一个进程的资源<br>所以两个进程要相互通信——-&gt;必须要先看到一份公共的资源(一方往里面放数据，另一方往里面取数据 )（这里的资源，就是一段内存）—-&gt; (这段公共进程属于谁，只能属于操作系统，)！！，因为进程具有独立性<br><strong>这段内存：可能以文件的方式存在，也可能以队列的方式存在，也可能提供的就是原始的内存块</strong><br>（这也是通信方式有很多的原因）</p><p>进程间通信本质上：其实是有OS参与，提供一封所有通信进程都能看到的公共资源，</p><p><strong>结论</strong></p><ol><li>我们要想办法让我们看到一份公共的资源，</li><li>通信的时候操作系统的方式不同，所以通信的方式也就不同</li></ol><h1 id="进程间通信分类"><a href="#进程间通信分类" class="headerlink" title="进程间通信分类"></a>进程间通信分类</h1><p>管道</p><blockquote><ul><li>匿名管道</li><li>命名管道</li></ul></blockquote><p>System V IPC</p><blockquote><ul><li>System V 消息队列</li><li><strong>System V 共享内存</strong></li><li>System V 信号量</li></ul></blockquote><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><blockquote><p>父子进程是独立的进程，所以父子通信也属于进程通信的一种</p></blockquote><p><img src="https://img-blog.csdnimg.cn/7191144e206a4ddc8e1fb7300e4017b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/23ca2b3446b94365a7917d9d354272df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d7bc8912c98649a19074f9bf95eb95ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>让双方进程看到了同一份进程<br>接下来我们还想要让他钔通信</p></blockquote><p>我们可以使用系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">PIPE(<span class="hljs-number">2</span>)                                                                               Linux Programmer<span class="hljs-number">&#x27;</span>s Manual                                                                              <span class="hljs-title function_">PIPE</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span><br><br>NAME<br>       pipe, pipe2 - create pipe<br><br>SYNOPSIS<br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>       <span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span>;<br><br>       <span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE             <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>              <span class="hljs-comment">/* Obtain O_* constant definitions */</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>       <span class="hljs-type">int</span> <span class="hljs-title function_">pipe2</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>], <span class="hljs-type">int</span> flags)</span>;<br><br>DESCRIPTION<br>       <span class="hljs-title function_">pipe</span><span class="hljs-params">()</span>  creates  a pipe, a unidirectional data channel that can be used <span class="hljs-keyword">for</span> interprocess communication.  The <span class="hljs-built_in">array</span> pipefd is used to <span class="hljs-keyword">return</span> two file descriptors referring to the ends of the<br>       pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by the kernel until  it  is  read<br>       from the read end of the pipe.  For further details, see <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-number">7</span>)</span>.<br><br>       If flags is 0, then <span class="hljs-title function_">pipe2</span><span class="hljs-params">()</span> is the same as <span class="hljs-title function_">pipe</span><span class="hljs-params">()</span>.  The following values can be bitwise ORed in flags to obtain different behavior:<br><br>       O_NONBLOCK  Set the O_NONBLOCK file status flag on the two new open file descriptions.  Using this flag saves extra calls to <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> to achieve the same result.<br><br>       O_CLOEXEC   Set the close-on-<span class="hljs-title function_">exec</span> <span class="hljs-params">(FD_CLOEXEC)</span> flag on the two new file descriptors.  See the description of the same flag in <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> <span class="hljs-keyword">for</span> reasons why this may be useful.<br><br>RETURN VALUE<br>       On success, zero is returned.  On error, -1 is returned, and errno is <span class="hljs-built_in">set</span> appropriately.<br><br>ERRORS<br>       EFAULT pipefd is not valid.<br><br>       <span class="hljs-title function_">EINVAL</span> <span class="hljs-params">(pipe2())</span> Invalid value in flags.<br><br>       EMFILE Too many file descriptors are in use by the process.<br><br>       ENFILE The system limit on the total number of open files has been reached.<br></code></pre></td></tr></table></figure><blockquote><ol><li>pipefd[2]是一个输出型参数；意味着我们向通过这个参数读取到打开的两个fd，就是把这个值带出去，</li><li>pipe(pipefd[2]),数组名就是首元素地址，到时候通过指针把文件描述符拷贝到我们的数组之中，</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">if</span>(pipe(fd)!=<span class="hljs-number">0</span>)<br>  &#123;<br>    perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe[0]=%d\n&quot;</span>,fd[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe[1]=%d\n&quot;</span>,fd[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bb4ea9b247064d458b6853e6914f31fc.png" alt="在这里插入图片描述"><br>我们发现一个是3，一个是4<br><strong>匿名管道的特点</strong></p><blockquote><ol><li>管道是一个单向的流通信号，</li><li>管道是面向字节流的，tcp FILE,fstream,我们读的时候是只有字节的概念，并不是说我想读多少，就读多少</li><li>仅限于父子特性</li><li>管道回自带同步机制，管道里面没有数据就不会读到管道里面的废弃数据，原子性写入</li><li>管道的生命周期是随进程的</li></ol></blockquote><p>我们测试了一下，写段一直不写，读端一直不读</p><blockquote><p>写满64KB 的时候，write就不再写入了，为什么呢？因为管道有大小！当write写满的时候，要让reader来读，同样的读端也要等写端，我们不会出现读取新老数据的覆盖事件，</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">if</span>(pipe(fd)!=<span class="hljs-number">0</span>)<span class="hljs-comment">//创建管道</span><br>  &#123;<br>    perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-comment">//打印文件描述符</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe[0]=%d\n&quot;</span>,fd[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe[1]=%d\n&quot;</span>,fd[<span class="hljs-number">1</span>]);<br>  <span class="hljs-comment">//实现进程键通信</span><br>  <span class="hljs-type">pid_t</span> id =fork();<br>  <span class="hljs-keyword">if</span>(id&lt;<span class="hljs-number">0</span>)<br>  &#123;<br>    perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">//我们向让父进程执行读取，子进程执行写入</span><br>  <span class="hljs-comment">//0-----&gt;就是读取端，1-----&gt;就是写入端</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(id==<span class="hljs-number">0</span>)<span class="hljs-comment">//创建子进程</span><br>  &#123;<br>    <span class="hljs-comment">//child</span><br>    <span class="hljs-comment">//关闭读写端，建立一个单向的管道</span><br>    <span class="hljs-comment">//子进程把文件描述符也都给继承下来了</span><br>    close(fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg=<span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">cout</span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//我们还可以使用read 和write进行读写操作</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br><br>    <span class="hljs-comment">//write(fd[1],msg,strlen(msg));//我们不需要+1,因为\0本身只是c语言的标准，</span><br>    write(fd[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//子进程不断往管道里面写入，但是父进程不读</span><br>    <span class="hljs-built_in">cout</span>++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cout=%d\n&quot;</span>,<span class="hljs-built_in">cout</span>);<br>    <span class="hljs-comment">//write的动作就是pipe里面只要有缓冲区区域就一直写入</span><br>    <span class="hljs-comment">//当我们一直些的时候，写满64KB的时候，写段就不再写入了，因为管道有大小，</span><br>    <span class="hljs-comment">//当写端写满的时候，为什么不写了，</span><br>    <span class="hljs-comment">//因为要让读端来读，</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//dup2(fd[1],1);</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    <span class="hljs-comment">//father</span><br>    close(fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//父进程就一直在那里读取</span><br>    <span class="hljs-comment">//while(1)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//  char buf[32]=&#123;0&#125;;</span><br>    <span class="hljs-comment">//  ssize_t ret=read(fd[0],buf,sizeof(buf));//如果此时ret=0说明子进程关闭文件描述符了，相当于读到文件的结尾了</span><br>    <span class="hljs-comment">//  //read是只要有数据就可以一直读取</span><br>    <span class="hljs-comment">//  //这就叫字节流</span><br>    <span class="hljs-comment">//  if(ret==0)</span><br>    <span class="hljs-comment">//    break;</span><br>    <span class="hljs-comment">//  else </span><br>    <span class="hljs-comment">//  &#123;</span><br>    <span class="hljs-comment">//  buf[ret]=0;//把\0位置就设置为0</span><br>    <span class="hljs-comment">//  printf(&quot;child say : %s\n&quot;,buf);</span><br><br>    <span class="hljs-comment">//  //我们没有让父进程去sleep</span><br>    <span class="hljs-comment">//  &#125;</span><br><br>    dup2(fd[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>);<span class="hljs-comment">//绑定打印到文件里面</span><br>    <span class="hljs-comment">//&#125;</span><br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//dup2(fd[0],0);</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/68d05a91411c40f2b282df02435d102b.png" alt="在这里插入图片描述"><br>写段被关闭了，读端继续读，就会都到文件的最后</p><blockquote><p>当我们的读端关闭，写端还在写入，此时站在操作系统的角度，合理吗？？<br>严重不合理，因为已经没有人读了，你还在写入，本质就是在浪费操作系统的资源，所以OS会直接终止写入进程，OS给目标进程发送信号，SIGPIPE</p></blockquote><p>管道的四种情况：</p><blockquote><ol><li>读端不读或者读的满，那么写端要等读端读完</li><li>读端关闭，没人读了，写端就没有了存在的必要，写端直接受到SIGPIPE 的信号，直接终止</li><li>写端不写或者写的慢，读端就要等写端</li><li>写端关闭，读端就读完全部pipe内部的数据，然后再读就会读到0，表面文件的结尾！</li></ol></blockquote><blockquote><p>管道实在具有血缘关系的进程之间可以进行进程间通信，但是常用于父子间通信的</p></blockquote><blockquote><p>管道是文件吗？<br>如果一个文件只能被当前进程打开，相关进程退出了，被打开的文件呢？会被OS自动关闭，</p></blockquote><p>可以看我的github仓库详细情况<br><a href="https://github.com/zevin02/Linuxstudy/tree/master/procommunicate">匿名管道代码详细</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态库和静态库</title>
    <link href="/2022/04/21/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2022/04/21/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">时间</a></li><li><ul><li><a href="#makefile_14">makefile更新的机制</a></li></ul></li><li><a href="#_26">静态库和动态库</a></li><li><ul><li><a href="#_27">查看可执行程序依赖库</a></li></ul></li><li><a href="#_51">如何制作库</a></li><li><ul><li><a href="#_99">打包成一个库</a></li><li><a href="#_130">使用自己的库</a></li><li><ul><li><a href="#_163">形成动态库</a></li></ul></li></ul></li></ul><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>Access：文件最近被访问的时间，<br>Modify： 最近一次修改<strong>文件内容</strong>的时间<br>Change:最近一次修改<strong>文件属性</strong>的时间</p><p>Change time<br><img src="https://img-blog.csdnimg.cn/eb3b8ef9a3d347a195da120c83036a85.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>修改文件内容的时候，有可能也会修改文件的属性<br>比如： 可能会更改文件的大小属性<br><img src="https://img-blog.csdnimg.cn/434f923ddc2b4d2e9f3840800f82a4cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我们会发现操作下来， 文件时间貌似没有变化：<br>在较新的Linux内核中，Accsee中不会被立即刷新更新，而是有一定的时间间隔进行刷新</p><h2 id="makefile更新的机制"><a href="#makefile更新的机制" class="headerlink" title="makefile更新的机制"></a>makefile更新的机制</h2><blockquote><p>makefile and gcc 会根据时间问题，来判定源文件和可执行文件次序谁更新，为就以谁为主<br>如gcc test.c -o test<br>如果test的modify时间比test.c的modify时间新，说明就已经更新了，反之，如果test.c的时间比test的时间新，说明makefile需要更新</p></blockquote><p><img src="https://img-blog.csdnimg.cn/438f04709f2342fe965a237722351501.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b5ca66e7fa7948058bb1bef1751631e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对于这种伪目标的，他总是被执行，因为他不关心时间<br><img src="https://img-blog.csdnimg.cn/b093f985cf8243f6ad3db676ee02c9eb.png" alt="在这里插入图片描述"><br>touch会更新文件的时间，我们重新make也可以<br><img src="https://img-blog.csdnimg.cn/af9383933b484ce684a903cc7e105946.png" alt="在这里插入图片描述"></p><h1 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><h2 id="查看可执行程序依赖库"><a href="#查看可执行程序依赖库" class="headerlink" title="查看可执行程序依赖库"></a>查看可执行程序依赖库</h2><p>ldd 【可执行文件】<br><img src="https://img-blog.csdnimg.cn/f9defcb9fb5c428eb84cd35083db1dee.png" alt="在这里插入图片描述"></p><p>第二个是c标准库,我们查看了一下，发现是软链接，<br>我们发现这个文件也是有inode<br><img src="https://img-blog.csdnimg.cn/9d1d716e9a48413fa0ebd71053b0966e.png" alt="在这里插入图片描述"></p><blockquote><p>linux当中，一般库分为两种： 动态库和静态库（库也是一个文件）<br>在Linux中，如果是库文件：库文件一般是以.so作为后缀的，如果是静态库，一般是以.a为后缀的</p></blockquote><blockquote><ol><li>库文件的命名：<br>::libXXX.so- or libYYY.a-</li><li>库的真正名字<br>去掉包含lib前缀，去掉包含a-,so-的后缀<br>如&#x2F;lib64&#x2F;libc.so.1真实名字就是c<br>&#x2F;lib64&#x2F;libc-2.17.so真实名字就是c-2.17</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/fb50bfc25d484bad9390fd0e51787a85.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>c++标准库</p><p>也可以使用file查看连接库的情况<br><img src="https://img-blog.csdnimg.cn/12b0659ee4624aa08b3482a74d4adbc2.png" alt="在这里插入图片描述"><br>动态库只有一个，删除的话，其他文件都无法使用了</p><h1 id="如何制作库"><a href="#如何制作库" class="headerlink" title="如何制作库"></a>如何制作库</h1><p>库本身就是一个二进制文件，<br>一套完整的库：</p><ol><li>库文件本身</li><li>头文件.h（文本，会说明库中暴露出来的方法的基本使用！）<br>我们在C&#x2F;C++ 中，为什么在写代码的时候，有时候.h里面放上声明，在.c里面放上定义，为什么要这么设计</li></ol><blockquote><p>因为我们要制作库！</p><ol><li>方便使用 2. 私密，比较安全，用库对头文件进行封装保护，</li></ol></blockquote><ul><li><img src="https://img-blog.csdnimg.cn/4aacc7177ef14e5881f293f18845c06c.png"><br>我们在other目录下面写一个add.cpp add.h这两个，一个声明，一个定义</li><li>如果我们想要使用的话,要加上这个库的路径<br><img src="https://img-blog.csdnimg.cn/9d16613ad8854d8cb78cc52d27a2e5e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>编译的时候<br><img src="https://img-blog.csdnimg.cn/86afbdcb671b45678b87179b200bc676.png" alt="在这里插入图片描述"><br>添加上特定的路径中的定义，才能使用</li></ul><p>如果没有库，我们想要编译要怎么编译呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mytest:%.o<br>     gcc -o $@ $^<br>%.o:%.c<br>     gcc -c $&lt;  <br></code></pre></td></tr></table></figure><p>,o是我们汇编之后生成的<br>所以%.o 依赖所有的%.c<br>$&lt;就是把上面的所有东西展开，一个一个的进行编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> obj=mytest.o add.o sub.o<br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> mytest:$(obj)<br><span class="hljs-number">4</span>     gcc -o $@ $^<br><span class="hljs-number">5</span> %.o:%.c<br><span class="hljs-number">6</span>     gcc -c $&lt;<br><span class="hljs-number">7</span> <br><span class="hljs-number">8</span> %.o:./other/%.c<br><span class="hljs-number">9</span>     gcc -c $&lt;    <br> <br></code></pre></td></tr></table></figure><p>先形成3个.o文件，最后在链接形成可执行</p><p>如果我们想把自己的代码给别人用</p><ol><li>提供源代码+头文件</li><li>只提供.o文件也可以链接，所以库的思想：就是把所有的.o打包就是库了</li></ol><h2 id="打包成一个库"><a href="#打包成一个库" class="headerlink" title="打包成一个库"></a>打包成一个库</h2><blockquote><ol><li>所有的源代码要先被编译成为.0文件（可重定向文件）</li><li>制作动静态库的本质就是将所有.0打包好，使用ar 或者gcc来打包</li><li>交付： inlcude + .a or .so文件</li></ol></blockquote><p>ar (类比tar)<br>-rc（replace and creat）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">libmymath.a:sub.o add.o<br>ar -rc $@ $^  <span class="hljs-comment">//把所有的.o文件都打包成一个静态库</span><br>%.o:%.c<br>gcc -c $&lt;   <span class="hljs-comment">//把所有的.c都展开成.o文件</span><br><br></code></pre></td></tr></table></figure><p>查看静态库中的内容<br><img src="https://img-blog.csdnimg.cn/a8025134a69b4ee7bddf15caef9cc525.png" alt="在这里插入图片描述"></p><p>我们可以查看c标准静态库中的内容都是.o<img src="https://img-blog.csdnimg.cn/d1e53d5525494de9bd47a8604fe0672d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>这样我们就把我们自己的源文件都隐藏起来<br>别人想要用我们的库，就还需要一些头文件，因为二进制根本看不懂<br>所以我们可以发布一个output</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">PHONY:output</span><br><span class="hljs-section">output:</span><br>mkdir output <br>cp -rf *.h output <br>cp libmymath.a output<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b625bbcd22b34644b9af0a3a746542b0.png" alt="在这里插入图片描述"><br>头文件和库文件都在</p><h2 id="使用自己的库"><a href="#使用自己的库" class="headerlink" title="使用自己的库"></a>使用自己的库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;add.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;sub.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> y=<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y1=add(x,y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y1=%d&quot;</span> ,y1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ gcc demo.c -I./output -L./output -lmymath<br></code></pre></td></tr></table></figure><p>这样编译才可以<br>-I 指明，我们要使用知名头文件搜索路径<br>-L 指明：我们要指明库文件的搜索路径<br>-l 指明：我们要链接那一个库</p><blockquote><p>我们之前写的代码，也用了库，为什么就没有指明选项呢？？<br>之前的库，在系统的默认路径下，&#x2F;lib64，&#x2F;user&#x2F;lib,&#x2F;user&#x2F;include等<br>编译器是能够识别这些路径的，</p></blockquote><blockquote><p>换一句话说我们如果想不添加这些选项，我是不是可以把对应的库和头文件，拷贝到默认的路径之下<br>没有问题的，这也就是一般软件的安装过程</p></blockquote><p>我们给别人交付的其实就是一个库文件+ 一套头文件</p><h3 id="形成动态库"><a href="#形成动态库" class="headerlink" title="形成动态库"></a>形成动态库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">libmymath.so:add.o sub.o<br>gcc -shared -o $@ $^ <br>%.o:%.c<br>gcc -fPIC -c $&lt;<br><br>.PHONY:clean<br>clean:<br>rm -f libmymath.so<br>.PHONY:lib <br>lib:<br>mkdir lib<br>cp *.h lib<br>cp libmymath.so lib<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/49c2a159e5f54059bfed4b2b20c79d8b.png" alt="在这里插入图片描述"><br>编译使用的方法和静态库一样的<br>我们在加载的时候，还要进一步高树系统，我们的库在哪里，因为动态库我们编译的时候需要，不编译的时候就不需要，不像静态库是一次性直接拷贝进去，在编译的时候就不需要去考虑库在哪里</p><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ gcc x.c  -o x -I./lib -L./lib -lmymath <br></code></pre></td></tr></table></figure><p>导入环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">export LD_LIBRARY_PATH=/home/xvzewen/githubgovern/Linuxstudy/link/friend/lib<br><br></code></pre></td></tr></table></figure><p>执行<br>.&#x2F;x<br>为什么我们之前写所有的代码都没有报错呢？？</p><blockquote><p>默认情况下我们都是动态的，因为我们一定有动态库！，因为我们linux很多都是用c语言写的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux c语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统与inode</title>
    <link href="/2022/04/19/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8Einode/"/>
    <url>/2022/04/19/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8Einode/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#inode_39">inode</a></li><li><a href="#bitmap_55">bitmap</a></li><li><a href="#inode_68">inode操作</a></li><li><a href="#_104">软硬链接</a></li></ul><p>文件&#x3D;文件内容+文件属性<br>一个文件没有被打开。那么这个文件就在磁盘里面存放着</p><p>磁盘是：我们计算机中的一个机械设备（SSD，FLASH卡，USB）<br><img src="https://img-blog.csdnimg.cn/3dc9d2be1fe748d09c1d3f5d7affc145.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>扇区：同心园中一道一道的以小块区域，<br>磁道：每一快同心园<br>柱面：半径相同的扇形围起来构成的一圈<br>磁盘写入的基本单位：扇区！ 512字节<br>定位方式：<br>可以把磁盘想象成线性结构，</p><p><img src="https://img-blog.csdnimg.cn/dd61dac99b58438d83f51b9715c63487.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>LBA可以理解为数组的下标，访问地址，如果我们要写到物理地址，我们就要转换成为物理地址<br>类比（虚拟地址和物理地址）</p><p>大磁盘管理成本就非常高<br>先要把磁盘划分成一个有一个的小区域<br><img src="https://img-blog.csdnimg.cn/dcef41ad278f477fbd6c397aa04ce91d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li><strong>分区</strong>：磁盘中就是分区（C盘D 盘），新加卷，把大盘分解成好几个盘（大磁盘变成小空间）</li><li><strong>格式化</strong>：：分区写入文件系统： 类比我们给每个省，写入省政府领导班子，（格式化）—》更换领导班子，（更换文件系统）</li></ol><p>Linux特有的ext系列的文件系统<br><img src="https://img-blog.csdnimg.cn/154e1750601c4fbe979fe28dbf6265a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>super block：里面存放的是每个空间的使用情况，是描述整个分区的相关文件系统信息（可以理解为做了一个备份），避免其他的super block坏掉</li><li>group describe table: 描述组的情况，inode bitmap和data bitmap中使用的情况，没有用多少，</li></ul><p>一个文件包含文件数据和文件属性，<br><strong>data block</strong>里面存放的就是文件数据（4kb）<br><strong>inode block</strong>里面存放的就是文件的属性（512b）<br>inode都被存放在了inode table里面</p><blockquote><p>要让inode和block先关联才方便我们去查找，而我们在Linux里面利用文件名操作，在操作系统角度是毫无意义的，操作系统是通过inode的编号，因为一个文件一个inode</p></blockquote><h1 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h1><p>我们可以通过inode的编号找到文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span><br><span class="hljs-class"> &#123;</span><br><span class="hljs-comment">//文件的所有属性(文件大小,文件权限,文件的拥有者,所属组,文件的编号inode)</span><br><span class="hljs-comment">//数据信息  int inode number</span><br><span class="hljs-comment">//int block[32]//用数组的方式把和inode关联的写到inode里面</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>找到一个文件的inode就可以找到他的所有属性,<br>block是通过映射关系找到器对应的数据块</p><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>位图<br>block bitmap<br>inode bitmap<br>00001010<br>从右向左:<br>比特位的位置含义:inode 编号<br>比特位内容含义: 特定的inode是否有被占用,</p><p>将inode bitmap加载到内存中,找到一个没有被使用的inode(使用位操作)找到里面为0的位置,将其使用<br>同理对于,block bitmap(对数据块的使用情况,未进行数据的申请释放,遍历5个为0 的位置,在填如到inode里面)</p><h1 id="inode操作"><a href="#inode操作" class="headerlink" title="inode操作"></a>inode操作</h1><p>目录是文件吗</p><blockquote><p>目录是文件,他也是有inode,里面的文件大小,权限,所有人,所属组也都是有的,同样,目录也是有数据的</p></blockquote><blockquote><p>目录中的数据存放这将目录中的文件名映射到对应inode编号,我们创建的文件一定是在特定的目录当中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">touch a<br>echo hello &gt; a<br>cat a<br></code></pre></td></tr></table></figure><p>这一系列的操作</p><ol><li>我们通过inode bitmap找到未被使用的位,inode</li><li>我们再把文件的相关信息全都存放进去</li><li>写入: 再block bitmap里面看未被使用的block,建立映射关系,把数据写入到相应的块中</li><li>查看: 再当前目录下,把hello.c和新的inode的映射关系查找到,查找到相应的文件</li></ol><p>假如我们mkdir demo<br>在里面查找inode&#x3D;1234的hello.c<br>我们通过inode把数据映射到当前路径之下,</p><p>维护1234的inode的hello.c的映射关系—&gt; 找到inode&#x3D;1234—-&gt; 在inode table里面找到对应的inode --&gt; 就可以找到了对应的block 数据块—&gt;再打印文件内容</p><p>然而<br>rm hello.c并不是按照上述流程来操作的<br>他不需要inode table 将上述的操作把inode bitmap给清掉 即可<br>把所有的数据块清掉<br>(属性数据和内容数据都还在),—&gt;(恢复文件,把inode bitmap把曾经的位由0置1就可以了,同理block)<br>:rm并不是删除文件的属性和数据,只是把其是否有有效位给置去了</p><blockquote><p>如果我们误操作了，删除了文件，最好的做法是什么？？<br>什么东西都没有，找人</p></blockquote><p>实际上： 我们创建了一个文件，实在inode table里面创建了一个节点，然后再数据区里面，找多个数据块，进行维护，，然后再inode里面数据和属性建立关系</p><h1 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h1><p>软连接相当于一个快捷方式，方便我们查找一个路径</p><ol><li><pre><code class="hljs">创建软链接</code></pre></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ln -s [file] [lname]<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/584d65e5fb55410ca4bf308ccf96c2be.png" alt="在这里插入图片描述"><br>2. 删除链接<br>unlink [链接名]<br><img src="https://img-blog.csdnimg.cn/d04ef57381ca409a919af048b9b31859.png" alt="在这里插入图片描述"><br>软连接是有独立的inode 的<img src="https://img-blog.csdnimg.cn/a53070ecc9174ba384cf588a78e9d55a.png" alt="，"><br>说明他就是一个独立文件，，有自己的属性集合，和数据块，数据块里面保存的是指向文件的所在路径+文件名</p><ol start="3"><li>创建硬链接<br>硬链接本质上就不是一个独立的文件，而是一个文件名和inode编号的<strong>映射关系</strong>，因为自己没有独立的inode，所以就没有所谓的属性数据</li></ol><blockquote><p>创建硬链接，本质是在特定的路径下，填写一对文件名和inode的映射关系，相当于完成了重命名，</p></blockquote><p><img src="https://img-blog.csdnimg.cn/5776b27d6b704869899a351fc33c2d87.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/88b69757bc3645c98c8717a659fc5bcd.png" alt="在这里插入图片描述"></p><p>ref就是有多少个硬链接数<br>建立硬链接数就是ref++，就是叫做引用计数<br>ref&#x3D;0的时候就才把这个文件给删除掉</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux----基础IO</title>
    <link href="/2022/04/14/Linux----%E5%9F%BA%E7%A1%80IO/"/>
    <url>/2022/04/14/Linux----%E5%9F%BA%E7%A1%80IO/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#Cio_2">复习C语言io知识</a></li><li><a href="#_65">学习文件的系统调用接口</a></li><li><a href="#_113">文件描述符</a></li><li><ul><li><a href="#_150">文件与进程</a></li><li><a href="#_202">一切皆文件</a></li><li><a href="#_233">文件描述符的分配规则</a></li></ul></li><li><a href="#write_272">write</a></li><li><a href="#read_307">read</a></li><li><a href="#_335">重定向</a></li><li><ul><li><a href="#dup2_391">dup2</a></li></ul></li><li><a href="#_411">缓冲区</a></li><li><ul><li><a href="#_412">标准输出和标准错误</a></li><li><a href="#_444">缓存区</a></li></ul></li></ul><h1 id="复习C语言io知识"><a href="#复习C语言io知识" class="headerlink" title="复习C语言io知识"></a>复习C语言io知识</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">//FILE* fp=fopen(&quot;./log.txt&quot;,&quot;r&quot;);</span><br>  FILE* fp=fopen(<span class="hljs-string">&quot;./log.txt&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<span class="hljs-comment">//追加，不会覆盖掉</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==fp)<br>  &#123;<br>    perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  &#125;<br>  <span class="hljs-meta">#<span class="hljs-keyword">if</span> </span><br><span class="hljs-comment">//  char buffer[32];</span><br><span class="hljs-comment">//  while(fgets(buffer,sizeof(buffer),fp)!=NULL)</span><br><span class="hljs-comment">//  &#123;</span><br><span class="hljs-comment">//    printf(&quot;%s&quot;, buffer);</span><br><span class="hljs-comment">//  &#125;</span><br><span class="hljs-comment">//  if(!feof(fp))</span><br><span class="hljs-comment">//  &#123;</span><br><span class="hljs-comment">//    printf(&quot;fgets quit not normal\n&quot;);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  &#125;</span><br><span class="hljs-comment">//  else </span><br><span class="hljs-comment">//  &#123;</span><br><span class="hljs-comment">//    printf(&quot;fgets quit normal\n&quot;);</span><br><span class="hljs-comment">//  &#125;</span><br><br>  <span class="hljs-type">int</span> cnt=<span class="hljs-number">10</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg=<span class="hljs-string">&quot;hello &quot;</span>;<br>  <span class="hljs-keyword">while</span>(cnt--)&#123;<br>  <span class="hljs-built_in">fputs</span>(msg,fp);<br>  &#125;<br>  fclose(fp);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C 程序默认会打开3个输出流，stdin，stdout，stderr<br>stdin对应键盘，stdout对应显示器，stderr对应显示器</p><blockquote><p>fputs(msg,stdout);&#x2F;&#x2F;直接向显示器去写入</p></blockquote><p>stdout是向显示器去输出<br>将原本应该显示到显示屏的内容，显示到了文件里面<br>本质是指把stdout的内容重定向到文件中<br><img src="https://img-blog.csdnimg.cn/d86f05bcf2b34305ad2b8250b016c48a.png" alt="在这里插入图片描述"></p><p>把原本应该打印在文件里面的打印在了显示器里面<br><img src="https://img-blog.csdnimg.cn/43766ebd44194c93aa70db11ae7029c0.png" alt="在这里插入图片描述"><br>fputs向一般文件或者硬件设备都能写入<br>磁盘也是硬件<br>同理<br>c++：cin,cout cerr</p><ol><li><p>c语言的一切操作实际上都是在向硬件写入（所有语言上对“文件”的操作都要贯穿操作系统）<br>即最终都是访问硬件，<br><strong>用户行为–&gt;语言，程序，lib–&gt;OS–&gt;驱动–&gt;硬件</strong></p></li><li><p>但是操作系统不相信任何人 ，所以访问操作系统是需要系统调用接口的<br>所以几乎所有的语言fopen，fclose,fread等等的底层一定是使用OS提供的系统调用</p></li></ol><h1 id="学习文件的系统调用接口"><a href="#学习文件的系统调用接口" class="headerlink" title="学习文件的系统调用接口"></a>学习文件的系统调用接口</h1><blockquote><p>离OS更近，更能了解</p></blockquote><p>文件打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br> <span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br> <br></code></pre></td></tr></table></figure><p>pathname就是要打开的路径名，flags就是我们打开的方式，mode就是打开的权限信息，<br>会返回一个文件描述符,int类型<br>flag是整数，：传递标志位，</p><blockquote><p>int:32个bit位，一个bit，就代表一个标志，就代表一个标志位<br>0000 0000,如以最后一个标志位为0还是1,代表是读还是写<br>，以第一个标志位，代表是否创建文件<br>可以传多个，还快</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(O_WRONLY&amp;flag)<br></code></pre></td></tr></table></figure><p>判断结果，所以O_WRONLY O_rdnly O_CREAT<br>这些都是只有一个比特位为1的数据，而且都不重复</p><blockquote><p>#define O_WRONLY 0x1<br>#define O_RDONLY 0x2<br>等等</p></blockquote><p>如果想要得到两个以上的功能，我们直接|就可以了</p></blockquote><p>这就是通过比特位的方式传多组标记的做法</p><p>文件关闭<br><img src="https://img-blog.csdnimg.cn/40733187b9354c3ab233f652d2fbd7af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./lg.txt&quot;</span>,O_WRONLY|O_CREAT);<span class="hljs-comment">//以只写方式打开,如果文件不存在，就会帮助我们创建一个</span><br><span class="hljs-comment">//相当于C语言中的w选项,</span><br><span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<br>&#123;<br>  <span class="hljs-comment">//打开文件失败</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open err\n&quot;</span>);<br>&#125;<br>close(fd);<span class="hljs-comment">//文件就关掉了</span><br></code></pre></td></tr></table></figure><p>我们没有输入第三个参数（权限参数），那么加入不存在这个文件，那么产生的文件的权限是乱的<br><img src="https://img-blog.csdnimg.cn/e48d1bf7d861415d9971fa9040d25d37.png" alt="在这里插入图片描述"></p><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="hljs-number">0644</span>);<span class="hljs-comment">//一次传递两个标志位</span><br><span class="hljs-comment">//以只写方式打开,如果文件不存在，就会帮助我们创建一个</span><br><span class="hljs-comment">//相当于C语言中的w选项,0644以二进制的方式显示权限</span><br><span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<br>&#123;<br>  <span class="hljs-comment">//打开文件失败</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open err\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd:%d\n&quot;</span>,fd);<br>close(fd);<span class="hljs-comment">//文件就关掉了</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4372f3a8e2d8422cab2970bb56dbe8ff.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="hljs-number">0644</span>);<span class="hljs-comment">//一次传递两个标志位</span><br> <span class="hljs-type">int</span> fd1=open(<span class="hljs-string">&quot;./g1.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="hljs-number">0644</span>);<span class="hljs-comment">//一次传递两个标志位</span><br> <span class="hljs-type">int</span> fd2=open(<span class="hljs-string">&quot;./g2.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="hljs-number">0644</span>);<span class="hljs-comment">//一次传递两个标志位</span><br> <span class="hljs-type">int</span> fd3=open(<span class="hljs-string">&quot;./g3.txt&quot;</span>,O_WRONLY|O_CREAT,<span class="hljs-number">0644</span>);<span class="hljs-comment">//一次传递两个标志位</span><br> <span class="hljs-comment">//以只写方式打开,如果文件不存在，就会帮助我们创建一个</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8a09e45ff0d04346b676e6a44bb27647.png" alt="在这里插入图片描述"><br>我们发现是从3开始连续</p><p>文件描述符那么0,1,2去那里了呢</p><blockquote><p>0：标准输入,键盘<br>1：标准输出，显示器<br>2：标准错误，显示器</p></blockquote><blockquote><p>0 1 2 3 4 5 6 7<br>我们可以联想到一个数组的下标</p></blockquote><blockquote><p>open的返回值是OS系统给我们的</p></blockquote><h2 id="文件与进程"><a href="#文件与进程" class="headerlink" title="文件与进程"></a>文件与进程</h2><p>所有的文件操作，表现上都是进程执行对应的函数</p><blockquote><p>进程对文件的操作</p><ol><li>要操作文件必须先<strong>打开文件</strong></li><li><strong>打开文件</strong>的本质：将文件相关的属性信息加载到内存</li><li>系统中会存在大量的进程，进程可以打开多个文件，系统中存在更多的<strong>打开的文件</strong><br>那么OS 要把<strong>打开的文件</strong>管理起来，<br>（先描述再组织）</li></ol><ul><li>如果一个文件没有被打开，没有被创建，那么这个文件就在磁盘上，同理一个<strong>进程</strong>没有被打开，这个进程也在<strong>磁盘</strong>上面</li><li>如果创建了空文件（内容），要不要占磁盘空间呢，但是还有文件的属性，也是数据，，所以也是要占据磁盘空间，<br><strong>磁盘文件&#x3D;文件内容+文件的属性</strong></li></ul></blockquote><p>对文件的操作：</p><ol><li>对文件内容进行操作</li><li>对文件属性进行操作</li></ol><p>管理的思路<br>先描述再组织</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">//包含了打开文件的相关属性信息</span><br><span class="hljs-comment">//链接属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在进程里面有<br>struct task_struct<br>{<!-- --><br>struct files_struct* fs;&#x2F;&#x2F;地址，指向的就是其对应的内容<br>}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_strtuct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span>* <span class="hljs-title">fd_array</span>[];</span><span class="hljs-comment">//指针数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为array是一个指针数组，所以可以用对应的下标找到对应的地址0,1,2<br>相当于fd_array[0]就指向了一个文件</p><p>所以0，1，2分别被标准输入，标准输出，标准错误文件给占用<br>每次生成一个文件，再内存里面就要形成一个struct file结构，在把地址填入到array下标处</p><p>而我们再write和read的时候，都要传入fd</p><ol><li>执行write和read调用的是进程，而进程就能通过自己的PCB 找到对应的fs指针，找到files_struct里面根据文件描述符找到对应的文件，进行相关操作</li></ol><p>fd</p><blockquote><p>本质就是内核中进程和文件关联的数组的下标</p></blockquote><h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><p>一切皆为文件<br>每一个硬件都有其对应的write和read的方法<br><img src="https://img-blog.csdnimg.cn/7a73113f7c10454c929050f818c639af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>虚拟文件，可以类比于多态，使用函数指针，就用指针调用对应的函数，这些函数调用这些硬件对应的方法，<br>多态就是实现一切皆（）的高级方法<br><img src="https://img-blog.csdnimg.cn/c2c476988cd84e60825709b66aa60755.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如我们在上层调用read&#x2F;write的时候，就指向了对应的fd，再指向其对应的方法<br><img src="https://img-blog.csdnimg.cn/8d45a116fccc424cb09fe3faf25343ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fd_Dewrite</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg=<span class="hljs-string">&quot;hello&quot;</span>;<br>    write(<span class="hljs-number">1</span>,msg,<span class="hljs-built_in">strlen</span>(msg));<span class="hljs-comment">//向标准输出去写入</span><br>    write(<span class="hljs-number">1</span>,msg,<span class="hljs-built_in">strlen</span>(msg));<span class="hljs-comment">//向标准输出去写入</span><br>    write(<span class="hljs-number">1</span>,msg,<span class="hljs-built_in">strlen</span>(msg));<span class="hljs-comment">//向标准输出去写入</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们直接向标准输出去书出<br><img src="https://img-blog.csdnimg.cn/24c87b8c2d1a43a0bacf1ef17538ccee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>直接从键盘输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">read(<span class="hljs-number">0</span>,buf,<span class="hljs-keyword">sizeof</span>(buf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//直接从键盘上写入</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;echo :%s&quot;</span>,buf);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3dc1d44a8e7247f6a3292610d5a9e694.png" alt="在这里插入图片描述"></p><h2 id="文件描述符的分配规则"><a href="#文件描述符的分配规则" class="headerlink" title="文件描述符的分配规则"></a>文件描述符的分配规则</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">Fd_Alloc_Base</span><span class="hljs-params">()</span><br>&#123;<br>close(<span class="hljs-number">0</span>);<br>    close(<span class="hljs-number">2</span>);<span class="hljs-comment">//把0对应的标准输入给关闭</span><br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_CREAT|O_WRONLY,<span class="hljs-number">0644</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd=%d \n&quot;</span>,fd);<br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3334ef27554d46788570faf59f0f9f81.png" alt="在这里插入图片描述"><br><strong>分配规则</strong></p><blockquote><p>每次给新文件分配的fd，是从fd_array中找到最小的，没有被使用的，作为新的fd</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">Fd_Alloc_Base</span><span class="hljs-params">()</span><br>&#123;<br>    close(<span class="hljs-number">1</span>);<br>    close(<span class="hljs-number">2</span>);<span class="hljs-comment">//把0对应的标准输入给关闭</span><br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_CREAT|O_WRONLY,<span class="hljs-number">0644</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd=%d \n&quot;</span>,fd);<br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把1的标准输出给关了，<br><img src="https://img-blog.csdnimg.cn/5862bfdbd03f4160923b96ba054cc483.png" alt="在这里插入图片描述"></p><p>没有显示到显示屏中，而是显示到了文件中<br>这就是输出重定向</p><p>原因：我们把1的文件描述符给关了，所以现在给g.txt里面的fd就是1，<br>而printf里面对应的文件的fd一定是1，所以现在g.txt的fd为&#x3D;1，就写到了g.txt</p><p>而printf和fprintf里面的都是有相关的fd，因为操作系统最大，</p><h1 id="write"><a href="#write" class="headerlink" title="write"></a>write</h1><p>功能：向文件描述符写入，在buf的用户缓冲区里面，期望写入cout个字节<br>return：返回的是实际向文件里面写入多少个字节的内容<br><img src="https://img-blog.csdnimg.cn/d73391c9fded40a391f41a1552f4998b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;demo.txt&quot;</span>,O_CREAT|O_WRONLY,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*msg=<span class="hljs-string">&quot;hello \n&quot;</span>;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">while</span>(cnt)<br>    &#123;<br>        write(fd,msg,<span class="hljs-built_in">strlen</span>(msg));<span class="hljs-comment">//我们写入文件的过程中，我们要不要加入\0呢，不需要，</span><br>        <span class="hljs-comment">//因为\0作为字符串的结束标志位，只是c的规定，而文件关心字符串的内容，</span><br>        cnt--;<br>    &#125;<br><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用write写入了5个hello，<br><img src="https://img-blog.csdnimg.cn/b95a0a5239b1424db95268c7c34bdabb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="read"><a href="#read" class="headerlink" title="read"></a>read</h1><p>功能：从文件描述符中读取指定内容，一次读取到的内容，都放到用户层缓冲区中，每次读取count个字节<br>return：如果count是我们期望读多少个字节，返回就是我们实际读取多少个字节<br><img src="https://img-blog.csdnimg.cn/fe6457ab397b43fb8abb6780c90e9f14.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FdRead</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./demo.txt&quot;</span>,O_RDONLY);<span class="hljs-comment">//以读的方式打开不涉及到创建,权限也不要写了</span><br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">ssize_t</span> s=read(fd,buff,<span class="hljs-keyword">sizeof</span>(buff)<span class="hljs-number">-1</span>);<span class="hljs-comment">//-1是因为我们不需要\0</span><br><br>    <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//说明我们读取到了有效的内容</span><br>        <span class="hljs-comment">//因为我们要把读取到的内容当作一个字符串看待，所以要在最结尾添加一个\0,作为字符串结束标志</span><br>        buff[s]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buff);<br>    &#125;<br>    close(fd);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/248173fe5f82407d95c2a6e93685fb0f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>输出重定向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">echo <span class="hljs-string">&quot;hello world&quot;</span>&gt;<span class="hljs-built_in">log</span>.txt<br></code></pre></td></tr></table></figure><p>我们可以理解为把echo的1关掉，在把log打开，再把所有内容打印到里面</p><p>追加重定向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">Fd_Alloc_Base</span><span class="hljs-params">()</span><br>&#123;<br>    close(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// close(2);//把0对应的标准输入给关闭</span><br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="hljs-number">0644</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd=%d \n&quot;</span>,fd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-comment">// close(fd);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只在open的时候把append选项加上去<br>输入重定向<br>就是把原来从键盘里面读入的东西，现在从一个文件里面读<br><img src="https://img-blog.csdnimg.cn/2adcaa30d0244985a17d93f0998d8452.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fd_Redefout</span><span class="hljs-params">()</span><br>&#123;<br>    close(<span class="hljs-number">0</span>);<span class="hljs-comment">//把输入给关掉</span><br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_RDONLY);<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">while</span>(fgets(line,<span class="hljs-keyword">sizeof</span>(line)<span class="hljs-number">-1</span>,<span class="hljs-built_in">stdin</span>))<span class="hljs-comment">//因为现在g.txt的fd为0,所以stdin就是g.txt</span><br>    &#123;<br>        <span class="hljs-comment">//原本应该从键盘读取的内容，现在是从文件里面读取了</span><br>        <span class="hljs-comment">//输入重定向</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,line);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>验证文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Verify_IO</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stdin-&gt; %d&quot;</span>,<span class="hljs-built_in">stdin</span>-&gt;_fileno);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stdout-&gt; %d&quot;</span>,<span class="hljs-built_in">stdout</span>-&gt;_fileno);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stderr-&gt; %d&quot;</span>,<span class="hljs-built_in">stderr</span>-&gt;_fileno);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2c03163e4be84359824382a1ff14261f.png" alt="在这里插入图片描述"></p><h2 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h2><p><img src="https://img-blog.csdnimg.cn/423cb249338647bb97bbf9d6d36b747c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>newfd是oldfd的一份拷贝，数组内容的拷贝，指针的拷贝<br>所以全部变成old，<br>输出重定向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dup2(fd,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>shell中的重定向<br>echo “hello” &gt; file.c<br>fork-&gt;child-&gt;dup2(fd,1)-&gt;exec(“echo,“echo”)</p><p>fork创建之后 子进程也有fd，而且文件描述符和父进程都一样<br>但是打开的那些文件不会新建，因为我们是在创建进程，</p><blockquote><p>如果父进程打开了标准输入，输出，错误，子进程也会继承下去<br>因为bash是所有进程的父进程，而bash打开了标准输入，输出，错误，所以所有的子进程也都继承下去了</p></blockquote><h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><h2 id="标准输出和标准错误"><a href="#标准输出和标准错误" class="headerlink" title="标准输出和标准错误"></a>标准输出和标准错误</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg=<span class="hljs-string">&quot;hello stdout\n&quot;</span>;<br>    write(<span class="hljs-number">1</span>,msg,<span class="hljs-built_in">strlen</span>(msg));<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg2=<span class="hljs-string">&quot;hello stderr\n&quot;</span>;<br>    write(<span class="hljs-number">2</span>,msg2,<span class="hljs-built_in">strlen</span>(msg2));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fd7473564dd042b9ba523cdf969555c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我们发现只有标准输出重定向到了文件里面，但是标准错误仍然打印在屏幕里面了</p><blockquote><p>因为重定向只有fd&#x3D;1的被弄进去，而fd&#x3D;2不会被弄进去</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./redir &gt;<span class="hljs-built_in">log</span>.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>把标准输出和标准错误都重定向进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">$ cat <span class="hljs-built_in">log</span>.txt<br>hello <span class="hljs-built_in">stdout</span><br>hello <span class="hljs-built_in">stderr</span><br></code></pre></td></tr></table></figure><blockquote><p>.&#x2F;redir &gt;log.txt 2&gt;&amp;1<br>先执行前面第一条语句，此时把fd&#x3D;1原本指向显示器改为指向一个特定文件，而fd&#x3D;2的文件原本指向了显示屏，把1里面的内容拷贝到2里面，所以2也指向1指向的文件</p></blockquote><h2 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h2><ol><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg=<span class="hljs-string">&quot;hello stdout\n&quot;</span>;<br>    write(<span class="hljs-number">1</span>,msg,<span class="hljs-built_in">strlen</span>(msg));<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg2=<span class="hljs-string">&quot;hello stderr\n&quot;</span>;<br>    write(<span class="hljs-number">2</span>,msg2,<span class="hljs-built_in">strlen</span>(msg2));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello printf\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>,<span class="hljs-string">&quot;hello fprintf\n&quot;</span>);<br>    close(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fe822a980e8c465b8a307e390c12c7a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第一次可以显示出fprintf<br>close后，第二次不能输出这些内容</p><ol start="2"><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">Fd_Alloc_Base</span><span class="hljs-params">()</span><br>&#123;<br>    close(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// close(2);//把0对应的标准输入给关闭</span><br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="hljs-number">0644</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd=%d \n&quot;</span>,fd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-comment">// close(fd);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>把fd关闭之后就没有显示内容了</p><blockquote><p>c语言本身也<br>我们曾经说的缓冲区都是用户级缓冲区，都是语言层面<br>printf是向stdout写入（FILE*）–》（struct file)<br>我们使用printf和fprintf，我们并没有写到OS里面，而是写到c语言缓冲区，把c语言的缓存区刷新到操作系统，</p></blockquote><p><img src="https://img-blog.csdnimg.cn/e0f7135cdddb406ea8787cd343b577dc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我们在特定的情况下才会把数据刷新到内核缓冲区，</p><ol><li>遇到\n的时候，会刷新到显示器上面，</li><li>进程退出的时候，会刷新FILE 内部的数据到OS，没有进程退出的时候数据还会在C缓冲区里面，</li></ol><p>用户——&gt;OS</p><blockquote><p>刷新策略</p><ol><li>立即刷新（不缓冲）</li><li>行刷新（行缓冲\n）：如显示器打印，</li><li>全缓冲区满了才刷新(也就是不会溢出)，比如，往磁盘文件里面写入</li></ol></blockquote><p>OS—&gt; 硬件，也是同样使用的</p><p>如果发生了重定向，<br>显示器 --&gt; log.txt</p><blockquote><p>原本是行刷新（行缓冲），现在就变成了全缓冲</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <span class="hljs-title function_">Fd_Alloc_Base</span><span class="hljs-params">()</span><br>&#123;<br>    close(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// close(2);//把0对应的标准输入给关闭</span><br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;./g.txt&quot;</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="hljs-number">0644</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd=%d \n&quot;</span>,fd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-comment">// close(fd);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个代码</p><blockquote><p>如果不close的话，所有的信息都打印到了文件当中</p><blockquote><p>没有close的话，所有的消息都直接输出到了c语言缓冲区里面，然后因为没有close掉fd，这批数据就会在进程退出的时候，数据就会刷新到内核，</p></blockquote><p>把close放开，文件里面什么都没有，</p><blockquote><p>所有的消息，刷新变成了全缓冲，有可能并没有被写满，说明可能没有立即被刷新到文件里头，而进程退出之前调用了close，就把文件描述符给关了，进程退出的时候数据还在缓冲区里面，<strong>来不及刷新</strong>到内核当中，所以文件里面就没有看到对应的内容</p></blockquote><p>如果把close（1）关掉，那么printf把数据都刷新到用户缓冲区里头，行刷新，立马刷新了</p></blockquote><p>如果在close之前<br>fflush（stdout），强制刷新缓冲区里面，就可以了写到文件里面了，</p><p><strong>FILE*里面是有包含缓冲区的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;hello stdout\n&quot;</span>;<br>    write(<span class="hljs-number">1</span>, msg, <span class="hljs-built_in">strlen</span>(msg));<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg2 = <span class="hljs-string">&quot;hello stderr\n&quot;</span>;<br>    write(<span class="hljs-number">2</span>, msg2, <span class="hljs-built_in">strlen</span>(msg2));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello printf\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;hello fprintf\n&quot;</span>);<br>    close(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f2c2a61da41a4436b4b4dc935804780c.png" alt="在这里插入图片描述"><br>我们发现我们即使close(1),仍然能够打印在显示屏上，因为三行刷新，有\n就刷新了</p><blockquote><p>我们把内容重定向到文件里面，<br>发现只有write的1被写进去了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20669ce307064e1d8e97980962011270.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7aa9920a748a4a0bbe156df21e8ae9b1.png" alt="在这里插入图片描述"><br>这是因为我们close（1），当重定向的时候原本要写到1里面的内容，显示到文件中，就从行刷新，变成了全缓冲，不立即刷新，而write是系统调用没有经过c语言缓冲区，就可以打印到文件里面，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;hello stdout\n&quot;</span>;<br>    write(<span class="hljs-number">1</span>, msg, <span class="hljs-built_in">strlen</span>(msg));<br>    <span class="hljs-comment">// const char *msg2 = &quot;hello stderr\n&quot;;</span><br>    <span class="hljs-comment">// write(2, msg2, strlen(msg2));</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello printf\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;hello fprintf\n&quot;</span>);<br>    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;hello puts\n&quot;</span>,<span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-comment">// close(1);</span><br><br>    fork();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4cc7ba0ed97849f5bfa46663a59ff733.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmV2aW4uLg==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我们如果2往显示器上打印，大家都正常，如果往文件里面打印，c接口会重复，系统接口不受影响<br>刷新策略变了，<br>写入文件里面的时候，就变成了全缓冲，数据就先写到了c语言缓冲区里面（不是操作系统提供的），</p><blockquote><p>fork之后发生了写时拷贝，父进程写到了缓冲区里面，子进程也刷新到了缓冲区里面，当副进程退出的时候，就把数据i刷新出去，子进程也要刷新，所以因为写实拷贝的问题，出现了重复刷新</p></blockquote><p>而如果在fork之前就把数据全部fflush出去的话，fork之后就不会发生写实拷贝，因为缓冲区里面没有数据了，可是write没有打印两个，</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL中string类的模拟实现</title>
    <link href="/2022/04/04/STL%E4%B8%ADstring%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/04/04/STL%E4%B8%ADstring%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">namespace</span> xzw<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span> *_str;<br>        <span class="hljs-type">size_t</span> _size;<br>        <span class="hljs-type">size_t</span> _capacity;              <span class="hljs-comment">//能存有效字符的空间个数，不算上\0</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> npos = <span class="hljs-number">-1</span>; <span class="hljs-comment">//静态成员变量属于整个类域</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// string()//构造一个空字符串</span><br>        <span class="hljs-comment">//     :_str(new char[1])</span><br>        <span class="hljs-comment">//     ,_size(0)</span><br>        <span class="hljs-comment">//     ,_capacity(0)//存0个有效，</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     _str[0]=&#x27;\0&#x27;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">//string::npos=-1;//整形的最大值</span><br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *iterator;             <span class="hljs-comment">//迭代器，指针类型，内嵌类型，就是在类里面定义的类型,普通迭代器</span><br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *const_iterator; <span class="hljs-comment">//只可以读，不可以写</span><br><br>        <span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//解引用之后那个内容是不可以修改的，const对象</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str;<br>        &#125;<br>        <span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str + _size;<br>        &#125;<br>        <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str; <span class="hljs-comment">//返回第一个位置的地址</span><br>        &#125;<br>        <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str + _size; <span class="hljs-comment">//最后一个地址的下一个位置</span><br>        &#125;<br><br>        <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">//构造函数，我们可以给一个全缺省</span><br>            <span class="hljs-comment">//: _str(str)//不能这样写，因为我们要能够动态的扩容</span><br>            : _size(<span class="hljs-built_in">strlen</span>(str)), _capacity(_size)<br>        &#123;<br>            _str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_capacity + <span class="hljs-number">1</span>]; <span class="hljs-comment">//增容就是相等的时候就扩容,+1是为了使字符串保护\0</span><br>            <span class="hljs-built_in">strcpy</span>(_str, str);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">c_str</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _str;<br>        &#125;<br>        <span class="hljs-comment">//传统写法--本本分分的去开空间拷贝数据</span><br>        <span class="hljs-comment">// string(const string &amp;s) //传引用拷贝</span><br>        <span class="hljs-comment">//     : _size(s._size), _capacity(s._capacity)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     _str = new char[_capacity + 1];</span><br>        <span class="hljs-comment">//     strcpy(_str, s._str);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// //assign，赋值运算符</span><br>        <span class="hljs-comment">// string &amp;operator=(const string &amp;s) //我们也要自己写，不然就是浅拷贝，还要考虑自己给自己赋值</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     //如果自己给自己赋值，要拷贝的东西被我们毁掉，就没办法操作了</span><br>        <span class="hljs-comment">//     // if (this!=&amp;s)</span><br>        <span class="hljs-comment">//     // &#123;</span><br>        <span class="hljs-comment">//     //     delete[] _str; //直接简单粗暴的把原来的空间给释放调，,我们不能把s给释放调，说不定以后还会用到s的数据，有可能new失败</span><br>        <span class="hljs-comment">//     //     //先把原来的空间给释放调，再重新开辟一块空间</span><br>        <span class="hljs-comment">//     //     _str = new char[strlen(s._str) + 1];//开一个和s一样大的空间，</span><br>        <span class="hljs-comment">//     //     strcpy(_str, s._str);</span><br>        <span class="hljs-comment">//     // &#125;</span><br>        <span class="hljs-comment">//     if (this != &amp;s)</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         char *tmp = new char[s._capacity+1];</span><br>        <span class="hljs-comment">//         strcpy(tmp, s._str); //先拷贝再释放掉</span><br>        <span class="hljs-comment">//         delete[] _str;       //</span><br><br>        <span class="hljs-comment">//         _str = tmp;</span><br>        <span class="hljs-comment">//         _size = s._size;</span><br>        <span class="hljs-comment">//         _capacity = s._capacity;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//     return *this; //出了作用于*this还在，所以传引用返回</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">//现代写法---投机取巧的方式去实现深拷贝</span><br>        <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string &amp;s)<br>            : _str(<span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//tmp交换后指向空，delete 空是不会报错的</span><br>              ,<br>              _size(<span class="hljs-number">0</span>), _capacity(<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s._str)</span></span>; <span class="hljs-comment">//是一种代码复用行为</span><br>            <span class="hljs-built_in">swap</span>(_str, tmp._str);<br>            <span class="hljs-built_in">swap</span>(_size, tmp._size);<br>            <span class="hljs-built_in">swap</span>(_capacity, tmp._capacity);<br>        &#125;<br><br>        <span class="hljs-comment">// string operator=(const string&amp; s)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     if(this!=&amp;s)</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         string tmp(s);//调用一个拷贝构造</span><br>        <span class="hljs-comment">//         swap(_str,tmp._str);//出了作用域，tmp现在是s的地址，出了作用域还帮助s把空间给释放掉</span><br><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//     return *this;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// void Swap(string &amp;s)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     swap(_str, s._str); //所有类的赋值都可以这样做</span><br>        <span class="hljs-comment">//     string tmp(s._str); //是一种代码复用行为</span><br>        <span class="hljs-comment">//     swap(_size, s._size);</span><br>        <span class="hljs-comment">//     swap(_capacity, s._capacity);</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">//提倡</span><br>        string <span class="hljs-keyword">operator</span>=(string s) <span class="hljs-comment">//使用拷贝构造，没有用引用传参,s就是原来的拷贝</span><br>        &#123;<br>            <span class="hljs-built_in">swap</span>(_str, s._str); <span class="hljs-comment">//所有类的赋值都可以这样做</span><br>            <span class="hljs-comment">//string tmp(s._str); //是一种代码复用行为</span><br>            <span class="hljs-built_in">swap</span>(_size, s._size);<br>            <span class="hljs-built_in">swap</span>(_capacity, s._capacity);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        string <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s)<br>        <br>        &#123;<br>            _str=<span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s)</span></span>;<br>            <span class="hljs-built_in">swap</span>(tmp._str,_str);<br>            <span class="hljs-built_in">swap</span>(_size,tmp._size);<br>            <span class="hljs-built_in">swap</span>(_capacity,tmp._capacity);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        ~<span class="hljs-built_in">string</span>() <span class="hljs-comment">//析构函数</span><br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] _str; <span class="hljs-comment">//new完之后就要delete</span><br>            _str = <span class="hljs-literal">nullptr</span>;<br>            _size = _capacity = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//遍历string,const在后面，则this的东西都不能够修改</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> _size;<br>        &#125;<br>        <span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-comment">//重载，返回其引用</span><br>        &#123;<br>            <span class="hljs-built_in">assert</span>(pos &lt; _size);<br>            <span class="hljs-keyword">return</span> _str[pos]; <span class="hljs-comment">//出了作用域，还存在,并且我们能够对其进行修改，this的东西发生了修改</span><br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span> <span class="hljs-comment">//重载,const变量，不可以改变</span><br>        &#123;<br>            <span class="hljs-comment">//判断是否出了范围</span><br>            <span class="hljs-built_in">assert</span>(pos &lt; _size);<br>            <span class="hljs-keyword">return</span> _str[pos]; <span class="hljs-comment">//const修饰都不能改变</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> <span class="hljs-comment">//对容量进行一个改变,给一个小于capacity的数值，不会对容量有影响</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//n代表实际的空间</span><br>            <span class="hljs-keyword">if</span> (n &gt; _capacity)<br>            &#123;<br>                <span class="hljs-comment">//空间不够</span><br>                <span class="hljs-type">char</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">//容量到n要对\0多开一个</span><br>                <span class="hljs-built_in">strcpy</span>(tmp, _str);<br>                <span class="hljs-keyword">delete</span>[] _str; <span class="hljs-comment">//把原来的空间销毁掉</span><br>                _str = tmp;<br>                _capacity = n;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> <span class="hljs-comment">//尾插</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (_size == _capacity) <span class="hljs-comment">//满了就要增容</span><br>            &#123;<br>                <span class="hljs-comment">//增容</span><br>                <span class="hljs-built_in">reserve</span>(_capacity == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span> : _capacity * <span class="hljs-number">2</span>);<br>            &#125;<br>            _str[_size] = ch;<br>            _size++;<br>            _str[_size] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//</span><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;\0&#x27;</span>)</span> <span class="hljs-comment">//改变容量的同时对未有的东西进行初始化，已经有东西就不用初始化</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//如果n小于size的话,容量不改变，,但是字符串也要减小</span><br>            <span class="hljs-keyword">if</span> (n &lt; _size) <span class="hljs-comment">//只保留前n个字符</span><br>            &#123;<br>                _str[n] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//在n的位置设置为\0</span><br>                _size = n;      <span class="hljs-comment">//同时将</span><br>                <span class="hljs-comment">//在</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_size &lt; n &amp;&amp; _capacity &gt; n) <span class="hljs-comment">//size小,容量大，就不用扩容</span><br>            &#123;<br>                <span class="hljs-type">int</span> rest = n - _capacity;<br><br>                <span class="hljs-keyword">while</span> (rest--)<br>                &#123;<br>                    <span class="hljs-built_in">push_back</span>(ch);<br>                &#125;<br>                <span class="hljs-comment">//memset(_str+_size,ch,n-_size);//这样也可以</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_size &lt; n &amp;&amp; _capacity &lt; n) <span class="hljs-comment">//size小，容量小，也需要扩容</span><br>            &#123;<br>                <span class="hljs-type">int</span> rest = n - _capacity;<br>                <span class="hljs-built_in">reserve</span>(n);<br>                <span class="hljs-keyword">while</span> (rest--)<br>                &#123;<br>                    <span class="hljs-built_in">push_back</span>(ch);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//reserve(n);</span><br>            <span class="hljs-comment">//dui</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> <span class="hljs-comment">//不能直接常数个的去扩容，扩容可能还是不太够用</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//计算实际的空间</span><br>            <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(str);<br><br>            <span class="hljs-keyword">if</span> (_size + len &gt; _capacity) <span class="hljs-comment">//天然考虑一个\0</span><br>            &#123;<br>                <span class="hljs-comment">//就要扩容</span><br>                <span class="hljs-built_in">reserve</span>(_size + len);<br>            &#125;<br>            <span class="hljs-built_in">strcpy</span>(_str + _size, str); <span class="hljs-comment">//从原来\0位置开始往后拷贝，\0也会自动拷贝进去</span><br>            _size += len;<br>        &#125;<br>        string &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)<br>        &#123;<br>            <span class="hljs-comment">//this-&gt;append(str);</span><br>            <span class="hljs-built_in">append</span>(str);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        string &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> ch)<br>        &#123;<br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">push_back</span>(ch);<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> <span class="hljs-comment">//返回第一次出现时候的位置，不存在就返回一个npos，</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _size; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (_str[i] == ch)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> npos;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-comment">//查找一个字符串,从pos位置开始找</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">strstr</span>(_str + pos, s); <span class="hljs-comment">//找不到就返回一个nillptr，找到了就返回第一次在s里面出现的位置的指针</span><br>            <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> npos;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> ptr - _str; <span class="hljs-comment">//和第一个位置相减就可以得到他的下标</span><br>        &#125;<br>        <span class="hljs-function">string &amp;<span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">char</span> ch)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">assert</span>(pos &lt;= _size); <span class="hljs-comment">//必须三小于size</span><br>            <span class="hljs-keyword">if</span> (_size == _capacity)<br>            &#123;<br>                <span class="hljs-built_in">reserve</span>(_capacity == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span> : _capacity * <span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-comment">//从后往前挪动</span><br>            <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span>) <span class="hljs-comment">//头插</span><br>            &#123;<br>                <span class="hljs-comment">//用指针</span><br><br>                string s;<br>                s += ch;<br>                s += _str;<br>                <span class="hljs-built_in">swap</span>(s._str, _str); <span class="hljs-comment">//交换之后s直接去调用他的稀构函数，就会把s原来的空间给释放掉</span><br>                _size++;<br>                <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">size_t</span> end = _size + <span class="hljs-number">1</span>; <span class="hljs-comment">//为了解决那个问题，我们可以让end=size+1</span><br>                <span class="hljs-keyword">while</span> (end &gt; pos)       <span class="hljs-comment">//end会越界，一个超大的数值，但是因为pos还是一个无符号数的比较，只要有一方是无符号数，就会按照无符号数进行比较,通常往范围大的提升</span><br>                &#123;<br>                    _str[end] = _str[end - <span class="hljs-number">1</span>];<br>                    end--;<br>                &#125;<br>                <span class="hljs-comment">//插入</span><br>                _str[pos] = ch;<br>                _size++;<br>                _str[_size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">string &amp;<span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(s);<br>            <span class="hljs-keyword">if</span> (len + _size &gt; _capacity)<br>            &#123;<br>                <span class="hljs-built_in">reserve</span>(len + _capacity);<br>            &#125;<br>            <span class="hljs-comment">//数据全部都往后挪动</span><br>            <span class="hljs-type">size_t</span> end = _size + len; <span class="hljs-comment">//为了解决那个问题，我们可以让end=size+1</span><br>            <span class="hljs-keyword">while</span> (end &gt;= pos+len)         <span class="hljs-comment">//end会越界，一个超大的数值，但是因为pos还是一个无符号数的比较，只要有一方是无符号数，就会按照无符号数进行比较,通常往范围大的提升</span><br>            &#123;<br>                <span class="hljs-comment">//&gt;pos会出现越界的情况</span><br>                _str[end] = _str[end - len];<br>                end--;<br>            &#125;<br>            <span class="hljs-comment">//插入</span><br>            <span class="hljs-built_in">strncpy</span>(_str+pos,s,len);<span class="hljs-comment">//拷贝len个字符过去,不能带\0,从_str+pos的位置从s里面拷贝len个字符</span><br>            _size+=len;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos,<span class="hljs-type">size_t</span> len=npos)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">assert</span>(pos&lt;_size);<br>            <span class="hljs-type">size_t</span> rest=_size-pos;<br>            <span class="hljs-keyword">if</span>(len==npos||len&gt;=rest)<br>            &#123;<br>                <span class="hljs-comment">//有多少删除多少</span><br>                _str[pos]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>                _size=pos;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">strncpy</span>(_str+pos,_str+pos+len,_size-pos-len);<br>                _str[pos+len]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>                _size=pos+len;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;       <br>    &#125;;<br>    ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;out,<span class="hljs-type">const</span> string&amp; s)<span class="hljs-comment">//带返回值，为了连续的访问</span><br>    &#123;   <br>        <span class="hljs-comment">//ostream//可以支持输出库的内置类型，可以也可以自动识别类型</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s)<span class="hljs-comment">//没有\0</span><br>        &#123;<br>            out&lt;&lt;ch;<span class="hljs-comment">//把每个字符输出出来，</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> out;<br>        <span class="hljs-comment">//out&lt;&lt;s.c_str();不能这样输出，这个是有\0</span><br>        <br><br>    &#125;<br>    istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp;in,string &amp;s)<br>    &#123;<br>        <span class="hljs-comment">//获取每个字符</span><br>        <span class="hljs-type">char</span> ch=in.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">while</span>(ch !=<span class="hljs-string">&#x27; &#x27;</span>||ch!=<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            s+=ch;<br>            ch=in.<span class="hljs-built_in">get</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> in;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello &quot;</span>)</span></span>;<br>        <span class="hljs-comment">//string s2(s);//拷贝构造,对默认类型会完成数值拷贝，浅拷贝，指向同一块空间，出了作用域，调用释放函数，自定义类型，调用他的拷贝构造</span><br>        <span class="hljs-comment">//我们不能在同一块空间</span><br>        <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s)</span></span>;<br>        <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;hello &quot;</span>)</span></span>;<br>        s = s3; <span class="hljs-comment">//如果我们不写就是浅拷贝，连着地址一起拷贝过去了，s内存还没有释放，内存泄漏</span><br>        <span class="hljs-comment">//我们不能直接去拷贝，因为可能会出现空间不够，导致还要去进一步的扩容，小拷贝到大，会导致空间用不完，</span><br>        s = <span class="hljs-string">&quot;alcd&quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sdahello,world a\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br><br>        string s1;                  <span class="hljs-comment">//不带参数</span><br>        cout &lt;&lt; s.<span class="hljs-built_in">c_str</span>() &lt;&lt; endl;  <span class="hljs-comment">//c形式的输出，</span><br>        cout &lt;&lt; s1.<span class="hljs-built_in">c_str</span>() &lt;&lt; endl; <span class="hljs-comment">//遇到\0就结束,\0是不可见的字符</span><br>        s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>        s[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;g&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br><br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string3</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>        string::iterator it = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (it != s.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            *it += <span class="hljs-number">2</span>;<br>            it++;<br>        &#125;<br>        it = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (it != s.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            it++;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : s) <span class="hljs-comment">//编译之后就被自动替换成迭代器</span><br>        &#123;<br>            cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string4</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;@&#x27;</span>);<br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;j&#x27;</span>);<br>        s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;hellllo worlldddd&quot;</span>);<br>        string s1;<br>        s1 += <span class="hljs-string">&#x27;f&#x27;</span>;<br>        s1 += <span class="hljs-string">&quot;hfih&quot;</span>;<br>        cout &lt;&lt; s1.<span class="hljs-built_in">c_str</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string5</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;abcdefg&quot;</span>)</span></span>;<br>        s.<span class="hljs-built_in">resize</span>(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br>        <span class="hljs-type">size_t</span> pos = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;cd&quot;</span>);<br>        cout &lt;&lt; pos &lt;&lt; endl;<br>        s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;l&#x27;</span>);<br>        s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;abdh&quot;</span>);<span class="hljs-comment">//尽量少用insert，0（n）</span><br>        cout &lt;&lt; s.<span class="hljs-built_in">c_str</span>() &lt;&lt; endl;<br>        s.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);<br>        cout &lt;&lt; s.<span class="hljs-built_in">c_str</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string6</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        string s=<span class="hljs-string">&quot;hello&quot;</span>;<br>        s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,详情<span class="hljs-string">&quot;ab&quot;</span>);<br>        <span class="hljs-comment">//s.erase(1,2);//把2位置后面的东西全部都删除掉</span><br>        cout&lt;&lt;s.<span class="hljs-built_in">c_str</span>()&lt;&lt;endl;<br>        string s2;<br>        cin&gt;&gt;s2;<br>        cout&lt;&lt;s2&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//浅拷贝的问题：</span><br><span class="hljs-comment">//1.会稀构两次</span><br><span class="hljs-comment">//2.其中一个对象进行修改会影响另一个，</span><br><span class="hljs-comment">//3.</span><br><br><span class="hljs-comment">//引用计数的写时拷贝</span><br><span class="hljs-comment">//当有两个对象指向同一块空间的时候，计数为2,如果有一个对象要西沟，发现不是1,就减引用计数，为1的时候，再去西沟</span><br><span class="hljs-comment">//不写的时候，就都不去改变，如果写的话才要去做深拷贝，延迟拷贝</span><br><br><span class="hljs-comment">//inser erase 的先查看引用计数，不是1,才要去做生拷贝，再去修改</span><br><span class="hljs-comment">//如果不写就只是增加引用计数，不进行深拷贝，提高效率</span><br><br><span class="hljs-comment">//缺陷：引用计数存在线程安全问题，在多线程环境下要付出代价，在动态库，静态库中有些场景会存在问题</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/zevin02/governcode/tree/master/STL/stl/string/mystring">string模拟实现的代码详情</a></p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ visual studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程——控制进程</title>
    <link href="/2022/03/31/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B/"/>
    <url>/2022/03/31/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">进程创建</a></li><li><ul><li><a href="#fork_2">fork</a></li><li><ul><li><a href="#_10">写时拷贝</a></li></ul></li></ul></li><li><a href="#_17">进程终止</a></li><li><ul><li><a href="#_19">进程退出场景</a></li><li><ul><li><a href="#_40">错误的退出码</a></li><li><a href="#_60">代码异常终止</a></li></ul></li><li><a href="#_64">进程常见退出方法</a></li><li><a href="#_114">进程等待</a></li><li><ul><li><a href="#_115">进程等待是什么？</a></li><li><a href="#_119">为什么要让父进程等待呢</a></li><li><a href="#_127">进程等待的方法</a></li><li><ul><li><a href="#wait_128">wait</a></li><li><a href="#waitpid_183">waitpid</a></li><li><ul><li><a href="#_224">阻塞等待</a></li></ul></li><li><a href="#_233">非阻塞等待</a></li></ul></li></ul></li></ul></li></ul><h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>进程调用fork，当控制转移到内核中的fork代码后，内核做：</p><blockquote><ul><li>分配新的<strong>内存块</strong>和<strong>核心数据结构</strong>给子进程<br>(<strong>进程PCB</strong>，<strong>进程地址空间</strong>，<strong>页表</strong>，<strong>构建映射关系</strong>)</li><li>将父进程部分数据结构内容拷贝至子进程</li><li>添加子进程到<strong>系统列表</strong>当中</li><li>fork返回后，开始调度器调度</li></ul></blockquote><h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p><img src="https://img-blog.csdnimg.cn/b1fd4dbd85f54597b78b31f866201391.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>页表中需要有2^32个地址需要映射，如果页表每一部分6字节<br>则一共需要24GB</p><blockquote><p>缺页中断：父子当中突然改变了数据，OS就发生了中断，但是之前那个空间是共享的，OS就开辟了一个空间，把老的空间给拷过来，OS重新修改了页表，映射关系，把只读选项给去掉了，保持进程的独立性<br>有了写时拷贝，就能保证父子进程数据的独立性</p></blockquote><h1 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h1><p>把进程开辟的东西都释放掉</p><h2 id="进程退出场景"><a href="#进程退出场景" class="headerlink" title="进程退出场景"></a>进程退出场景</h2><blockquote><ol><li>代码运行完毕，结果是正确的</li><li>代码运行完毕，结果是错误的</li><li>代码异常中止</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；<br></code></pre></td></tr></table></figure><ul><li>为什么main函数要return 0，意义在哪里？</li></ul><blockquote><p>进程的退出码，<strong>衡量代码</strong>跑完了，是对还是不对，<br>return <strong>0代表success</strong><br>return 100<br>echo $？查看退出码<br><img src="https://img-blog.csdnimg.cn/a892988c1c16488fb41e33d9f131741a.png" alt="在这里插入图片描述"><br>退出码会被父进程继承<br>echo $?<br>会输出最近一次进程退出时的退出码<br><img src="https://img-blog.csdnimg.cn/089d9a149f914aa9809718102f6f4401.png" alt="在这里插入图片描述"><br>而第二次输出0<br>是echo命令的退出码</p></blockquote><h3 id="错误的退出码"><a href="#错误的退出码" class="headerlink" title="错误的退出码"></a>错误的退出码</h3><p>每个退出码都有其对应的错误原因</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br> <span class="hljs-number">3</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br> 4 &#123;<br> <span class="hljs-number">5</span>   <span class="hljs-comment">//printf(&quot;hello\n&quot;);</span><br> <span class="hljs-number">6</span>   <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br> <span class="hljs-number">7</span>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br> <span class="hljs-number">8</span>   &#123;<br> <span class="hljs-number">9</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: %s \n&quot;</span>,i,strerror(i));<span class="hljs-comment">//返回错误信息，;里面对应的i就是返回的错误码，返回的信息就是对应的错误信息                                                                                 </span><br><span class="hljs-number">10</span>   &#125;<br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span>   <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br><span class="hljs-number">13</span> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/eea95fa15a0441f19607e5a8971e0d47.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>错误码与错误描述</p><h3 id="代码异常终止"><a href="#代码异常终止" class="headerlink" title="代码异常终止"></a>代码异常终止</h3><p>运行终止的退出码，我们并不关系</p><h2 id="进程常见退出方法"><a href="#进程常见退出方法" class="headerlink" title="进程常见退出方法"></a>进程常见退出方法</h2><p>1.main函数return,代表<strong>进程退出</strong>！！<br>而非main函数</p><p>2.exit(退出码)进程退出程序<br>在任意地方使用都是让进程退出<br>参数是退出码</p><p>都可以达到进程退出的目的</p><p>3._exit(退出码)<br>强制终止进程，不要进行进程的后续收尾工作，如刷新缓冲区，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fun test&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">//fun();</span><br>  <span class="hljs-comment">//printf(&quot;hello\n&quot;);</span><br>  <span class="hljs-comment">//int a=10;</span><br>  <span class="hljs-comment">//a/=0;//跑到一半异常终止</span><br>  <span class="hljs-comment">//在vs中一般叫程序崩溃</span><br>  <span class="hljs-comment">//</span><br><br> <span class="hljs-comment">// int i=0;</span><br> <span class="hljs-comment">// for(i=0;i&lt;140;i++)</span><br> <span class="hljs-comment">// &#123;</span><br> <span class="hljs-comment">//   printf(&quot;%d: %s \n&quot;,i,strerror(i));//返回错误信息，;里面对应的i就是返回的错误码，返回的信息就是对应的错误信息</span><br> <span class="hljs-comment">// &#125;</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">//此时数据被暂时保存在输入缓冲区中</span><br>  sleep(<span class="hljs-number">3</span>);<br>   _exit(<span class="hljs-number">12</span>);<br>  <span class="hljs-comment">//  exit(EXIT_SUCCESS);</span><br> <span class="hljs-comment">//exit或return 本身就是会要求系统进行缓冲区刷新 </span><br>  <span class="hljs-comment">//return 123;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用户级缓冲区<br><img src="https://img-blog.csdnimg.cn/db78ab073c6841189432e1bcda9f1cc3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>进程退出在操作系统层面做了什么？</p><blockquote><p>系统场面上少了一个进程，free PCB，free 页表，mm_struct，页表和各种映射关系，代码+数据申请的空间也要被释放掉</p></blockquote><h2 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h2><h3 id="进程等待是什么？"><a href="#进程等待是什么？" class="headerlink" title="进程等待是什么？"></a>进程等待是什么？</h3><blockquote><p>fork（）：创建子进程（为了帮助父进程某种任务），父进程<br>让我们的父进程fork之后，需要通过wait&#x2F;waitpid来等待子进程退出</p></blockquote><h3 id="为什么要让父进程等待呢"><a href="#为什么要让父进程等待呢" class="headerlink" title="为什么要让父进程等待呢"></a>为什么要让父进程等待呢</h3><blockquote><ol><li>通过获取子进程退出的信息，能够得知子进程执行结果</li><li>可以保证，时序问题，子进程先退出，父进程后退出</li><li>进程退出的时候，会先进入<strong>僵尸状态</strong>，会<strong>造成内存泄漏</strong>的问题，需要通过父进程wait，来释放该子进程占用的空间（子进程的僵尸资源）</li></ol></blockquote><blockquote><p>进程进入了僵尸进程，kill -9就没有办法杀掉该进程</p></blockquote><h3 id="进程等待的方法"><a href="#进程等待的方法" class="headerlink" title="进程等待的方法"></a>进程等待的方法</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>作用是等待任意一个子进程<br>头文件</p><blockquote><p>1 #include &lt;stdio.h&gt;<br>2 #include&lt;sys&#x2F;types.h&gt;<br>3 #include&lt;sys&#x2F;wait.h&gt;</p></blockquote><p>成功返回被等待进程的pid，失败就返回-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pid_t</span> id=fork();<br>  <span class="hljs-keyword">if</span>(id==<span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-comment">//child</span><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">while</span>(cnt)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child[%d] is running : cnt is :%d \n&quot;</span>,getpid() ,cnt);<br>      cnt--;<br>      sleep(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//子进程会持续5秒之后就exit，但是父进程；立刻就退出了</span><br>      <span class="hljs-comment">//子进程就会变成一个孤儿进程，被系统领养</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//我们执行完子进程之后直接退出，不执行父进程的代码</span><br>    <span class="hljs-comment">//进程退出</span><br>  &#125;<br>  sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//先让父进程等待10秒</span><br>  <span class="hljs-comment">//前5秒是正常运行的</span><br>  <span class="hljs-comment">//后5秒子进程处于z状态</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father wait begin\n&quot;</span>);<br>  <span class="hljs-comment">//因为父进程和子进程是同时执行的</span><br>  <span class="hljs-comment">//parent</span><br>  <span class="hljs-comment">//为了不让子进程变成一个孤儿进程，父进程必须在那里等待</span><br>  <span class="hljs-type">pid_t</span> ret=wait(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//成功的话就返回其</span><br>  <span class="hljs-keyword">if</span>(ret&gt;<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father wait %d\n &quot;</span>,ret);<br>  <span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father wait fail\n&quot;</span>);<br>  <span class="hljs-comment">//到这里僵尸状态就没了</span><br>  sleep(<span class="hljs-number">10</span>);<br>  <span class="hljs-comment">//回收完毕之后父进程继续活上10秒</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/98c6dc9744254913951ffb6fb5eda36c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><blockquote><p>一开始前5秒都共同运行着，5秒之后，子进程退出，进入z状态，因为父进程还在sleep，没有去wait，再过5秒，父进程开始执行wait，wait成功，僵尸进程就没了，再过了10秒钟，父进程就退出了</p></blockquote><p>wait完全可以回收僵尸进程</p><h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><p>成功了就会返回其等待的子进程的pid，错了就会返回-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br>      <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br>      <span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *wstatus)</span>;<br><br>      <span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><p>waitpid就是一个系统调用，<br>status就是一个输出形参数<br>最终一定要让父进程，通过status，得到子进程执行的结果<br>正常退出代码<br><img src="https://img-blog.csdnimg.cn/99e62ad4a7ae4ebc8a562181f3c77590.png" alt="在这里插入图片描述"></p><p>异常终止代码<br><img src="https://img-blog.csdnimg.cn/d72761ef27fc456b9428d0d942eba0cf.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2ed01bc770784ac7ab36cabe7e37dd85.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b2bff113264b4d60a56eecb5e1eb8046.png" alt="在这里插入图片描述"></p><p>bash是命令行启动的所有进程的父进程|<br>bash一定是通过wait 方式得到子进程的退出结果，所以我们能看到echo$？<br>查看到子进程的退出码</p><p><strong>status：</strong><br>WIFEXITED（status）：若进程正常退出，就为真<br>WEXITSTATUS(status）：若WIFEXITED非0，就可以提取子进程的退出码<br>（就不要进行麻烦的位操作）</p><p><img src="https://img-blog.csdnimg.cn/315fa4c3ddae4e26bcc4eedeff905400.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>option</strong><br>0为默认行为，阻塞等待<br>掉wait的时候，父进程啥也不干，就在哪里等子进程，等待子进程退出，<br><strong>WNOHANG</strong>：设置等待方式为非阻塞等待</p><h5 id="阻塞等待"><a href="#阻塞等待" class="headerlink" title="阻塞等待"></a>阻塞等待</h5><p>啥也不干，就在那里静静的等待，就等子进程退出才会返回</p><blockquote><p>阻塞的本质<br>就是将进程的PCB被放入到等待队列当中,并将进程的状态改为S状态,<br>返回的本质,进程的PCB 从等待队列中拿到R 队列,从而被CPU 调度,</p></blockquote><p><img src="https://img-blog.csdnimg.cn/44f03a0f25754f87b97e6c398aa3fd6b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="非阻塞等待"><a href="#非阻塞等待" class="headerlink" title="非阻塞等待"></a>非阻塞等待</h4><p>检测子进程的运行状态，等待的过程中，可能需要多次检测：<br>基于非阻塞等待的轮询方案，</p><blockquote><p>调用一个接口,CPU立马返回,CPU不断重复的调度父进程,就是重复调度waitpid的过程</p></blockquote><p>无论是阻塞还是非阻塞，都是等待的一种方式，<br>谁等（父进程）<br>等（子进程）<br>等待子进程退出（条件&#x2F;事件）</p><p>我们看到吗某些运用或者OS本身，长时间不动，是应用或程序hang住了<br>WNOHANG：非阻塞</p><ol><li><pre><code class="hljs">返回值结果，子进程改变就没有退出，</code></pre></li><li><pre><code class="hljs">子进程退出，waitpid（调用成功or失败），</code></pre></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pid_t</span> id=fork();<br>  <span class="hljs-keyword">if</span>(id==<span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-comment">//child</span><br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">while</span>(cnt)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child[%d] is running : cnt is :%d \n&quot;</span>,getpid() ,cnt);<br>      cnt--;<br>      sleep(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//子进程会持续5秒之后就exit，但是父进程；立刻就退出了</span><br>      <span class="hljs-comment">//子进程就会变成一个孤儿进程，被系统领养</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//我们执行完子进程之后直接退出，不执行父进程的代码</span><br>  &#125;<br>  <span class="hljs-type">int</span> status=<span class="hljs-number">0</span>;<br> <br>  <span class="hljs-comment">//pid_t ret=waitpid(id,&amp;status,0);//阻塞等待</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//非阻塞的轮询方案</span><br>  &#123;<br>  <span class="hljs-type">pid_t</span> ret=waitpid(id,&amp;status,WNOHANG);<span class="hljs-comment">//非阻塞等待</span><br>  <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">0</span>)&#123;<br>   <br>    <span class="hljs-comment">//检测子进程没有退出，但是waitpid等待是成功的，需要父进程继续进行等</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;do father thing\n&quot;</span>);<span class="hljs-comment">//得知还没好，就可以做一下自己的事情</span><br>    <br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret&gt;<span class="hljs-number">0</span>)<br>  &#123;<br><br>    <span class="hljs-comment">//子进程退出了，waitpid也成功了，获取到了对应的结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit code: %d\n,&quot;</span>,WEXITSTATUS(status));<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <br>  &#123;<br>    <span class="hljs-comment">//ret&lt;0</span><br>    <span class="hljs-comment">//等待失败</span><br>    perror(<span class="hljs-string">&quot;waitpid&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  sleep(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 运维 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序地址空间</title>
    <link href="/2022/03/21/%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/03/21/%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">进程地址空间</a></li><li><a href="#_77">进程地址空间概念</a></li><li><ul><li><a href="#_104">页表</a></li><li><a href="#_112">为什么要这么干</a></li></ul></li></ul><h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>c&#x2F;c++程序地址空间<strong>不是内存</strong><br>而是进程虚拟地址空间</p><p><img src="https://img-blog.csdnimg.cn/c46b2d16137044d48bb1c76e9a310560.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br>  <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br>  <span class="hljs-number">3</span> <span class="hljs-type">int</span> g_unval;  <br>  <span class="hljs-number">4</span> <span class="hljs-type">int</span> g_val=<span class="hljs-number">100</span>;  <br>  <span class="hljs-number">5</span>                                           <br>  <span class="hljs-number">6</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">  7 </span>&#123;  <br>  <span class="hljs-number">8</span>   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s=<span class="hljs-string">&quot;hello world&quot;</span>;<span class="hljs-comment">//在字符常量区域保存  </span><br>  <span class="hljs-number">9</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;code addr: %p\n&quot;</span>,main);  <span class="hljs-comment">//代码区</span><br> <span class="hljs-number">10</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string rdonly addr: %p\n&quot;</span>,s);  <br> <span class="hljs-number">11</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;uninit addr: %p\n&quot;</span>,&amp;g_unval);<br> <span class="hljs-number">12</span>   <span class="hljs-type">char</span>* heap=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br> <span class="hljs-number">13</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap affr :%p \n&quot;</span>,heap);<span class="hljs-comment">//我们要读到堆区的地址，而不是heap，heap是在栈区开辟的地址，</span><br> <span class="hljs-number">14</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr: %p\n&quot;</span>,&amp;s);<span class="hljs-comment">//s也是在栈上开辟的地址，</span><br> <span class="hljs-number">15</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr: %p\n&quot;</span>,&amp;heap);<span class="hljs-comment">//heap也是在栈上开辟的地址，</span><br> <span class="hljs-number">16</span>   <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br> <span class="hljs-number">17</span>   <span class="hljs-type">int</span> b=<span class="hljs-number">9</span>;<br> <span class="hljs-number">18</span> <br> <span class="hljs-number">19</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr: %p\n&quot;</span>,&amp;a);<span class="hljs-comment">//a也是在栈上开辟的地址，</span><br> <span class="hljs-number">20</span>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr: %p\n&quot;</span>,&amp;b);<span class="hljs-comment">//b也是在栈上开辟的地址，</span><br> <span class="hljs-number">21</span>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                                                                                                                                                   <br> <span class="hljs-number">22</span> &#125;  <br>~       <br><br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/aa84cfe30cc24e40a66c20d271926e19.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">24</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span>                                                                                                                                                                                  </span><br><span class="hljs-function">25 </span>&#123;<br><span class="hljs-number">26</span>   <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br><span class="hljs-number">27</span>   &#123;<br><span class="hljs-number">28</span>    <span class="hljs-comment">//child</span><br><span class="hljs-number">29</span>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">5</span>;<br><span class="hljs-number">30</span>    <span class="hljs-keyword">while</span>(cnt)<br><span class="hljs-number">31</span>   &#123;<br><span class="hljs-number">32</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child,time %d,g_val %d,&amp;g_val %p\n&quot;</span>,cnt,g_val,&amp;g_val);<br><span class="hljs-number">33</span>    cnt--;<br><span class="hljs-number">34</span>  <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-number">35</span>    <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">3</span>)<br><span class="hljs-number">36</span>   &#123;<br><span class="hljs-number">37</span>    g_val=<span class="hljs-number">200</span>;<br><span class="hljs-number">38</span> <br><span class="hljs-number">39</span>    &#125;<br><span class="hljs-number">40</span>    &#125;<br><span class="hljs-number">41</span>   &#125;<br><span class="hljs-number">42</span>   <span class="hljs-keyword">else</span> <br><span class="hljs-number">43</span>   &#123;<br><span class="hljs-number">44</span>   ? <span class="hljs-comment">//parent</span><br><span class="hljs-number">45</span>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br><span class="hljs-number">46</span>    &#123;<br><span class="hljs-number">47</span>   <br><span class="hljs-number">48</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father,g_val %d,&amp;g_val %p\n&quot;</span>,g_val,&amp;g_val);<br><span class="hljs-number">49</span>   <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);                                         <br><span class="hljs-number">50</span>   &#125;                                         <br><span class="hljs-number">51</span>   &#125;                                                                                                                                                         <br><span class="hljs-number">52</span> &#125;                     <br><span class="hljs-number">53</span> <br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0bbab1a45a8846c49a4ff686fb436911.png" alt="在这里插入图片描述"></p><blockquote><p>父子进程中，数据是相互独立的，子进程中变不影响父进程，</p></blockquote><blockquote><ul><li>地址怎么能没有发生变化呢<br>如果C&#x2F;C++中打印出来的地址是物理内存的地址，这种现象是绝对不可能存在<br>所以这里我们使用的地址绝对不是物理地址<br><strong>而是虚拟地址</strong></li></ul></blockquote><h1 id="进程地址空间概念"><a href="#进程地址空间概念" class="headerlink" title="进程地址空间概念"></a>进程地址空间概念</h1><p>进程地址空间本质上也是内核中的一种数据结构<br>struct mm_struct<br><img src="https://img-blog.csdnimg.cn/8aef87fb7ec145e38cf90102783305ab.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code_start;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> code_end;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> init_data_start;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> init_data_end;<br>  ……<br>  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这一个一个的都是区域，<br>虽然这里只有start和end，但是每个进程都可以认为mm_struct 代表整个内存，且所有的地址为0x00000000到0xffffffff<br>在start到end内就是其的区域</p></blockquote><blockquote><p>每个进程都认为地址空间的划分是按照4GB空间划分的，每个进程都认为之际拥有4GB</p></blockquote><blockquote><p>地址空间进行线性划分时，对应的线性位置可以认为是虚拟地址<br>而从start到end里就是虚拟地址，<br>如：start&#x3D;20，end&#x3D;30<br>那么21，22，23就是虚拟地址</p></blockquote><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>：将虚拟地址转化为物理地址（映射表）（哈希表）<br><img src="https://img-blog.csdnimg.cn/71345b2f5fa8493da4635d42f11a602b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="页表"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> * table[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>]<br></code></pre></td></tr></table></figure><blockquote><p>可以理解为下标就是对应的是虚拟地址，而下标所对应的值就是物理地址 ，用户使用的都是虚拟地址，而操作系统会根据其虚拟地址找到其对应的物理地址中的数据与代码</p></blockquote><h2 id="为什么要这么干"><a href="#为什么要这么干" class="headerlink" title="为什么要这么干"></a>为什么要这么干</h2><p><img src="https://img-blog.csdnimg.cn/df0cce05fac246c4971b7339d3a8a373.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>而地址空间加页表就是操作系统中的管理者角色<br>而<strong>页表</strong>和<strong>MMU</strong>是通过操作系统帮我们转化的（权限管理）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str=<span class="hljs-string">&quot;hello&quot;</span>;<br>*str=<span class="hljs-string">&#x27;.&#x27;</span>;<br></code></pre></td></tr></table></figure><p>不可以这样做的，在字符常量区</p><blockquote><p>本质是<strong>OS</strong> 给你的权限只有<strong>r</strong>权限，<br>而用<strong>str</strong>指针的时候用的就是虚拟地址，指向那个位置，访问的时候就要对<strong>虚拟地址和物理地址进行转换</strong>，而只有<strong>读</strong>权限，那么就会直接被崩溃掉</p></blockquote><ol><li>通过添加一层软件层，完成有效的对进程操作内存进行<strong>风险管理</strong>（权限管理），本质目的是为了，保护物理内存以及各个进程的数据安全，映射之后会到不同的内存区，绝对不一样</li><li>将<strong>内存申请</strong>，和<strong>内存使用</strong>的概念在时间上划分清楚，通过<strong>虚拟地址</strong>空间来<strong>屏蔽</strong>掉<strong>申请内存</strong>的过程，达到进程读写内存和OS 进行内存管理操作，进行软件上面的分离（写时拷贝）<br><img src="https://img-blog.csdnimg.cn/1b81ed5743f643cfaa698184968ae130.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><blockquote><p>如我想我爸要8000，我爸答应了，（进程向操作系统要空间，操作系统同意了，在进程地址空间里面开了地址，），到实际要钱的时候，爸发现钱不够，就借钱，各种渠道，把钱给我，（OS通过内存管理算法，把一些没在用的空间，给进程）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/e84243a0f7ca4c7abb9fbd5f2e51b713.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol start="3"><li>可以做到站在CPU和应用层的角度，进程统一使用4GB 空间，而且每个空间区域的相对位置，是比较确定的</li></ol><pre><code class="hljs">&gt; 之后便可以使得程序和代码数据被加载到物理内存的任意位置  &gt; 因为**页表可以映射**，在**虚拟地址**上是**连续**的，而在**物理地址**上**不是连续**的，大大减少内存管理的负担&gt; OS 最终这样设计的目的，达到一个目标，每个进程都认为自己是**独占资源**</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>*p=<span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>*q=<span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p=%p\n&quot;</span>,p);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;q=%p\n&quot;</span>,q);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6870c6cfd5694c37ba890412d5858769.png" alt="在这里插入图片描述"></p><p>打印的结果是一样的，都是只读的，这样维护成本最低</p><p><img src="https://img-blog.csdnimg.cn/64facc88261f4d9a8e679f37f763500a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[],<span class="hljs-type">char</span>*env[])</span><br><br>&#123;<br>  <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;argv[i];i++)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argv[%d]:%p\n&quot;</span>,i,argv[i]);<span class="hljs-comment">//不需要&amp;，</span><br><br>  &#125;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;env[i];i++)<br>  &#123;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;env[%d]:%p\n&quot;</span>,i,env[i]);<span class="hljs-comment">//不需要&amp;，</span><br>  &#125;<br><span class="hljs-comment">//  test1();</span><br>  test3();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>命令行的参数地址远高于栈，环境变量更高于命令行<br><img src="https://img-blog.csdnimg.cn/eb45e224aad0458bb35af5386207580e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/f5b80df2574c4d289ff85825692c0a2e.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟实现ls的总结与感悟</title>
    <link href="/2022/03/19/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0ls%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    <url>/2022/03/19/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0ls%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><p><a href="#1_3">前期准备[^1]</a></p></li><li><ul><li><a href="#argcargv_6">argc与argv</a></li><li><a href="#getopt_23">getopt</a></li><li><a href="#statlstat_40">stat与lstat</a></li><li><ul><li><a href="#struct_stat_51">struct stat结构体</a></li><li><a href="#lstat_116">与lstat的区别</a></li></ul></li><li><a href="#sprintffprintf_121">sprintf与fprintf</a></li><li><a href="#opendir__closedir_134">opendir &amp;&amp; closedir</a></li><li><a href="#readdir_160">readdir</a></li></ul></li><li><p><a href="#_185">实现过程中遇到的麻烦</a></p></li><li><ul><li><a href="#_186">颜色控制</a></li><li><a href="#Linux_213">Linux中多文件操作</a></li></ul></li><li><p><a href="#_240">代码实现</a></p></li><li><p>引言<br>我们每个人在学习Linux的时候使用的第一个命令都应该是ls，这个命令也开启了我们学习Linux的大门，但是应该很少有人知道ls是如何实现的，所以我便在自己的能力范围内对ls进行模拟实现</p></li></ul><h1 id="前期准备1"><a href="#前期准备1" class="headerlink" title="前期准备1"></a>前期准备<a href="#fn1">1</a></h1><h2 id="argc与argv"><a href="#argc与argv" class="headerlink" title="argc与argv"></a>argc与argv</h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux c语言 github git vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stl--vector</title>
    <link href="/2022/03/17/stl--vector/"/>
    <url>/2022/03/17/stl--vector/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_vector1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//构造函数初始化</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<span class="hljs-comment">//无参,</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v2</span>(<span class="hljs-number">10</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//10个8</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v3</span>(++v2.<span class="hljs-built_in">begin</span>(),--v2.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//使用迭代器进行赋值的初始化，6个8</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v4</span>(v3);<span class="hljs-comment">//用v3进行拷贝构造</span><br>    <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">char</span>&gt;<span class="hljs-built_in">v5</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//类比v3</span><br>    <br><br>    <br>&#125;   <br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_vector2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//尾插</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//遍历</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//v.size()计算vector的有效个数</span><br>    &#123;<br>        v[i]+=<span class="hljs-number">1</span>;<br>        cout&lt;&lt;v[i];<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//迭代器</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span>(it!=v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        *it-=<span class="hljs-number">1</span>;<br>        cout&lt;&lt;*it;<br>        ++it;<br>    &#125;<br>   <br><br><span class="hljs-comment">//    for(auto e:v)</span><br><span class="hljs-comment">//    &#123;</span><br><span class="hljs-comment">//        cout&lt;&lt;e;</span><br><span class="hljs-comment">//    &#125;</span><br>        <br>   <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_vector3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>    v.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//尾巴删除</span><br>    <br>    v.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">//用10个5去覆盖,变成新的值</span><br>    cout&lt;&lt;v.<span class="hljs-built_in">max_size</span>()&lt;&lt;endl;<span class="hljs-comment">//非常大</span><br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">50</span>);<span class="hljs-comment">//把扩容成50</span><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//把空间弄成100，同时把其余初始化为0,这个在vector里面非常常用</span><br>    <span class="hljs-comment">//v[]是用assert来判断错误</span><br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_vector4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator ret= <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">3</span>);<span class="hljs-comment">//返回的是找到的3的第一个位置迭代器,</span><br>    <span class="hljs-keyword">if</span>(ret!=v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;<br>        v.<span class="hljs-built_in">insert</span>(ret,<span class="hljs-number">30</span>);<span class="hljs-comment">//头插,第一个是迭代器的位置，在ret迭代器位置插入一个30</span><br>        <span class="hljs-comment">//不能在这里删除，迭代器会失效</span><br>        <br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;v[i];<br><br>    &#125;<br>    <span class="hljs-comment">//删除一个值</span><br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator ret1= <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">3</span>);<span class="hljs-comment">//返回的是找到的3的第一个位置迭代器,</span><br>   <span class="hljs-keyword">if</span>(ret1!=v.<span class="hljs-built_in">end</span>())<br>    &#123;<br>    v.<span class="hljs-built_in">erase</span>(ret1);<span class="hljs-comment">//删除ret1迭代器位置的数</span><br>    &#125;   <br>    v.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//将所有数字都清空</span><br>   cout&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;  <span class="hljs-comment">//计算v的容量</span><br>    v.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//v的第一个元素</span><br>    v.<span class="hljs-built_in">back</span>();<span class="hljs-comment">//v的最后一个数据</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_vector5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//二维数组</span><br>    <span class="hljs-comment">//c语言的二维数组静态可以弄，但是无法动态扩容</span><br>  <span class="hljs-comment">//  int** p=(int**)malloc(sizeof(int*)*3);//每个数组存int*，他就是int**,同时他的每一行都要进行开辟，所以就很麻烦</span><br>    <span class="hljs-comment">//p[i][j];//第i行的第j个</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; vv;<span class="hljs-comment">//二维数组，里面的每个数据又是一个vector,VV[I][J],由析构函数，两次的函数调用，</span><br>    vv.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>    cout&lt;&lt;vv.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<span class="hljs-comment">//5</span><br>    cout&lt;&lt;vv.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<span class="hljs-comment">//5，</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        <span class="hljs-comment">//先开空间再使用，</span><br>        vv[i].<span class="hljs-built_in">resize</span>(i+<span class="hljs-number">1</span>);<span class="hljs-comment">//vv[i]里面也是vector，使用resize对其size进行设置</span><br>        <span class="hljs-comment">//先开空间再去访问</span><br>        vv[i].<span class="hljs-built_in">front</span>()=vv[i].<span class="hljs-built_in">back</span>()=<span class="hljs-number">1</span>;<span class="hljs-comment">//第一列和每一行的最后一个都是1</span><br>        <span class="hljs-comment">//vv[i][0]=vv[i][vv[i].size()-1]=1;//和上面是一样的</span><br>    &#125;<br>    <span class="hljs-comment">//遍历二维数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vv.<span class="hljs-built_in">size</span>(),i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;vv[i].<span class="hljs-built_in">size</span>();j++)<br><br>        &#123;<br>            <span class="hljs-keyword">if</span>(vv[i][j]==<span class="hljs-number">0</span>)<span class="hljs-comment">//上面resize初始化默认是0</span><br>            &#123;<br>                vv[i][j]=vv[i<span class="hljs-number">-1</span>][j]+vv[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><span class="hljs-comment">//vector可以动态内存申请的数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test_vector1</span>();<br>    <span class="hljs-built_in">test_vector2</span>(); <br>    <span class="hljs-built_in">test_vector3</span>();<br>    <span class="hljs-built_in">test_vector4</span>();<br>    <span class="hljs-built_in">test_vector5</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 算法 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stl-string</title>
    <link href="/2022/03/17/stl-string/"/>
    <url>/2022/03/17/stl-string/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-comment">//string就是管理字符串的类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//库里面定义</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">basic_string</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>T* _str;<br><span class="hljs-comment">//...</span><br>&#125;;<br><br><br><span class="hljs-comment">//编码 --值--符号建立映射关系--编码表（用值和符号建立对应关系） </span><br><span class="hljs-comment">// ASCILL编码表---表示英文编码</span><br><span class="hljs-comment">// unicode ---（包含ascill）表示全世界文字编码</span><br><span class="hljs-comment">//又包含utf -8，utf-16 </span><br><span class="hljs-comment">//gbk        --     中国自己量身定做的编码表</span><br><span class="hljs-comment">// 汉字可以用2个字节，</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">//typrdef basic_string&lt;char&gt; string,我们用的是typedef后出来的，模板的</span><br><br><span class="hljs-comment">//int main()</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//string s1(&quot;hello&quot;);</span><br><span class="hljs-comment">//char str2[] = &quot;吃饭&quot;;</span><br><span class="hljs-comment">//cout &lt;&lt; sizeof(char) &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; sizeof(wchar_t) &lt;&lt; endl;//2个字节，wstring</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//return 0;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><br><span class="hljs-comment">//初始化</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s1;<span class="hljs-comment">//无调用构造函数</span><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<span class="hljs-comment">//构造函数</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;<span class="hljs-comment">//拷贝构造</span><br><span class="hljs-comment">//cin &gt;&gt; s1;</span><br>cout &lt;&lt; s1 &lt;&lt; endl;<br>cout &lt;&lt; s2 &lt;&lt; endl;<br>cout &lt;&lt; s3 &lt;&lt; endl;<br><span class="hljs-comment">//substring (3)</span><br><br><span class="hljs-comment">//string(const string &amp; str, size_t pos, size_t len = npos);</span><br><span class="hljs-comment">//利用字串进行初始化，pos是从0开始，从string里面先后数len个长度进行拷贝</span><br><br><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(s2, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>)</span></span>;<br>cout &lt;&lt; s4 &lt;&lt; endl;<span class="hljs-comment">//llo wo</span><br><span class="hljs-function">string <span class="hljs-title">s5</span><span class="hljs-params">(s2, <span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//默认从坐标为2的地方往后截取所有的s2</span><br>cout &lt;&lt; s5 &lt;&lt; endl;<span class="hljs-comment">//ello world</span><br><br><span class="hljs-comment">//string (const char* s, size_t n);</span><br><span class="hljs-function">string <span class="hljs-title">s7</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//取前3个字符</span><br>cout &lt;&lt; s7 &lt;&lt; endl;<br><span class="hljs-comment">//string(size_t n, char c);连续弄n个c</span><br><span class="hljs-function">string <span class="hljs-title">s8</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;!&#x27;</span>)</span></span>;<span class="hljs-comment">//！！！</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-comment">//不计算‘\0’，这两个对于string没什么区别，size是后出现为了保证容器的一致性</span><br>cout &lt;&lt; s1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">//5</span><br>cout &lt;&lt; s1.<span class="hljs-built_in">length</span>() &lt;&lt; endl;<span class="hljs-comment">//5</span><br>cout &lt;&lt; s1.<span class="hljs-built_in">max_size</span>() &lt;&lt; endl;<span class="hljs-comment">//没什么意义</span><br>cout &lt;&lt; s1 &lt;&lt; endl;<br>  <span class="hljs-comment">//计算容量</span><br>cout &lt;&lt; s1.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<span class="hljs-comment">//15</span><br>s1.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//把有效数据都清理掉,空间保留，变成空字符串，0个字符</span><br>cout &lt;&lt; s1 &lt;&lt; endl;<br>cout &lt;&lt; s1.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>())<span class="hljs-comment">//判断此字符串是否为空，即是否长度为0</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;not&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br>&#125;<br><br><br><span class="hljs-comment">//char&amp; operator[] (size_t pos);这里的引用返回是因为这个数组是在堆上开辟的，出了作用域还在，并且可以对其中的字符进行修改，或者调用，还可以减少拷贝（不是主要目的）</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operatoracess</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s1.<span class="hljs-built_in">length</span>(); i++)<br>&#123;<br>cout &lt;&lt; s1[i];<span class="hljs-comment">//[]是断言终止程序，检查错误</span><br>s1[i] += <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s1.<span class="hljs-built_in">length</span>(); i++)<br>&#123;<br>s1.<span class="hljs-built_in">at</span>(i) -= <span class="hljs-number">1</span>;<span class="hljs-comment">//和上面是一样的</span><br>cout &lt;&lt; s1.<span class="hljs-built_in">at</span>(i) &lt;&lt; endl;<span class="hljs-comment">//at是抛异常检查错误,建议还是使用[ ]</span><br>&#125;<br>cout &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-comment">//对字符串进行尾部添加字符或字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br>s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;bcde&quot;</span>);<span class="hljs-comment">//尾插bcd</span><br>cout &lt;&lt; s &lt;&lt; endl;<span class="hljs-comment">//abcd</span><br>s += <span class="hljs-string">&#x27;!&#x27;</span>;<span class="hljs-comment">//也可以利用运算符重载进行实现尾插，推荐,abcd!</span><br>&#125;<br><br><br><span class="hljs-comment">//只交换字符</span><br><span class="hljs-comment">//abc-bcd-qwlkj变成 jkl-wqd-cbcba  </span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//计算最后一个单词的长度如“hello world  ”g</span><br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> end=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>                    <span class="hljs-keyword">while</span>(s[end]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                    &#123;<br>                                  s.<span class="hljs-built_in">erase</span>(end,<span class="hljs-number">1</span>);<span class="hljs-comment">//无法使用</span><br>                                              end--;<br>                                                      <br>                                                      <br>                    &#125;<br>                            <br>                    <span class="hljs-type">size_t</span> pos=s.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot; &quot;</span>);<br><br>                    string sub=s.<span class="hljs-built_in">substr</span>(pos+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> sub.<span class="hljs-built_in">size</span>();<br><br><br><br>                        <br>  &#125;<br><br><br><br><br>&#125;;<br><br><span class="hljs-comment">//遍历，1.迭代器2.范围for</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>string::iterator it=s1.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//s1.begin(),是第一个数据的地址，s1.end（）是最后一个数据的后一个的地址</span><br><span class="hljs-comment">//这个iterator是定义在string里面，it现在指向了第一个数据的地址</span><br><span class="hljs-comment">//现在可以先想象成一个像指针一样的类型</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">while</span>(it!=s1.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//直到结尾就结束了，但是不建议用&lt;</span><br>&#123;<br>  cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//*就是取他的数据</span><br>  ++it;<span class="hljs-comment">//到下一个地址</span><br>&#125;<br>cout&lt;&lt;endl;<br><span class="hljs-comment">//除了可以读还可以写</span><br> it=s1.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//s1.begin(),是第一个数据的地址，s1.end（）是最后一个数据的后一个的地址</span><br><span class="hljs-comment">//这个iterator是定义在string里面，it现在指向了第一个数据的地址</span><br><span class="hljs-comment">//现在可以先想象成一个像指针一样的类型</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">while</span>(it!=s1.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//直到结尾就结束了</span><br>&#123;<br>  *it-=<span class="hljs-number">1</span>;<span class="hljs-comment">//*就是取他的数据</span><br>  ++it;<span class="hljs-comment">//到下一个地址</span><br>&#125;<br>cout&lt;&lt;endl;<br><br><br><span class="hljs-comment">//范围for,auto可以自动识别</span><br><span class="hljs-comment">//for(auto e:s1)//把s1里面每个字符取出来赋值给e，不需要自己++，自动判断结束</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//  cout&lt;&lt;e&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">//&#125;</span><br>cout&lt;&lt;endl;<br><br><span class="hljs-comment">//要修改就要用引用</span><br><span class="hljs-comment">//for(auto&amp; e:s1)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//  e-=1;</span><br><span class="hljs-comment">//&#125;</span><br>cout&lt;&lt;endl;<br><br><span class="hljs-comment">//反向迭代器</span><br><span class="hljs-comment">//倒着遍历</span><br>string::reverse_iterator rit=s1.<span class="hljs-built_in">rbegin</span>();<span class="hljs-comment">//rbegin（），是最后一个数据的地址</span><br><span class="hljs-comment">//为了简化代码也可以直接auto推到</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//auto  rit=s1.rbegin()</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">while</span>(rit!=s1.<span class="hljs-built_in">rend</span>())<span class="hljs-comment">//rend（）是第一个数据的前一个地址</span><br>&#123;<br>  cout&lt;&lt;*rit&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//olleh，反过来遍历</span><br>  ++rit;<span class="hljs-comment">//反向迭代器的++，是往左走的</span><br>&#125;<br>cout&lt;&lt;endl;<br><br><span class="hljs-comment">//迭代器遍历的意义是什么呢：所有的容器都可以用迭代器这种访问修改</span><br><span class="hljs-comment">//1.对于string类来说，利用[]都足够好用,确实可以不用迭代器</span><br><span class="hljs-comment">//2。对于其他容器（数据结构）也可以使用，如list，map，set，这些是不支持[]，因为只有像数组一样的东西才支持[]遍历和下标，</span><br><span class="hljs-comment">//结论：：对于string得会用迭代器，但是我们还是喜欢下标加[],</span><br><br><span class="hljs-comment">//还有const迭代器，普通迭代器是可读可写的</span><br><span class="hljs-function">string <span class="hljs-title">cstr</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br><span class="hljs-comment">//funcion(cstr);</span><br>string::const_iterator re=s1.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//只读不写，同理还有反向迭代器</span><br><span class="hljs-comment">//cbegin（）就是const迭代器，但是我们平时都不太用，</span><br><br>&#125;<br><br><br><br><span class="hljs-comment">//对于容量的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s1;<br>s1.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//可以设置容量的大小，容量就是100，加上原来的容量</span><br>string s2;<br>s2.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">//也是可以设置容量的大小，同时还可以对其进行初始化，如将s1有效数据的后面全部设置成x，如果没有第二个参数，则默认是‘\0’</span><br>&#125;<br><br><br><br><br><br><span class="hljs-comment">//对于find，c_str ,rfind的认识与理解</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>string s2=<span class="hljs-string">&quot;hello world&quot;</span>;<br>cout&lt;&lt;s2.<span class="hljs-built_in">c_str</span>()&lt;&lt;endl;<span class="hljs-comment">//将string转变成c语言的形式字符串，char*，以\0截至</span><br><span class="hljs-function">string <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;test.txt&quot;</span>)</span></span>;<br><span class="hljs-comment">//我们要以c语言的形式打开一个文件</span><br><span class="hljs-comment">//FILE* fout=fopen(s2.c_str(),&quot;w&quot;); //fopen第一个参数是char*，所以用这函数</span><br><br><span class="hljs-comment">//要求取出文件的后缀</span><br><br>  <span class="hljs-type">size_t</span> pos=file.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<span class="hljs-comment">//在file里面查找‘x’的位置，find的返回值是size_t,下标从0开始，查找第一个符合的坐标，否则就返回-1</span><br>  <br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(file,pos)</span></span>;<br>cout&lt;&lt;s1&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(pos!=string::npos)<br>&#123;<br>  string suffix=file.<span class="hljs-built_in">substr</span>(pos);<br>cout&lt;&lt;suffix&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//rfind()//可以从后面完前找，找到第一个.，方便找后缀名</span><br><span class="hljs-comment">//https://blog.csdn.net/m0_61567378?spm=1000.2115.3001.5343</span><br><span class="hljs-function">string <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">&quot;http://blog.csdn.net/m0_61567378?spm=1000.2115.3001.5343&quot;</span>)</span></span>;<br><span class="hljs-comment">//找协议头</span><br><span class="hljs-type">size_t</span> pos1=url.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;:&#x27;</span>);<span class="hljs-comment">//：前面的就是协议头</span><br><br>string protocol=url.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,pos1<span class="hljs-number">-0</span>);<span class="hljs-comment">//取得字串就是从0开始，到pos1位置，长度为pos1的字串，也就是http</span><br>cout&lt;&lt;protocol&lt;&lt;endl;<br><br><span class="hljs-comment">//找域名，</span><br><span class="hljs-type">size_t</span> pos2=url.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;/&#x27;</span>,pos1+<span class="hljs-number">3</span>);<span class="hljs-comment">//find默认从0开始找，现在我们给定他从pos1+3位置处开始找，也就是b开始，往后找，找到/的位置</span><br><br>string domain=url.<span class="hljs-built_in">substr</span>(pos1+<span class="hljs-number">3</span>,pos2-pos1<span class="hljs-number">-3</span>);<br>cout&lt;&lt;domain&lt;&lt;endl;<br><br><span class="hljs-comment">//统一资源定位</span><br>string uri=url.<span class="hljs-built_in">substr</span>(pos2+<span class="hljs-number">1</span>);<br>cout&lt;&lt;uri&lt;&lt;endl;<br><br><br>&#125;<br><br><br><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//insert不太推荐用,O(n),效率低</span><br><br>  string s=<span class="hljs-string">&quot;hell&quot;</span>;<br>  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;owlod&quot;</span>);<span class="hljs-comment">//在头上插入一个owlod，是从第0个位置往后插入</span><br>  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">//在头上插入一个x,是</span><br>  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;xx&quot;</span>);<span class="hljs-comment">//从第4个位置往后插入xx</span><br>  cout&lt;&lt;s&lt;&lt;endl;<br><br>  <span class="hljs-comment">//要挪动数据效率很低，</span><br>  s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//从4位置，删除两个长度的字符</span><br>  cout&lt;&lt;s&lt;&lt;endl;<br>  s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//尾删</span><br>  s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//第二个参数不给值就后面全部都删除了</span><br><br>  <span class="hljs-comment">//尾删也可以</span><br><span class="hljs-comment">//s.pop_back();</span><br><br><span class="hljs-comment">//输入一整行的数据，包括‘ ’</span><br><span class="hljs-built_in">getline</span>(cin,s);<span class="hljs-comment">//第一个参数是流 </span><br><br><br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>  string s1=<span class="hljs-string">&quot;hello&quot;</span>;<br>  string s2=<span class="hljs-string">&quot;string&quot;</span>;<br>  cout&lt;&lt;(s1&lt;s2)&lt;&lt;endl;<span class="hljs-comment">//h&lt;s所以就是小于</span><br><br>  cout&lt;&lt;(<span class="hljs-string">&quot;hello&quot;</span>&lt;s2)&lt;&lt;endl;<span class="hljs-comment">//char*的也可以比较</span><br>  cout&lt;&lt;(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>)&lt;s2)&lt;&lt;endl;<span class="hljs-comment">//这样也是可以的</span><br>&#125;<br><br><br><br><span class="hljs-comment">//字符串与整形的转化</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string6</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-type">int</span> val=<span class="hljs-built_in">stoi</span>(<span class="hljs-string">&quot;1234&quot;</span>);<span class="hljs-comment">//转变成int</span><br>  cout&lt;&lt;val&lt;&lt;endl;<span class="hljs-comment">//1234</span><br>  <span class="hljs-type">double</span> val1=<span class="hljs-built_in">stod</span>(<span class="hljs-string">&quot;123&quot;</span>);<br>  <span class="hljs-comment">//转变成字符串</span><br>  string str=<span class="hljs-built_in">to_string</span>(<span class="hljs-number">12.345</span>);<br>string s=<span class="hljs-built_in">to_string</span>(<span class="hljs-number">123456</span>);<br><br><br>  string str = <span class="hljs-built_in">to_string</span>(<span class="hljs-number">12.345</span>);<br><br>&#125;<br><br><br><span class="hljs-comment">//浅拷贝，完成值拷贝，将每个字节一起拷贝</span><br><span class="hljs-comment">//对于指针类型的就不可以靠浅拷贝</span><br><span class="hljs-comment">//浅拷贝抄作业连名字都没改，完完全全的抄</span><br><span class="hljs-comment">//深拷贝就是抄作业改了名字，不完全的抄</span><br><span class="hljs-comment">//</span><br><br>classm  my_string <br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* _str;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">my_string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)<br>    :_str(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>])<br>    &#123;<br><span class="hljs-built_in">strcpy</span>(_str,str);<br>    &#125;<br><br>    <span class="hljs-comment">//拷贝构造要用深拷贝</span><br>    <span class="hljs-built_in">my_string</span>(<span class="hljs-type">const</span> my_string&amp; s)<br>      :_str(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>])<br>    &#123;<br>      <span class="hljs-built_in">strcpy</span>(_str,s.str);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_string7</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><br>&#125;<br><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//init();</span><br><span class="hljs-comment">//func();</span><br><span class="hljs-comment">//operatoracess();</span><br><span class="hljs-comment">//add();</span><br><span class="hljs-comment">//Solution sl;</span><br><br><span class="hljs-comment">//sl.reverseOnlyLetters(&quot;Test1ng-Leet=code-Q!&quot;);</span><br><span class="hljs-comment">//test_string1();</span><br><span class="hljs-comment">//test_string3();</span><br><span class="hljs-comment">//test_string2();</span><br><span class="hljs-comment">//test_string4();</span><br>Solution ts;<br>string s=<span class="hljs-string">&quot;hello world  &quot;</span>;<br><span class="hljs-comment">//int k=ts.lengthOfLastWord(s);</span><br><span class="hljs-comment">//cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="hljs-comment">//test_string6();</span><br><br>string s1 = <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span>;<br><br><span class="hljs-built_in">isPalindrome</span>(s1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 算法 visual studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux ----环境变量</title>
    <link href="/2022/03/17/Linux%20----%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2022/03/17/Linux%20----%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_3">进程的相关概念</a></li><li><a href="#_10">环境变量</a></li><li><ul><li><a href="#_48">常见的环境变量</a></li><li><a href="#_139">获得环境变量</a></li><li><a href="#_200">环境变量通常具有全局属性</a></li></ul></li></ul><h1 id="进程的相关概念"><a href="#进程的相关概念" class="headerlink" title="进程的相关概念"></a>进程的相关概念</h1><ul><li><strong>竞争性</strong>：系统进程数目众多，而CPU 资源只有少量，甚至1个，所以进程之间具有竞争属性，为了高效的完成任务，就有了优先级</li><li><strong>独立性</strong>：进程本身具有独立性，打开如何软件其他软件都不会受影响，需要独享资源，多个进程之间互不干扰</li><li><strong>并行</strong>：多个进程再多个CPU 下分别，同时运行</li><li><strong>并发</strong>：多个进程在一个CPU 下采用切换的方式，在一个时间段，多个进程都得以推进</li></ul><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br>  <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br>  <span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  4 </span>&#123;<br>  <span class="hljs-number">5</span>   <span class="hljs-type">int</span> cnt=<span class="hljs-number">5</span>;<br>  <span class="hljs-number">6</span>   <span class="hljs-keyword">while</span>(cnt--)<br>  <span class="hljs-number">7</span>   &#123;<br>  <span class="hljs-number">8</span>   ¦<span class="hljs-comment">// printf(&quot;I am a process ,pid %d,ppid %d\n&quot;,getpid(),getppid());</span><br>  <span class="hljs-number">9</span>   ¦ <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br> <span class="hljs-number">10</span>   ¦ <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am a cmd --&gt;process\n&quot;</span>);<br> <span class="hljs-number">11</span>                                                                                                                    <br> <span class="hljs-number">12</span>   &#125;<br> <span class="hljs-number">13</span>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-number">14</span> &#125;<br>~<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0c618f9274eb410db05c3232d4a1223e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>这些命令，程序工……本质上都是可执行的文件</p><p>那么我们运行的时候，为何要.&#x2F;???</p></blockquote><blockquote><p>.&#x2F;可以帮助系统确认对应的程序在哪里</p><p>那么为什么系统的命令不需要带路径呢？</p><blockquote><p>就是因为有环境变量</p></blockquote></blockquote><h2 id="常见的环境变量"><a href="#常见的环境变量" class="headerlink" title="常见的环境变量"></a>常见的环境变量</h2><ul><li>PATH ：指定命令的搜索路径</li></ul><p>echo $PATH</p><p>显示某个环境变量值，在这个环境变量里面的可执行文件就可以直接运行执行</p><p><img src="https://img-blog.csdnimg.cn/46c73704cc4b4fd3a183c0d796006c49.png" alt="在这里插入图片描述"></p><p>export</p><p><strong>添加设置一个新的环境变量</strong>，这样我们自己写的myproc就可以直接运行了<br><img src="https://img-blog.csdnimg.cn/1cfe05d6ef4a4171b6454bc6bec12ecf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/1c2d04a3863e4e30ae112905cd18e0ae.png" alt="在这里插入图片描述"></p><p>将本地变量导成环境变量</p><ul><li><p>set</p><p>显示本地定义的shell命令和环境变量</p></li><li><p>unset</p><p>清除环境变量<br><img src="https://img-blog.csdnimg.cn/d60b5951ce934debbae35504a2f05f08.png" alt="在这里插入图片描述"></p></li><li><p>HOME</p><p>指定用户的主目录<br><img src="https://img-blog.csdnimg.cn/58cd078b76474504bee50140aa63ab9e.png" alt="在这里插入图片描述"></p></li><li><p>env</p></li></ul><p><img src="https://img-blog.csdnimg.cn/d08da37af75b430f8ae322017b10913d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>显示所有的环境变量</p><ul><li>echo 显示某个环境变量的值</li></ul><p>语言上面定义变量：本质上是在内存中开辟一个空间</p><blockquote><p>环境变量本质上，<strong>OS</strong> 在<strong>内存&#x2F;磁盘文件</strong>中<strong>给自己开辟的空间</strong>，用来<strong>保存系统相关的数据</strong></p></blockquote><p>环境变量</p><p>：变量名+变量内容（a，10）</p><p>系统上还有一种变量，是与本次登录有关的变量，只在本次登录有效，叫做本地变量</p><p>以空格为分隔符，每个都看作字符串，argv[0]&#x3D;当前目录，程序的名字，最后一个元素指向NULL</p><p>argc决定有几个有效的元素</p><p><img src="https://img-blog.csdnimg.cn/35b10088e3824d339ef8408a291498c7.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eduG3KHr-1647503602595)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220316130008181.png)]"></p><h2 id="获得环境变量"><a href="#获得环境变量" class="headerlink" title="获得环境变量"></a>获得环境变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc ,<span class="hljs-type">char</span>* argv[],<span class="hljs-type">char</span> *env[])</span><span class="hljs-comment">//可以获得环境变量的字符串数组，和argv相类似</span></span><br><span class="hljs-function"> 4   <span class="hljs-comment">//argv是一个字符串数组，有argc个变量</span></span><br><span class="hljs-function"> 5 </span>&#123;<br> <span class="hljs-number">6</span>   <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br> <span class="hljs-number">7</span>   <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;env[j];j++)<span class="hljs-comment">//这个是系统自动给我们添加的，所以不带数字的参数</span><br> <span class="hljs-number">8</span>   &#123;                                                                                                                                                                                              <br> <span class="hljs-number">9</span>   ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,env[j]);<span class="hljs-comment">//因为最后一个数据是NULL</span><br><span class="hljs-number">10</span>   &#125;<br><span class="hljs-number">11</span>   <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-number">12</span>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;argc;i++)<br><span class="hljs-number">13</span>   &#123;<br><span class="hljs-number">14</span>   ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argv[%d]=%s\n&quot;</span>,i,argv[i]);<br><span class="hljs-number">15</span>   &#125;<br><span class="hljs-number">16</span> <span class="hljs-comment">//  int cnt=5;</span><br><span class="hljs-number">17</span> <span class="hljs-comment">//  while(cnt--)</span><br><span class="hljs-number">18</span> <span class="hljs-comment">//  &#123;</span><br><span class="hljs-number">19</span> <span class="hljs-comment">//   // printf(&quot;I am a process ,pid %d,ppid %d\n&quot;,getpid(),getppid());</span><br><span class="hljs-number">20</span> <span class="hljs-comment">//    sleep(1);                                                                                                  </span><br><span class="hljs-number">21</span> <span class="hljs-comment">//    printf(&quot;I am a cmd --&gt;process\n&quot;);                 </span><br><span class="hljs-number">22</span> <span class="hljs-comment">//                                                                </span><br><span class="hljs-number">23</span> <span class="hljs-comment">//  &#125;             </span><br><span class="hljs-number">24</span>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                         <br><span class="hljs-number">25</span> &#125; <br></code></pre></td></tr></table></figure><p>函数如果没有参数，可以传参吗</p><blockquote><p>是可以的，只不过获取数据的参数</p></blockquote><p>常见的获得环境变量的方式</p><p>getenv（char *name）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PATH: %s &quot;</span>,getenv(<span class="hljs-string">&quot;PATH&quot;</span>));<span class="hljs-comment">//获得PATH 的环境变量</span><br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是我们也很少获取环境变量</p><h2 id="环境变量通常具有全局属性"><a href="#环境变量通常具有全局属性" class="headerlink" title="环境变量通常具有全局属性"></a>环境变量通常具有全局属性</h2><p>父进程一直都不会变</p><p>父进程是命令行解释器</p><p>命令行上启动的进程，父进程都是bash（以及把系统的环境变量都导入的，，也可以继承给子进程），也是用fork启动的，</p><p><img src="https://img-blog.csdnimg.cn/4ba3795297a2457aac9bffeb720a1727.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LRgbApwk-1647503602596)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220317152931780.png)]"></p><p>my_env是一个本地变量</p><p>也可以被子进程继承</p><p><img src="https://img-blog.csdnimg.cn/0070fecfa1f648cc9c22f9a8c85ed57c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oRO2hW5m-1647503602596)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220317153254465.png)]"></p><p>但是不是环境变量</p><p><img src="https://img-blog.csdnimg.cn/9941130722cf4d4eaf735d7775e27b4e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IzeFqVkn-1647503602597)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220317153351778.png)]"></p><p><img src="https://img-blog.csdnimg.cn/6746a9c74d794b33b91e4d7d12e730ee.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hEksAeOI-1647503602598)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220317153715456.png)]"></p><p>我们在命令行上写的也是环境变量（是父进程的）</p><p><img src="https://img-blog.csdnimg.cn/b6f3c4a075714fc38e5d9442a84fd716.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pUCf5Wue-1647503602598)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220317153807734.png)]"></p><p>将这个变量导成环境变量，实际上是导给了bash的环境变量列表</p><p><img src="https://img-blog.csdnimg.cn/3eff0b0f38214ff4a8e004dcce94e921.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WdWNHsvz-1647503602598)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220317153915422.png)]"></p><p>导入之后就可以执行了</p><p><img src="https://img-blog.csdnimg.cn/138f6b28690e42c8b1d5d05a45b255ce.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2HuDkpUI-1647503602598)(E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220317154021128.png)]"></p><blockquote><p>环境变量具有全局属性，本质上我们的环境变量可以被子进程继承下去，一个bash被设置那么所有的子进程都可以继承下去bash的内容</p><p>我们定义的本地变量就无法继承，只能自己用，自己bash使用这个变量，子进程无法使用这个本地变量</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 运维 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统与进程（1）</title>
    <link href="/2022/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <url>/2022/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">冯诺依曼体系结构</a></li><li><a href="#_22">操作系统</a></li><li><ul><li><a href="#_25">是什么</a></li><li><a href="#_29">为什么</a></li><li><a href="#_33">怎么办</a></li></ul></li><li><a href="#_48">进程（软件）</a></li><li><ul><li><a href="#PCB_55">PCB</a></li><li><a href="#_61">如</a></li><li><a href="#vs_72">进程vs程序</a></li><li><a href="#PCB_83">PCB的内部构成</a></li><li><a href="#_116">查看进程的方案</a></li></ul></li><li><a href="#fork_125">fork</a></li><li><ul><li><a href="#fork_156">如何理解fork创建子进程</a></li><li><a href="#fork_186">fork的返回值</a></li><li><a href="#_248">对多进程的控制</a></li></ul></li><li><a href="#_287">进程状态</a></li><li><ul><li><a href="#_298">具体的状态</a></li><li><a href="#_401">状态代码验证</a></li><li><ul><li><a href="#R_403">R</a></li><li><a href="#S_424">S</a></li><li><a href="#_480">+</a></li><li><a href="#z_488">z</a></li><li><ul><li><a href="#_525">孤儿进程</a></li></ul></li></ul></li><li><a href="#_562">进程优先级</a></li><li><a href="#_570">查看进程的方案</a></li><li><ul><li><a href="#_614">优先级设置</a></li></ul></li></ul></li></ul><h1 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h1><p>冯诺依曼体系结构</p><p><img src="https://img-blog.csdnimg.cn/88d988efcff5488ba4c19e5397f3ac49.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>1.输入设备：键盘，磁盘（外设，读取文件（没读的时候就在磁盘）），网卡，显卡，话筒，摄像头(效率是s,ms级别)<br>2.输出设备：显示器，打印机，磁盘（写文件，就是把数据写到磁盘上），网卡，显卡，音箱等<br>3.存储器（内存）：离cpu越近的设备存储效率越高也越贵，有了内存，cpu就不用直接和外设打交道，存储器的快慢决定快慢（<strong>内存是体系结构的核心设备</strong>）<br>4.运算器&amp;&amp;控制器（CPU）：运算器（算术运算与逻辑运算）<br>控制器（读取指令，分析指令，执行指令）（效率ns级别）</p><p>如<br>a和b通过qq发消息<br><img src="https://img-blog.csdnimg.cn/6725f24a9a2c44bd85db91aee161d644.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>任何的外设，在数据层面，基本都是有限和内存打交道！，<br>cpu，在数据层面上，也直接和内存打交道</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>启动的（将软件数据与代码，加载到内存中）操作系统，才有意义</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><strong>OS</strong> 是一款<strong>软件</strong>，专门针对<strong>软硬件</strong>资源进行管理工作的<strong>软件</strong><br>（核心工作就是做管理的）</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p><strong>对下</strong>：管理好软硬件资源。对上：给用户提供<strong>稳定高效安全</strong>的运行环境<br><strong>方式</strong> <strong>目的</strong></p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><p>核心在<strong>管理</strong>，管理是对人的属性数据进行管理，描述属性结合的就是<strong>结构体</strong>，里面就有被管理者的全部数据，再加个联系指针<strong>连接</strong>起来（链表，哈希，树等），对<strong>学生</strong>的管理就变成了对链表的管理，对<strong>学生的褒奖工作</strong>就变成了对链表的<strong>增删查改</strong></p><p>本质（<strong>先描述再组织</strong>）</p><blockquote><p>管理理念：先描述，再组织，<br>可以转化成对目标的管理，<br>转化成对数据的管理</p></blockquote><p><img src="https://img-blog.csdnimg.cn/a779c12f3b404525b32c598d887fc0a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="进程（软件）"><a href="#进程（软件）" class="headerlink" title="进程（软件）"></a>进程（软件）</h1><p><strong>加载到内存</strong>的程序就叫做<strong>进程</strong><br>系统中可能存在大量的进程，操作系统要<strong>管理</strong>进程<br>如何管理进程？</p><blockquote><p>先描述，再组织<br>任何进程在形成的时候，操作系统要为该进程创建PCB，进程控制块（ 先描述，struct PCB 里面就是进程的所有属性，结构体描述），</p></blockquote><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>OS 上面，PCB 进程控制块，就是一个结构体类型<br>在Linux系统中，PCB -&gt;struct task_struct{ &#x2F;&#x2F;进程的所有属性 }</p><blockquote><p>类比shell和bash的关系<br>类比媒婆和王婆的关系</p></blockquote><h2 id="如"><a href="#如" class="headerlink" title="如"></a>如</h2><p>我们所有<strong>启动的程序</strong>的过程都是在系统上面<strong>创建进程</strong></p><p><img src="https://img-blog.csdnimg.cn/f157da24ee06426ab6a22173c5b7e78f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/96b8441b859b41238ca9b86bf8b15ecc.png" alt="在这里插入图片描述"><br>把程序运行起来，就是把程序加载到内存，就是把程序由磁盘加载到内存中变成一个进程<br><img src="https://img-blog.csdnimg.cn/4340816fb4194245af3dd531a5260c69.png" alt="在这里插入图片描述">进程的属性<br><img src="https://img-blog.csdnimg.cn/b9e3855bfe084bb5b4e4490db91f81f4.png" alt="在这里插入图片描述">程序运行结束进程就结束了<br><img src="https://img-blog.csdnimg.cn/1ee78da007a64127b1bf1b486d9616ae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="进程vs程序"><a href="#进程vs程序" class="headerlink" title="进程vs程序"></a>进程vs程序</h2><p><img src="https://img-blog.csdnimg.cn/e8d6a5bf81e74625832fca695ac99c6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/60b7f0dbbc314a32bb519abb0e3bb507.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>有了进程控制块，所有进程管理任务与进程对于的程序毫无关系！！！<br>与进程对应的内核创建的进程的 PCB 强相关</p><p>进程&#x3D;程序+操作系统维护进程的相关数据结构（更多的数据结构）（进程控制块）</p><h2 id="PCB的内部构成"><a href="#PCB的内部构成" class="headerlink" title="PCB的内部构成"></a>PCB的内部构成</h2><ul><li>pid：描述本进程的唯一标识符，原来区别其他进程</li></ul><p><img src="https://img-blog.csdnimg.cn/4ec0f76deb794e8b947066ac8fde4805.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/989ac926f94548a8a37917240c20480f.png" alt="在这里插入图片描述"></p><p>结束进程<br>kill -9 pid<br><img src="https://img-blog.csdnimg.cn/d58e4f877c7544419672ba39d8b4cf19.png" alt="5"><br><img src="https://img-blog.csdnimg.cn/0cf4cad7b58a4e2bb68a927baf867dd8.png" alt="在这里插入图片描述"></p><ul><li>ppid:获得其父的pid（在命令行上运行的命令，基本上其父进程都是-bash）</li></ul><p><img src="https://img-blog.csdnimg.cn/b5c73184c6904691874cc7fd8f97d06b.png" alt="在这里插入图片描述"></p><ul><li><p>状态：任务状态，退出代码，退出信号等。<br><img src="https://img-blog.csdnimg.cn/a158abe80a3f4d119d9b74d772f43c5d.png" alt="在这里插入图片描述">0<br>输出离他最近执行命令的退出码<br><img src="https://img-blog.csdnimg.cn/81acc03ae5c34e588a1389e8f044ba35.png" alt="在这里插入图片描述"></p></li><li><p>优先级：相对于其他进程的优先级，CPU 只有1个，进程有非常多个，确认先后的问题，</p></li><li><p>程序计数器：程序中即将被执行的<strong>下一条指令</strong>的<strong>地址</strong></p></li><li><p>内存指针：可以通过PCB 找到对应的代码和数据</p></li><li><p>IO状态信息：进程可能要进行的IO，（从输入设备读入）（输出设备读出），进程在进行IO，</p></li><li><p>记账信息：进程被os调度器调度的信息（os为了较为均衡的调用每个进程（获得cpu的资源（进程被执行））），有处理器时间总和，使用的时间限制，记帐号</p></li><li><p>上下文数据：（进程执行时处理器的寄存器中的数据）<strong>寄存器</strong>（当前正在运行的进程的临时数据）<br><strong>时间片</strong>（单次运行每个进程的最大时间10ms，没跑完，排到最后等待继续运行），在cpu情况下，用户感受到多个进程都在运行（靠cpu快速切换完成的），进程在运行期间是由切换的，进程可能存在大量的临时数据—-》暂时在cpu的寄存器中保存，</p></li></ul><blockquote><p>保护上下文<br>恢复上下文<br>虽然寄存器硬件只有一份，但是寄存器里面的数据是你这个进程的，走的时候，把寄存器里面的数据返回pcb里面，进入下一个进程，等待下一次使用，再进入时，再把之前的临时数据放回cpu</p></blockquote><p>通过上下文的保护和恢复，我们可以感受到进程被切换的</p><h2 id="查看进程的方案"><a href="#查看进程的方案" class="headerlink" title="查看进程的方案"></a>查看进程的方案</h2><p>ls &#x2F;proc<br><img src="https://img-blog.csdnimg.cn/9e0e5c8501c64af482e8dfc50721dbfc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/44a200d8ba844383b107a46411ba138b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>exe就是当前执行的文件路径<br>cwd就是当前工作路径</p><p><img src="https://img-blog.csdnimg.cn/61c02e9d39b94976ad20d613e8247797.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><p>fork就是用来创建子进程的</p><hr><p>演示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>  <span class="hljs-number">2</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br>  <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br>  <span class="hljs-number">4</span>  <br>  <span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  6 </span>&#123;                                                                 <br>  <span class="hljs-number">7</span>     fork();<span class="hljs-comment">//创建子进程</span><br>  <span class="hljs-number">8</span>     cout&lt;&lt;<span class="hljs-string">&quot;hello proc &quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;<span class="hljs-string">&quot;hello parent &quot;</span>&lt;&lt;<span class="hljs-built_in">getppid</span>()&lt;&lt;endl;<br>  <span class="hljs-number">9</span>     <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);                                                                                   <br> <span class="hljs-number">10</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                                                    <br>      <br> <span class="hljs-number">11</span> &#125;    <br></code></pre></td></tr></table></figure><blockquote><p>上面的代码我们fork后，只写了一行的打印，但是运行结果是有两条的内容</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f3e2b94a47584af08b44211457a6380b.png#pic_center" alt="在这里插入图片描述"></p><h2 id="如何理解fork创建子进程"><a href="#如何理解fork创建子进程" class="headerlink" title="如何理解fork创建子进程"></a>如何理解fork创建子进程</h2><blockquote><ol><li><p>有我们在命令行里面.&#x2F;cmd or run command(执行指令) ,与<strong>fork</strong>相比：在操作系统角度上，创建进程的方式都是没有差别的，只不过fork创建的进程间有<strong>父子关系</strong></p></li><li><p>fork本质是<strong>创建进程</strong> -—&gt; 系统里面<strong>多了一个进程</strong> —&gt;在系统里面多了一份与进程相关的内核数据结构 （task_struct） + 进程的代码和数据(我们只是fork了，创建了子进程，但是子进程对应的代码和数据)———》</p></li></ol><ul><li>默认情况下，会继承父进程的代码和数据</li><li>内核数据结构task_struct 也会以父进程为模板，初始化子进程的task_struct</li></ul><blockquote><p>例如父亲是做鞋的工厂老板，那么你就会继承父亲的基因（数据结构），同时你也会子承父业继续做鞋（继承代码和数据）</p></blockquote><blockquote><hr></blockquote><p><strong>进程具有独立性</strong></p><blockquote><ol><li>代码</li></ol></blockquote><blockquote><ul><li>fork之后子进程和父进程代码是共享的</li><li>代码是不可以被修改的</li><li>父子代码只有一份</li></ul></blockquote><blockquote><ol start="2"><li>数据</li></ol></blockquote><blockquote><ul><li><strong>默认情况</strong>下“数据也是共享的”，不过因为进程具有独立性，所以也要考虑修改的情况</li><li>可以通过“写时拷贝”来完成进程数据的独立性</li></ul></blockquote></blockquote><h2 id="fork的返回值"><a href="#fork的返回值" class="headerlink" title="fork的返回值"></a>fork的返回值</h2><p>我们创建的子进程，就是为了和父进程干一样的事情？？？</p><p>一般是没有意义的，我们一般还是希望要让父进程和子进程做不一样的事</p><p>我们通常是用fork的返回值来完成</p><blockquote><ul><li>失败: &lt;0</li><li>成功:<ul><li>给父进程返回子进程的pid</li><li>给子进程返回0</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                                       </span><br> <span class="hljs-number">2</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;             <br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span>  </span><br> <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>  </span><br> <span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"> 6 </span>&#123;  <br> <span class="hljs-number">7</span>     <span class="hljs-type">pid_t</span> id=fork();<span class="hljs-comment">//获得其返回值 </span><br> <span class="hljs-number">8</span>     cout&lt;&lt;<span class="hljs-string">&quot;hello proc &quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt; <span class="hljs-string">&quot; hello parent &quot;</span>&lt;&lt;<span class="hljs-built_in">getppid</span>()&lt;&lt;<span class="hljs-string">&quot; ret: &quot;</span>&lt;&lt; id &lt;&lt;endl;  <br> <span class="hljs-number">9</span>     <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);                                                                                            <br><span class="hljs-number">10</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                                      <br><span class="hljs-number">11</span> &#125;    <br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0932e104a1084a58a2a23c77449129d4.png#pic_center" alt="在这里插入图片描述"></p><ol><li><p>如何理解有两个返回值？</p><blockquote><p>如果一行函数已经执行return，那么函数的核心功能执行完了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建子进程的逻辑</span><br><br> <span class="hljs-keyword">return</span> XXX;<span class="hljs-comment">//也是语句，父子共享return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>到return的时候，他创建子进程的逻辑也完了，所以子进程已经有了，父进程要return，子进程也要return</p></blockquote><ul><li>返回的是数据吗？return的时候也会写入吗？</li></ul><blockquote><p>返回的也是数据，会，发生了写时拷贝</p></blockquote></li><li><p>如何理解两个返回值的设置</p><blockquote><p>父：子&#x3D;1：n，</p><p>子进程的父进程只有1个，而父进程可以有很多的子进程，所以要得到其子进程的pid来控制子进程，而子进程通过ppid就可以找到父进程</p></blockquote></li></ol><h2 id="对多进程的控制"><a href="#对多进程的控制" class="headerlink" title="对多进程的控制"></a>对多进程的控制</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pid_t</span> id=fork();<br>    <span class="hljs-keyword">if</span>(id==<span class="hljs-number">0</span>)<span class="hljs-comment">//利用if else，进行分流，实现父子进程完成不同的事</span><br>    &#123;<br><span class="hljs-comment">//child</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;I am 子进程 pid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;<span class="hljs-string">&quot; ppid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getppid</span>()&lt;&lt;endl;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(id&gt;<span class="hljs-number">0</span>)<br>    &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;I am 父进程 pid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;<span class="hljs-string">&quot; ppid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getppid</span>()&lt;&lt;endl;<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><span class="hljs-comment">//todo</span><br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>fork之后谁先跑呢？？</p><p>不确定</p><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>进程的状态信息在哪里呢？？<br>在 task_struct(PCB)</p><p>进程状态的意义：</p><p>方便OS 快速判断进程，完成特定的功能，比如调度，本质是一种分类</p><h2 id="具体的状态"><a href="#具体的状态" class="headerlink" title="具体的状态"></a>具体的状态</h2><ul><li><p>R：<strong>运行态</strong>，不一定正在CPU上面正在运行，但是如果处于<strong>运行的队列</strong>（<strong>等待CPU</strong>）中，那么这些状态都可以称为<strong>R状态</strong>，随时都可以被CPU进行调度</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-p20zfQoB-1647504125418)(picture&#x2F;image-20220310140329017.png)]</p></li><li><p>S&#x2F;D：<strong>睡眠状态</strong>，当我们想要完成某种任务的时候，任务条件不具备，需要进程进行某种等待时，就S，D，<strong>等待资源就绪</strong></p><p>如：今天想打游戏，但是电脑没开，那么我们就要开机等待电脑开机，那么此时我们就是S，D</p><hr><blockquote><p>所谓的进程，在运行的时候可能会因为运行的需要，可以会在不同的队列里，</p><p>在不同的队列里面，所处的状态是不一样的</p></blockquote><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3K13Q8eR-1647504125419)(picture&#x2F;image-20220310141732027.png)]</p></li></ul><blockquote><p>如果资源就绪了那么S状态就变成了R状态，放到运行队列里，</p><p>如果这个进程突然卡死了，那OS就会把他从运行队列放到等待队列里面去</p></blockquote><blockquote><p>我们把，从运行状态的task_struct（run_queue）,放到等待队列中，就叫做挂起等待（阻塞）</p><p>从等待队列，放到运行队列，被CPU调度，就叫做唤醒进程</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unist.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello &quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0vxSbIJj-1647504125420)(picture&#x2F;image-20220310144349978.png)]</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uAi5lsGD-1647504125420)(picture&#x2F;image-20220310143310732.png)]</p><blockquote><p>等待我们设定的10s就绪，那么他就处于S状态，</p><p>可以直接立即终止（可中断睡眠）</p></blockquote><ul><li><p><strong>深度睡眠</strong> ；不可中断睡眠，</p><blockquote><p>假设进程发出了一个命令，要将1t数据（数据量非常大）都放到磁盘里面，让磁盘去读写，之后磁盘就开始工作了，这个时候进程就开始等待</p><p>等待磁盘把任务完成，这个时候，OS来了发现进程在休息，就把他给杀掉了，</p><p>磁盘读写完了，要把失败与否的结论告诉进程，但是发现进程不见了，</p><p>进程：是OS把我杀掉的</p><p>磁盘：是进程不见的</p><p>没有办法解决问题</p><hr><p>本质上是因为操作系统把正在等待的进程给杀掉的</p></blockquote><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JH3pVRNg-1647504125421)(picture&#x2F;image-20220310153558797.png)]</p></li></ul><p>所以为了解决这个问题，就有了深度睡眠的D状态，</p><p><strong>进程进入了D状态，不可被杀掉</strong></p><ul><li><p>T :<strong>暂停状态</strong>，完全暂停不会因为某种条件达成变成R,做某些任务的时候，进程需要暂停</p></li><li><p>t（trace stop）：经常调试程序的时候，在调试的时候，进程所处的状态，打个断点，就停下来了，临时查看很多资源数据</p></li><li><p>x（dead）：<strong>死亡状态</strong>，回收进程资源&#x3D;进程相关的数据结构+你的代码和数据（和创建的操作是一样的），死亡状态无法查到</p></li><li><p>z（zombie）：<strong>僵尸状态</strong>，先进入僵尸状态再进入死亡状态</p><hr><ul><li><p>为什么要有僵尸状态</p><blockquote><p>为了辨别退出<strong>死亡</strong>原因，进程退出时要暂时保存退出的信息</p><p>在task_struct存了进程退出的所有信息</p></blockquote></li></ul></li></ul><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VWpdwoVG-1647504125421)(<a href="https://raw.githubusercontent.com/zevin02/image/master//%20202203121022560.png/)/]">https://raw.githubusercontent.com/zevin02/image/master/\%20202203121022560.png\)\]</a></p><h2 id="状态代码验证"><a href="#状态代码验证" class="headerlink" title="状态代码验证"></a>状态代码验证</h2><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>：没有IO ，所以就不用等待</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">2</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">4 </span>&#123;<br><span class="hljs-number">5</span>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-number">6</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                                                            <br><span class="hljs-number">7</span> &#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e4f98f27ffd0545cd51bb54b5e8aec79.png" alt="image-20220311102359163"></p><h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>  <span class="hljs-number">2</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>  <span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  4 </span>&#123;<br>  <span class="hljs-number">5</span>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-number">6</span>     &#123;<br>  <span class="hljs-number">7</span>        cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;endl;<br>  <span class="hljs-number">8</span>     &#125;                                                                                              <br>  <span class="hljs-number">9</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         <br> <span class="hljs-number">10</span> &#125;                     <br>~         <br></code></pre></td></tr></table></figure><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RYSD1QuG-1647504125422)(<a href="https://raw.githubusercontent.com/zevin02/image/master//%20202203111201188.png/)/]">https://raw.githubusercontent.com/zevin02/image/master/\%20202203111201188.png\)\]</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/127f153ba86c6066cf94fe6b5b71db1b.png" alt="image-20220311102847664"></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-w6blxo0h-1647504125423)(<a href="https://raw.githubusercontent.com/zevin02/image/master//%20202203121024675.png/)/]">https://raw.githubusercontent.com/zevin02/image/master/\%20202203121024675.png\)\]</a></p><p>有可能还能检测到r状态</p><blockquote><p>打印，是往显示器打印，外设慢，IO，实际上等待外设就绪是很慢的，所以大部分状态都是S状态，CPU太快了</p></blockquote><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NWVrfyha-1647504125423)(<a href="https://raw.githubusercontent.com/zevin02/image/master//%20202203121028603.png/)/]">https://raw.githubusercontent.com/zevin02/image/master/\%20202203121028603.png\)\]</a></p><p>暂停进程</p><p><img src="https://img-blog.csdnimg.cn/img_convert/aef691ce3611944417e58e18c8b31de1.png" alt="image-20220311104417143"></p><p>继续进程</p><p>后面没有+号，在后台运行</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e94c02036508e9f388ac207b67fb7e7c.png" alt="image-20220311104606124"></p><p>但是按ctrl c无法结束进程</p><p>结束进程</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a2b3474591e579a18d58b45c3f9d1d92.png" alt="image-20220311104640401"></p><h3 id=""><a href="#" class="headerlink" title="+"></a>+</h3><p>：带了+，说明是在前台运行，在命令行输入任何内容都是没有用的，但是ctrl c来干掉进程</p><p>后台进程.&#x2F;myproc &amp;，就变成后台进程，可以在命令行中输入命令，无法用ctrl c来结束进程，只能用kill -9 pid来结束进程</p><h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>如果没有人检测回收进程（父进程），该进程退出或进入z</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                                                                </span><br>  <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br>  <span class="hljs-number">3</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>  <span class="hljs-number">4</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>                                       </span><br><span class="hljs-function">  5 </span>&#123;                 <br>  <span class="hljs-number">6</span>     <span class="hljs-type">pid_t</span> id=fork();<br>  <span class="hljs-number">7</span>     <span class="hljs-keyword">if</span>(id==<span class="hljs-number">0</span>)<br>  <span class="hljs-number">8</span>     &#123;                 <br>  <span class="hljs-number">9</span>        <span class="hljs-comment">//child       </span><br> <span class="hljs-number">10</span>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br> <span class="hljs-number">11</span>       &#123;                <br> <span class="hljs-number">12</span>          cout&lt;&lt;<span class="hljs-string">&quot;I am child,running&quot;</span>&lt;&lt;endl;<br> <span class="hljs-number">13</span>           <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br> <span class="hljs-number">14</span>        &#125;                                   <br> <span class="hljs-number">15</span>     &#125;                                       <br> <span class="hljs-number">16</span>     <span class="hljs-keyword">else</span>           <br> <span class="hljs-number">17</span>     &#123;  <br> <span class="hljs-number">18</span>        <span class="hljs-comment">//father</span><br> <span class="hljs-number">19</span>        cout&lt;&lt;<span class="hljs-string">&quot;I am father ,doing nothing&quot;</span>&lt;&lt;endl;<br> <span class="hljs-number">20</span>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">50</span>); <br> <span class="hljs-number">21</span>     &#125;  <br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-number">22</span> &#125;<br>      <br></code></pre></td></tr></table></figure><p>把<strong>子进程给终止掉</strong>，但是父进程没有回收，就变成了僵尸进程</p><p>（子进程先死了，父进程还在运行）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/05e150fa957b664e423420db6e0bc646.png" alt="image-20220311111949238"></p><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>被1号进程领养，1号进程也叫做操作系统OS</p><p>父进程终止了，子进程还在运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                                                                </span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-number">3</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-number">4</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>                                       </span><br><span class="hljs-function"> 5 </span>&#123;                 <br> <span class="hljs-number">6</span>     <span class="hljs-type">pid_t</span> id=fork();<br> <span class="hljs-number">7</span>     <span class="hljs-keyword">if</span>(id==<span class="hljs-number">0</span>)<br> <span class="hljs-number">8</span>     &#123;                 <br> <span class="hljs-number">9</span>        <span class="hljs-comment">//child       </span><br><span class="hljs-number">10</span>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-number">11</span>       &#123;                <br><span class="hljs-number">12</span>          cout&lt;&lt;<span class="hljs-string">&quot;I am child,running&quot;</span>&lt;&lt;endl;<br><span class="hljs-number">13</span>           <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br><span class="hljs-number">14</span>        &#125;                                   <br><span class="hljs-number">15</span>     &#125;                                       <br><span class="hljs-number">16</span>     <span class="hljs-keyword">else</span>           <br><span class="hljs-number">17</span>     &#123;  <br><span class="hljs-number">18</span>        <span class="hljs-comment">//father</span><br><span class="hljs-number">19</span>        cout&lt;&lt;<span class="hljs-string">&quot;I am father ,doing nothing&quot;</span>&lt;&lt;endl;<br><span class="hljs-number">20</span>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-number">21</span>     &#125;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">22</span> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0fd60e0184c37a45e9311815f6c07797.png" alt="image-20220311112302660"></p><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>为什么会有优先级？</p><p>本质上是资源太少的问题，优先级本质是获得资源，分配资源的一种方式</p><h2 id="查看进程的方案-1"><a href="#查看进程的方案-1" class="headerlink" title="查看进程的方案"></a>查看进程的方案</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br>  <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br>  <span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  4 </span>&#123;<br>  <span class="hljs-number">5</span>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-number">6</span>   &#123;<br>  <span class="hljs-number">7</span>   ¦ <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am a process ,pid %d,ppid %d\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">getppid</span>());                           <br>  <span class="hljs-number">8</span>   ¦ <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-number">9</span>   &#125;<br> <span class="hljs-number">10</span>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-number">11</span> &#125;<br>~<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>UID</strong> 相当于我的名字，不过他是以数字来标识（类似身份证号码）</p><p><strong>PRI</strong>就是优先级数据</p><p>NI优先级的修正数据，</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/727a41d2d438641b94cbe380176374b0.png" alt="image-20220314163706374"></p><blockquote><p>linux中的优先级数据，值越小，优先级越高，</p><p>就尽快的享受到某种资源</p></blockquote><p>PRI vs NI</p><blockquote><p>加入nice值，PRI（new）&#x3D;PRI（old）+nice</p><p>所以nice为正，优先级变满，</p><p>反之亦然</p></blockquote><p>特别不建议自己修改优先级</p><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>nice值（-20~19）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e5ef9ff7dbe3a0452e417cca19218788.png" alt="image-20220314165836267"></p><p>old不会因为之前的改变而改变，还是一开始的值</p><p>nice值为什么是一个相对小的范围</p><blockquote><p>优先级再怎么设置，也只能是一种相对的优先级，不能出现绝对的优先级，避免有的进程出现饥饿问题，而我们的调度器</p><p>就是为了较为均衡的让每个进程享受到CPU资源，</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git（3）</title>
    <link href="/2022/02/25/git%EF%BC%883%EF%BC%89/"/>
    <url>/2022/02/25/git%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">分支</a></li><li><ul><li><a href="#_4">什么是分支</a></li><li><a href="#_13">操作分支</a></li></ul></li><li><a href="#_22">分支冲突</a></li></ul><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支"></a>什么是分支</h2><p>（1）什么是分支：<br>在版本控制过程中，使用多条先同时推进多个任务，这里面的多条线就是分支<br>（2）通过一张图来演示一下<br><img src="https://img-blog.csdnimg.cn/561e75e8b7504fdc9dbf192910f13dd8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">（3）分支的好处：<br>多个分支可以并行开发，互相不耽误，互相不影响，提高开发效率<br>如果有一个分支，功能开发失败，直接删除这个分支就可以了，不会对其他分支产生其他任何影响</p><h2 id="操作分支"><a href="#操作分支" class="headerlink" title="操作分支"></a>操作分支</h2><p>（1）创建test4.txt<br>（2）查看分支</p><p><img src="https://img-blog.csdnimg.cn/93faf73872fe430b842e7b166985070a.png" alt="在这里插入图片描述">（3）创建分支<br><img src="https://img-blog.csdnimg.cn/43b38d696f08461788a34f759d6ae173.png" alt="在这里插入图片描述">（4）切换分支</p><p><img src="https://img-blog.csdnimg.cn/153cbb14a1254f8b9f02c5ead077ebbc.png" alt="在这里插入图片描述"></p><h1 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h1><p>在branch01分支里面添加了东西不影响master里面的东西<br><img src="https://img-blog.csdnimg.cn/37824d9b2d6e406f81b02ff163a1b369.png" alt="在这里插入图片描述">在master里面添加了东西不影响分支里面的东西</p><p><img src="https://img-blog.csdnimg.cn/86eb92b094a24df68c576cb8531fc45d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>现在我们想让他们合并到master</p><p>（1）切换到主分支<br>（2）让branch里面的内容和master进行合并<br><img src="https://img-blog.csdnimg.cn/6c0d4f945b654286a3300e500f147c25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">什么时候会冲突？在同一个文件的同一个位置修改<br>查看文件：出现冲突<br><img src="https://img-blog.csdnimg.cn/87ba4ffa2c084fa987022b6e3702e7a8.png" alt="在这里插入图片描述">上面的是master里面修改的内容，下面的就是branch01里面修改的内容</p><p>解决就是：<br>公司内部商议解决，或者自己决定，人为决定</p><p><img src="https://img-blog.csdnimg.cn/c896ae153aa64573b1da0f1b7c526089.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d3e862186fdb4cdcad9ca176c623db11.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_18,color_FFFFFF,t_70,g_se,x_16" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux编程必备（yum vim gcc g++ gdb makefile）</title>
    <link href="/2022/02/23/linux%E7%BC%96%E7%A8%8B%E5%BF%85%E5%A4%87%EF%BC%88yum%20vim%20gcc%20g++%20gdb%20makefile%EF%BC%89/"/>
    <url>/2022/02/23/linux%E7%BC%96%E7%A8%8B%E5%BF%85%E5%A4%87%EF%BC%88yum%20vim%20gcc%20g++%20gdb%20makefile%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#yum_1">yum</a></li><li><ul><li><a href="#_14">下载安装</a></li><li><a href="#_18">删除软件</a></li></ul></li><li><a href="#vim_24">vim</a></li><li><ul><li><a href="#_42">命令模式</a></li><li><a href="#_81">底行模式</a></li><li><a href="#_92">插入模式</a></li><li><a href="#vim_99">vim的配置</a></li></ul></li><li><a href="#gccg_104">gcc和g++</a></li><li><ul><li><a href="#gcc_106">gcc</a></li><li><ul><li><a href="#_108">背景知识</a></li><li><a href="#gcc_123">gcc简单演示</a></li><li><a href="#gcc_132">gcc选项</a></li><li><ul><li><a href="#_134">预处理</a></li><li><a href="#_142">编译</a></li><li><a href="#_147">汇编</a></li><li><a href="#_156">链接</a></li><li><ul><li><a href="#_168">函数库</a></li></ul></li></ul></li></ul></li><li><a href="#g_180">g++</a></li></ul></li><li><a href="#gdb_188">gdb</a></li><li><ul><li><a href="#_201">选项</a></li><li><ul><li><a href="#run_203">run</a></li><li><a href="#listl_208">list&#x2F;l</a></li><li><a href="#bbreakpoint_215">b（breakpoint）（打断点）</a></li><li><a href="#s_224">s</a></li><li><a href="#n_228">n</a></li><li><a href="#display_230">display</a></li><li><ul><li><a href="#p_235">p</a></li><li><a href="#undisplay_239">undisplay</a></li></ul></li><li><a href="#finish_243">finish（结束当前函数）</a></li><li><a href="#ccontinue_247">c（continue）</a></li><li><a href="#until_251">until</a></li><li><a href="#d_255">d</a></li><li><a href="#disable_261">disable</a></li></ul></li></ul></li><li><a href="#makemakefile_268">make&#x2F;makefile</a></li></ul><h1 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h1><p>（等同于手机上的应用市场）<br>Linux中安装软件并不简单<br>方法<br>1.源码安装，编译一个源码进行安装<br>2.rpm安装，安装包<br>3.Linux可能存在大量软件之间的依赖关系，就需要安装许多第三方库，安装非常麻烦，因此可以使用<br><strong>yum</strong>，自己会考虑依赖关系，而不许要我们去处理<br><strong>查找软件</strong><br><img src="https://img-blog.csdnimg.cn/ac125774683648e0a17f3eb007a72837.png" alt="在这里插入图片描述"><br>可以搭配grep进行搜索过滤<br><img src="https://img-blog.csdnimg.cn/1835b2e7fa0445228adf2202d4fc4535.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>yum install (软件名)<br><img src="https://img-blog.csdnimg.cn/d6ce997b6b3e4aa196b042b316bbc55f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="删除软件"><a href="#删除软件" class="headerlink" title="删除软件"></a>删除软件</h2><p>yum remove （软件名）<br><img src="https://img-blog.csdnimg.cn/2eb6de6ef8a14c11b342a8b794926659.png" alt="在这里插入图片描述"></p><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><ul><li>IDE集成开发环境，干什么都可以，而linux里面可以安装这样的集成开发环境，但是我们一般不会这么做</li></ul><blockquote><ul><li>编写代码 —》vim（vi的升级版）.vi 文本编辑器，从定位上和记事本没有任何差别，都是用来写代码的（只能写代码）</li><li>编译代码</li><li>调试代码</li><li>发布代码，运行<br>代码关系的维护（.h文件谁包含谁）<br>这些写代码都要包含</li></ul></blockquote><p>vim是多模式的编辑器<br>（默认是命令模式）<br>进入后按i可以插入文字</p><p>还有底行模式<br><img src="https://img-blog.csdnimg.cn/4e678061dabe4aeeb4d0da8413bc6325.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>光标我们不用键盘中的上下左右<br>而用hjkl</p><blockquote><p>h 在这4个字母的最左边所以是光标向<strong>左</strong>移动<br>l在最右边所以是向<strong>右</strong>移动<br>j（jump）向下跳，所以是向下移动<br>k（king）国王高高在上，所以向上移动</p></blockquote><blockquote><p>光标位置锚点，快速定位到行首 shift+^<br>行尾 shift+$<br>gg光标直接定位到第一行<br>shift+g直接定位到行尾<br>n+shift +g 快速定位到指定行<br>w可以按照单词为单位，一个单词一个单词向后进行查找<br>b向前移动</p></blockquote><blockquote><p>复制粘贴<br>yy复制当前行<br>p就粘贴<br>n+p就是一次重复粘贴n行<br>2yy就从当前行往下两行复制（多行复制）<br>u就可以撤销之前的操作<br>dd：删除当前光标所在行<br>dd+p就是剪切<br>n+dd就是<br>shift+~大小写切换<br>（小写）x就会把当前所在光标的1个字符给删掉<br>n+x就会把光标之后的n个字符给删掉<br>（大写）X就会从光标处往前删除字符<br>n+X就会从光标处往前删除n个字符<br>r可以替换光标处的字符<br>shift r（替换模式），可以实现多个内容的替换<br>ctrl r撤销刚才的撤销</p></blockquote><p>在插入模式也可以这样弄，但是特别慢</p><h2 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h2><p>shift ：</p><blockquote><p>set nu可以把行号调出来<br>set nonu就取消行号<br>vs .c可以实现不同文件的分屏显示<br>ctrl ww就可以在不同屏中光标切换<br>wq就是退出光标所在的屏幕<br>w是保存<br>q是退出<br>！强制</p></blockquote><h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><p>进入插入模式有<br>a光标往后移动一位进入插入模式<br>o就是光标往下一行进入插入模式</p><p>插入模式不能进入底行模式</p><h2 id="vim的配置"><a href="#vim的配置" class="headerlink" title="vim的配置"></a>vim的配置</h2><p>vim配置在自己的配置文件中，只会影响自己的操作，不会影响别的用户<br>root有自己的配置文件，只影响自己，<br>(只会影响自己，不会影响别人)</p><h1 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h1><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ul><li>预处理（进行宏替换，去注释，头文件展开，条件编译）</li><li>编译（生成汇编）</li><li>汇编（生成机器可识别代码）</li><li>连接（生成可执行文件或库文件）</li></ul><p>1.为什么c程序的翻译是这个过程</p><blockquote><ul><li>一开始都是二进制编程（打孔编程），只有高级科研人才才可以写</li><li>出现了汇编语言 助记符，利用编译器变成二进制代码</li><li>出现了c语言，先变成汇编语言，更加简单，开发效率更加高<br>C语言中有很多需要被提前处理的，比如注释等</li></ul></blockquote><p>2.链接如何理解</p><blockquote><p>自己写的c程序和语言上或者第三方库</p></blockquote><h3 id="gcc简单演示"><a href="#gcc简单演示" class="headerlink" title="gcc简单演示"></a>gcc简单演示</h3><p>在vim上编写mycode.c文件<br><img src="https://img-blog.csdnimg.cn/b220d38cc7ed4340b4c4815824cd7078.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/3391a8d1cfc0410e9bd808da4a7ce0d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">gcc是编译c语言程序</p><ul><li>gcc [目标文件]</li><li>.&#x2F;a.out</li></ul><p><img src="https://img-blog.csdnimg.cn/ad91994cedad463baa378c248a7b599f.png" alt="在这里插入图片描述"></p><h3 id="gcc选项"><a href="#gcc选项" class="headerlink" title="gcc选项"></a>gcc选项</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>gcc -E mycode.c :开始进行翻译，完成预处理之后，就停下来不做下面的事情<br><img src="https://img-blog.csdnimg.cn/d04d1132a6394c568a4ae1e5f6692ce7.png" alt="在这里插入图片描述">将预处理生成的写入一个临时文件 mycode.i（已经经过了预处理阶段）</p><p><img src="https://img-blog.csdnimg.cn/d863d211b22442ba9af1369ab3a61a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/132140cf87a04a8395d23c25a5576a68.png" alt="在这里插入图片描述"></p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>gcc -S mycode.c（-S，开始进行程序的翻译，完成编译之后就停下来就不要往后走了）<br><img src="https://img-blog.csdnimg.cn/3158c3f6e977420394b92751490c9ccd.png" alt="在这里插入图片描述">因为已经经过了预处理所以可以直接使用mycode.i，跳过预处理阶段，并将生成的临时文件放入mycode.s里面<br><img src="https://img-blog.csdnimg.cn/942d6d909733421fb38f6c81ad30663a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">生成了汇编语言</p><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>计算机不可以直接执行汇编语言<br>汇编语言需要编译器<br>gcc -c mycode.c(从源文件开始)<br>也可以gcc -c mycode.s<br><img src="https://img-blog.csdnimg.cn/75a782e7d1e44b94b81df6bbe952f0af.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/77990438b190410183052c1364034512.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">汇编形成的二进制文件并不可以直接执行，叫做可重定向目标文件</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>语言也是有库的！调用了第三方的语言库（一套头文件+一套库文件（libc.a,libc.so））<br>需要链接将我们自己的代码中的函数调用，外部数据，和库关系起来</p><ul><li>gcc mycode.o<br>gcc mycode.o -o mycode<br>自定义生成可执行程序的名字<br>.&#x2F;mycode<br><img src="https://img-blog.csdnimg.cn/799540d423dd4a5a8e81fd27ddd140af.png" alt="在这里插入图片描述">方便的时候也可以<br>gcc mycode.c -o mycode(生成可执行程序)<strong>推荐</strong><br>.&#x2F;mycode<br><img src="https://img-blog.csdnimg.cn/e987996e6d72497dae3550274b08dee2.png" alt="在这里插入图片描述"></li></ul><h5 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h5><p>linux分为：</p><ul><li><p>静态库： .a，指编译链接时，<strong>把库文件</strong>的代码<strong>全部</strong>加入到<strong>可执行文件</strong>中，因此生成的文件比较大，但在运行时也就不再需要库文件了，其后缀名一般为“.a”，<strong>静态链接</strong></p></li><li><p>动态库: .so 在编译链接时并没有把库文件的代码加入到可执行文件中，而是<strong>在程序执行时由运行</strong>时<strong>链接文件</strong>加载库，这样可以节省系统的开销，一般后缀名为“.so”，<strong>动态链接</strong><br>(都和程序成功运行有关)</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2c121155c7424ac0818b7ee845e7f25f.png" alt="在这里插入图片描述">gcc默认采用动态链接方式，形成可执行程序<br><img src="https://img-blog.csdnimg.cn/eae4aceaf2a04811affd0e3b9b95c61d.png" alt="在这里插入图片描述"><br>如果想要采用静态链接 -static</p><h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p>编译c++程序，g++也可以编译c语言<br>g++和gcc的选项和过程都是一样的<br><img src="https://img-blog.csdnimg.cn/4781e61f2d704e4d9df37485d8613a41.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/84876d94c6d543f595ece9956996dc2c.png" alt="在这里插入图片描述"><br>Linux可以直接跑很多语言如python，shell</p><p><img src="https://img-blog.csdnimg.cn/656dd726de3f494bbae143914788c6bf.png" alt="在这里插入图片描述"></p><h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p>调试代码<br>gdb带上可执行程序的名字<br><img src="https://img-blog.csdnimg.cn/3dc608b7d76d429bb780e1a612a8984e.png" alt="在这里插入图片描述"><br>如果一个程序可以被调试的，该程序的二进制文件一定加入了一些debug信息<br>release去掉了debug信息<br><strong>linux中默认的可执行程序是release</strong><br>但是我们如果想要调试的话，要g++ mycode.cpp -o mycode -g<br>加入-g选项就可以了</p><p><img src="https://img-blog.csdnimg.cn/f512f82b92474816bdb1bf38b860dc25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a36aa29fa2f445ac85a7c9d5801b33b8.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2cf0dc5bb216406cb8b7ea68fbe5fba4.png" alt="在这里插入图片描述"></p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>相当于f5<br><img src="https://img-blog.csdnimg.cn/500496468d5647aa99e38b813ae3c658.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="list-x2F-l"><a href="#list-x2F-l" class="headerlink" title="list&#x2F;l"></a>list&#x2F;l</h3><p>会显示代码，一次显示10行，再l会接上之前代码后面显示</p><p>l 1会从第一行开始显示<br><img src="https://img-blog.csdnimg.cn/bae2814aa0084963b8beebfd918ef534.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="b（breakpoint）（打断点）"><a href="#b（breakpoint）（打断点）" class="headerlink" title="b（breakpoint）（打断点）"></a>b（breakpoint）（打断点）</h3><p>b （行）<br><img src="https://img-blog.csdnimg.cn/c6f6a67eee6d4c07bd852af3c3584eec.png" alt="在这里插入图片描述">info b（显示断点）</p><p><img src="https://img-blog.csdnimg.cn/ecabcdb7955646a8b47aaf24e42d0f37.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/9edd63facf7c494f88d635a6241fa98b.png" alt="在这里插入图片描述">再r一下，就在断点处停了下来</p><h3 id="s"><a href="#s" class="headerlink" title="s"></a>s</h3><p>相当于f11<br><img src="https://img-blog.csdnimg.cn/5ee5079e4fd94fd0a2a05eed6b77de7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="n"><a href="#n" class="headerlink" title="n"></a>n</h3><p>相当于f10</p><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>（常显示，每次调试都会显示一次）<br>相当于监视窗口查看一个变量的值<br><img src="https://img-blog.csdnimg.cn/10b60a6c97b445958aaf7501e99dcff7.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/703a698d4c5545e69420ed4ef70321ff.png" alt="在这里插入图片描述"></p><h4 id="p"><a href="#p" class="headerlink" title="p"></a>p</h4><p>只显示一次<br><img src="https://img-blog.csdnimg.cn/24cb31bee78041f2abd5b653ac65d383.png" alt="在这里插入图片描述"></p><h4 id="undisplay"><a href="#undisplay" class="headerlink" title="undisplay"></a>undisplay</h4><p>不想再常显示之前设的变量<br><img src="https://img-blog.csdnimg.cn/c03c5a34f88e45a4806051eb14998cec.png" alt="在这里插入图片描述"></p><h3 id="finish（结束当前函数）"><a href="#finish（结束当前函数）" class="headerlink" title="finish（结束当前函数）"></a>finish（结束当前函数）</h3><p>可以自行的把一个函数给跑完<br><img src="https://img-blog.csdnimg.cn/3c3719d1f0fe48c59abc0757842ffd75.png" alt="在这里插入图片描述"></p><h3 id="c（continue）"><a href="#c（continue）" class="headerlink" title="c（continue）"></a>c（continue）</h3><p>直接跳到下一个断电<br><img src="https://img-blog.csdnimg.cn/4bf4aef6c82d40a5a0c6609e23424388.png" alt="在这里插入图片描述"></p><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>直接跳到某一行<br>until 12</p><h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><p>删除断电<br>d （几号断电）</p><p><img src="https://img-blog.csdnimg.cn/610157b909e74b47b9f18fbb58e36417.png" alt="在这里插入图片描述"></p><h3 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h3><p>禁用断电<br>disable （第几个断点）<br><img src="https://img-blog.csdnimg.cn/53eaad4ff5f84e59ace85dbff5ec0ec3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>enable就开启断点<br><img src="https://img-blog.csdnimg.cn/c0ab58a420324d9e91dbec43457ed143.png" alt="在这里插入图片描述"></p><h1 id="make-x2F-makefile"><a href="#make-x2F-makefile" class="headerlink" title="make&#x2F;makefile"></a>make&#x2F;makefile</h1><p><strong>1.make是一条命令 ，makefile是一个文件</strong><br><strong>2.文件和文件之间的互相依赖关系</strong></p><p>make和makefile可以达到我们形成可执行程序的目的</p><p><strong>makefile</strong></p><blockquote><p>1.依赖关系<br>2.依赖方法</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0c7cb9261f2a4fd59bc4998f157773af.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/d83f771f9dc443f8b1d911e012c2f640.png" alt="在这里插入图片描述">清理功能（删除可执行文件）<br><img src="https://img-blog.csdnimg.cn/69c6eb1b84c842f182a025dde9bd7ee4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4e04384e488d4063b8358e3886ee0bb8.png" alt="在这里插入图片描述">.PHONY 修饰对于的符号，伪目标（总是可执行的）的概念</p><p><img src="https://img-blog.csdnimg.cn/50d1b34c9d504888a7f4e4c87df0f16e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">make一次只会执行一个依赖关系，</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux vim 编辑器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板初阶</title>
    <link href="/2022/02/22/C++%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/"/>
    <url>/2022/02/22/C++%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">引子</a></li><li><a href="#_20">模板</a></li><li><ul><li><a href="#_22">函数模板</a></li><li><a href="#_92">类模板</a></li></ul></li></ul><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我们以前对于交换两个变量可能会根据其参数类型的不同写不同的函数，但是每个函数除去参数类型之外都是相同的<br>如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//交换两个变量</span><br><span class="hljs-comment">//c语言交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapint</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br><br><span class="hljs-comment">//c++</span><br><span class="hljs-comment">//c++可以重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a,<span class="hljs-type">int</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">double</span>&amp; a,<span class="hljs-type">double</span>&amp;b)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>因此就造成了很大的冗余没有必要，所以就提出了模板的概念</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><blockquote><p>模板和印刷术非常像 普通情况下，如，要抄一首诗，1000编，让1000个人来抄，效率很低<br>我们就可以把诗词刻在一个模具上面，印刷出来1000份，非常的方便</p></blockquote><p>template &lt; class T&gt;<br>也可以template &lt; class T1，class T2……&gt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//函数模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-comment">//也可以这样template&lt;typename T&gt;，模板参数列表--参数的类型</span><br><br><span class="hljs-comment">//也可以定义多个类型</span><br><span class="hljs-comment">//template&lt;class T1,class T2&gt;</span><br><br><span class="hljs-comment">//无论有多少个函数类型，都用他就可以了，自定义类型也可以</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span><span class="hljs-comment">//函数参数列表，参数对象，</span></span><br><span class="hljs-function"></span>&#123;<br>T x = a;<br>a = b;<br>b = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> c = <span class="hljs-number">1.1</span>, d = <span class="hljs-number">2.0</span>;<br><span class="hljs-comment">//我们写函数交换</span><br><span class="hljs-built_in">swap</span>(a, b);<span class="hljs-comment">//调用的是实例化之后的函数，模板实例化swap(d, c);</span><br><span class="hljs-type">char</span> e = <span class="hljs-string">&#x27; &#x27;</span>, f = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">//很麻烦都是类似的，这些swap最大的不同再类型上面，只是单纯的类型不一样其他东西都是一样的，</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> t&gt;</span><br><span class="hljs-function">t <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> t&amp; a, <span class="hljs-type">const</span> t&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1,<span class="hljs-keyword">class</span> T2,<span class="hljs-keyword">class</span> T3&gt;</span><br><span class="hljs-function">T1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> T2&amp; a, <span class="hljs-type">const</span> T3&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br><span class="hljs-type">double</span> c = <span class="hljs-number">1.1</span>, d = <span class="hljs-number">2.3</span>;<br>cout &lt;&lt; <span class="hljs-built_in">add</span>(a, b) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">add</span>(c, d) &lt;&lt; endl;<br><span class="hljs-comment">//如果要对于a和d加,不可以直接弄</span><br><span class="hljs-comment">//1.强制转</span><br>cout&lt;&lt;<span class="hljs-built_in">add</span>((<span class="hljs-type">double</span>)a, d)&lt;&lt;endl;<span class="hljs-comment">//这些都是自己推</span><br> <br><span class="hljs-comment">//2.显示实例化</span><br>cout &lt;&lt; <span class="hljs-built_in">add</span>&lt;<span class="hljs-type">int</span>&gt;(a, d) &lt;&lt; endl;<span class="hljs-comment">//指定我们要实例化的类型，指定t用int类型</span><br>cout &lt;&lt; <span class="hljs-built_in">add</span>&lt;<span class="hljs-type">double</span>&gt;(a, d) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">add</span>(c, d) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//类的模板，语法也是类似的</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span>&gt;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _top; <br><span class="hljs-type">int</span> _capacity;<br>t1 * _a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> capacity = <span class="hljs-number">4</span>)<br>:_top(<span class="hljs-number">0</span>)<br>, _capacity(<span class="hljs-number">4</span>)<br>&#123;<br>_a = <span class="hljs-keyword">new</span> t1[capacity];<span class="hljs-comment">//对于*a的处理初始化非常方便</span><br>&#125;<br>~<span class="hljs-built_in">Stack</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] _a;<br>_a = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">const</span> t1&amp; m)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span>&gt;<br><br><span class="hljs-type">void</span> Stack&lt;t1&gt;::<span class="hljs-built_in">Push</span>(<span class="hljs-type">const</span> t1&amp; m)<span class="hljs-comment">//要指定类模板</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//类模板不支持参数类型的推演，只支持显示实例化的指定</span><br><span class="hljs-function">Stack&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st1</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//存int</span><br>Stack &lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">st2</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//存double</span><br>Stack&lt;<span class="hljs-type">int</span>*&gt;st3;<br>Stack&lt;<span class="hljs-type">char</span>&gt;st4;<br>st1.<span class="hljs-built_in">Push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++内存管理</title>
    <link href="/2022/02/22/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/02/22/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#newdelete_1">new和delete</a></li><li><ul><li><a href="#newmallocdeletefree_3">new和malloc的区别&amp;delete和free的区别</a></li><li><a href="#newdelete_79">new和delete的应用</a></li></ul></li><li><a href="#newdelete_167">new和delete的底层</a></li><li><ul><li><a href="#operator_newoperator_delete_169">operator new和operator delete</a></li></ul></li><li><a href="#new_185">定位new</a></li><li><a href="#_219">内存泄漏</a></li></ul><h1 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h1><h2 id="new和malloc的区别-amp-delete和free的区别"><a href="#new和malloc的区别-amp-delete和free的区别" class="headerlink" title="new和malloc的区别&amp;delete和free的区别"></a>new和malloc的区别&amp;delete和free的区别</h2><blockquote><p>new动态开辟空间还可以调用其构造函数对其初始化，可以对于之定义类型进行初始化，<br>malloc只会动态开辟空间，不会初始化<br>但是对于内置类型没有区别</p></blockquote><blockquote><p>delete可以完成资源的清理和空间的销毁，对于自定义类型可以调用其析构函数完成其资源的清理<br>free只会完成空间的销毁</p></blockquote><p>用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><br><span class="hljs-type">int</span> _a;<br><span class="hljs-type">int</span> _b;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//总结malloc/free和new/delete 对于内置类型没有本质的区别，只有用法上的区别</span><br><br><br><span class="hljs-comment">//动态申请int和5个int的数组</span><br><br><span class="hljs-comment">//c语言</span><br><br><span class="hljs-type">int</span>* ptr1 = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-type">int</span>* ptr2 = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//c++</span><br><span class="hljs-type">int</span>* p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-comment">//动态开辟一个int</span><br><span class="hljs-type">int</span>* p4 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">//动态申请5个int的空间</span><br><span class="hljs-type">int</span>* p5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//申请1个int空间，**初始化**为5</span><br><span class="hljs-type">int</span>* p6 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span> &#125;;<span class="hljs-comment">//5个int也可以这样初始化</span><br><br><br><span class="hljs-comment">//删除</span><br><span class="hljs-built_in">free</span>(ptr1);<br><span class="hljs-built_in">free</span>(ptr2);<br>ptr1 = <span class="hljs-literal">nullptr</span>;<br>ptr2 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">delete</span> p3;<br><span class="hljs-keyword">delete</span>[] p4;<br>p3 = <span class="hljs-literal">nullptr</span>;<br>p4 = <span class="hljs-literal">nullptr</span>;<br><br>A* pa = (A*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(A));<br>A* pa2 = <span class="hljs-keyword">new</span> A;<br><span class="hljs-comment">//对于自定义类型，new还可以调用其初始化，还可以开空间</span><br><span class="hljs-comment">//malloc只会开空间</span><br><br>A* pa3 = (A*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(A) * <span class="hljs-number">5</span>);<br>A* pa4 = <span class="hljs-keyword">new</span> A[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">//delete要先调用指针类型的析构函数，再去释放空间给堆上</span><br><span class="hljs-keyword">delete</span> pa3;<br><span class="hljs-keyword">delete</span>[] pa4;<br><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是new要和delete配对<br>new[]要和delete[]配对</p><h2 id="new和delete的应用"><a href="#new和delete的应用" class="headerlink" title="new和delete的应用"></a>new和delete的应用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _top;<br><span class="hljs-type">int</span> _capacity;<br><span class="hljs-type">int</span>* _a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> capacity = <span class="hljs-number">4</span>)<br>:_top(<span class="hljs-number">0</span>)<br>,_capacity(<span class="hljs-number">4</span>)<br>&#123;<br>_a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[capacity];<span class="hljs-comment">//对于*a的处理初始化非常方便</span><br>&#125;<br>~<span class="hljs-built_in">Stack</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] _a;<span class="hljs-comment">//清理资源</span><br>_a = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Stack* s1 = <span class="hljs-keyword">new</span> Stack;<span class="hljs-comment">//会自动调用构造函数和开空间，</span><br><span class="hljs-keyword">delete</span> s1;<span class="hljs-comment">//调用析构函数，清理对象中的资源再释放空间，先把里面的资源给干掉，再释放掉s1指向的这空间给释放掉</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>```cpp<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>ListNode* prev;<br>ListNode* next;<br><span class="hljs-type">int</span> _val;<br><br><span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val)<span class="hljs-comment">//初始化列表</span><br>:<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>)<br>,<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)<br>,_val(val)<br>&#123;&#125;<br><br><br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">List</span>()<span class="hljs-comment">//双向带头循环链表,构造函数初始化</span><br>&#123;<br>_head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>_head-&gt;next = _head;<br>_head-&gt;prev = _head;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushback</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>ListNode* newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<span class="hljs-comment">//这样用的话就是用一次就删除一次，因为new调用operator new ，operator new又调用malloc，</span><br><span class="hljs-comment">//所以我们就可以存在一个新的operator new，使用内存池</span><br>ListNode* tail = _head-&gt;prev;<br>tail-&gt;next = newnode;<br>newnode-&gt;prev = tail;<br>_head-&gt;prev = newnode;<br>newnode-&gt;next = _head;<br><br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>ListNode* _head;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* n1 = (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListNode));<br>n1-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>n1-&gt;next = <span class="hljs-literal">nullptr</span>;<br>n1-&gt;_val = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//cpp</span><br>ListNode* n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//更加容易</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="new和delete的底层"><a href="#new和delete的底层" class="headerlink" title="new和delete的底层"></a>new和delete的底层</h1><h2 id="operator-new和operator-delete"><a href="#operator-new和operator-delete" class="headerlink" title="operator new和operator delete"></a>operator new和operator delete</h2><blockquote><p>operator new中调用malloc申请内存，但是malloc失败之后返回null，而operator new失败以后，改为抛异常处理错误，这样符合c++面向对象语言处理错误的方式<br>这个operator new是给new用的一般不是给我们用的</p></blockquote><p>new就是使用operator new（申请空间）+调用构造函数（初始化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Stack* ps1 = (Stack*)<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(Stack));<span class="hljs-comment">//只会开空间不会调用构造函数，</span><br></code></pre></td></tr></table></figure><p>同理operator delete就是只会申请空间，不会调用析构函数，也是给delete所使用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span> ps1;<span class="hljs-comment">//就只会销毁空间，和free差不多</span><br></code></pre></td></tr></table></figure><h1 id="定位new"><a href="#定位new" class="headerlink" title="定位new"></a>定位new</h1><p>定位new对已经分配的原始内存空间中调用构造函数初始化一个对象<br>用法：<br>new(地址)类型（值）</p><blockquote><p>定位new表达式在实际中一般时配合<strong>内存池</strong>使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)<br>:_a(a)<br>&#123;&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A* p = (A*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(A));<br><span class="hljs-keyword">new</span>(p)<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//new(地址)类型（值），对一块已经分配好的内存调用初始化构造函数，不开辟空间</span><br><span class="hljs-comment">//对于内存池来的就用定位new</span><br><br><span class="hljs-comment">//析构函数</span><br>p-&gt;~<span class="hljs-built_in">A</span>();<span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>1–动态申请的内存，不使用了，又没有主动释放，就存在内存泄漏了<br>2–内存泄露的危害：<br>a，出现内存泄露的进程会正常结束，进程结束时这些内存会还给系统，不会又危害<br>b，出现内存泄露的进程非正常结束，比如僵尸内存，系统用的内存越来越少<br>c。需要长期运行的程序出现内存泄露，危害很大，系统会越来越满，甚至卡死宕机 —服务器程序，</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 链表 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github（1）</title>
    <link href="/2022/02/20/github%EF%BC%881%EF%BC%89/"/>
    <url>/2022/02/20/github%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">创建远程库</a></li><li><ul><li><a href="#1_3">（1）创建一个远程库</a></li><li><a href="#_9">查找地址（起别名）</a></li><li><ul><li><a href="#_15">查看别名</a></li><li><a href="#_19">起别名</a></li></ul></li></ul></li><li><a href="#_24">推送</a></li><li><a href="#_35">克隆操作</a></li><li><a href="#_push_45">邀请加入团队 push</a></li><li><ul><li><a href="#pull_62">pull操作</a></li></ul></li><li><a href="#_84">协同开发</a></li><li><ul><li><a href="#_86">协同开发合作时冲突的解决办法</a></li></ul></li><li><a href="#SSH__103">SSH 免密登陆</a></li><li><ul><li><a href="#1_105">（1）进入到用户的主目录中</a></li><li><a href="#2ssh_109">(2)执行命令，生成一个.ssh的命令</a></li><li><a href="#ssh_119">进入.ssh的目录下</a></li><li><a href="#4github_125">（4）打开github账号</a></li><li><a href="#_132">起一个别名</a></li></ul></li></ul><h1 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h1><h2 id="（1）创建一个远程库"><a href="#（1）创建一个远程库" class="headerlink" title="（1）创建一个远程库"></a>（1）创建一个远程库</h2><p>点击new repository<br><img src="https://img-blog.csdnimg.cn/2e04f779f3034c70bde58a3dee7cced3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">完成了<br><img src="https://img-blog.csdnimg.cn/981c9047c5314141b0b40eaf707517f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="查找地址（起别名）"><a href="#查找地址（起别名）" class="headerlink" title="查找地址（起别名）"></a>查找地址（起别名）</h2><p><img src="https://img-blog.csdnimg.cn/b90e9c345377462793d77001c19f69f7.png" alt="在这里插入图片描述"><a href="https://github.com/zevin02/GitResp2.git">https://github.com/zevin02/GitResp2.git</a></p><p>远程库比较长，每次复制比较麻烦，可以在git本地将地址保存，通过别名</p><h3 id="查看别名"><a href="#查看别名" class="headerlink" title="查看别名"></a>查看别名</h3><p><img src="https://img-blog.csdnimg.cn/23af13390004486cbbcbd834fc61b037.png" alt="在这里插入图片描述"></p><h3 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h3><p>用origin来代替那么长的地址（可以随便取名字）<br><img src="https://img-blog.csdnimg.cn/7a5dea876f4442dcae115baba82fabe0.png" alt="在这里插入图片描述"></p><h1 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h1><p><img src="https://img-blog.csdnimg.cn/0671d14f302c48b6be3b0e20c3332a22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>git push origin master<br>origin是远程库的别名，master是我们要推送的分支ew<br>[new branch ]在远程库传建了分支<br>master-&gt;master 是将本地库的master内容提交到远程库里的master里面去</p><p>查看远程库内容</p><p><img src="https://img-blog.csdnimg.cn/2ffc4fda145a49298e3ea9001631ca73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="克隆操作"><a href="#克隆操作" class="headerlink" title="克隆操作"></a>克隆操作</h1><p>克隆的路径<br><img src="https://img-blog.csdnimg.cn/ad4aab1d946f4057b29c8532e4430b73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>克隆操作可以帮我们完成<br>（1）.初始化本地库<br>（2）将远程库内容完整的克隆到本地<br>（3）替我们创建远程库的别名<br><img src="https://img-blog.csdnimg.cn/9b86e4b2c4b340c58cfa30031c05ee4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6ecf764253b2450c83d3c1ab0121ff1f.png#pic_center" alt="在这里插入图片描述"></p><h1 id="邀请加入团队-push"><a href="#邀请加入团队-push" class="headerlink" title="邀请加入团队 push"></a>邀请加入团队 push</h1><p>更新本地库的内容，然后添加到暂存去里面，又提交到本地库<br><img src="https://img-blog.csdnimg.cn/cc10245a5536460eac98f894a0534b0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>（2）push内容到远程库中去<br>发现可以直接push进去，并没有让我们录入账号和密码，或者也没有 提示错误–》结果很诡异<br>原因：<br>git使用的时候在本地是有缓存的，将缓存删除调<br>用的是另一个人的帐号密码</p><p>所以我们必须要先加入团队，<br>登陆项目经理的账号，邀请普通成员加入团队</p><p>（1）。点击setting<br><img src="https://img-blog.csdnimg.cn/7464d2729a664490b7b8cfc0381cae35.png#pic_center" alt="在这里插入图片描述"><br>（2）。输入账号名<br><img src="https://img-blog.csdnimg.cn/1990181564664be8a0aed5f5b0e1f06a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="pull操作"><a href="#pull操作" class="headerlink" title="pull操作"></a>pull操作</h2><p>fetch+merge</p><p>1.项目经理先确认远程库的内容是否更新了<br>2.项目经理进行拉取<br>先是远程库的别名与后为对应的分支<br><img src="https://img-blog.csdnimg.cn/3e3a7ebd657348d3a97a05327e84d9ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>在抓取操作执行以后，只是将远程库的内容下载到本地，但是工作区中的文件并没有更新，<br><img src="https://img-blog.csdnimg.cn/ade9b5ba69054da08738d27dbd71057b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>切换到远程库里面查看一下内容，<br>抓取后可以去远程库里面看看内容是否正确，发现都正确就可以进行合并操作<br>（2）进行合并 merge<br>要先将分支切换回来<br><img src="https://img-blog.csdnimg.cn/f1cfa9380c0543f986153a9c9ea26c61.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>也可以直接用<br><img src="https://img-blog.csdnimg.cn/63de6e22e26049c0b9a644467509ffd7.png#pic_center" alt="在这里插入图片描述"></p><h1 id="协同开发"><a href="#协同开发" class="headerlink" title="协同开发"></a>协同开发</h1><h2 id="协同开发合作时冲突的解决办法"><a href="#协同开发合作时冲突的解决办法" class="headerlink" title="协同开发合作时冲突的解决办法"></a>协同开发合作时冲突的解决办法</h2><p>向远程库推送数据<br><img src="https://img-blog.csdnimg.cn/ed14c3717d8e422b973d066f4bf10ad3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>做一个拉取操作<br><img src="https://img-blog.csdnimg.cn/1afd5801876348908dfe22bbc00ce482.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>到目前为止，现在远程操作都没有任何问题，<br>现在操作同一个文件的同一个位置的时候就会引起冲突：</p><p>修改之后再次推送到远程库<br>在冲突的情况下，要先拉取下来，然后修改冲突，再提交到远程库</p><h1 id="SSH-免密登陆"><a href="#SSH-免密登陆" class="headerlink" title="SSH 免密登陆"></a>SSH 免密登陆</h1><h2 id="（1）进入到用户的主目录中"><a href="#（1）进入到用户的主目录中" class="headerlink" title="（1）进入到用户的主目录中"></a>（1）进入到用户的主目录中</h2><p>cd ~</p><h2 id="2-执行命令，生成一个-ssh的命令"><a href="#2-执行命令，生成一个-ssh的命令" class="headerlink" title="(2)执行命令，生成一个.ssh的命令"></a>(2)执行命令，生成一个.ssh的命令</h2><p><img src="https://img-blog.csdnimg.cn/5d5be5bd23eb47fa96baf08e6e7adfa8.png#pic_center" alt="在这里插入图片描述"></p><p>keygen—&gt;key generation<br>注意 C 要大写<br>后面邮箱就是github注册的邮箱<br><img src="https://img-blog.csdnimg.cn/632b71488592489f8a39c5477c3085de.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="进入-ssh的目录下"><a href="#进入-ssh的目录下" class="headerlink" title="进入.ssh的目录下"></a>进入.ssh的目录下</h2><p><img src="https://img-blog.csdnimg.cn/074b5f67694449c68bb7d72a765abd2f.png#pic_center" alt="在这里插入图片描述"><br>打开id_rsa.pub里面内容<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC1O7w+fPe4wSc9kfMmBJse351dymzy5zZ9AAZ4V3OHtNivKPJDJKX0Rrre+g1+hK4qAXV8PFpNDyFFIPLqpSgtfeW587G9U7g078&#x2F;LV6LULkfOw9uEK&#x2F;jF4dJkN0zu8Cxnhonz5p+JXR0pioiLRS1ubRebLYLvKMjdjr9cX3peDk+ENGmJxH6ZIn39MB98pJmLNZBKNpKh2cQUzDtGtdumRpOf3SpMFRL7z5ohHWhsHsYdYR3&#x2F;yYcRlY3J73x8sAE2WcfjLc06E+hwgy5WAuUoF+RbQbzivWITstrgsRs8Hk9dNf&#x2F;9IcX74WD313tWEiGRwuljn7bevo&#x2F;d8pzRSJILZdFxFjzNqaKmTJ09LGB4m2Xmu9I9HBqSDWmy11eSb1NexvfYejsdV5Fi93xRWmwgVyo7eah6ULuSpOx1U6cxUSioG6udB1GRHnmBvV2dd388XxJTQe0B3jcoAk14kBVVUK9XAZg+BRnSuNGR7Z4rr4p8G7SPHZKxtCckE9EOoUM&#x3D; 1833195090@qq.com</p><h2 id="（4）打开github账号"><a href="#（4）打开github账号" class="headerlink" title="（4）打开github账号"></a>（4）打开github账号</h2><p><img src="https://img-blog.csdnimg.cn/df04169b56b540b08df773d4612c2111.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>找到ssh地址进行复制<br><img src="https://img-blog.csdnimg.cn/b9d5eb905ee14b6280ae1bff6aafea67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="起一个别名"><a href="#起一个别名" class="headerlink" title="起一个别名"></a>起一个别名</h2><p><img src="https://img-blog.csdnimg.cn/79495493e8204a6980dfec89b8cdbf5c.png#pic_center" alt="在这里插入图片描述"></p><p>先传建一个文件</p><p><img src="https://img-blog.csdnimg.cn/8e2fe26eb2ea42ef954aa23266c445a7.png#pic_center" alt="在这里插入图片描述"></p><p>ssh好处就是不用每次都进行身份验证<br>不过只针对一个账号</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github git css3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux权限</title>
    <link href="/2022/02/03/Linux%E6%9D%83%E9%99%90/"/>
    <url>/2022/02/03/Linux%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#Linux_1">Linux中的用户</a></li><li><a href="#_7">切换用户</a></li><li><a href="#sudo_16">sudo</a></li><li><a href="#_22">权限</a></li><li><a href="#_35">权限修改</a></li><li><ul><li><a href="#chmod_37">chmod</a></li><li><a href="#chown_53">chown</a></li><li><ul><li><a href="#chgrp_62">chgrp</a></li></ul></li></ul></li><li><a href="#_69">粘置位</a></li><li><a href="#umask_101">umask</a></li></ul><h1 id="Linux中的用户"><a href="#Linux中的用户" class="headerlink" title="Linux中的用户"></a>Linux中的用户</h1><p>Linux中，默认又两类用户<br>1.root：超级管理员，具有非常高的权限<br>2.普通用户：具有一般权限，需要受权限约束的，只有root可以创建普通用户</p><h1 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h1><p>使用su -<br>我们对于root和普通用户应该要有两套完全不同的密码来区别<br><img src="https://img-blog.csdnimg.cn/715055c257ce4cc5889aa3cb2f3f4617.png" alt="在这里插入图片描述">从root切换回来  </p><ol><li><img src="https://img-blog.csdnimg.cn/a9ee68624f1b47f182f0633f3f8e0dcf.png" alt="在这里插入图片描述">2.exit或者ctrl d<br><img src="https://img-blog.csdnimg.cn/ea59ac5765444e5c8180004d808b444d.png" alt="在这里插入图片描述">不建议直接用su - name（比较麻烦）</li></ol><h1 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h1><p><strong>临时权限提升，我们提升后仍然要使用普通用户</strong><br>但是一开始没办法使用</p><p><img src="https://img-blog.csdnimg.cn/aa0a4422d0a343e1acbd004410c3bf38.png" alt="在这里插入图片描述"></p><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>人+事物的属性<br><img src="https://img-blog.csdnimg.cn/7c33c5d81d534070bdf1e95be97e1197.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">Linux下一切皆为文件</p><p>第一列标识的文件类型<br>linux系统中，不以文件的后最作为区分文件类型的方式<br>1.-：普通文件（文本，各种动静态库，可执行程序，源程序）<br>2.d：目录文件<br>3.c：字符设备文件(键盘与显示器，按字节作为单位打出打入)<br>4.b：块设备文件，磁盘<br>5.p：管道文件，通信<br>6.l：链接文件，软链接</p><h1 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h1><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>1.修改所有权限<br>g（group）<br>o（other）<br>u（user）<br>a（all）<br>更改权限的属性<br>添加权限<br><img src="https://img-blog.csdnimg.cn/339ffea5531d41e59e2b4b4a6d8116f7.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/282139ba7f644e7085be22dc298c9010.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/28eb012cfa2e4e1595a7ecde2d18a32b.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/e4a917306b5040d1914be89527df3ff5.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1ce6c28926904f03a0db8e5a1e3172ca.png" alt="在这里插入图片描述">权限低的效果<br><img src="https://img-blog.csdnimg.cn/b9cd453a0824412daec7e7a8fd37198d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">但是root不受权限约束，权限只是对于普通用户的</p><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>=》（一个文件的创建者可能并不是一个文件的拥有者）<br>修改权限所有人</p><p>将root权限给成zevin02，现在root.txt 变成了zevin02为所有者</p><p><img src="https://img-blog.csdnimg.cn/e75f6b7da03f44dc9268e508dbbb3274.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果普通用户就要加一个sudo</p><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>修改所属组的所有者<br><img src="https://img-blog.csdnimg.cn/e2951cf7d85a4b5f87eaee5c395f425c.png" alt="在这里插入图片描述">一次性修改拥有者和所属组<br><img src="https://img-blog.csdnimg.cn/e0cf241efb354c8b8d477fb4f209e59c.png" alt="在这里插入图片描述">也可以用8进制来修改权限<br><img src="https://img-blog.csdnimg.cn/99531e1f424541d3943451c4a3227819.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/732aa2d218714c51b2b7d0238099324b.png" alt="在这里插入图片描述"></p><h1 id="粘置位"><a href="#粘置位" class="headerlink" title="粘置位"></a>粘置位</h1><p>如果目录本身对于other具有w权限，other可以删掉任何目录下的文件<br>如果目录本身对于other没有w权限，other不可以删掉任何文件<br><img src="https://img-blog.csdnimg.cn/1f44c9393d784f65838919b15295f7dd.png" alt="在这里插入图片描述"></p><p><strong>需求</strong><br>other有w权限可以再特定的目录下创建文件，并写入<br>但是不想让任何人删掉自己的文件（产生矛盾）<br>所以就有了<br>：粘滞位<br>chmod o+t dir<br>（只能对目录设置，一般设置other权限）<br>对设置了粘滞位的目录再在该目录下，只能文件的拥有者可以删除，</p><p><img src="https://img-blog.csdnimg.cn/f30c9b954e2d4bc7a0691dc1b1590961.png" alt="在这里插入图片描述">（t也是一种特殊的x，可以进入）</p><blockquote><p>但是有时候，有多个人，或者系统会有好多的临时数据，所有的临时文件放在系统的&#x2F;tmp<br>=》需要把所有的权限放开<br>=》但是只想让文件的拥有者自己删除自己的文件<br>=》所以可以设置粘滞位</p></blockquote><p>默认权限；<br>普通文件，起始权限（666）<br>目录文件，起始权限（777）</p><h1 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h1><p>默认掩码就是 0002</p><p>umask里有1就说明不能有这个权限<br>#权限掩码<br>凡是在umask当中出现的权，都应该在起始权限中去掉<br>有效权限就是002</p><blockquote><p>如1111 1111<br>要过滤掉若干个1，<br>和1111 0000&amp;<br>1111 0000</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8a549da1bfd547f08be3b4410605c002.png" alt="在这里插入图片描述">000 000 010 权限掩码，这里出现的起始为0<br>普通权限是666<br>110 110 110</p><p>设置默认权限（只和本次登录有效，并不是全局有效的，不要随便乱改）<br><img src="https://img-blog.csdnimg.cn/cf4558da69d04801822dbafd182483f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 服务器 运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux认识（3）</title>
    <link href="/2022/02/02/Linux%E8%AE%A4%E8%AF%86%EF%BC%883%EF%BC%89/"/>
    <url>/2022/02/02/Linux%E8%AE%A4%E8%AF%86%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">远程管理常用命令</a></li><li><a href="#_14">查看或配置网卡信息</a></li><li><ul><li><a href="#IP_16">网卡与IP地址</a></li><li><a href="#_26">查看与配置网卡信息</a></li><li><ul><li><a href="#config_31">config</a></li><li><a href="#ping_37">ping</a></li></ul></li></ul></li><li><a href="#_45">用户权限相关命令</a></li><li><ul><li><a href="#_47">用户的概念</a></li><li><a href="#_56">组</a></li><li><a href="#lsl_60">ls-l输出信息介绍</a></li><li><ul><li><a href="#_66">硬链接数</a></li></ul></li></ul></li></ul><h1 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h1><p>shutdown<br>格式： shutdown [选项] [时间] 关机&#x2F;重启</p><p>shutdown 不指定选项或者参数的话，就默认1分钟后取消<br>选项： -r 重启<br>时间 now 是现在就执行<br>（时间可以我们自己随意设置）<br>shutdown -c 可以把关机或重启的命令取消掉</p><p>但是我们最好用-r选项<br><img src="https://img-blog.csdnimg.cn/2fd900e1f7a44645b5bab786701d7226.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h1><h2 id="网卡与IP地址"><a href="#网卡与IP地址" class="headerlink" title="网卡与IP地址"></a>网卡与IP地址</h2><blockquote><p>网卡：是专门负责网络通讯的硬件设备（有线网卡，无线网卡（wifi））</p></blockquote><blockquote><p>IP地址：即在网卡后的地址信息</p></blockquote><blockquote><p>网卡与IP地址<br>我们可以把电脑类比成电话，网卡类比sim卡，IP地址类比电话号码<br>有了sim卡我们才可以打电话，我们可以用IP地址找到一台电脑</p></blockquote><h2 id="查看与配置网卡信息"><a href="#查看与配置网卡信息" class="headerlink" title="查看与配置网卡信息"></a>查看与配置网卡信息</h2><table><thead><tr><th>ifconfig</th><th>查看或配置 计算机中的网卡信息</th></tr></thead><tbody><tr><td>ping IP地址</td><td>检测到目标IP地址是否连接正常</td></tr></tbody></table><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>inet是我们要在Linux系统下找的<br><img src="https://img-blog.csdnimg.cn/f2931a7701a1484bb18473deccab9ef8.png#pic_center" alt="在这里插入图片描述"><br>其中127.0.0.1称为本地回环，检测本机网卡是否正常</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>检测到目标主机是否连接正常<br>ping 127.0.0.1可以检测本地网卡是否正常<br><img src="https://img-blog.csdnimg.cn/9e0b0222dd6f48ab9c7db24311933295.png#pic_center" alt="在这里插入图片描述"></p><p>输入错误的ip会显示无法连接到<br><img src="https://img-blog.csdnimg.cn/00a30d4caae14863a40f240fabf100da.png#pic_center" alt="在这里插入图片描述"></p><h1 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h1><h2 id="用户的概念"><a href="#用户的概念" class="headerlink" title="用户的概念"></a>用户的概念</h2><p>使用Linux系统，无论是本级还是远程都要有一个用户账户，有了用户账户才可以登陆，才可以根据当前用户的权限，访问文件或目录<br>权限包括</p><table><thead><tr><th>权限</th><th>权限</th><th>缩写</th><th>数字代号</th></tr></thead><tbody><tr><td>读</td><td>read</td><td>-r</td><td>4</td></tr><tr><td>写</td><td>write</td><td>-w</td><td>2</td></tr><tr><td>读</td><td>execute</td><td>-x</td><td>1</td></tr></tbody></table><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>简化对用户权限的设置<br>给组设 置权限，再将成员添加到组中，从而不用成员都设置权限</p><h2 id="ls-l输出信息介绍"><a href="#ls-l输出信息介绍" class="headerlink" title="ls-l输出信息介绍"></a>ls-l输出信息介绍</h2><p><img src="https://img-blog.csdnimg.cn/3ef6be8c32dd49d284af3eb486a1db88.png#pic_center" alt="在这里插入图片描述"></p><table><thead><tr><th>d</th><th>rwx</th><th>r-x</th><th>- - -</th><th>22</th></tr></thead><tbody><tr><td>d为目录，-为文件</td><td>文件所有者的权限（xvzewen）</td><td>组的权限（xvzewen）</td><td>其他用户的权限</td><td>硬链接数</td></tr></tbody></table><h3 id="硬链接数"><a href="#硬链接数" class="headerlink" title="硬链接数"></a>硬链接数</h3><p>有多少</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 网络 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux指令(3)</title>
    <link href="/2022/02/02/linux%E6%8C%87%E4%BB%A4(3)/"/>
    <url>/2022/02/02/linux%E6%8C%87%E4%BB%A4(3)/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>1.新增：adduser name<br>2.密码：passwd name<br>3：删除用户：userdel name</p><p>写了一个简单代码<br>nano就是一个记事本，退出就是ctrl x</p><p><img src="https://img-blog.csdnimg.cn/0d5dc4dec15e4628ba80db7894046975.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>which ls<br>查看特定指令的路径</p><p><img src="https://img-blog.csdnimg.cn/588e4e7cb06546fc83f06e331d29bd84.png" alt="在这里插入图片描述"></p><h1 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h1><p>查看时间<br><img src="https://img-blog.csdnimg.cn/23c4f95c544540938c020e196f8557cf.png" alt="在这里插入图片描述"></p><h1 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h1><p>显示日历</p><p><img src="https://img-blog.csdnimg.cn/98662518fe68421a8a5ec0b6339c7e60.png"><img src="https://img-blog.csdnimg.cn/1703c7a8aaf04d30a1d1c9e1f53d7a71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>find -name<br>查找特定的文件，<br><img src="https://img-blog.csdnimg.cn/1e889696e96b45d2b0cce97898a59f92.png" alt="在这里插入图片描述"></p><h1 id="zip-x2F-unzip"><a href="#zip-x2F-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h1><p>打包和压缩<br><strong>语法</strong>：zip压缩文件 .zip目录或文件<br><strong>功能</strong>：将目录或文件打包成zip格式<br>-r是递归处理</p><blockquote><p>将test目录压缩 zip test.zip test&#x2F;*<br>压缩到tmp目录里面，</p></blockquote><p>压缩普通文件<br><img src="https://img-blog.csdnimg.cn/ed8ca4c694f741489cc96a1813e5c69a.png" alt="在这里插入图片描述"><br>解压<br><img src="https://img-blog.csdnimg.cn/c758afdb8cb94d3793887220efdb442f.png" alt="在这里插入图片描述">压缩目录<br><img src="https://img-blog.csdnimg.cn/a02a6f8b75454cc0ba2b786bae5cc53a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16">解压目录<br><img src="https://img-blog.csdnimg.cn/5e0c0c4301b244bd88029a5fbe826c9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>unzip -d 可以指定到特定的路径下<br>解压到home目录下<br><img src="https://img-blog.csdnimg.cn/ea3ebfea62584ea5bd874a81ea915a45.png" alt="在这里插入图片描述"></p><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p>打包&#x2F;压缩，不打开他，直接看内容</p><blockquote><p>-c 创建一个压缩文件（creat）<br>-z 是否要对他进行压缩<br>-f 后面跟着文件名<br>-v 解压过程显示文件<br>-x 解压<br>-C 解压到特定路径下</p></blockquote><p>压缩<br><img src="https://img-blog.csdnimg.cn/ed8c800a03524d92948bbcdd1c50c967.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/650371498d14428fa24fa3aec80d1ce4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">打包和压缩</p><p>：打包是把大小放到一起<br>压缩是为了减少空间</p><h1 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h1><p>linux里面充当一个计算器<br><img src="https://img-blog.csdnimg.cn/c895cf0f26bd4780a60c0244e5b7995c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e7a83866622245389b8332b10e7a8c49.png" alt="在这里插入图片描述"></p><p>shell<br>命令行解释器（如windows的图形界面系统）<br>bash是shell里面对于用户的一个特定的shell</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 运维 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类和对象（下）</title>
    <link href="/2022/02/02/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2022/02/02/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1">再谈构造函数</a></li><li><ul><li><a href="#_3">初始化列表</a></li></ul></li><li><a href="#explicit_60">explicit</a></li><li><a href="#static_108">static</a></li><li><ul><li><a href="#_157">练习</a></li></ul></li></ul><h1 id="再谈构造函数"><a href="#再谈构造函数" class="headerlink" title="再谈构造函数"></a>再谈构造函数</h1><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>类里面的成员变量都是声名<br>而初始化列表里面就可以对变量进行定义</p><blockquote><p>1.初始化列表是成员变量定义的地方<br>2.const 引用 ，没有默认构造函数的自定义类型成员变量必须在初始化列表初始化，因为<br>初始化列表就是他们定义的地方，<br>3.对于像其他类型的成员变量，如int year,int month在哪里初始化都可以，影响不大，</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _year;<br><span class="hljs-type">int</span> _month;<br><span class="hljs-type">int</span> _day;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> _N;<span class="hljs-comment">//必须要初始化，但是不能在这里（声名）初始化，</span><br><span class="hljs-type">int</span>&amp; _ref;<span class="hljs-comment">//引用，必须要初始化</span><br>A _aa;<span class="hljs-comment">//没有默认构造函数的自定义类型的成员变量</span><br><span class="hljs-comment">//自定义类型会在定义的时候调用构造函数</span><br><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//初始化列表 - 只有构造函数才可以，</span><br><span class="hljs-comment">//每个对象的成员变量定义的地方</span><br><span class="hljs-comment">//用;开始，用，进行间隔，括号就是其定义的值</span><br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day,<span class="hljs-type">int</span> i)<span class="hljs-comment">//：开始，间隔</span><br>:_year(year)<br>, _month(month)<br>, _day(day)<br>,_N(<span class="hljs-number">10</span>)<span class="hljs-comment">//这样就可以用了</span><br>,_ref(i)<span class="hljs-comment">//在定义的地方初始化，</span><br>,_aa(<span class="hljs-number">1</span>)<span class="hljs-comment">//这样初始化也行</span><br>&#123;&#125;<br><br><span class="hljs-comment">//这样也可以用</span><br><span class="hljs-comment">//Date(int year, int month, int day)</span><br><span class="hljs-comment">//:_N(10)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//_year = year;</span><br><span class="hljs-comment">//_month = month;</span><br><span class="hljs-comment">//_day = day;</span><br><span class="hljs-comment">//&#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initlist</span><span class="hljs-params">()</span><span class="hljs-comment">//初始化列表</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Date d(2022, 1, 19);//对象实例化，对象定义</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<span class="hljs-comment">//常量必须才定义的时候初始化，</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-function">Date <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, i)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/* Date1(int year)</span><br><span class="hljs-comment"> :_year(year)</span><br><span class="hljs-comment"> &#123;&#125;*/</span><br> <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Date1</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span></span><br><span class="hljs-function"> :_year(year)</span><br><span class="hljs-function"> &#123;</span>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _year;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">explicit_test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date1 <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">2022</span>)</span></span>;<br>Date1 d2 = <span class="hljs-number">2022</span>;<span class="hljs-comment">//也允许这样的事情发生，并且都是去调用构造函数</span><br><span class="hljs-comment">//叫做隐式类型转换，</span><br><span class="hljs-comment">//d2的实际过程是2022先构造一个临时变量Date tmp(2022)，再用这个对象去拷贝构造d2</span><br><span class="hljs-comment">//但是c++编译器对于连续过程中的构造会合二为一</span><br><span class="hljs-comment">//所以这里就只有一个构造</span><br><span class="hljs-comment">//但是如果不想这样实现，我们前面加一个explicit就不会发生这样的转换了</span><br><br><br><span class="hljs-comment">//类比c语言</span><br><span class="hljs-comment">//隐式类型转换--相近的类型---表示意义相似的类型</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">101</span>;<br><span class="hljs-type">int</span> ii = d;<span class="hljs-comment">//</span><br><br><span class="hljs-comment">//强制类型转换--把不相关的类型---</span><br><span class="hljs-type">int</span>* p = &amp;ii;<br><span class="hljs-type">int</span> k = (<span class="hljs-type">int</span>)p;<span class="hljs-comment">//</span><br><br><br><span class="hljs-comment">//如我们以后学习的string类</span><br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>string s2 = <span class="hljs-string">&quot;hell&quot;</span>;<br><span class="hljs-comment">//这也是这种情况</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _a=<span class="hljs-number">0</span>;<span class="hljs-comment">//这里可以用，这个是给个缺省值，并不是初始化的地方</span><br><span class="hljs-comment">//静态成员变量属于整个类，只属于这个类，所有的对象，生命周期再整个程序运行期间</span><br><span class="hljs-comment">//类的成员函数在中可以随便范围</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> _Scount;<span class="hljs-comment">//声名</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>)<br>:_a(a)<br><br>++_Scount;<br>&#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B&amp;b)<br>:_a(b._a)<br>&#123;<br>++_Scount;<br>&#125;<br><span class="hljs-comment">//静态的成员函数，没有this指针，只能访问静态的的成员变量和成员函数</span><br><span class="hljs-comment">//不能访问那些_a这些成员变量，</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">Getcount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _Scount;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-type">int</span> B::_Scount = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义初始化，</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B b)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//类外面访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">static_test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>B b1;<br>B b2 = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">f</span>(b1);<br><span class="hljs-comment">//cout &lt;&lt;B::_Scount  &lt;&lt; endl;//值都是一样的，属于所有的对象</span><br><span class="hljs-comment">//cout &lt;&lt; b1._Scount &lt;&lt; endl;</span><br>cout &lt;&lt; b1.<span class="hljs-built_in">Getcount</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>计算1+2+……+n</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sum</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">sum</span>()<span class="hljs-comment">//sum是构造函数，每次调用构造函数，_ret就会加上，_i也会自增</span><br>&#123;<br>_ret += _i;<br>++_i;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">GetRet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _ret;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//使用静态成员变量</span><br><span class="hljs-comment">//声名</span><br><span class="hljs-comment">//静态成员变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> _i;<span class="hljs-comment">//i是每次的加的数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> _ret;<span class="hljs-comment">//ret用来记录总数d</span><br>&#125;;<br><br><span class="hljs-comment">//定义</span><br><span class="hljs-type">int</span> sum::_i = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> sum::_ret = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>sum a[n];<span class="hljs-comment">//对数组里面每个成员都要初始化，去调用构造函数，</span><br><span class="hljs-keyword">return</span> sum::<span class="hljs-built_in">GetRet</span>();<br>&#125;<br>&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">sum</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">sum</span>()<span class="hljs-comment">//sum是构造函数，每次调用构造函数，_ret就会加上，_i也会自增</span><br>&#123;<br>_ret += _i;<br>++_i;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">GetRet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _ret;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//使用静态成员变量</span><br><span class="hljs-comment">//声名</span><br><span class="hljs-comment">//静态成员变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> _i;<span class="hljs-comment">//i是每次的加的数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> _ret;<span class="hljs-comment">//ret用来记录总数d</span><br>&#125;;<br><br><span class="hljs-comment">//定义</span><br><span class="hljs-type">int</span> sum::_i = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> sum::_ret = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>sum a[n];<span class="hljs-comment">//对数组里面每个成员都要初始化，去调用构造函数，</span><br><span class="hljs-keyword">return</span> sum::<span class="hljs-built_in">GetRet</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Date类</title>
    <link href="/2022/01/28/Date%E7%B1%BB/"/>
    <url>/2022/01/28/Date%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Date.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _year;<br><span class="hljs-type">int</span> _month;<br><span class="hljs-type">int</span> _day;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> month=<span class="hljs-number">1</span>, <span class="hljs-type">int</span> day=<span class="hljs-number">1</span>);<span class="hljs-comment">//缺省参数不能声名和定义都有，最好就声名有就可以了</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetMonthDay</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> day)</span></span>;<span class="hljs-comment">//获得这月的天数</span><br><span class="hljs-comment">//运算符的重载</span><br><br><span class="hljs-comment">//所有类都是这样使用的</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Date&amp; d);<br><span class="hljs-comment">//bool operator==(const Date&amp; d);</span><br>Date&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Date&amp; d);<br><span class="hljs-comment">//加天数</span><br>Date&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day);<br><br><span class="hljs-comment">//减天数</span><br>Date&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day);<br>Date&amp; <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day);<br><br><br>Date <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day);<br><span class="hljs-comment">//++d</span><br>Date&amp; <span class="hljs-keyword">operator</span>++();<span class="hljs-comment">//单目运算符，只有一个参数this,</span><br><br><br><span class="hljs-comment">//d++,增加一个参数原来占位，进行函数重载</span><br>Date <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> );<br><br><br>Date <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>);<br>Date&amp; <span class="hljs-keyword">operator</span>--();<br><span class="hljs-comment">//判断相等</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Date&amp; d);<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Date&amp; d);<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> Date&amp; d);<br><span class="hljs-comment">//日期相减，</span><br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Date&amp; d);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintWeekDay</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Date.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Date.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::GetMonthDay</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month)</span><span class="hljs-comment">//获得每个月的天数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//每次进来都要弄一下这数组，所以我们可以考虑弄成静态的,就不用每次进来都开辟数组，浪费空间</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> MonthDay[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span> ,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<span class="hljs-comment">//用数组来获得,默认2月28天,</span><br><span class="hljs-comment">//if ((year % 4 == 0 &amp;&amp; year % 100 != 0) ||( year % 400 == 0)&amp;&amp;month==2)//可以先判断闰年</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//MonthDay[2] = 29;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">if</span> (month == <span class="hljs-number">2</span>)<span class="hljs-comment">//先判断是否为2月再选择是否要进入</span><br>&#123;<br><span class="hljs-keyword">if</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>&#123;<br>MonthDay[<span class="hljs-number">2</span>] = <span class="hljs-number">29</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> MonthDay[month];<br>&#125;<br><br><br>Date::<span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month , <span class="hljs-type">int</span> day)<span class="hljs-comment">//在外面引用加个：：，构造函数</span><br>&#123;<br>_year = year;<br>_month = month;<br>_day = day;<br><span class="hljs-comment">//检查一下日期是否合法</span><br><span class="hljs-keyword">if</span> (!(_year &gt;= <span class="hljs-number">0</span> &amp;&amp; _month &gt;= <span class="hljs-number">0</span> &amp;&amp; _month&lt;<span class="hljs-number">13</span> &amp;&amp; _day&gt;<span class="hljs-number">0</span> &amp;&amp; day &lt;= <span class="hljs-built_in">GetMonthDay</span>(year, month)))<span class="hljs-comment">//整体取个非</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;非法日期&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">Print</span>();<span class="hljs-comment">//类里面还可以访问成员函数</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; _year &lt;&lt;<span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt;<span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//&gt;的重载</span><br><span class="hljs-type">bool</span> Date::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Date&amp; d)<br>&#123;<br><span class="hljs-keyword">if</span> (_year &gt; d._year)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_year == d._year &amp;&amp; _month &gt; d._month)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><br>Date&amp; Date::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day)<span class="hljs-comment">//日期加天数，一直进位，天满了往月进位，月满了往年进位</span><br>&#123;<br>_day += day;<br><span class="hljs-keyword">while</span> (_day &gt;= <span class="hljs-built_in">GetMonthDay</span>(_year, _month))<br>&#123;<br>_day -= <span class="hljs-built_in">GetMonthDay</span>(_year, _month);<br>_month++;<br><span class="hljs-keyword">if</span> (_month == <span class="hljs-number">13</span>)<br>&#123;<br>_year++;<br>_month -= <span class="hljs-number">12</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//返回的是Date类型的，所以返回*this就可以了,出了作用域还在，所以我们用引用返回</span><br><br><br>&#125;<br><br><br><span class="hljs-comment">//不想改变原来的值</span><br>Date Date::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day)<br>&#123;<br><span class="hljs-function">Date <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<span class="hljs-comment">//拷贝构造</span><br><span class="hljs-comment">//我们可以直接调用+=</span><br>ret += <span class="hljs-number">100</span>;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br>Date Date::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<span class="hljs-comment">//后置++，返回之前的值，d++</span><br>&#123;<br><span class="hljs-function">Date <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<span class="hljs-comment">//用拷贝构造接收之前的值</span><br>*<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-comment">//推荐以后自定义类型++用前置，这样就可以不用做无用的拷贝构造</span><br><br>Date&amp; Date::<span class="hljs-keyword">operator</span>++()<span class="hljs-comment">//前置++，返回之后的值</span><br>&#123;<br><br>*<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> Date::<span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Date&amp; d)<span class="hljs-comment">//判断相等</span><br>&#123;<br><span class="hljs-keyword">return</span> _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day == d._day;<br>&#125;<br><br><span class="hljs-type">bool</span> Date:: <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> Date&amp; d)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> &gt; d || *<span class="hljs-keyword">this</span> == d;<br>&#125;<br><br><br><span class="hljs-type">bool</span> Date::<span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Date&amp; d)<br>&#123;<br><span class="hljs-keyword">return</span> !((*<span class="hljs-keyword">this</span>) &gt;= d);<span class="hljs-comment">//小于是&gt;=取反</span><br>&#125;<br><br><br><span class="hljs-comment">//2022 1  17</span><br><span class="hljs-comment">//        30</span><br><span class="hljs-comment">//       -13</span><br><span class="hljs-comment">//2021 12 18</span><br><br><br><span class="hljs-comment">//日期不合法就往月去借，月不够了就往年去借</span><br><br><br>Date&amp; Date::<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day)<br>&#123;<br><br><span class="hljs-keyword">if</span> (day &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> += -day;<br>&#125;<br>_day -= day;<br><span class="hljs-keyword">while</span> (_day &lt; <span class="hljs-number">1</span>)<br>&#123;<br>--_month;<br><span class="hljs-keyword">if</span> (_month == <span class="hljs-number">0</span>)<span class="hljs-comment">//月也不合法</span><br>&#123;<br>--_year;<span class="hljs-comment">//年也减</span><br>_month = <span class="hljs-number">12</span>;<span class="hljs-comment">//将他置为12</span><br>_day += <span class="hljs-built_in">GetMonthDay</span>(_year, _month) ;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>Date&amp; Date::<span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day)<br>&#123;<br><span class="hljs-function">Date <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>ret -= day;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br>Date Date::<span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>)<span class="hljs-comment">//后置++，返回之前的值</span><br>&#123;<br><br>*<span class="hljs-keyword">this</span> -= <span class="hljs-number">1</span>;<br><span class="hljs-function">Date <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-comment">//推荐以后自定义类型++用前置，这样就可以不用做无用的拷贝构造</span><br><br>Date&amp; Date::<span class="hljs-keyword">operator</span>--()<span class="hljs-comment">//前置++，返回之后的值</span><br>&#123;<br><br>*<span class="hljs-keyword">this</span> -= <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//   2022  9  1</span><br><span class="hljs-comment">//-  2022  1  17</span><br><span class="hljs-comment">//     0   8   -16</span><br><span class="hljs-comment">//     0   7   15 </span><br><br>Date&amp; Date::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Date&amp; d)<br>&#123;<br>_year = d._year;<br>_month = d._month;<br>_day = d._day;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//实现日期相减</span><br><span class="hljs-type">int</span> Date::<span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Date&amp; d)<span class="hljs-comment">//构成函数重载//d1-d2,我们不知道谁大谁小，所以大小是他们的绝对值，最后乘一个1或-1</span><br>&#123;<br><span class="hljs-comment">//让小的那个天数加到大的天，有多少天就加多少天</span><br>Date less = *<span class="hljs-keyword">this</span>;<br>Date more = d;<br><span class="hljs-comment">//一开始假设*this小也就是d1小减出来是一个负数</span><br><span class="hljs-type">int</span> flag = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> &gt; d)<br>&#123;<br>less = d;<br>more = *<span class="hljs-keyword">this</span>;<br>flag = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> day = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!(less == more))<br>&#123;<br>day++;<br>less++;<br>&#125;<br><span class="hljs-keyword">return</span> day*flag;<span class="hljs-comment">//前小后大，就是负的，后小前大就是正的</span><br><br><br>&#125;<br><br><span class="hljs-comment">//获取今天是星期几</span><br><br><span class="hljs-comment">//1971的1月1日星期五，作为一个基准</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::PrintWeekDay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* arr[<span class="hljs-number">7</span>] = &#123; <span class="hljs-string">&quot;星期1&quot;</span>,<span class="hljs-string">&quot;星期2&quot;</span>,<span class="hljs-string">&quot;星期3&quot;</span>,<span class="hljs-string">&quot;星期4&quot;</span>,<span class="hljs-string">&quot;星期5&quot;</span> ,<span class="hljs-string">&quot;星期6&quot;</span>,<span class="hljs-string">&quot;星期7&quot;</span> &#125;;<br><br><span class="hljs-function">Date <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-number">1900</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-type">int</span> count = *<span class="hljs-keyword">this</span> - start;<br>cout &lt;&lt; arr[count%<span class="hljs-number">7</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>test.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Date d1;<br><span class="hljs-function">Date <span class="hljs-title">d2</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">16</span>)</span></span>;<br>d1.<span class="hljs-built_in">Print</span>();<br>d2.<span class="hljs-built_in">Print</span>();<br><span class="hljs-function">Date <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>)</span></span>;<br><span class="hljs-function">Date <span class="hljs-title">d4</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">2</span>, <span class="hljs-number">29</span>)</span></span>;<br><span class="hljs-function">Date <span class="hljs-title">d5</span><span class="hljs-params">(<span class="hljs-number">2020</span>, <span class="hljs-number">2</span>, <span class="hljs-number">29</span>)</span></span>;<br>d5.<span class="hljs-built_in">Print</span>();<br>d4.<span class="hljs-built_in">Print</span>();<br><span class="hljs-comment">//想算一下100天后是多少天</span><br>d2 += <span class="hljs-number">100</span>;<br>d2.<span class="hljs-built_in">Print</span>();<br><span class="hljs-comment">//实现d1+100；不改变d1的值</span><br>Date ret = d1 + <span class="hljs-number">100</span>;<br>ret.<span class="hljs-built_in">Print</span>();<br>Date ret1 = d1++;<span class="hljs-comment">//实现后置++，先使用再自增</span><br>Date ret2 = ++d1;<br><br><span class="hljs-function">Date <span class="hljs-title">d6</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">17</span>)</span></span>;<br>d6 -= <span class="hljs-number">30</span>;<br>d6.<span class="hljs-built_in">Print</span>();<br>Date k = d2 - <span class="hljs-number">20</span>;<br>k.<span class="hljs-built_in">Print</span>();<br><span class="hljs-function">Date <span class="hljs-title">d7</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>)</span></span>;<br><span class="hljs-function">Date <span class="hljs-title">d8</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>)</span></span>;<br><span class="hljs-type">int</span> day = d7 - d8;<br>d7.<span class="hljs-built_in">PrintWeekDay</span>();<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git（2）</title>
    <link href="/2022/01/25/git%EF%BC%882%EF%BC%89/"/>
    <url>/2022/01/25/git%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#status_1">status命令</a></li><li><a href="#git_log_16">git log</a></li><li><a href="#rm_54">删除文件的操作rm</a></li><li><ul><li><a href="#1_56">1.删除文件并恢复本地库的文件</a></li><li><a href="#2_71">2.删除文件并恢复暂存区的文件</a></li></ul></li><li><a href="#diff_79">diff命令</a></li></ul><h1 id="status命令"><a href="#status命令" class="headerlink" title="status命令"></a>status命令</h1><p>git status可以查看工作区和暂存区的状态</p><p><img src="https://img-blog.csdnimg.cn/a83c8f5c28a2445fb3435b038c4ac57d.png" alt="在这里插入图片描述">在暂存区里面没有可以被提交的<br><img src="https://img-blog.csdnimg.cn/2a15a67491d84d7d812fbd4d974af7cb.png" alt="在这里插入图片描述"> 在文件夹里面创建一个文件，查看状态<br><img src="https://img-blog.csdnimg.cn/e07872b1b2184e199291d817909821e4.png" alt="在这里插入图片描述">利用git add命令将之提交到暂存区，后用git commit命令将其提交到本地库<br><img src="https://img-blog.csdnimg.cn/9b9c8e8467d543be943ba049e8a2adf8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">修改de2.txt里面内容<br>再查看状态</p><p><img src="https://img-blog.csdnimg.cn/c92475c5df9b44d4bc72852e2fbb169e.png" alt="在这里插入图片描述"><br>需要重新添加到暂存区，后提交到本地库<br><img src="https://img-blog.csdnimg.cn/d74034e7426e46528df70287c238c8ad.png" alt="在这里插入图片描述"></p><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>git log可以查看我们提交的，显示从最近到最远的日志<br><img src="https://img-blog.csdnimg.cn/8c90b4c6e0c54c3eb1fb29dd484c1cf8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当历史命令过多的时候，查看历史日志的时候，有分页的效果，分屏效果<br>一页展示不下，<br>到下一页：空格<br>到上一页：b<br>退出：q</p><p>日志展示方式<br>1.方法1.git log --》分页<br>2.方法2.git log --pretty&#x3D;oneline ——》再一行显示</p><p><img src="https://img-blog.csdnimg.cn/565300f8c0944d71b863448d03c9166c.png" alt="在这里插入图片描述">3.方法3.git log --oneline（更加简洁的方式）<br><img src="https://img-blog.csdnimg.cn/97bdd2cb5e2c401e87bd3360b81a1550.png" alt="在这里插入图片描述"></p><p>4.git reflog<br>多了信息，head@（数字），<br>代表指针回到历史状态需要走多少步<br><img src="https://img-blog.csdnimg.cn/7939ec6010fc4485a836a3d47defbd2b.png" alt="在这里插入图片描述"><br>git reset<br>可以前进或者后退历史版本<br><img src="https://img-blog.csdnimg.cn/ef104a27b80f40119327086d5c745753.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>git reset 参数<br>(1)hard（最有用）<br>git reset --hard [索引]<br>本地仓库的指针移动的同时，重置暂存区，重置工作区</p><p>（2）mixed<br>git reset --hard [索引]<br>在移动本地库的时候，暂存区也动，工作区不动（我们很少用这个参数）<br>（3）soft<br>git reset --soft [索引]<br>在移动本地库的时候，其他都不动（少用）</p><h1 id="删除文件的操作rm"><a href="#删除文件的操作rm" class="headerlink" title="删除文件的操作rm"></a>删除文件的操作rm</h1><h2 id="1-删除文件并恢复本地库的文件"><a href="#1-删除文件并恢复本地库的文件" class="headerlink" title="1.删除文件并恢复本地库的文件"></a>1.删除文件并恢复本地库的文件</h2><p>新建一个test2.txt，并提交到本地库</p><p><img src="https://img-blog.csdnimg.cn/3c8f315dd3d546daab331d7519d03c78.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">删除工作区的test2.txt</p><p><img src="https://img-blog.csdnimg.cn/9defca047cd342efafe906bfb9ecd4fd.png" alt="在这里插入图片描述">将删除操作同步到暂存区<br>将删除操作同步到本地库</p><p><img src="https://img-blog.csdnimg.cn/0588ef0b84934ed687b30ec50636e6a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">查看记录</p><p><img src="https://img-blog.csdnimg.cn/bd8a97650e4f4c3a81f876ce943074e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">（恢复本地库文件）找回本地库中删除的文件（实际上就是将历史版本切换到刚才添加文件的 那个版本）</p><h2 id="2-删除文件并恢复暂存区的文件"><a href="#2-删除文件并恢复暂存区的文件" class="headerlink" title="2.删除文件并恢复暂存区的文件"></a>2.删除文件并恢复暂存区的文件</h2><p>（1）删除工作区数据</p><p><img src="https://img-blog.csdnimg.cn/36ffe84abb47438590c2964d93e5dd99.png" alt="在这里插入图片描述">（2）同步的暂存区</p><p><img src="https://img-blog.csdnimg.cn/40bf9707373a409283d83a1c3156d9f5.png" alt="在这里插入图片描述">（3）后悔了，恢复暂存区中的数据<br><img src="https://img-blog.csdnimg.cn/82cbc3f3f42d4e0a91892594a7508bc6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="diff命令"><a href="#diff命令" class="headerlink" title="diff命令"></a>diff命令</h1><p>1.先创建一个文件，添加到暂存区，再提交到本地库<br><img src="https://img-blog.csdnimg.cn/d2e4c5b2d4204495aed8100141a0f5df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/45bb1034809c4e0383202170cfa7271f.png" alt="在这里插入图片描述"><br>（2）更改工作区中test3.txt里面的内容</p><p><img src="https://img-blog.csdnimg.cn/6ff7d489f6ea4c41a8fdf41dd455b20b.png" alt="在这里插入图片描述">git diff [文件名]–&gt;将工作区的文件和暂存区的文件进行比较</p><p>多个文件的比对</p><p><img src="https://img-blog.csdnimg.cn/46baaff40a5247fda3c14b01b67e3369.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">总结：git diff–》比较工作区和暂存区中所有文件的差异</p><p>可以通过索引，也可以用head<br>比较本地库和暂存区中的差别<br>git diff [历史版本] [ 文件名]<br><img src="https://img-blog.csdnimg.cn/842f774e141440d6820a2324452488a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git(1)</title>
    <link href="/2022/01/25/git(1)/"/>
    <url>/2022/01/25/git(1)/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://img-blog.csdnimg.cn/56957adf1a6046ac970e57afd7ece122.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类和对象（2）</title>
    <link href="/2022/01/25/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/"/>
    <url>/2022/01/25/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#1_6">1.构造函数</a></li><li><a href="#2_87">2.析构函数</a></li><li><a href="#_148">拷贝构造函数</a></li><li><a href="#_190">运算符的重载</a></li><li><ul><li><a href="#_227">赋值运算符的重载</a></li></ul></li></ul><p>如果我们写了一个空类，那么真的这空类什么都没有吗？<br>答案并不是<br>对于任何一个类对象，都有6个默认成员函数<br><img src="https://img-blog.csdnimg.cn/d1e488303a8a4e15a84523d15860cf0a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h1><p>我们每次写一个类的时候，都很有可能会忘记初始化，所以c++就有默认的构造函数，构造函数就是解决初始化的问题</p><p>1.构造函数（特殊的成员函数）<br>2.他的任务不是开辟空间，而是初始化对象</p><p><strong>特征</strong></p><blockquote><p>1.函数名与类名相同<br>2.没有返回值<br>3.在对象实例化的时候自动调用<br>4.构造函数可以重载<br>5.如果没有显示定义构造函数，编译器会自动生成一个无参的默认函数，一旦用户显示定义编译器将不在生成</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//这可以用缺省参数来合成一个</span><br><span class="hljs-comment">//Date()//函数名相同，没有返回值</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//year_ = 0;</span><br><span class="hljs-comment">//month_ = 1;</span><br><span class="hljs-comment">//day_ = 1;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//Date(int year,int month,int day)//函数重载</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//year_ = year;</span><br><span class="hljs-comment">//month_ = month;</span><br><span class="hljs-comment">//day_ = day;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> month=<span class="hljs-number">1</span>, <span class="hljs-type">int</span> day=<span class="hljs-number">2</span>)<span class="hljs-comment">//函数重载，全缺省更好用,推荐全缺省或者版半缺省 </span><br>&#123;<br>year_ = year;<br>month_ = month;<br>day_ = day;<br>&#125;<br><br><br><span class="hljs-keyword">private</span>:<br><br><span class="hljs-comment">//c++里面把类型分为两类，内置类型（基本类型），自定义类型</span><br><span class="hljs-comment">//内置类型，int,double,long ,int arr[]</span><br><span class="hljs-comment">//自定义类型：struct class</span><br><span class="hljs-comment">//我们不写编译器默认生成的构造函数，对于内置类型不做初始化处理</span><br><span class="hljs-comment">//对于自定义类型回去调用他的无参默认构造函数（不用参数就可以调用的）初始化</span><br><br><span class="hljs-comment">//默认构造函数，1.无参的2.全缺省的。3，我们不写，编译器自己默认生成的</span><br><br><span class="hljs-comment">//如果没有默认构造函数就会报错</span><br><span class="hljs-type">int</span> year_;<br><span class="hljs-type">int</span> day_;<br><span class="hljs-type">int</span> month_;<br>A _aa;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//自动调用</span><br>Date d;<span class="hljs-comment">//这就是对象的实例化</span><br><span class="hljs-comment">//year=0,day=1,month=1</span><br><br><span class="hljs-function">Date <span class="hljs-title">d2</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>)</span></span>;<br><span class="hljs-comment">//year=2022,month=1,day=15</span><br><span class="hljs-function">Date <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">2022</span>)</span></span>;<br><span class="hljs-function">Date <span class="hljs-title">d4</span>  <span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">3</span>)</span></span>;<br><br><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>全局变量是最先开辟的，局部范围内无论是静态成员与否都是按顺序开辟的</strong></p><h1 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2.析构函数"></a>2.析构函数</h1><p>析构函数<br>不是完成对象的销毁，而是完成对象中资源清理（malloc的free）<br>特性<br>1.析构函数的函数名是在这类名前加个~ 如~Date<br>2.没有参数没有返回值<br>3.一个类有且只有一个析构函数<br>4.对象生命周期结束时，c++系统编译会自动调用析构函数</p><p>默认生成构造函数和析构函数会对自定义类型成员变量调用他的构造和析构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> month = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> day = <span class="hljs-number">2</span>)<br>&#123;<br>_year = year;<br>_month = month;<br>_day = day;<br>&#125;<br><br>~<span class="hljs-built_in">Date</span>()<br>&#123;<br><span class="hljs-comment">//资源的清理</span><br>cout &lt;&lt; <span class="hljs-string">&quot;~Date()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _year;<br><span class="hljs-type">int</span> _month;<br><span class="hljs-type">int</span> _day;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//自动调用</span><br>Date d;<span class="hljs-comment">//这就是对象的实例化</span><br><span class="hljs-comment">//year=0,day=1,month=1</span><br><br><span class="hljs-function">Date <span class="hljs-title">d2</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>)</span></span>;<br><span class="hljs-comment">//year=2022,month=1,day=15</span><br><span class="hljs-function">Date <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">2022</span>)</span></span>;<br><span class="hljs-function">Date <span class="hljs-title">d4</span>  <span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-comment">//结束了就会自动上去调用析构函数</span><br><span class="hljs-comment">//但是对于Date类没有必要清理，</span><br><br>Stack   s1;<br><span class="hljs-function">Stack <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br><span class="hljs-comment">//析构的顺序是相反的,从后往前析构 </span><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>局部范围内非静态变量是按顺序从后往前西沟的 ，然后再到静态成员，最后到全局变量</p><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>拷贝构造函数，是构造函数的重载</p><p>概念：是一个特殊的成员函数<br>函数名和类名相同<br>如果没有显示构造，系统会生成默认的构造函数<br>对于内置类型成员会按字节序的拷贝，memcpy，每个字节一次拷贝</p><p>总结，拷贝构造是我们不写也会生成的默认拷贝构造函数</p><blockquote><p>传值传参和传值返回都会调用拷贝构造<br>如f（x），会调用一次<br>return x,也会调用一次拷贝构造</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用一个已经存在的成员去初始化一个不存在的成员</span><br><span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Date&amp;d);<span class="hljs-comment">//要用传引用，否则就会一直循环下去，</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">2022</span>, <span class="hljs-number">11</span>, <span class="hljs-number">9</span>)</span></span>;<br><span class="hljs-comment">//想去拷贝一下对象，</span><br><span class="hljs-comment">//拷贝复制</span><br><br><span class="hljs-comment">//前拷贝</span><br><br><span class="hljs-function">Date <span class="hljs-title">d2</span><span class="hljs-params">(d1)</span></span>;<span class="hljs-comment">//c++里面传值传参就是拷贝构造，用一个同类型对象初始化我，就是拷贝构造，我们不写也会拷贝</span><br><span class="hljs-function">Stack <span class="hljs-title">st1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Stack <span class="hljs-title">st2</span><span class="hljs-params">(st1)</span></span>;<br><span class="hljs-comment">//st2里面的数组地址指向同一个空间，出了作用域st2要析构，要对指向的空间进行析构，但是st1已经析构过了，一块空间不能析构两次</span><br><span class="hljs-comment">//导致程序崩溃，应该要有自己独立的空间</span><br><span class="hljs-comment">//后面还要学习深拷贝（要我们自己实现拷贝构造函数）</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h1><p>operator</p><blockquote><p>函数名加运算符<br>返回值是看这个操作符运算后返回的值是什么<br>参数，有几个操作符，就有操作数，就有几个参数<br>1.不能通过连接其他的符号来创建新的操作符，比如operator@<br>2.重载运算符必须有一个类类型参数（必须是自定义类型）<br>3.我们不能改变他的含义（&gt;不能弄成&lt;）<br>4.（::） （sizeof） （?） （.） （.*）这些不能重载，经常在笔试题里面出现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//写在类里面，因为有一个隐含的this指针，所以看上去只有一个参数，实际上是有两个，实现和原来运算符一样的功能</span><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Date&amp; d2)<span class="hljs-comment">//==(const Date* this,const Date&amp; d),d1传给this，d2传给d</span><br>&#123;<br><span class="hljs-keyword">if</span> (_year &gt; d2._year)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_month &gt; d2._month)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_year == d2._year &amp;&amp; _month == d2._month &amp;&amp; _day &gt; d2._day)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Date&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Date&amp; d)<span class="hljs-comment">//两个参数</span><br>&#123;<br><span class="hljs-comment">//极端情况下自己给自己赋值就可以不用处理了，直接判断一下跳过，</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;d)<span class="hljs-comment">//如果自己和自己不相等，&amp;d是取地址,this也是指针，用地址去比较</span><br>&#123;<br>_year = d._year;<br>_month = d._month;<br>_day = d._day;<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//this是指针，*this就是一个d1，返回左操作数</span><br><span class="hljs-comment">//会有传值返回就会有调用拷贝构造，所以我们用传引用比较好一点，不会调用拷贝构造</span><br><span class="hljs-comment">//出了作用域*this还在，*this就是d1，所以我们传引用返回</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类和对象（1）</title>
    <link href="/2022/01/18/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%881%EF%BC%89/"/>
    <url>/2022/01/18/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_3">面向对象和面向过程区别</a></li><li><a href="#_14">类的引入</a></li><li><a href="#_69">面向对象—-编程有三大特性：封装，继承，多态</a></li><li><a href="#_148">计算类或类对象的大小</a></li><li><a href="#this_201">this指针</a></li></ul><h1 id="面向对象和面向过程区别"><a href="#面向对象和面向过程区别" class="headerlink" title="面向对象和面向过程区别"></a>面向对象和面向过程区别</h1><p>如：<br>设计简单外卖系统<br>面向过程：关注实现下单，接单，送餐&#x3D;&gt;体现在代码层面—函数&#x2F;方法</p><p>面向对象：关注实现类对象及类对象间的关系，用户，商家，骑手以及他们之间的关系，他体现到代码层面–类的设计，以及类之间的关系</p><p>c++基于面向对象：面向对象与面向过程可以混编（c++兼容c）<br>Java纯面向对象：只有面向对象</p><h1 id="类的引入"><a href="#类的引入" class="headerlink" title="类的引入"></a>类的引入</h1><p>定义类可以用struct，class<br>定义一个最简单的类<br>c++里面兼容c里面结构体的用法<br>同时struct在c++里面也升级成了类<br>c++类的结构体不同的是除了可以定义变量，还可以定义函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-comment">//成员变量</span><br><span class="hljs-type">char</span> _name[<span class="hljs-number">10</span>];<span class="hljs-comment">//加个_就是一个成员变量</span><br><span class="hljs-type">int</span> _age;<br><span class="hljs-type">int</span> _id;<br><br><span class="hljs-comment">//成员方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">strcpy_s</span>(_name, name);<span class="hljs-comment">//为了避免与定义的变量冲突，所以在成员变量里加个_来区分</span><br>_age = age;<br>_id = id;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PRINT</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; _name &lt;&lt; endl;<br>cout &lt;&lt; _age &lt;&lt; endl;<br>cout &lt;&lt; _id &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br>```<span class="hljs-function">cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//struct Student s1;//兼容c</span><br>Student s2;<span class="hljs-comment">//升级到类，Student类型，也是类型</span><br>Student s3;<br><span class="hljs-comment">//这样一个一个弄就很麻烦，我们可以用成员函数</span><br><span class="hljs-comment">/*strcpy_s(s2.name, &quot;hda&quot;);</span><br><span class="hljs-comment">s2.age = 12;</span><br><span class="hljs-comment">s2.id = 1;*/</span><br><br>s2.<span class="hljs-built_in">init</span>(<span class="hljs-string">&quot;zhangshan&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>);<br>s3.<span class="hljs-built_in">init</span>(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>);<br>s2.<span class="hljs-built_in">PRINT</span>();<br>s3.<span class="hljs-built_in">PRINT</span>();<br>Stack st;<br>st._init();<br>st._push(<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> top=st.<span class="hljs-built_in">Top</span>();<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="面向对象—-编程有三大特性：封装，继承，多态"><a href="#面向对象—-编程有三大特性：封装，继承，多态" class="headerlink" title="面向对象—-编程有三大特性：封装，继承，多态"></a>面向对象—-编程有三大特性：封装，继承，多态</h1><p>封装：1.数据和方法放到了一起，在类里面<br>2.访问限定符<br>public，private，protect<br>访问限定符说明<br>public修饰的成员可以在类外面直接访问<br>private和protect修饰的成员不可以在类外面直接访问<br>class 的默认访问限定符是private，struct的默认访问限定符是public<br>在使用的时候，最好明确他的访问限定符，不要用默认访问限定符</p><p>封装是一种更好的严格管理,我们要执行的一切操作都要通过类里面的函数，乱操作可能会有问题<br>1。数据和方法都封装到类里面了<br>2.可以给你访问的定义成public，不想给你访问的定义成private</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><span class="hljs-comment">//调用这个接口是没有问题的</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">void</span> _init()<span class="hljs-comment">//封装达到 的效果</span><br>&#123;<br>_a = <span class="hljs-literal">nullptr</span>;<br>_top = _capacity = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Top</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(_top &gt; <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> _a[_top - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> _push(<span class="hljs-type">int</span> x)<br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">// 限制我们直接访问</span><br><br><span class="hljs-type">int</span>* _a;<br><span class="hljs-type">int</span> _top;<br><span class="hljs-type">int</span> _capacity;<br><br>&#125;;<br><br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><span class="hljs-comment">//Student1类名，class</span><br>&#123;<br><span class="hljs-comment">//成员变量，不加访问限定符也是默认private</span><br><span class="hljs-type">char</span> _name[<span class="hljs-number">10</span>];<span class="hljs-comment">//加个_就是一个成员变量</span><br><span class="hljs-type">int</span> _age;<br><span class="hljs-type">int</span> _id;<br><br><span class="hljs-comment">//成员方法</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//访问限定符是从该访问限定符位置到下一个访问限定符的位置，如果后面没有访问限定符，就默认访问结束</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">strcpy_s</span>(_name, name);<br>_age = age;<br>_id = id;<br>&#125;<br><br><span class="hljs-comment">//private://这下面就变成了私有</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PRINT</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; _name &lt;&lt; endl;<br>cout &lt;&lt; _age &lt;&lt; endl;<br>cout &lt;&lt; _id &lt;&lt; endl;<br>&#125;<br><br><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="计算类或类对象的大小"><a href="#计算类或类对象的大小" class="headerlink" title="计算类或类对象的大小"></a>计算类或类对象的大小</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><span class="hljs-comment">//调用这个接口是没有问题的</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">void</span> _init()<span class="hljs-comment">//封装达到 的效果</span><br>&#123;<br>_a = <span class="hljs-literal">nullptr</span>;<br>_top = _capacity = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Top</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(_top &gt; <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> _a[_top - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">void</span> _push(<span class="hljs-type">int</span> x)<br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">// 限制我们直接访问</span><br><br><span class="hljs-type">int</span>* _a;<br><span class="hljs-type">int</span> _top;<br><span class="hljs-type">int</span> _capacity;<br><br>&#125;;<br><br><br><br><br><span class="hljs-comment">//计算类或类对象大小，只看成员变量，考虑内存对齐，c++对齐和c结构体一致</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//对象中存了成员变量，不存成员函数，成员函数在一个公共的代码区（代码段），</span><br>Stack s1;<br>Stack s2;<br>s1.top_ = <span class="hljs-number">0</span>;<br>s2.top_ = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//不同对象调用成员函数，调用的是同一个</span><br><br>s1.<span class="hljs-built_in">init</span>();<span class="hljs-comment">//是到公共区域里面去找init</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Stack) &lt;&lt; endl;<span class="hljs-comment">//=12，只和成员变量的总大小有关</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(s1) &lt;&lt; endl;<br><span class="hljs-comment">//空类会给1个字节，不存储有效数据，只是占位，表示对象存在</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">隐藏的<span class="hljs-keyword">this</span>指针<br>调用成员函数时，不能显示传实参给<span class="hljs-keyword">this</span>，<br>定义成员函数时，也不能显示声明传给<span class="hljs-keyword">this</span><br>在成员函数内部可以显示使用<span class="hljs-keyword">this</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//void Init(Date*this,int year, int month, int day)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">int</span> year,<span class="hljs-type">int</span> month,<span class="hljs-type">int</span> day)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//year = year;//假如year前后不加_区别，在局部范围内2022就是year，而不是year_</span><br><span class="hljs-comment">//Date::year = year;//指定这个year是Date里面的</span><br>year_ = year;<br>month_ = month;<br>day_ = day;<br>&#125;<br><br><span class="hljs-comment">//void Print(//Date*this)//this-&gt;year_,this-&gt;month_,this-&gt;day</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//一般我们都不会显示的写this，没必要，但是实际上就是this-&gt;year_</span><br><br>cout &lt;&lt;<span class="hljs-keyword">this</span>-&gt; year_ &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; month_ &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; day_ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//int year;</span><br><span class="hljs-type">int</span> year_;<br><span class="hljs-type">int</span> month_;<br><span class="hljs-type">int</span> day_;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Date d1;<br>d1.<span class="hljs-built_in">Init</span>(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<br>d1.<span class="hljs-built_in">Print</span>();<br>Date d2;<span class="hljs-comment">//只考虑成员变量不考虑成员函数</span><br>d2.<span class="hljs-built_in">Init</span>(<span class="hljs-number">2022</span>, <span class="hljs-number">1</span>, <span class="hljs-number">16</span>);<br>d2.<span class="hljs-built_in">Print</span>(<span class="hljs-comment">//&amp;d2);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>面试题</p><p>1.this指针是存在哪的？严格来说是存在栈的，（形参）<br>有些编译器会放到寄存器里面，放到了ecx中，</p><p>2.this指针也可以为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//A* const this</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;show&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//A *const this</span><br><span class="hljs-comment">//进行了this-&gt;_a，对空指针解引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//this-&gt;_a</span><br>cout &lt;&lt; a_ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a_;<br> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A* p = <span class="hljs-literal">nullptr</span>;<br>p-&gt;<span class="hljs-built_in">show</span>();<span class="hljs-comment">//程序正常运行</span><br><span class="hljs-comment">//不会出现语法错误，，</span><br><span class="hljs-comment">//1。p是一个空指针，p调用成员函数不会编译报错，因为空指针不是语法错误，编译器检查不出来</span><br><span class="hljs-comment">//2.p虽然是个空指针，但是p调用成员函数也不会出现空指针访问，因为成员函数没有存在对象里面，</span><br><span class="hljs-comment">//3.这里会把p作为实参传递给隐藏this指针，</span><br>p-&gt;<span class="hljs-built_in">PrintA</span>();<span class="hljs-comment">//运行崩溃，出现了空指针，报在PrintA，</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++基础语法</title>
    <link href="/2022/01/17/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/01/17/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h1><p>auto可以自动识别类型，根据右边自动识别类型<br>警告：<br>1.auto不能做函数的参数<br>2.auto不能定义数组<br>3.auto使用的时候不能独立定义，必须给值<br>即auto a&#x3D;2；这样是不合理的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//auto自动推导c的类型，什么类型都可以</span><br><span class="hljs-keyword">auto</span> c = &amp;a;<span class="hljs-comment">//a的类型是int，c就是int*</span><br><span class="hljs-keyword">auto</span> d = <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//d是char</span><br><span class="hljs-keyword">auto</span> k = <span class="hljs-number">1.1</span>;<br><br><span class="hljs-comment">//typeid可以自动打印对象的类型</span><br><span class="hljs-built_in">cout</span> &lt;&lt; typeid(c).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; typeid(d).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; typeid(k).name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//实际中我们不会用那样用auto</span><br><span class="hljs-comment">//STL和范围或里面用</span><br><span class="hljs-comment">//std::map &lt;std::string, std::string&gt; dict = &#123; &#123;&quot;sort&quot;,&quot;排序&quot;&#125;,&#123;&quot;insert&quot;,&quot;插入&quot;&#125; &#125;;</span><br><span class="hljs-comment">//std::map &lt;std::string, std::string&gt;::iterator it = dict.begin();</span><br><span class="hljs-comment">//auto it = dict.begin();//自动识别右边的变量，简化前面类型</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-type">const</span> <span class="hljs-type">double</span> m = <span class="hljs-number">1.1</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> a = &amp;x;<span class="hljs-comment">//auto 是int*</span><br><span class="hljs-keyword">auto</span>* b = &amp;x;<span class="hljs-comment">//auto 和auto*都是一样的</span><br><span class="hljs-keyword">auto</span>&amp; d = m;<span class="hljs-comment">//这个不会识别前面的const，相当于权限的放大，auto只是一个类型</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> y = x;<span class="hljs-comment">//</span><br><span class="hljs-keyword">auto</span>&amp; c = x;<span class="hljs-comment">//int,c是x的引用</span><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(d).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>auto的应用<br>范围for</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//语法糖，用起来很甜——范围for</span><br><span class="hljs-type">int</span> array[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(array)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>); i++)<br>&#123;<br>cout &lt;&lt; array[i] &lt;&lt; endl;<span class="hljs-comment">//遍历数组</span><br>&#125;<br><span class="hljs-comment">//c++11</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e:array)<span class="hljs-comment">//自动依次取array数组里面中的每个元素赋值给e，名称是我们随机取的,int也可以</span><br>&#123;<br>cout &lt;&lt; e &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//范围for，修改把数组中的每个值+1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : array)<br>&#123;<br>e++;<span class="hljs-comment">//这样写不改变里面的每个值</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : array)<span class="hljs-comment">//e是里面每个值的别名</span><br>&#123;<br>e++;<span class="hljs-comment">//这样就对每个值进行++，e的生命周期是一次循环，加个指针就不行，</span><br>&#125;<br><br><span class="hljs-comment">//范围for的array必须是数组名，不能是指针，所以不能用传参过去使用</span><br><span class="hljs-built_in">TESTFOR</span>(array);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h1><p>因为c++里面NULL既可以代表空指针，也可以代表0，如果传NULL的话就可能有歧义，所以我们就专门用nullptr来代表c++里面的空指针</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ 排序算法 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>log算法</title>
    <link href="/2022/01/13/log%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/13/log%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">二分查找</a></li><li><ul><li><a href="#1x_4">1.查找大于等于x的最小值</a></li><li><a href="#x_51">查找重复数组中x的最小下标</a></li></ul></li><li><a href="#_93">二分答案</a></li><li><ul><li><a href="#_99">进击的奶牛</a></li></ul></li></ul><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="1-查找大于等于x的最小值"><a href="#1-查找大于等于x的最小值" class="headerlink" title="1.查找大于等于x的最小值"></a>1.查找大于等于x的最小值</h2><p><img src="https://img-blog.csdnimg.cn/85491fcd8b554aac9fe2dc24a64327fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> num[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<span class="hljs-comment">//-1说明ans不存在</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid;<br><br><span class="hljs-keyword">while</span> (left &lt;= right)<br>&#123;<br>mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (num[mid] &gt;= x)<br>&#123;<br><br>ans = num[mid];<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; n &gt;&gt; x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num[i]);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-built_in">binary</span>(x) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查找重复数组中x的最小下标"><a href="#查找重复数组中x的最小下标" class="headerlink" title="查找重复数组中x的最小下标"></a>查找重复数组中x的最小下标</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binaryindex</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid;<br><br><span class="hljs-keyword">while</span> (left &lt;= right)<br>&#123;<br>mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (num[mid] &gt;= x)<br>&#123;<br><br>ans =mid;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; n &gt;&gt; x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num[i]);<br>&#125;<br><br><span class="hljs-keyword">if</span> (num[<span class="hljs-built_in">binaryindex</span>(x)] == x)<span class="hljs-comment">//判断找到的下标对应的值是否是x</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">binaryindex</span>(x) &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h1><blockquote><p>这些值 1 2 3 4 5 6 7<br>对应 1 1 1 1 0 0 0 要找到符合条件的最大值</p></blockquote><h2 id="进击的奶牛"><a href="#进击的奶牛" class="headerlink" title="进击的奶牛"></a>进击的奶牛</h2><p><a href="https://www.luogu.com.cn/problem/P1824">link</a>.</p><blockquote><p><strong>题目描述</strong><br>Farmer John 建造了一个有 N(2&lt;&#x3D;N&lt;&#x3D;1000000)个隔间的牛棚，这些隔间分布在一条直线上，坐标是 x1x_1x1​ ,…,xNx_NxN​(0&lt;xi&lt;1000000000),他的c（2&lt;c&lt;n）头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John 想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢?</p></blockquote><blockquote><p><strong>输入格式</strong></p><p>第 1 行：两个用空格隔开的数字 N 和 C。</p><p>第 2 ~ N+1 行：每行一个整数，表示每个隔间的坐标</p></blockquote><blockquote><p><strong>输出格式</strong><br>输出只有一行，即相邻两头牛最大的最近距离。</p></blockquote><blockquote><p>输入<br>5 3<br>1<br>2<br>8<br>4<br>9<br>输出<br>3</p></blockquote><blockquote><p>计算最大的最近距离<br>1.再dis下可以放几头牛（首先先排序）<br>2.判断是否等于c<br>3.用二分法找到最小值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N, C;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e7</span> + <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> arr[MAXN];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* e1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* e2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)e1 - *(<span class="hljs-type">int</span>*)e2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coutcow</span><span class="hljs-params">(<span class="hljs-type">int</span> dis)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> now = arr[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[i] - now &gt;= dis)<br>&#123;<br>cnt++;<br>now = arr[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">beyondC</span><span class="hljs-params">(<span class="hljs-type">int</span> dis)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">coutcow</span>(dis) &gt;= C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> mid;<br><span class="hljs-keyword">while</span> (left &lt;= right)<br>&#123;<br>mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">beyondC</span>(mid))<br>&#123;<br>ans = mid;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; N &gt;&gt; C;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>&#125;<br><span class="hljs-built_in">qsort</span>(arr, N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), comp);<br>cout &lt;&lt; <span class="hljs-built_in">binary</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>皮皮的糖果</strong><br>皮皮有n包不同口味的糖果，分给每个人糖果的 数量必须相等，并且每个人只能有一种口味，也就是说，可以把一包糖分给多个人，但是一个人的糖不能有多少口味，每个人最多能分到几颗糖</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> arr[MAXN];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>sum += arr[i] / b;<span class="hljs-comment">//sum计算在分b个糖果的情况下可有多少个人</span><br><br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(b) &gt;= m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; n, <span class="hljs-type">int</span>&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> mid;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right)<br>&#123;<br>mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid,m))<br>&#123;<br>ans = mid;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//n种口味，m个人</span><br><span class="hljs-type">int</span> t;<br>cin &gt;&gt; t ;<br><span class="hljs-keyword">while</span> (t--)<br>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>&#125;<br><br><span class="hljs-type">int</span> min = arr[<span class="hljs-number">0</span>];<br>cout&lt;&lt;<span class="hljs-built_in">binary</span>( n, m)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法 排序算法 数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RMQ 问题——ST表</title>
    <link href="/2022/01/09/RMQ%20%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94ST%E8%A1%A8/"/>
    <url>/2022/01/09/RMQ%20%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94ST%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#RMQ_1">RMQ问题</a></li><li><a href="#_13">例题模板：区间最值</a></li><li><a href="#_60">例题：区间最大公约数</a></li><li><a href="#_110">区间最大间距</a></li></ul><h1 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h1><p>不带修改的区间最值，重叠的区间不会对区间的最大值产生影响</p><p>可以用 ST表（稀疏表）<br>（不带修改的区间问题可以用，一经修改就不可以用了）</p><h1 id="例题模板：区间最值"><a href="#例题模板：区间最值" class="headerlink" title="例题模板：区间最值"></a>例题模板：区间最值</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br> <span class="hljs-type">int</span> dp[<span class="hljs-number">8</span>][<span class="hljs-number">35</span>];<span class="hljs-comment">//dp[i][j]表示左端点为i，长度为2^j这样的长度的区间,也就是&lt;==&gt;ans[i][i+2^j-1]</span><br><br><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r )</span></span><br><span class="hljs-function"> </span>&#123;<br><span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)<span class="hljs-built_in">log2</span>(r - l + <span class="hljs-number">1</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[l][j], dp[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);<span class="hljs-comment">//区间最大值可以有重合覆盖上，右边长度还是j</span><br> &#125;<br><br><br><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123; <br> <span class="hljs-type">int</span> arr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span> &#125;;<br> <span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;<br><span class="hljs-comment">//填充dp[i][j]</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br> &#123;<br> dp[i][<span class="hljs-number">0</span>] = arr[i];<span class="hljs-comment">//ans[i][i+2^0-1]=arr[i]</span><br> &#125;<br><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">log2</span>(n); j++)<span class="hljs-comment">//j=0已经处理了，先要枚举j，而不是先枚举i，j的最大长度是log2(n);</span><br> &#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt; n; i++)<span class="hljs-comment">// i + (1 &lt;&lt; j) - 1是区间的右端点，要小于n,不要越界，</span><br> &#123;<br> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<span class="hljs-comment">//把一个长的区间，把他砍一半，，一半一半的求</span><br> <span class="hljs-comment">//j-1相当于区间长度取了一半，一半一半的求最值</span><br> <span class="hljs-comment">// dp[i][j]的值为，最值（dp[i][j-1]相当于[i][i+2^(j-1)-1]的区间，与[i+2^(j-1)][i+2^(j-1)+2^(j-1)-1]的最值</span><br><br> &#125;<br><br> &#125;<br> <span class="hljs-type">int</span> l, r;<span class="hljs-comment">//左右断电</span><br> <span class="hljs-keyword">while</span> (cin &gt;&gt; l &gt;&gt; r)<br> &#123;<br> cout &lt;&lt; <span class="hljs-built_in">query</span>(l, r) &lt;&lt; endl;<span class="hljs-comment">//query就是询问函数询问l，r的区间最大值</span><br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="例题：区间最大公约数"><a href="#例题：区间最大公约数" class="headerlink" title="例题：区间最大公约数"></a>例题：区间最大公约数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">8</span>][<span class="hljs-number">35</span>];<span class="hljs-comment">//dp[i][j]表示左端点为i，长度为2^j这样的长度的区间,也就是&lt;==&gt;ans[i][i+2^j-1]</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)<span class="hljs-built_in">log2</span>(r - l + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(dp[l][j], dp[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);<span class="hljs-comment">//区间最大值可以有重合覆盖上，右边长度还是j</span><br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;<br><span class="hljs-comment">//填充dp[i][j]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>dp[i][<span class="hljs-number">0</span>] = arr[i];<span class="hljs-comment">//ans[i][i+2^0-1]=arr[i]</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">log2</span>(n); j++)<span class="hljs-comment">//j=0已经处理了，先要枚举j，而不是先枚举i，j的最大长度是log2(n);</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt; n; i++)<span class="hljs-comment">// i + (1 &lt;&lt; j) - 1是区间的右端点，要小于n,不要越界，</span><br>&#123;<br>dp[i][j] = <span class="hljs-built_in">gcd</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<span class="hljs-comment">//把一个长的区间，把他砍一半，，一半一半的求</span><br><span class="hljs-comment">//j-1相当于区间长度取了一半，一半一半的求最值</span><br><span class="hljs-comment">// dp[i][j]的值为，最值（dp[i][j-1]相当于[i][i+2^(j-1)-1]的区间，与[i+2^(j-1)][i+2^(j-1)+2^(j-1)-1]的最值</span><br><br>&#125;<br><br>&#125;<br><span class="hljs-type">int</span> l, r;<span class="hljs-comment">//左右断电</span><br><span class="hljs-keyword">while</span> (cin &gt;&gt; l &gt;&gt; r)<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">query</span>(l, r) &lt;&lt; endl;<span class="hljs-comment">//query就是询问函数询问l，r的区间最大值</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区间最大间距"><a href="#区间最大间距" class="headerlink" title="区间最大间距"></a>区间最大间距</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iiostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dpmax[<span class="hljs-number">30</span>][<span class="hljs-number">35</span>];<br><span class="hljs-type">int</span> dpmin[<span class="hljs-number">30</span>][<span class="hljs-number">35</span>];<br><span class="hljs-comment">//区间最值差</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">querymax</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> j =(<span class="hljs-type">int</span>) <span class="hljs-built_in">log2</span>(r - l + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dpmax[l][j], dpmax[r - (<span class="hljs-number">1</span> &gt;&gt; j) + <span class="hljs-number">1</span>][j] );<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">querymin</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)<span class="hljs-built_in">log2</span>(r - l + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dpmin[l][j], dpmin[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);<span class="hljs-comment">//区间最大值可以有重合覆盖上，右边长度还是j</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m;<br>cin &gt;&gt; n&gt;&gt;m;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">25</span>]; <br><span class="hljs-comment">//预处理</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; arr[i];<br>dpmax[i][<span class="hljs-number">0</span>] = arr[i];<br>dpmin[i][<span class="hljs-number">0</span>] = arr[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">log2</span>(n); j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt; n; i++)<br>&#123;<br>dpmax[i][j]=<span class="hljs-built_in">max</span>(dpmax[i][j<span class="hljs-number">-1</span>],dpmax[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>    dpmin[i][j]=<span class="hljs-built_in">min</span>(dpmin[i][j - <span class="hljs-number">1</span>], dpmin[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j<span class="hljs-number">-1</span>]);<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br><span class="hljs-type">int</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br>cout &lt;&lt; <span class="hljs-built_in">querymax</span>(l,r)-<span class="hljs-built_in">querymin</span>(l,r) &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划 算法 leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论---扩展欧几里得算法</title>
    <link href="/2022/01/07/%E6%95%B0%E8%AE%BA---%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/07/%E6%95%B0%E8%AE%BA---%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">欧几里得算法（辗转相除法）</a></li><li><a href="#_26">最小公倍数</a></li><li><a href="#_39">贝祖定理</a></li><li><a href="#_46">扩展欧几里得算法</a></li></ul><h1 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a>欧几里得算法（辗转相除法）</h1><p>欧几里得算法是用于求最大公约数<br>任何一个数a都可以表示成</p><blockquote><p>a&#x3D;pb+r</p></blockquote><blockquote><p>如果r&#x3D;0则b就是其最大公约数<br>如果r！&#x3D;0，就转化为b，r的</p></blockquote><p>a,q,p,r均为整数<br>gcd表示最大公约数</p><blockquote><p>gcd(a,b)&#x3D;gcd(b,r)&#x3D;gcd(b,a%b)</p></blockquote><p>因此结束条件就是r&#x3D;0，即b&#x3D;0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-comment">//最大公约数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:<span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h1><p>我们知道a和b的最小公倍数是a和b的乘积除以gcd（a，b）<br>但是我们如果用两数相乘的话有可能会溢出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//最小公倍数a*b/gcd（a，b），为了避免溢出应该用a/gcd（a，b）*b</span><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><span class="hljs-comment">//</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a / <span class="hljs-built_in">gcd</span>(a, b) * b;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h1><p>ax+by称a，b的线性组合，<br>ax+by&#x3D;m有解，当且仅当m为gcd（a，b）的倍数<br>ax+by&#x3D;1时，说明a，b互质</p><blockquote><p>如8和12的最大公约数是4<br>8x+12y&#x3D;4,x&#x3D;-1,y&#x3D;1为其的一组解</p></blockquote><h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll&amp; x, ll&amp; y)</span><span class="hljs-comment">//通过计算出gcd求得解</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">0ll</span>)<br>&#123;<br><span class="hljs-comment">//此时ax+by=g</span><br><span class="hljs-comment">//gcd=a</span><br><span class="hljs-comment">//x=1,y=0/1/2………任意数</span><br><span class="hljs-comment">//x=1,y=0为其中的一组解</span><br>x = <span class="hljs-number">1</span>;<br><br>y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> a;<span class="hljs-comment">//到达递归边界开始向上一层返回</span><br>&#125;<br><span class="hljs-comment">//gcd（a，b）=gcd(b,a%b)</span><br>ll x1=<span class="hljs-number">0</span>, y1=<span class="hljs-number">0</span>;<br>ll g = <span class="hljs-built_in">exgcd</span>(b, a % b, x1, y1);<span class="hljs-comment">//最大公约数,g为最大公约数</span><br><span class="hljs-comment">//b*x1+(a%b)*y1=gcd(b,a%b)=gcd(a,b);</span><br><br><span class="hljs-comment">//(x1,y1)-&gt;(x,y)</span><br><br>x = y1;<span class="hljs-comment">//x等于上一轮的y1</span><br>y = x1 - (a / b) * y1;<br><span class="hljs-keyword">return</span> g;<span class="hljs-comment">//g就是最大公约数</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ll a, b;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b)<br>&#123;<br><span class="hljs-comment">//先判断是否有解</span><br><span class="hljs-comment">//（a，b），的最大公约数为1,有解</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">gcd</span>(a, b) != <span class="hljs-number">1ll</span>)<span class="hljs-comment">//无解，不为互质数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;sorry&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>ll x, y;<span class="hljs-comment">//x和y就是解</span><br><span class="hljs-comment">//求ax+by的一组解,用引用传就可以把x和y给解出来</span><br>ll g = <span class="hljs-built_in">exgcd</span>(a, b, x, y);<br><span class="hljs-comment">//x = (x % b + b) % b;//以正数形式表现</span><br>cout &lt;&lt;<span class="hljs-string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;  y=&quot;</span> &lt;&lt; y &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5b196ae4f11141b9b0cc210d256297fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法 线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序详解</title>
    <link href="/2022/01/07/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/01/07/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2">稳定性</a></li><li><a href="#_12">归并排序</a></li><li><ul><li><a href="#_14">递归版</a></li><li><a href="#_95">非递归版本</a></li><li><ul><li><a href="#1_97">版本1</a></li><li><a href="#2_185">版本2</a></li></ul></li></ul></li></ul><h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>稳定性：保持相对位置不变</p><blockquote><p>冒泡排序，归并排序，直接插入排序的具有稳定性，在排序的时候不会改变数据的相对位置</p></blockquote><blockquote><p>快速排序，希尔排序，选择排序都不具有稳定性</p></blockquote><p>综合比较之下快速排序的效率最高，在大多面试时候也多以快速排序，堆排序，归并排序为主</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> _mergesort(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> *tmp)<br>&#123;<br><span class="hljs-comment">//1个就不用分了</span><br><span class="hljs-keyword">if</span>(left&gt;=right)<br><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> mid=(left+right)/<span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//[left,mid]有序[mid+1,right],有序就可以进行归并了</span><br><span class="hljs-comment">//左边和右边都有序了就可以进行归并了</span><br><br>_mergesort(a,left,mid,tmp);<br>_mergesort(a,mid+<span class="hljs-number">1</span>,right,tmp);<br><span class="hljs-comment">//后序</span><br><span class="hljs-comment">//开始归并了</span><br><span class="hljs-type">int</span> begin1=left,end1=mid;<br><span class="hljs-type">int</span> begin2=mid+<span class="hljs-number">1</span>,end2=right;<br><span class="hljs-type">int</span> i=left;<span class="hljs-comment">//i不是0而是left，这样返回原数组就可以</span><br><span class="hljs-keyword">while</span>(begin1&lt;=end1&amp;&amp;begin2&lt;=end2)<span class="hljs-comment">//有一个结束了就可以把另一个全部都接起来</span><br>&#123;<br><span class="hljs-keyword">if</span>(a[begin1]&lt;a[begin2])<br>&#123;<br>tmp[i++]=a[begin1];<br>begin1++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    tmp[i++]=a[begin2];<br>    begin2++;<br>&#125;<br>&#125;<br><span class="hljs-comment">//不知道谁结束了</span><br><span class="hljs-keyword">while</span>(begin1&lt;=end1)<br>&#123;<br>    tmp[i++]=a[begin1];<br>begin1++;<br>&#125;<br><span class="hljs-keyword">while</span>(begin2&lt;=end2)<br>&#123;<br>   tmp[i++]=a[begin2];<br>    begin2++; <br>&#125;<br><span class="hljs-comment">//tmp还要拷贝回a，这样才可以回去进行归并</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=left;j&lt;=right;j++)<br>&#123;<br>    a[j]=tmp[j];<br>&#125;<br><br>&#125;<br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span><br>&#123;<br><br>    <span class="hljs-type">int</span> *tmp=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n);<br>    <span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc fail&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>_mergesort(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,tmp);<span class="hljs-comment">//在这里容易递归，子函数</span><br><span class="hljs-built_in">free</span>(tmp);<br>tmp=<span class="hljs-literal">NULL</span>;<br><br>&#125;<br><br>```c<br>在这里插入代码片<br></code></pre></td></tr></table></figure><h2 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h2><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//归并非递归循环写法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergesortnonr</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//n为个数</span><br>&#123;<br> <span class="hljs-type">int</span> *tmp=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n);<br>    <span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc fail&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>   <span class="hljs-type">int</span> gap=<span class="hljs-number">1</span>;<span class="hljs-comment">//一个一个归，gap作为归并的间距</span><br>  <br>   <span class="hljs-keyword">while</span>(gap&lt;n)<br>   &#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i+=<span class="hljs-number">2</span>*gap)<br>   &#123;<br><span class="hljs-comment">//这个循环里面就变成归并</span><br><span class="hljs-comment">//[i,i+gap-1],[i+gap,i+2*gap-1]</span><br><span class="hljs-comment">//[0,     0 ],[1    , 1       ]</span><br><span class="hljs-type">int</span> index=i;<span class="hljs-comment">//tmp数组的起始位置是i相当于递归里面的left</span><br><br><span class="hljs-type">int</span> begin1=i,end1=i+gap<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> begin2=i+gap,end2=i+gap*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br><span class="hljs-comment">//如果个数为奇数的话</span><br><span class="hljs-comment">//第一组越界,end1越界，【begin2,end2】不存在</span><br><span class="hljs-keyword">if</span>(end1&gt;=n)<span class="hljs-comment">//等于n就已经越界了//先end1</span><br>&#123;<br>    end1=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//进行修正</span><br>&#125;<br><br><span class="hljs-comment">//第2组不存在,begin2,end2不存在，再被begin2</span><br><span class="hljs-keyword">if</span>(begin2&gt;=n)<br>&#123;<br>    <span class="hljs-comment">//让这个区间不存在，就不用对这个区间进行操作了</span><br>    begin2=n;<br>    end2=n<span class="hljs-number">-1</span>;<br><br>&#125;<br><br><span class="hljs-keyword">if</span>(end2&gt;=n)<span class="hljs-comment">//begin2存在，区间存在就修正为n-1</span><br>&#123;<br>    end2=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//再修正一下</span><br>&#125;<br><span class="hljs-comment">//如果begin1=end1=begin2=end2=n-1的话，tmp就会越界，重复的index++，后free多的未开辟的空间，index越界，进取一次出来又一次+</span><br><br><br><span class="hljs-comment">//将其进行归并</span><br><span class="hljs-keyword">while</span>(begin1&lt;=end1&amp;&amp;begin2&lt;=end2)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a[begin1]&lt;a[begin2])<br>    &#123;<br>        tmp[index++]=a[begin1++];<br>    &#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><br>    tmp[index++]=a[begin2++];<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">while</span>(begin1&lt;=end1)<br>&#123;<br>    tmp[index++]=a[begin1++];<br>&#125;<br><span class="hljs-keyword">while</span>(begin2&lt;=end2)<br>&#123;<br>     tmp[index++]=a[begin2++];<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//把归并数组拷贝回原数组</span><br><span class="hljs-comment">//整段拷贝回去</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>    a[i]=tmp[i];<br>&#125;<br>gap*=<span class="hljs-number">2</span>;<br>   &#125;<br><br><span class="hljs-built_in">free</span>(tmp);<span class="hljs-comment">//解决了tmp的溢出问题</span><br>tmp=<span class="hljs-literal">NULL</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mergesortnonr2</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//n为个数</span><br>&#123;<br> <span class="hljs-type">int</span> *tmp=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n);<br>    <span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc fail&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>   <span class="hljs-type">int</span> gap=<span class="hljs-number">1</span>;<span class="hljs-comment">//一个一个归</span><br>  <br>   <span class="hljs-keyword">while</span>(gap&lt;n)<br>   &#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i+=<span class="hljs-number">2</span>*gap)<br>   &#123;<br><span class="hljs-comment">//这个循环里面就变成归并</span><br><span class="hljs-comment">//[i,i+gap-1],[i+gap,i+2*gap-1]</span><br><span class="hljs-comment">//[0,     0 ],[1    , 1       ]</span><br><span class="hljs-type">int</span> index=i;<span class="hljs-comment">//tmp数组的起始位置是i相当于递归里面的left</span><br><br><span class="hljs-type">int</span> begin1=i,end1=i+gap<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> begin2=i+gap,end2=i+gap*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">//end1越界 或者 begin2都不需要处理归并，</span><br><span class="hljs-keyword">if</span>(end1&gt;=n||begin2&gt;=n)<br>&#123;<br>     <span class="hljs-keyword">break</span>;<span class="hljs-comment">//进行修正</span><br>&#125;<br><span class="hljs-comment">//end2越界就需要归，就修正end2就可以</span><br><span class="hljs-keyword">if</span>(end2&gt;=n)<br>&#123;<br>    end2=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//再修正一下</span><br>&#125;<br><span class="hljs-comment">//如果begin1=end1=begin2=end2=n-1的话，tmp就会越界，重复的index++，后free多的未开辟的空间，index越界，进取一次出来又一次+</span><br><br><br><span class="hljs-comment">//将其进行归并</span><br><span class="hljs-keyword">while</span>(begin1&lt;=end1&amp;&amp;begin2&lt;=end2)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a[begin1]&lt;a[begin2])<br>    &#123;<br>        tmp[index++]=a[begin1++];<br>    &#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><br>    tmp[index++]=a[begin2++];<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">while</span>(begin1&lt;=end1)<br>&#123;<br>    tmp[index++]=a[begin1++];<br>&#125;<br><span class="hljs-keyword">while</span>(begin2&lt;=end2)<br>&#123;<br>     tmp[index++]=a[begin2++];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=begin1;j&lt;=end1;j++)<br>&#123;<br>    a[j]=tmp[j];<br>&#125;<br>&#125;<br><span class="hljs-comment">//把归并数组拷贝回原数组</span><br><span class="hljs-comment">//整段拷贝回去</span><br><br>gap*=<span class="hljs-number">2</span>;<br>   &#125;<br><br><span class="hljs-built_in">free</span>(tmp);<br>tmp=<span class="hljs-literal">NULL</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br><br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//归并排序</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;;<br>    <span class="hljs-comment">//mergesort(arr,sizeof(arr)/sizeof(int));</span><br>   <span class="hljs-comment">// mergesortnonr(arr,sizeof(arr)/sizeof(int));</span><br>    mergesortnonr2(arr,<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    print(arr,<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法 数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux认识与操作（2）</title>
    <link href="/2022/01/06/Linux%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89/"/>
    <url>/2022/01/06/Linux%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#tree_1">tree</a></li><li><a href="#cp_20">cp</a></li><li><a href="#mv_42">mv</a></li><li><a href="#_54">查看文件内容</a></li><li><ul><li><a href="#more_cat_56">more cat</a></li><li><a href="#grep_68">grep</a></li><li><ul><li><a href="#grep_81">grep允许对文本进行模式查找（正则表达式）</a></li></ul></li></ul></li><li><a href="#_86">其他指令</a></li><li><ul><li><a href="#echo_88">echo</a></li><li><a href="#_93">重定向</a></li><li><a href="#_105">|</a></li><li><a href="#date_113">date</a></li><li><ul><li><a href="#_120">时间戳</a></li></ul></li></ul></li></ul><h1 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h1><p>Linux中的tree命令 ：以树形结构显示文件目录结构</p><p>（tree这个命令要我们在终端里面先下载才可以使用）</p><p>tree什么都不加的话就显示当前目录下树形结构</p><p><img src="https://img-blog.csdnimg.cn/7634251044fb454cb0d9bb4ceb5da70b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>tree ~</p><p>显示家目录下的目录以树形结构显示</p><p><img src="https://img-blog.csdnimg.cn/72b5e11080cc482bb3549ef599742691.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>tree 加路径可以显示该目录下的树形图<br><img src="https://img-blog.csdnimg.cn/623c092aa38c48d7a5e032b9c0af6fba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>tree -d 只显示目录，不显示文件<br><img src="https://img-blog.csdnimg.cn/6dbe47251088470c96683ad6bb742675.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>cp是一个复制拷贝的命令</p><blockquote><p>cp 源文件 目标文件（文件或者目录都可以）<br>源文件要有路经，目标文件也是文件加路经，加个名字（名字可改可不改）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/a3105e070ada42ed80dc671b778bfa33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/dbd0e0655a2243a3b06ad1abfce6896a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>复制到当前目录下面，可以直接同名<br>如果目标文件在当前目录下面与源文件同名，可以直接用**.**</p><p><img src="https://img-blog.csdnimg.cn/bae361128a99449095a5210bd0056c94.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>cp -i 如果覆盖当前文件的时候会有一个提示，是否需要覆盖</p><p><img src="https://img-blog.csdnimg.cn/374036aa01be4ed8b2684b04adace754.png#pic_center" alt="在这里插入图片描述"><br>cp -r 可以递归的复制目录，<br><img src="https://img-blog.csdnimg.cn/00bd69eb744a4c25b7ae4c81d0c4e916.png#pic_center" alt="在这里插入图片描述"></p><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p>mv可以用来移动文件或目录，也可以给文件或目录重命名</p><blockquote><p>mv 源文件 目标文件</p></blockquote><p><img src="https://img-blog.csdnimg.cn/32bbe50ff0fc4827bc2b85e8af392bb4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>我们把a&#x2F;b路径下的c目录，移动到test目录下<br><img src="https://img-blog.csdnimg.cn/b82997e260244931b4e47b31b36d4578.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/96e0d9e783de47d5b8c83d003d730e1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>如果移动到该目录下的文件，目标文件并不存在，就可以把源文件进行重命名<img src="https://img-blog.csdnimg.cn/dd4aa6222d2b4f3c97414ad167003242.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>mv -i 选项可以当源文件被修改的时候，覆盖前会提示</p></blockquote><h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><h2 id="more-cat"><a href="#more-cat" class="headerlink" title="more cat"></a>more cat</h2><table><thead><tr><th>cat 文件名</th><th>一次性显示文件内容 （适合短的文件）</th></tr></thead><tbody><tr><td>more</td><td>分屏幕显示文件内容（适合长的文件）</td></tr><tr><td>cat -b</td><td>对有文字的部分行号进行编号</td></tr><tr><td>cat -n</td><td>对所有的行号进行编号</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/9cf789af02364cfd8ad1d0bca7c95fb1.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/97ac7ffe31644de8bbabaa3227ed302b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3e7641f9ef74431383b94d971a244b2b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>文本搜索工具<br>grep (搜索的关键字) (文件)</p><p>-n 可以显示其所在的行号<br>-v 可以将除关键字所在的文本都显示出来<br>-i 可以忽略大小写的情况</p><p><img src="https://img-blog.csdnimg.cn/4bb15ef3be37428bbdffd5ed5358e631.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/dc3b4aabcffd43b2a8f11659a8ec145c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>如果查找的文字中间有空格那么应该用双引号来连接这段文字<br><img src="https://img-blog.csdnimg.cn/333c173e127e4d8eadc3d004d6ace118.png#pic_center" alt="在这里插入图片描述"></p><h3 id="grep允许对文本进行模式查找（正则表达式）"><a href="#grep允许对文本进行模式查找（正则表达式）" class="headerlink" title="grep允许对文本进行模式查找（正则表达式）"></a>grep允许对文本进行模式查找（正则表达式）</h3><p>1.行首查找使用 <strong>^</strong>，如要查找出现在在行首的a<br>^a<br><img src="https://img-blog.csdnimg.cn/d7804a2af65e4ea382b0fb19c8801e97.png#pic_center" alt="在这里插入图片描述"></p><h1 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h1><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo 文字内容(会将后面敲的文字显示在终端里面)</p><p><img src="https://img-blog.csdnimg.cn/03b2d11ca06d4549807ef37247c6b6fb.png#pic_center" alt="在这里插入图片描述"></p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>将原本应在终端里面显示的内容显示到文件里面，如果我们敲的文件不存在就会在当前目录下创一个文件</p><table><thead><tr><th>&gt;</th><th>表示输出，覆盖原来文件里面的所有内容</th></tr></thead><tbody><tr><td>&gt;&gt;</td><td>表示追加，将内容追加到文件的末尾</td></tr><tr><td>&lt;</td><td>表示输入</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/b7e8389646504f68bce697d87f9abfd8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e829470a97364353b6026dd139bf5ca4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/971394a0063b4af2ab3b7ef3f6798e54.png" alt="在这里插入图片描述">输入重定向：本来应该从在键盘中读取，然后重定向到文件中读取</p><h2 id=""><a href="#" class="headerlink" title="|"></a>|</h2><p>左边流进去，右边流出来：</p><p>管道 |，可以 <strong>|</strong> 将左边命令输出的结果作为 **|**右边命令输入的参数<br><img src="https://img-blog.csdnimg.cn/1e592f3e95a14cbb84c599106cfdd6e9.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/dc14a5c276be4ffebfdd1ea8adc1f83d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/61146b2bc1ad471096eb46f8b432efa4.png" alt="在这里插入图片描述"></p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>查看时间<br>%m小写的是月<br>%M大写的是分钟<br>%S大写的是秒<br><img src="https://img-blog.csdnimg.cn/485fd35041fa4032b45819fb25858aaa.png" alt="在这里插入图片描述"></p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>（给程序看的）</p><p>从1970&#x2F;01&#x2F;01&#x2F;00:00时间点累计到现在的秒数，叫做时间戳<br><img src="https://img-blog.csdnimg.cn/bb34cf93e8894534b47dc495ba9fac59.png" alt="在这里插入图片描述"><br>在查看日志当中，会包含时间信息，tac，head，tail，</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 运维 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux认识与基本操作（1）</title>
    <link href="/2022/01/03/Linux%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%881%EF%BC%89/"/>
    <url>/2022/01/03/Linux%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#Linux_1">Linux介绍</a></li><li><ul><li><a href="#windows_6">与windows的区别</a></li></ul></li><li><a href="#linux_16">linux主要目录速查表</a></li><li><a href="#linux_26">linux常用指令以及使用</a></li><li><a href="#Linux_56">Linux终端命令模式</a></li><li><a href="#_64">在终端中查阅命令的相关信息</a></li><li><ul><li><a href="#command__help_68">command- - help</a></li><li><a href="#man_command_73">man command</a></li></ul></li><li><a href="#_80">终端中常用技巧</a></li><li><ul><li><a href="#1_82">1）自动部全</a></li><li><a href="#2_90">2)曾经使用过的命令</a></li></ul></li><li><a href="#_94">常用命令拓展</a></li><li><ul><li><a href="#ls_96">ls命令说明</a></li><li><ul><li><a href="#Linux_98">Linux下文件和目录的特点</a></li><li><ul><li><a href="#_100">隐藏文件</a></li><li><a href="#_106">当前目录</a></li><li><a href="#_110">上级目录</a></li></ul></li><li><a href="#ls_114">ls常用选项</a></li><li><a href="#ls_128">ls与通配符的使用</a></li></ul></li><li><a href="#cd_148">cd命令说明</a></li><li><ul><li><a href="#_158">相对路径与绝对路径</a></li></ul></li><li><a href="#touch_164">touch</a></li><li><ul><li><a href="#stat_179">stat</a></li></ul></li><li><a href="#mkdir_189">mkdir</a></li><li><a href="#rm_196">rm</a></li></ul></li></ul><h1 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h1><p>linux是一款多用户多任务的操作系统，即同一时间内，可以有多个用户同时使用共享系统中的硬件<br>（区别与windows是一款单用户多任务的操作系统，即只可以由一个用户使用）</p><h2 id="与windows的区别"><a href="#与windows的区别" class="headerlink" title="与windows的区别"></a>与windows的区别</h2><p><strong>windows</strong>：由于windows是单用户的操作系统，因此windows中右盘符的概念<br>如（C盘，D盘，E盘）在每个盘符下面，可以依照当前用户的喜好与意愿，将文件存放在自己想的驱动盘下面，所以每个驱动盘都有根目录结构，形成了多个树状的并列结构</p><p><strong>linux</strong>:由于linux是多用户的操作系统，因此它就没有盘符的概念，只有一个根目录（**&#x2F;<strong>），所有的文件都在这下面（</strong>只有根目录最顶级，他的下面有很多的 文件夹**）<br><img src="https://img-blog.csdnimg.cn/7ecf102103be4cf7a00f0b5cf8f8fef4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>home目录下所建的文件夹，每个用户自己建一个，且只能在自己所在的文件夹下进行操作</p><h1 id="linux主要目录速查表"><a href="#linux主要目录速查表" class="headerlink" title="linux主要目录速查表"></a>linux主要目录速查表</h1><table><thead><tr><th>目录</th><th>含义</th></tr></thead><tbody><tr><td>&#x2F;：根目录</td><td><strong>一般根目录</strong>下只存放目录，在Linux下面只有<strong>一个根目录</strong>，所有东西都在这个根目录下面，当输入&#x2F;home，告诉电脑先从&#x2F;（根目录）开始，再到home目录</td></tr><tr><td>&#x2F;bin .&#x2F;usr&#x2F;bin</td><td>存放可执行二进制文件的目录，常用的命令都在这个目录下面，如ls ，tar ，mv等</td></tr><tr><td>&#x2F;etc</td><td><strong>系统配置的文件</strong>都在这里面</td></tr><tr><td>&#x2F;home</td><td><strong>当前用户</strong>的文件夹都保存在home目录下</td></tr></tbody></table><h1 id="linux常用指令以及使用"><a href="#linux常用指令以及使用" class="headerlink" title="linux常用指令以及使用"></a>linux常用指令以及使用</h1><p><strong>指令</strong></p><table><thead><tr><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>pwd</td><td>print work directory</td><td>查看当前所在的文件路径</td></tr><tr><td>cd [目录]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>touch [文件名] （只可删除文件，不可删除文件名）</td><td>touch</td><td>如果文件不在就新建一个文件（非文件夹）</td></tr><tr><td>mkdir [目录]</td><td>make directory</td><td>切换文件夹</td></tr><tr><td>rm [文件名] （只可删除文件，不可删除文件名）</td><td>remove</td><td>删除文件</td></tr><tr><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><p><strong>使用</strong><br>ls<br><img src="https://img-blog.csdnimg.cn/56cf1a77196045f488274c29b1cc3cf1.png#pic_center" alt="在这里插入图片描述"><br>cd<br>pwd</p><p><img src="https://img-blog.csdnimg.cn/e3a9c09e5c384e2b991ccd59f5a49985.png#pic_center" alt="在这里插入图片描述"></p><p>touch<br><img src="https://img-blog.csdnimg.cn/5119a63633884931812bbdb31d2174d9.png#pic_center" alt="在这里插入图片描述"></p><p>mkdir<br><img src="https://img-blog.csdnimg.cn/218ebd59cd9d48c0be9ff15c9f2d6e04.png#pic_center" alt="在这里插入图片描述"></p><p>rm<br><img src="https://img-blog.csdnimg.cn/23a70168223e40d6815a24279f0a8b1b.png#pic_center" alt="在这里插入图片描述"></p><h1 id="Linux终端命令模式"><a href="#Linux终端命令模式" class="headerlink" title="Linux终端命令模式"></a>Linux终端命令模式</h1><p>command [-option] [parameter]<br>中间用空格隔开，[ ] 代表可选非必要</p><table><thead><tr><th>command （命令名）</th><th>相应功能的 英文单词的缩写 ls</th></tr></thead><tbody><tr><td>-option（选项）</td><td>可以用来控制命令的形式，也可以省略，如 ls -l</td></tr><tr><td>parameter</td><td>传给命令的参数，可以是0个1个或多个 cd 1.txt</td></tr></tbody></table><h1 id="在终端中查阅命令的相关信息"><a href="#在终端中查阅命令的相关信息" class="headerlink" title="在终端中查阅命令的相关信息"></a>在终端中查阅命令的相关信息</h1><p>我们可能有的时候需要用到某一个命令，但可能忘记了用法或则本就不知道他的用法，又不想百度，想直接在终端里面查阅该命令的信息<br>需要用到以下两个命令</p><h2 id="command-help"><a href="#command-help" class="headerlink" title="command- - help"></a>command- - help</h2><p>command - -help<br>如mkdir - -help，会出现他的使用方法<br><img src="https://img-blog.csdnimg.cn/a1e826c53c6f41f683733d8bb77d615b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="man-command"><a href="#man-command" class="headerlink" title="man command"></a>man command</h2><p>man command<br><img src="https://img-blog.csdnimg.cn/d6c768194869425599ed0fda1dc8069e.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/0e3994626a2049d684be59f735367dbf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="终端中常用技巧"><a href="#终端中常用技巧" class="headerlink" title="终端中常用技巧"></a>终端中常用技巧</h1><h2 id="1）自动部全"><a href="#1）自动部全" class="headerlink" title="1）自动部全"></a>1）自动部全</h2><p>按tab键就可以自动补全<br>如home下有desk文件夹<br>我们想切换到desk中</p><blockquote><p>在终端里面敲下 cd d，再按个tab建就可以自动补全</p></blockquote><h2 id="2-曾经使用过的命令"><a href="#2-曾经使用过的命令" class="headerlink" title="2)曾经使用过的命令"></a>2)曾经使用过的命令</h2><p>按下键盘的上下建就可以找到曾经用过的按键，<br>如果想出去，按下ctrl C即可</p><h1 id="常用命令拓展"><a href="#常用命令拓展" class="headerlink" title="常用命令拓展"></a>常用命令拓展</h1><h2 id="ls命令说明"><a href="#ls命令说明" class="headerlink" title="ls命令说明"></a>ls命令说明</h2><h3 id="Linux下文件和目录的特点"><a href="#Linux下文件和目录的特点" class="headerlink" title="Linux下文件和目录的特点"></a>Linux下文件和目录的特点</h3><h4 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h4><p>1.以 <strong>.</strong> 开头的文件为隐藏文件,创建和删除文件的时候都要加.,普通的 ls不会把显示出隐藏文件<br>使用ls -a才可以<br><img src="https://img-blog.csdnimg.cn/e910e21abe1a4dbb9b67a57b513c25a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h4 id="当前目录"><a href="#当前目录" class="headerlink" title="当前目录"></a>当前目录</h4><p><strong>.<strong>代表当前目录，一给点</strong>.</strong><br><img src="https://img-blog.csdnimg.cn/f285a2ac3963419aaa7af87f1506783f.png#pic_center" alt="在这里插入图片描述"></p><h4 id="上级目录"><a href="#上级目录" class="headerlink" title="上级目录"></a>上级目录</h4><p>**…**代表上级目录<br><img src="https://img-blog.csdnimg.cn/afa9bf9f36e7480682e7564b2d85baa7.png#pic_center" alt="在这里插入图片描述"></p><h3 id="ls常用选项"><a href="#ls常用选项" class="headerlink" title="ls常用选项"></a>ls常用选项</h3><table><thead><tr><th>ls -a</th><th>显示所有文件和目录，包括隐藏文件</th></tr></thead><tbody><tr><td>ls -l</td><td>以列表的形式打印文件的详细信息</td></tr><tr><td>ls -h</td><td>要配合-l，以个性化的方式显示文件大小</td></tr><tr><td>ls -d</td><td>只显示目录</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/a007c0df38da4e8db010f1dd6298011b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5b087353882f4358896a532408477f1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><blockquote><p>也可以将这些命令同时使用，且无顺序要求</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6b6a58e71ebd48edaa0ab84d71c57e10.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="ls与通配符的使用"><a href="#ls与通配符的使用" class="headerlink" title="ls与通配符的使用"></a>ls与通配符的使用</h3><p>如果文件特别多，有好多页，所以我们如果一个一个找就很麻烦，那么我们用通配符就可以很容易定位到</p><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意个数个字符，0或多</td></tr><tr><td>？</td><td>代表任意一个字符，至少一个</td></tr><tr><td>[ ]</td><td>表示可以匹配字符组的任一个</td></tr></tbody></table><p>ls <strong>1.txt可以把所有尾部为1的文件都找出来<br>ls 1</strong>*,可以把所有1开头的文件都找出来<br>ls 1*1.txt,可以把所有头尾位1的都找出来<br><img src="https://img-blog.csdnimg.cn/c18f39e9b7da4f6c9b27457a20c618fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>ls ?3?.txt把所有中间为3的都找出来<br>ls ?.txt,把所有只有1个字符的都找出来<br><img src="https://img-blog.csdnimg.cn/522e6546af9d402e9f74f0eab1fff660.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>把首尾为1,中间在1-5范围内的都找出来<br><img src="https://img-blog.csdnimg.cn/7ae42b09255948439e4dfc8d9f74e1a8.png#pic_center" alt="在这里插入图片描述"></p><h2 id="cd命令说明"><a href="#cd命令说明" class="headerlink" title="cd命令说明"></a>cd命令说明</h2><table><thead><tr><th>cd</th><th>切换到当前用户的主目录</th></tr></thead><tbody><tr><td>cd ~</td><td>切换到home目录</td></tr><tr><td>cd .</td><td>保持在当前目录不变</td></tr><tr><td>cd …</td><td>返回到上一级目录</td></tr><tr><td>cd -</td><td>在最近两次的工作目录间切换</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/e37f9efbd4fd4c6b8f8173e00af8e735.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h3><p>绝对路径就是从根目录下或home目录下到所在的文件路径<br><img src="https://img-blog.csdnimg.cn/3973074a623346bcb7b7e138a96196cd.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/08247ca582844792907e5ac422cdb3d1.png#pic_center" alt="在这里插入图片描述"><br>相对路径就是相对当前目录下的</p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>1.如果文件不存在，可以创建一个空文件<br>2.如果文件存在，可以修改文件的日期<br>touch默认更改的时间是所有时间<br>可以用参数改时间</p><table><thead><tr><th>-c</th><th>改变change时间</th></tr></thead><tbody><tr><td>-a</td><td>创建时间</td></tr><tr><td>-m</td><td>修改时间</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/fb56723d788543c68d586b35c7c89286.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/134e716e1dc443edbb4a31a9b3be0aa9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>查看文件的时间<br>有修改modify时间<br>更改change时间<br>进入acces时间<br><img src="https://img-blog.csdnimg.cn/54fa05e0a5394298a5b75c86efbd5b9d.png" alt="在这里插入图片描述"></p><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>创建一个文件夹目录<br>-p可以连续建多个子目录</p><p><img src="https://img-blog.csdnimg.cn/42c367a5ed6d4bb18a6b2d03cf47709e.png#pic_center" alt="在这里插入图片描述"></p><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除文件<br>rm -r 递归删除目录下的内容<br>rm -f强行删除，不管有没有文件<br><img src="https://img-blog.csdnimg.cn/6cb0cd16706e47b5a3917c31b02193d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux 运维 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运用反转链表的思想实现力扣题</title>
    <link href="/2022/01/01/%E8%BF%90%E7%94%A8%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E7%8E%B0%E5%8A%9B%E6%89%A3%E9%A2%98/"/>
    <url>/2022/01/01/%E8%BF%90%E7%94%A8%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E6%80%9D%E6%83%B3%E5%AE%9E%E7%8E%B0%E5%8A%9B%E6%89%A3%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​  </p><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_6">从尾到头打印链表</a></li><li><a href="#_51">回文链表</a></li></ul><h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">link</a>.</p><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><p>输入：head &#x3D; [1,3,2] 输出：[2,3,1]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">reversePrint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span>* returnSize)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        *returnSize=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><span class="hljs-comment">//先反转链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">newhead</span>=</span><span class="hljs-literal">NULL</span>,*cur=head,*next=cur-&gt;next;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(cur)<br>&#123;<br>    a++;<br>    cur-&gt;next=newhead;<br>    newhead=cur;<br>    cur=next;<br>    <span class="hljs-keyword">if</span>(next)<br>    next=next-&gt;next;<br>&#125;<br><span class="hljs-type">int</span> *ret=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*a);<span class="hljs-comment">//开辟数组来接收newnode的值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a;i++)<br>&#123;<br>    ret[i]=newhead-&gt;val;<br>    newhead=newhead-&gt;next;<br>&#125;<br>*returnSize=a;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p><a href="https://leetcode-cn.com/problems/aMhZSa/">link</a>.</p><blockquote><p>给定一个链表的 头节点 head ，请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p><p>示例 1：</p><p>输入: head &#x3D; [1,2,3,3,2,1] 输出: true</p><p>示例 2：</p><p>输入: head &#x3D; [1,2] 输出: false</p><p>提示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">链表 L 的长度范围为 <span class="hljs-selector-attr">[1, 105]</span><br><span class="hljs-number">0</span> &lt;= node<span class="hljs-selector-class">.val</span> &lt;= <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></blockquote><p>思路</p><blockquote><p>1221，我们先找到中间节点，然后再把mid进行后面链表进行反转 ，再一一比较，如果一条到空都相同则为真，有一个不同就是假<br>如1221，就是12和1221进行比较，都相同<br>或则12321，12321和123进行比较</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode*<span class="hljs-title function_">midnode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode*head)</span><span class="hljs-comment">//找中间节点</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">fast</span>=</span>head,*slow=head;<br>    <span class="hljs-keyword">while</span>(fast&amp;&amp;fast-&gt;next)<br>    &#123;<br>        slow=slow-&gt;next;<br>        fast=fast-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode*head)</span><span class="hljs-comment">//反转链表</span><br>&#123;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">newhead</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">cur</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">next</span>=</span>cur-&gt;next;<br>    <span class="hljs-keyword">while</span>(cur)<br>    &#123;<br>        cur-&gt;next=newhead;<br>        newhead=cur;<br>        cur=next;<br>        <span class="hljs-keyword">if</span>(next)<br>        next=next-&gt;next;<br>    &#125;<br><span class="hljs-keyword">return</span> newhead;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span><br>&#123;<br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">phead</span>=</span>head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">mid</span>=</span>midnode(phead);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">now</span>=</span>reverse(mid);<br><span class="hljs-keyword">while</span>(head&amp;&amp;now)<br>&#123;<br>    <span class="hljs-keyword">if</span>(head-&gt;val!=now-&gt;val)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    head=head-&gt;next;<br>    now=now-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表 leetcode 数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表取节点尾插力扣刷题（新年第一篇博客）</title>
    <link href="/2022/01/01/%E9%93%BE%E8%A1%A8%E5%8F%96%E8%8A%82%E7%82%B9%E5%B0%BE%E6%8F%92%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%88%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%89/"/>
    <url>/2022/01/01/%E9%93%BE%E8%A1%A8%E5%8F%96%E8%8A%82%E7%82%B9%E5%B0%BE%E6%8F%92%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%88%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_2"></a></li><li><a href="#_3"></a></li><li><ul><li><ul><li><a href="#_4"></a></li></ul></li></ul></li><li><a href="#_9">合并两个有序链表</a></li><li><a href="#_125">移除链表元素</a></li><li><a href="#_216">分割链表</a></li></ul><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">link</a>.</p><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><img src="https://img-blog.csdnimg.cn/86cc17cbb76349b9a31a10bd75758dc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><blockquote><p>示例 1：</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4] 输出：[1,1,2,3,4,4]</p><p>示例 2：</p><p>输入：l1 &#x3D; [], l2 &#x3D; [] 输出：[]</p><p>示例 3：</p><p>输入：l1 &#x3D; [], l2 &#x3D; [0] 输出：[0]</p><p>提示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">两个链表的节点数目范围是 <span class="hljs-literal">[<span class="hljs-number">0</span>, <span class="hljs-number">50</span>]</span><br>-<span class="hljs-number">100</span> &lt;= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Node</span>.</span></span><span class="hljs-keyword">val</span> &lt;= <span class="hljs-number">100</span><br>l1 和 l2 均按 非递减顺序 排列<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>思路，我们可以取节点下来尾插，取两节点中的较小的值尾插在新节点里面，我们同时可以弄一个哨兵位的头节点，尾插的时候，我们还可以定义一个尾指针，指向链表的尾部</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* list1, <span class="hljs-keyword">struct</span> ListNode* list2)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(list1==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果list1为空的话，就返回list2，无论list2是否为空都是符合的</span><br>    &#123;<br><span class="hljs-keyword">return</span> list2;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list2==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//同理</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">head</span>=</span><span class="hljs-literal">NULL</span>;<span class="hljs-comment">//一开始初始化新头和尾都是NULL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">tail</span>=</span><span class="hljs-literal">NULL</span>,*n1=list1,*n2=list2;<br><span class="hljs-comment">//1.没有带哨兵位的头节点</span><br><span class="hljs-comment">/*if(n1-&gt;val&lt;=n2-&gt;val)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    head=tail=n1;</span><br><span class="hljs-comment">    n1=n1-&gt;next;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">//这就是把里面判断头为空给跳过去了</span><br><span class="hljs-comment">else</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    head=tail=n2;</span><br><span class="hljs-comment">    n2=n2-&gt;next;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-comment">//带哨兵位的头</span><br><span class="hljs-comment">//head=tail=(struct ListNode*)malloc(sizeof(struct ListNode));//返回的时候是head-&gt;next;再free掉 </span><br><span class="hljs-keyword">while</span>(n1&amp;&amp;n2)<br>&#123;<br>    <span class="hljs-keyword">if</span>(n1-&gt;val&lt;=n2-&gt;val)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果新链表没有节点，就把第一个节点头和尾都为n1</span><br>        &#123;<br>            head=tail=n1;<br>          <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tail-&gt;next=n1;<span class="hljs-comment">//tail指向n1部分</span><br>            tail=n1;<span class="hljs-comment">//再把tail更新一下</span><br>         <br>        &#125;<br>          n1=n1-&gt;next;<br>    &#125;<br>       <span class="hljs-keyword">else</span><span class="hljs-comment">//同理</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            head=tail=n2;<br>        <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tail-&gt;next=n2;<br>            tail=n2;<br>           <br>        &#125;<br>         n2=n2-&gt;next;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n1)<span class="hljs-comment">//如果n1不为空，那么就把n1整个链接到tail的后面</span><br>&#123;<br>tail-&gt;next=n1;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    tail-&gt;next=n2;<br>&#125;<br><span class="hljs-keyword">return</span> head;<span class="hljs-comment">//返回头</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">link</a>.</p><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f0d1fdcfdc1048b9906e69f4b7734d42.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>示例 1：</p><p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]</p><p>示例 2：</p><p>输入：head &#x3D; [], val &#x3D; 1 输出：[]</p><p>示例 3：</p><p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]</p><p>提示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">列表中的节点数目在范围 <span class="hljs-literal">[<span class="hljs-number">0</span>, <span class="hljs-number">104</span>]</span> 内<br><span class="hljs-number">1</span> &lt;= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Node</span>.</span></span><span class="hljs-keyword">val</span> &lt;= <span class="hljs-number">50</span><br><span class="hljs-number">0</span> &lt;= <span class="hljs-keyword">val</span> &lt;= <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure></blockquote><p>思路</p><blockquote><p>弄一个新链表，如果不为val就把原链表的节点链接到新链表里面去<br>为val就跳过去</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">removeElements</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> val)</span>&#123;<br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//新定义一个头节点，尾节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">newhead</span>=</span><span class="hljs-literal">NULL</span>,*tail=<span class="hljs-literal">NULL</span>,*cur=head;<br><span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cur-&gt;val!=val)<span class="hljs-comment">//不为val</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(newhead==<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            newhead=tail=cur;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tail-&gt;next=cur;<br>            tail=cur;<br>        &#125;<br>     <br>        cur=cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//为val</span><br>    &#123;<br>            cur=cur-&gt;next;  <br>              <br>    &#125;<br>&#125;<br><span class="hljs-comment">//[7,6,7,7]   val=7</span><br><span class="hljs-comment">//新链表是[6,7,7],后面也会一起链接进去，所以我们要处理后面的val，而且后面全是val，prev指向l的下一个</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">l</span>=</span>newhead;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">prev</span>=</span><span class="hljs-literal">NULL</span>;<span class="hljs-comment">//prev是l的前驱</span><br><span class="hljs-keyword">while</span>(l)<br>&#123;<br><span class="hljs-keyword">if</span>(l-&gt;val!=val)<br>&#123;<br>    prev=l;<br>    l=l-&gt;next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    prev-&gt;next=l-&gt;next;<span class="hljs-comment">//prev指向后一个，跳过那个点</span><br><span class="hljs-built_in">free</span>(l);<span class="hljs-comment">//释放掉</span><br>    l=prev-&gt;next;l跳到prev的后一个，这个时候prev的后一个已经被改变了<br>&#125;  <br><br>&#125;<br><span class="hljs-keyword">return</span> newhead;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分割链表"><a href="#分割链表" class="headerlink" title="分割链表"></a>分割链表</h1><p><a href="https://leetcode-cn.com/problems/partition-list-lcci/">link</a>.</p><blockquote><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你不需要 保留 每个分区中各节点的初始相对位置<br><img src="https://img-blog.csdnimg.cn/724b68f8d184486ea0280b622aea74fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>示例 1：</p><p>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3 输出：[1,2,2,4,3,5]</p><p>示例 2：</p><p>输入：head &#x3D; [2,1], x &#x3D; 2 输出：[1,2]</p><p>提示：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">链表中节点的数目在范围 [0, 200] 内<br><span class="hljs-deletion">-100 &lt;= Node.val &lt;= 100</span><br><span class="hljs-deletion">-200 &lt;= x &lt;= 200</span><br></code></pre></td></tr></table></figure></blockquote><p>思路</p><blockquote><p>我们可以弄两个链表，一个链表是小于x的链表，一个是大于等于x的链表<br>后面把两个链表链接起来，循环后面都指向NULL，把后面都截断掉，避免还有链接</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">lesshead</span>=</span><span class="hljs-literal">NULL</span>,*lesstail=<span class="hljs-literal">NULL</span>,*morehead=<span class="hljs-literal">NULL</span>,*moretail=<span class="hljs-literal">NULL</span>,*cur=head;<br>lesshead=lesstail=(<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br><span class="hljs-comment">//</span><br>morehead=moretail=(<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br><span class="hljs-keyword">while</span>(cur)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cur-&gt;val&lt;x)<span class="hljs-comment">//小于x的链接起来</span><br>    &#123;<br>        lesstail-&gt;next=cur;<br>        lesstail=cur;<br>        cur=cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//大于x的链接起来</span><br>    &#123;<br>        moretail-&gt;next=cur;<br>        moretail=cur;<br>        cur=cur-&gt;next;<br>    &#125;<br>&#125;<br>lesstail-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//吧tail后面都置成空哦</span><br>moretail-&gt;next=<span class="hljs-literal">NULL</span>;<br>lesstail-&gt;next=morehead-&gt;next;<span class="hljs-comment">//再连接起来</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>*<span class="hljs-title">new</span>=</span>lesshead-&gt;next;<br><span class="hljs-built_in">free</span>(morehead);<br><span class="hljs-built_in">free</span>(lesshead);<br>morehead=lesshead=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> new;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表 leetcode 数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++入门</title>
    <link href="/2021/12/29/c++%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/29/c++%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1"></a></li><li><ul><li><a href="#_2"></a></li><li><ul><li><a href="#_3"></a></li></ul></li></ul></li><li><a href="#_7">命名空间</a></li><li><a href="#c_89">c++的输入输出</a></li><li><a href="#_134">缺省</a></li><li><a href="#_189">函数重载</a></li><li><a href="#_277">引用</a></li><li><ul><li><a href="#_322">引用的特性</a></li><li><a href="#_351">引用的应用</a></li><li><ul><li><a href="#1_353">1.引用做函数参数</a></li><li><a href="#2_422">2.引用做返回值</a></li><li><a href="#_514">常引用</a></li><li><a href="#_551">引用的优点：</a></li></ul></li></ul></li><li><a href="#extern_C_564">extern “C”</a></li><li><a href="#inline_583">内联函数inline</a></li></ul><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>解决c语言命名冲突问题<br>1.我们自己定义的变量，函数可能和库里面重名冲突<br>2.但是进入公司项目组里面，做的项目通常比较大，多人协助，会导致代码中命名冲突 c语言无法解决这个问题，除非换名字 c++提出了新语法，叫命名空间，<br>3.命名空间里面可以包含各种东西，函数，结构体，变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> rand = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, rand);<span class="hljs-comment">//如果没加stdlib.h这个头文件的化，</span><br><span class="hljs-comment">//是可以正常运行的，但是如果包了这个头文件时，rand就是里面的函数</span><br><span class="hljs-comment">//因为在预处理的时候，头文件展开，里面有rand这函数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, rand);<span class="hljs-comment">//以十进制方式打印，出来的是地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>namespace空间—–是一个域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//定义了一个叫b的命名空间，命名空间是全局的</span><br>namespace b<br>&#123;<br><span class="hljs-comment">//他们还是一个全局变量，放到静态域，</span><br><span class="hljs-type">int</span> rand = <span class="hljs-number">0</span>;<span class="hljs-comment">//加这个就是为了避免冲突</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-comment">//全局域</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><span class="hljs-comment">//函数里面叫局部域</span><br><span class="hljs-comment">//编译器会先在局部去找，再去全局去找，否则就会报错</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, rand);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, b::rand);<span class="hljs-comment">//::叫做域作用限定符，意思是去取左边这个域里面的，很明显要去b这个域里卖弄去找</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<span class="hljs-comment">//a为局部域里面去找</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ::a);<span class="hljs-comment">//a到左边的空白域里面去找，就是去全局域里面去找</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>namespace也可以嵌套包含<br>对嵌套包含的要用两层：：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//命名空间里面还可嵌套</span><br><span class="hljs-keyword">namespace</span> bt<span class="hljs-comment">//命名空间里面不仅可以定义变量，还可以定义函数，类型</span><br>&#123;<br><span class="hljs-type">int</span> rand = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> left + right; <br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> val;<br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">node</span>* next;<br>&#125;;<br><span class="hljs-keyword">namespace</span> n1<br>&#123;<br><span class="hljs-type">int</span> d = <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//使用命名空间里面的的东西</span><br><span class="hljs-comment">//不同文件里面定义的同样的命名空间，会被合并成一个，命名空间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>bt::rand = <span class="hljs-number">10</span>;<span class="hljs-comment">//使用其与其他进行隔离</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bt</span>:: node nt;<span class="hljs-comment">//要加bt：：才可以找得到里面的东西</span><br>bt::<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//这样就可以找到了，只是影响了编译器找的规则</span><br>bt::n1::d = <span class="hljs-number">2</span>;<span class="hljs-comment">//运用指定，这样子可以把嵌套的引用出来</span><br><span class="hljs-comment">//这种可以做到最好的命名隔离，</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="c-的输入输出"><a href="#c-的输入输出" class="headerlink" title="c++的输入输出"></a>c++的输入输出</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//输入输出流</span><br><br><span class="hljs-comment">//using namespace std;</span><br><span class="hljs-comment">//c++库的实现定义在一个std的一个命名空间中，</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//cout可以自动识别类型</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//endl是用来换行的</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">1.2</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">12</span>;<br>cout &lt;&lt; d &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;k&lt;&lt; endl;<span class="hljs-comment">//自动识别类型不用%d，不可以控制小数点的位数，c++d输入输出可以混在一起写</span><br>cin &gt;&gt; k &gt;&gt; d;<span class="hljs-comment">//把数据流向k和d</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="缺省"><a href="#缺省" class="headerlink" title="缺省"></a>缺省</h1><p>全缺省和半缺省</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//缺省参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>)</span><span class="hljs-comment">//如果func1里面传了参数，就和传的是一样的，如果func1里面没有传参数，相当于实参是0，形参是a</span></span><br><span class="hljs-function"><span class="hljs-comment">//把缺省值去当作实参传给a</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>)</span><span class="hljs-comment">//全缺省</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//半缺省，缺省一部分参数，必须从右往左缺省,必须连续缺省</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">32</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">89</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">func1</span>();<br><span class="hljs-built_in">func2</span>();<span class="hljs-comment">//啥都不传</span><br><span class="hljs-built_in">func2</span>(<span class="hljs-number">13</span>, <span class="hljs-number">42</span>);<span class="hljs-comment">//从左往右给</span><br><span class="hljs-built_in">func3</span>(<span class="hljs-number">13</span>);<span class="hljs-comment">//a必须要传，缺省的可以不传</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span><br>&#123;<br><span class="hljs-type">int</span>* a;<br><span class="hljs-type">int</span> top;<br><span class="hljs-type">int</span> capacity;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stackinit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack*ps,<span class="hljs-type">int</span> capcity=<span class="hljs-number">4</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>ps-&gt;a = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * capcity);<br>ps-&gt;top = <span class="hljs-number">0</span>;<br>ps-&gt;capacity = capcity;<br>&#125;<br><br><span class="hljs-comment">/*int main()</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">struct stack st;</span><br><span class="hljs-comment">stackinit(&amp;st);//不知道栈最多可以存多少数据，就用缺省值初始化</span><br><span class="hljs-comment">stackinit(&amp;st, 100);//知道最多可以存多少数据，就传值，减少增容次数，提高效率</span><br><span class="hljs-comment">return 0;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-comment">//缺省参数不能同时在声名与定义中出现，推荐大家写在声名，方便查找</span><br></code></pre></td></tr></table></figure><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><blockquote><p>函数重载：是函数的一种特殊情况，同一个函数有不同功能， 这些同名函数的形参列表（参数个数或类型或顺序）不同，用来处理实现功能类似的不同问题</p><p>函数名相同的不同函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1.参数的类型不同</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;left &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; right &lt;&lt; endl;<br><span class="hljs-keyword">return</span> left + right;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; right &lt;&lt; endl;<br><span class="hljs-keyword">return</span> left + right;<br>&#125;<br><br><span class="hljs-comment">//2参数个数不一样</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;f()&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//没传参数就调用他</span><br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;f(int a)&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//传了参数就调用他</span><br>&#125;<br><br><br><span class="hljs-comment">//顺序不同</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> b)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; fs(int a, char b)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fs</span><span class="hljs-params">(<span class="hljs-type">char</span> b,<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; fs(char b,int a)&quot;</span> &lt;&lt; endl; <br>&#125;<br><br><span class="hljs-comment">//返回值不同不能构成承载，返回值不同不能区分，参数不同可以区别的</span><br><span class="hljs-comment">//void a(int a)</span><br><span class="hljs-comment">//int a(int a)</span><br><br><span class="hljs-comment">//缺省值不同，不能构成重载</span><br><br><span class="hljs-comment">//1.</span><br><span class="hljs-comment">//void cz(int a)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;as&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//void cz(int a = 21)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;asd&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//2.形参个数不同，构成重载，但是使用的时候要小心</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">as</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ead&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">as</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">21</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;as&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br>cout&lt;&lt;<span class="hljs-built_in">add</span>(<span class="hljs-number">3.3</span>, <span class="hljs-number">8.3</span>)&lt;&lt;endl;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">fs</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;s&#x27;</span>);<br><span class="hljs-built_in">fs</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">32</span>);<br><span class="hljs-built_in">as</span>();<span class="hljs-comment">//存在歧义</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用就是给别的变量取别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = a;<span class="hljs-comment">//把a的值赋给b</span><br><span class="hljs-comment">//引用定义。</span><br><span class="hljs-type">int</span>&amp; c = a;<span class="hljs-comment">//引用，在变量名和类型的中间就是一个引用，是a的引用，</span><br><span class="hljs-comment">//c是a的别名</span><br><span class="hljs-comment">//c和a的地址和值都是一样的</span><br><span class="hljs-comment">//引用在语法层，我们要理解为这里没有开一个新空间，就是对原来的取了一个新名称叫做b</span><br><span class="hljs-comment">//如李逵，黑旋风都是一个人</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<span class="hljs-comment">//a和c都改成20，</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">30</span>;<span class="hljs-comment">//c和a都改成了30，</span><br><span class="hljs-comment">//如李逵吃饭了，黑旋风也吃了</span><br><span class="hljs-comment">//黑旋风吃饱了，李逵也吃饱了</span><br><span class="hljs-type">int</span>* p = &amp;a;<span class="hljs-comment">//单独就是取地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>&amp; b = a;<span class="hljs-comment">//相同类型不会产生临时变量</span><br><span class="hljs-type">double</span> c = <span class="hljs-number">1.1</span>;<br><span class="hljs-type">int</span> m = c;<span class="hljs-comment">//会产生一个临时变量,</span><br><span class="hljs-comment">//同样类型的截断，类型的提升都会产生一个临时变量</span><br><span class="hljs-comment">//函数的返回</span><br><span class="hljs-comment">//传值返回也是临时变量</span><br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; r = c;<span class="hljs-comment">//r是c的临时变量的别名，把精度丢了</span><br>cout &lt;&lt; r&lt;&lt;m &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用的特性"><a href="#引用的特性" class="headerlink" title="引用的特性"></a>引用的特性</h2><p>1.引用必须初始化<br>2.一个变量可以有多个引用<br>3.引用只能用一个实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1.引用在定义的时候必须初始化，引用是取别名，要说清楚是给谁取别名</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-comment">//2.一个变量可以有多个引用，</span><br><span class="hljs-type">int</span> k = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span>&amp; kt = k;<br><span class="hljs-type">int</span>&amp; ktt = k;<span class="hljs-comment">//相当于可以有很多个外号，</span><br><span class="hljs-type">int</span>&amp; m = kt;<span class="hljs-comment">//这样也可以，kt，k，m，kkt都是一个空间，一个人可以有很多个名字</span><br><span class="hljs-comment">//3.引用一旦引用了一个实体，再不能引用其他实体了，</span><br><span class="hljs-type">int</span> d = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; dt = d;<br><span class="hljs-type">int</span> c = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//1.这里有两层，是让dt变成c的别名呢？     否</span><br><span class="hljs-comment">//还是把c赋值给dt呢？                    是</span><br><span class="hljs-comment">//经过调试是把c赋值给dt，dt和d的值都变成了20</span><br>dt = c;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用的应用"><a href="#引用的应用" class="headerlink" title="引用的应用"></a>引用的应用</h2><h3 id="1-引用做函数参数"><a href="#1-引用做函数参数" class="headerlink" title="1.引用做函数参数"></a>1.引用做函数参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tmp = *a;<br>*a = *b;<br>*b = tmp;<br>&#125;<br><br><span class="hljs-comment">//cpp的实现</span><br><span class="hljs-comment">//1.做参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; r1, <span class="hljs-type">int</span>&amp; r2)</span><span class="hljs-comment">//r1是x的引用，x的别名，传引用，传地址和传引用功能相同 ，形参的改变可以改变实参</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t = r1;<br>r1 = r2;<br>r2 = t;<br>&#125;<br><br><span class="hljs-comment">//传值和传地址，传引用构成重载，但是调用时，传值和传引用存在歧义，不知道是传值还是传引用，</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">1</span>; <br><span class="hljs-built_in">swap</span>(&amp;x, &amp;y);<br><span class="hljs-built_in">swap</span>(x, y);<span class="hljs-comment">//传引用  </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpushback</span><span class="hljs-params">(slistnode*&amp; phead, slistdate x)</span><span class="hljs-comment">//指针的引用，别名不混在一起，phead的改变就是改变plist，不用传二级指针，好认识</span></span><br><span class="hljs-function"></span>&#123;<br>slistnode* newnode = <span class="hljs-built_in">buynode</span>(x);<br><span class="hljs-comment">//那么我们这个时候要找尾</span><br><span class="hljs-comment">//找到尾节点的指针</span><br><span class="hljs-keyword">if</span> (phead == <span class="hljs-literal">NULL</span>)<br>&#123;<br>phead = newnode;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>slistnode* tail = phead;<span class="hljs-comment">//我们要让tail走到尾部去，而非走到空</span><br><span class="hljs-keyword">while</span> (tail-&gt;next != <span class="hljs-literal">NULL</span>)<br>&#123;<br>tail = tail-&gt;next;<br>&#125;<span class="hljs-comment">//找到了尾节点,链接新节点</span><br>tail-&gt;next = newnode;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//指针也可以使用引用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-type">int</span>* p = &amp;a;<br><span class="hljs-type">int</span>*&amp; p2 = p;<br><span class="hljs-comment">//p2也是地址，p也是地址，p2是p的别名</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">single</span><span class="hljs-params">(<span class="hljs-type">int</span>* num, <span class="hljs-type">int</span> numsize, <span class="hljs-type">int</span>&amp; returnsize)</span><span class="hljs-comment">//returnsize就是传回去的长度的别名</span></span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="2-引用做返回值"><a href="#2-引用做返回值" class="headerlink" title="2.引用做返回值"></a>2.引用做返回值</h3><p>传值返回会有拷贝，就会有空间<br>传引用返回就不会有拷贝，原样返回<br>如果使用的变量在函数使用完之后没有销毁或者返回的空间较大，就用引用返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> c = a + b;<br><span class="hljs-keyword">return</span> c;<span class="hljs-comment">//返回的是c的临时拷贝，相当于int tmp=3被传回去了，只能调用一次，调用完了之后就会变成随机值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> c = a + b;<br><span class="hljs-keyword">return</span> c;<span class="hljs-comment">//f这里返回的就是c别名，</span><br><span class="hljs-comment">//c传给int&amp; tmp,就是c，所以不会有拷贝造成的空间浪费</span><br>&#125;<br><br><span class="hljs-comment">//但是如果函数返回的时候，返回的对象出了函数的作用域还没有销毁，就可以用传引用返回</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">cout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> n = <span class="hljs-number">12</span>;<br>n++;<br><span class="hljs-comment">//……</span><br><span class="hljs-keyword">return</span> n;<span class="hljs-comment">//n是一个静态变量，出了函数域不会消失，所以用传引用返回</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">dd</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//int&amp; ret=dd(1,2),这样是不行的</span><br><span class="hljs-type">int</span> r = <span class="hljs-built_in">d</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">//这样写会存在非法访问，因为add(1,2)的返回值是c的引用，所以add栈帧销毁了以后，回去访问c位置的空间</span><br><span class="hljs-comment">//如果add函数栈帧销毁了，清理空间那么取c值的时候，取到的就是随机值，给ret就是随机值，当然这个取决于编译器的的实现</span><br>cout &lt;&lt; ret &lt;&lt; endl;<br>cout &lt;&lt; r &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span><br>&#123;<br><span class="hljs-type">int</span>* a;<br><span class="hljs-type">int</span> top;<br><span class="hljs-type">int</span> capacity;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack st)</span><span class="hljs-comment">//传值参数，会有拷贝，有空间开辟，原样拷贝</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack* st)</span><span class="hljs-comment">//传地址参数，指针开辟了4个字节</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//引用做参数，随时都可以，可以1.提高效率，2.形参的修改可以影响实参，输出型参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack&amp; rst)</span><span class="hljs-comment">//传引用参数，rst就是st的别名，没有开辟空间</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> st;<br><span class="hljs-built_in">func1</span>(st);<br><span class="hljs-comment">//指针和引用可以构成函数重载，因为指针和引用是两种不同类型的参数</span><br><span class="hljs-built_in">func</span>(&amp;st);<br><span class="hljs-built_in">func</span>(st);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//传引用返回的价值</span><br><span class="hljs-comment">//1.提高效率，2.修改返回变量</span><br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//处理作用域，还在就很有用</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-comment">//第一次进入就创建了一个数组</span><br><span class="hljs-keyword">return</span> a[i];<span class="hljs-comment">//返回这数组第i个位置的别名</span><br><span class="hljs-comment">//变成了可读可写的，</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><p>用const进行修饰，在做参数的时候尽量都加一个const进行修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//尽量使用const引用进行传参</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//const 引用通吃</span><br><span class="hljs-comment">// const type&amp; 可以接收各种类型的对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//权限被放大了，a从一个只读不写的，变成b一个可读可写的就是错的</span><br><span class="hljs-comment">//const int a = 10;</span><br><span class="hljs-comment">//int&amp; b = a;</span><br><br><span class="hljs-comment">//权限不变，就可以</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = a;<span class="hljs-comment">//</span><br><br><span class="hljs-comment">//权限缩小</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">2</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; d = c;<span class="hljs-comment">//从可读可写的变成只读不写的是可以的</span><br><br><span class="hljs-type">double</span> d = <span class="hljs-number">1.11</span>;<br><span class="hljs-type">int</span> i = d;<span class="hljs-comment">//类型转化，把d的整形部分转过去,不加引用可以</span><br><span class="hljs-comment">//int&amp; k = d;//</span><br><span class="hljs-comment">//d的临时变量是具有常性，只读不写，而int&amp;具有可读可写， </span><br><span class="hljs-comment">//普通引用引的是左值，const引用引的是右值</span><br><span class="hljs-comment">//临时变量具有常性，不能被修改，</span><br><span class="hljs-comment">//const 接收就是常量了</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用的优点："><a href="#引用的优点：" class="headerlink" title="引用的优点："></a>引用的优点：</h3><p>引用和指针的不同点<br>1.引用在概念上定义一个<strong>变量的别名</strong>（没有开空间），指针存储一个变量的地址<br>2.引用在定义的时候<strong>必须初始化</strong>，指针<strong>最好初始化</strong>，但是不初始化也不会报错（会变成野指针）<br>3.<strong>引用</strong>在初始化时引用一个实体后，就<strong>不能再引用其他实体</strong>，而<strong>指针可以</strong>在任何时候指向任何一个相同类型的实体（如我们在<strong>链表</strong>的时候指向不同的地方）<br>4.没有NULL的引用，但是有NULL 的指针<br>5.在sizeof里面的含义不同，引用为<strong>引用类型的大小</strong>，但是指针是地址空间所占字节大小（32位下是<strong>4个字节</strong>或64位里面的<strong>8个字节</strong>）<br>6.<strong>引用</strong>自加**++<strong>是引用的那个</strong>实体+1**，而<strong>指针</strong>是指针指向<strong>偏移一个类型</strong>的大小<br>7.<strong>访问实体方式不同</strong>，指针需要解引用，引用编译器里面会自己处理<br>8.有多级指针没有多级引用，引用比指针更加安全</p><h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><p><strong>c++程序</strong>，调用<strong>c的库</strong>，再c++程序中加<strong>extern “C”</strong><br>告诉c++编译器，{}里面的函数是用c的编译器编译的，链接的时候，用c的函数名规则去找，就可以链接上了,只有c++才认识extern “c”</p><p>c程序，调用c++的库，再c++库中加extern “C”<br>c掉c++，c++的静态库就会用c的函数名修饰规则去处理以下函数，所以就不能用重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在c程序调用c++时候，在c++库里面加extern &quot;C&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  __cplusplus</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXTERN_C extern <span class="hljs-string">&quot;C&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXTERN_C</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//  __cplusplus</span></span><br></code></pre></td></tr></table></figure><h1 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h1><p>我们在每次调用函数都会建立栈帧，有栈帧就会有消耗,需要建立栈帧，栈帧中要保存一些寄存器，结束后又要恢复，<br>可以看到这些都是有消耗的，对于频繁调用的小函数，能否优化一下呢，<br>c语言可以用宏，来操作避免栈帧的建立</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ad(x,y) ((x)+(y));</span><br></code></pre></td></tr></table></figure><p>c++的实现方法inline，内联函数</p><blockquote><p>有了inline就不需要去用c的宏，因为<strong>宏很复杂</strong>，很容易出错 inline但是展开的话，指令就会特别多<br>1.inline是一种以<strong>空间换时间</strong>的做法，省去调用函数栈帧的过程，所以代码量长的函数，或者递归函数就不适合用inline，展开之后就会有特别多的指令，变得很大<br>所以小函数比较适合用inline<br>2.inline<strong>对于编译器只是一个建议</strong>，编译器会自动识别，递归或长的编译器会<strong>自动忽视inline</strong><br>3.inline<strong>函数声名和定义不能分离</strong>，.h和.cpp都要加一个inline，</p><p>结论：<strong>短小</strong>或<strong>频繁使用</strong>的函数就定义成inline</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><span class="hljs-comment">//这样就不会建立栈帧，内联函数，默认是不会展开的，没有函数调用了</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = x + y;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span><span class="hljs-comment">//swap也会经常会出现</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tmp = a;<br>a = b;<br>b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ c语言 visual studio c# qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2021/12/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2021/12/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1"></a></li><li><ul><li><a href="#_2"></a></li><li><ul><li><a href="#_3"></a></li></ul></li><li><a href="#_6">一维前缀和</a></li><li><a href="#_53">一维差分</a></li><li><a href="#_90">二维前缀和</a></li><li><a href="#_149">二维差分</a></li></ul></li></ul><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><blockquote><p>sum[i]&#x3D;sum[i-1]+a[i];i&gt;0<br>sum[i]&#x3D;sum[0]&#x3D;a[0] ;i&#x3D;0<br>arr 1,3, 7, 5, 2<br>sum 1,4,11,16,18<br>sum[i]是0到i的区间和<br>如2到4的区间和,k-r<br>sum[r,k]&#x3D;sum[k]-sum[r-1]; r&gt;0,<br>r&#x3D;0的时候， sum[k] r&#x3D;0;</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getsum(k,r) (k?sum[r]-sum[k-1]:sum[r])<span class="hljs-comment">//获得k到r间的和,宏定义更加的方便</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> r,<span class="hljs-type">int</span> *sum)</span><br>&#123;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> sum[r];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> sum[r] - sum[k - <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> sum[<span class="hljs-number">5</span>];<span class="hljs-comment">//sum原来记录前缀和</span><br>sum[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<span class="hljs-comment">//0单独记录</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>sum[i] = sum[i - <span class="hljs-number">1</span>] + arr[i];<br><br>&#125;<br><span class="hljs-comment">//获取前缀和</span><br><span class="hljs-comment">//获得k到r的和</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, getsum(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">//得到2-4的区间和，使用宏的方法</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, get_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>,sum));<span class="hljs-comment">//</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><blockquote><p>再区间里面对区间值进行修改，如果使用普通的方法，操作一次的时间复杂度是O(N),如果要询问k次，时间复杂度就是O（n*k）<br>差分就是d[0]&#x3D;a[0],d[1]&#x3D;a[1]-a[0];,差分的前缀和就是原数组</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一开始</span><br><span class="hljs-type">int</span> d[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//比arr多开辟一个空间原来r+1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> v)</span><br>&#123; <br>d[l] += v;<span class="hljs-comment">//在l-r的区间上都加上一个val，就是d[l]+v,加了之后对后面的所有值都加了一个val，但是d[r+1]-v,把后面加起来的v都抵消掉，只保证r-l间改变</span><br>d[r + <span class="hljs-number">1</span>] -=v;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span> &#125;;<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">//2-4都+5</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br>add(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>);<br><span class="hljs-comment">//将d取0进行操作 </span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<span class="hljs-comment">//对d进行做前缀和，就是要对arr改变的值</span><br>d[i] += d[i - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<span class="hljs-comment">//将d加到arr上</span><br>arr[i] += d[i];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>&#125;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(d));<span class="hljs-comment">//用完了之后要将d还原为0，以免后续有重新再用d</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><blockquote><p>将矩阵进行操作，从（x1，y1）-&gt;(x2,y2)形成的矩阵，进行前缀和相加</p></blockquote><p><img src="https://img-blog.csdnimg.cn/99c291c4611d43bcadccd3da07f36286.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/68aede86073b4f9aa26e037c1a1113ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br><br>&#123;<br><span class="hljs-type">int</span> matrix[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] = &#123; &#123;<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>&#125; &#125;;<br><br><span class="hljs-comment">//计算二维数组的前缀和</span><br><span class="hljs-type">int</span> sum[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<span class="hljs-comment">//sum[i][j]是从s[0][0]到s[i][j]形成的矩阵中进行前缀和相加</span><br><span class="hljs-type">int</span> i, j;<br><span class="hljs-comment">//计算前缀和，这里要用公式计算</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br>&#123;<br>sum[i][j] = matrix[i][j];<br><span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br>&#123;<br>sum[i][j] += sum[i - <span class="hljs-number">1</span>][j];<br>&#125;<br><span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br>&#123;<br>sum[i][j] += sum[i][j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; j - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br>&#123;<br>sum[i][j] -= sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-comment">//计算区间和</span><br><span class="hljs-comment">//如[2,2]-&gt;[3,3];</span><br><span class="hljs-type">int</span> row1 = <span class="hljs-number">2</span>, col1 = <span class="hljs-number">2</span>, row2 = <span class="hljs-number">3</span>, col2 = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> ans = sum[row2][col2];<br><span class="hljs-keyword">if</span> (col1 - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br>&#123;<br>ans -= sum[row2][col1 - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (row1 - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br>&#123;<br>ans -= sum[row1 - <span class="hljs-number">1</span>][col2];<br>&#125;<br><span class="hljs-keyword">if</span> (col1 - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; row1 - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br>&#123;<br>ans += sum[row1 - <span class="hljs-number">1</span>][col1 - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> d[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br><span class="hljs-comment">//二维前缀和</span><br><span class="hljs-comment">//二维差分</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> v)</span><br>&#123;<br>d[x1][y1] += v;<br>d[x2 + <span class="hljs-number">1</span>][y1] -= v;<br>d[x1][y2 + <span class="hljs-number">1</span>] -= v;<br>d[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += v;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span>** d, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; x; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; y; j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, d[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> matrix[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125; &#125;;<br><br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(d));<br>add( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>);<br><span class="hljs-type">int</span> i, j;<br><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br>matrix[i][j] += d[i][j];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, matrix[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵 线性代数 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树深入剖析</title>
    <link href="/2021/12/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
    <url>/2021/12/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1"></a></li><li><ul><li><a href="#_2"></a></li><li><ul><li><a href="#_3"></a></li></ul></li><li><a href="#_13">**二叉树的遍历（前序，中序，后序）**</a></li><li><a href="#_116">计算二叉树的节点的个数</a></li><li><a href="#k_172">计算第k层的节点</a></li><li><a href="#_207">二叉树的深度</a></li><li><a href="#_237">查找一个节点</a></li><li><a href="#_268">层序遍历</a></li><li><a href="#_306">判断是否为完全二叉树</a></li><li><a href="#testc_361">test.c</a></li></ul></li></ul><p>二叉树的基本结构</p><blockquote><p>用指针来指向两个子树节点，依次来把节点来连接起来</p></blockquote><p><img src="https://img-blog.csdnimg.cn/98db974fa2414e118028635e573b7981.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="二叉树的遍历（前序，中序，后序）"><a href="#二叉树的遍历（前序，中序，后序）" class="headerlink" title="二叉树的遍历（前序，中序，后序）"></a><strong>二叉树的遍历（前序，中序，后序）</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> btdata;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinaryTreeNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//指针域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinaryTreeNode</span> *<span class="hljs-title">left</span>;</span><span class="hljs-comment">//链接左孩子</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinaryTreeNode</span> *<span class="hljs-title">right</span>;</span><span class="hljs-comment">//链接右孩子</span><br>    btdata data;<span class="hljs-comment">//数据域</span><br>&#125;btnode;<br><br><br><span class="hljs-comment">//开辟节点</span><br>btnode* <span class="hljs-title function_">buynode</span><span class="hljs-params">(btdata x)</span><br>&#123;<br>    <br><br>    btnode*node=<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(btnode));<br>    <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//判定是否动态开辟成功</span><br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<span class="hljs-comment">//没开辟成功就退出</span><br>    &#125;<br><br>node-&gt;data=x;<span class="hljs-comment">//链接数据</span><br>node-&gt;left=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//还没链接其他指针就置成空</span><br>node-&gt;right=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-comment">//暴力造一个树</span><br>btnode*<span class="hljs-title function_">creatbinarytree</span><span class="hljs-params">()</span><br>&#123;<br><br>    btnode*nodeA=buynode(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    btnode*nodeB=buynode(<span class="hljs-string">&#x27;B&#x27;</span>);<br>    btnode*nodeC=buynode(<span class="hljs-string">&#x27;C&#x27;</span>);<br>    btnode*nodeD=buynode(<span class="hljs-string">&#x27;D&#x27;</span>);<br>    btnode*nodeE=buynode(<span class="hljs-string">&#x27;E&#x27;</span>);<br>    btnode*nodeF=buynode(<span class="hljs-string">&#x27;F&#x27;</span>);<br>    nodeA-&gt;left=nodeB;<br>    nodeB-&gt;left=nodeD;<br>    nodeA-&gt;right=nodeC;<br>    nodeC-&gt;left=nodeE;<br>    nodeC-&gt;right=nodeF;<br>    <span class="hljs-keyword">return</span> nodeA;<span class="hljs-comment">//返回的是根节点</span><br>&#125;<br><br><span class="hljs-comment">//前序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(btnode*root)</span><br>&#123;<br>    <span class="hljs-comment">//如果当前三一个空树</span><br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL-&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-comment">//不是一个空树</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c-&gt;&quot;</span>,root-&gt;data);<span class="hljs-comment">//先遍历根，后再遍历左右</span><br>preorder(root-&gt;left);<span class="hljs-comment">//左子树</span><br>preorder(root-&gt;right);<span class="hljs-comment">//右子树</span><br><br>&#125;<br><br><span class="hljs-comment">//中序   左根右</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(btnode*root)</span><br>&#123;<br>    <span class="hljs-comment">//如果当前三一个空树</span><br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL-&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-comment">//不是一个空树</span><br><br>inorder(root-&gt;left);<span class="hljs-comment">//左子树</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c-&gt;&quot;</span>,root-&gt;data);<span class="hljs-comment">//根</span><br>inorder(root-&gt;right);<span class="hljs-comment">//右子树</span><br>&#125;<br><br><span class="hljs-comment">//后序   左右根</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(btnode*root)</span><br>&#123;<br>    <span class="hljs-comment">//如果当前三一个空树</span><br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL-&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-comment">//不是一个空树</span><br><br>postorder(root-&gt;left);<span class="hljs-comment">//左子树</span><br>postorder(root-&gt;right);<span class="hljs-comment">//右子树</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c-&gt;&quot;</span>,root-&gt;data);<span class="hljs-comment">//根</span><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="计算二叉树的节点的个数"><a href="#计算二叉树的节点的个数" class="headerlink" title="计算二叉树的节点的个数"></a>计算二叉树的节点的个数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一.计算节点的个数</span><br><span class="hljs-comment">//错误方法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarytreesize</span><span class="hljs-params">(btnode*root)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//用了static的话，每次调用都会在原来的基础上对count进行++，</span><br>    <span class="hljs-comment">//如果不加static的话，cout在栈上开辟，调用完就会销毁</span><br>    count++;<br>    binarytreesize(root-&gt;left);<br>    binarytreesize(root-&gt;right);<br>    <span class="hljs-keyword">return</span> count;<span class="hljs-comment">//这样计算出来的结果永远都是1</span><br>&#125;<br><br><span class="hljs-comment">//正确的做法1.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">binarytreesize2</span><span class="hljs-params">(btnode*root,<span class="hljs-type">int</span>*x)</span><span class="hljs-comment">//用指针进行操作，这样每次都是对同一个空间进行操作</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ++(*x);<span class="hljs-comment">//对地址进行操作就不会出现static和销毁的情况了</span><br>    binarytreesize2(root-&gt;left,x);<br>    binarytreesize2(root-&gt;right,x);<br>&#125;<br><span class="hljs-comment">//正确的做法2.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarytreesize3</span><span class="hljs-params">(btnode*root)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> root==<span class="hljs-literal">NULL</span>?<span class="hljs-number">0</span>:binarytreesize3(root-&gt;left)+binarytreesize3(root-&gt;right)+<span class="hljs-number">1</span>;<span class="hljs-comment">//把问题分为了左右子树，和自己，不断的细分，左右+1</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//二.计算叶子节点的个数，就是没有子树节点的个数，度为0的个数</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">binaryleafsize2</span><span class="hljs-params">(btnode*root)</span><span class="hljs-comment">//左子树的叶子节点和右子树的叶子节点加起来</span><br>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//并非一定整个树都是空，后面递归可能三左子树或右子树是空</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>    <span class="hljs-keyword">return</span> (root-&gt;left==<span class="hljs-literal">NULL</span>)&amp;&amp;(root-&gt;right==<span class="hljs-literal">NULL</span>)?<span class="hljs-number">1</span>:binaryleafsize2(root-&gt;left)+binaryleafsize2(root-&gt;right);<span class="hljs-comment">//叶子节点左右都没有节点，则+1，为叶子就返回一，不为叶子就继续把左右子树的叶子加起来</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">在这里插入代码片<br></code></pre></td></tr></table></figure><h2 id="计算第k层的节点"><a href="#计算第k层的节点" class="headerlink" title="计算第k层的节点"></a>计算第k层的节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//三.计算第k层节点的个数</span><br><span class="hljs-comment">//如，要求第4层，就求的3层的左子树节点数量加上右子树第3层的节点</span><br><br><span class="hljs-comment">//这里我们用了一个相对距离的概念</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarytreelevelsize</span><span class="hljs-params">(btnode*root,<span class="hljs-type">int</span> k)</span><br>&#123;<br> <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//没有节点，就通通返回0</span><br> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-keyword">if</span>(k&lt;<span class="hljs-number">1</span>)<br> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-comment">//走到了这里，就不为空</span><br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)<br> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//如果要我们求第一层就返回1,不用求了</span><br> &#125;<br><span class="hljs-comment">//root不为空，k大于1</span><br><span class="hljs-comment">//说明root第k层的节点在子树里面，</span><br><span class="hljs-comment">//就转化为了左右子树的第k-1层节点的数量</span><br><span class="hljs-comment">//如要求我的第4层，相当于求为左子树的第三层和右子树的第3层,</span><br><span class="hljs-comment">//直到为第一层，本层</span><br><span class="hljs-keyword">return</span> binarytreelevelsize(root-&gt;left,k<span class="hljs-number">-1</span>)+binarytreelevelsize(root-&gt;right,k<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>```c<br></code></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算树的深度（高度）层次</span><br><span class="hljs-comment">//我们一般规定第一层为1，空树就算0,从1开始</span><br><span class="hljs-comment">//计算深度就是左子树深度和右子树深度中大的+1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binarytreedepth</span><span class="hljs-params">(btnode*root)</span><br>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//这样写会重复计算，因为前面比较的时候已经算出结果了，但因为没有保存结果，严重的浪费了，</span><br><span class="hljs-comment">//return binarytreedepth(root-&gt;left)&gt;binarytreedepth(root-&gt;right)?binarytreedepth(root-&gt;left)+1:binarytreedepth(root-&gt;right)+1;//大的那个+1</span><br><br><span class="hljs-comment">//用一个变量来记录</span><br><span class="hljs-type">int</span> leftdepth=binarytreedepth(root-&gt;left);<span class="hljs-comment">//一层一层留一个大的返回区</span><br><span class="hljs-type">int</span> rightdepth=binarytreedepth(root-&gt;right);<br><span class="hljs-comment">//相当于后序</span><br><span class="hljs-keyword">return</span> leftdepth&gt;rightdepth?leftdepth+<span class="hljs-number">1</span>:rightdepth+<span class="hljs-number">1</span>;<br><br>&#125;<br><br><br><br><br>```c<br></code></pre></td></tr></table></figure><h2 id="查找一个节点"><a href="#查找一个节点" class="headerlink" title="查找一个节点"></a>查找一个节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//二叉树中查找值为x的节点</span><br><span class="hljs-comment">//找到了就返回他的地址</span><br>btnode* <span class="hljs-title function_">binarytreefind</span><span class="hljs-params">(btnode*root,btdata x)</span><br>&#123;<br><span class="hljs-comment">//根左右的遍历</span><br><span class="hljs-comment">//先找根</span><br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//返回null是为了告诉上一层我没找到</span><br>&#125;<br><span class="hljs-keyword">if</span>(root-&gt;data==x)<span class="hljs-comment">//找到了</span><br>&#123;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br>      btnode*leftret=binarytreefind(root-&gt;left,x);<br>      <span class="hljs-keyword">if</span>(leftret)<span class="hljs-comment">//不为空，也就是左边找到了</span><br>      &#123;<br>            <span class="hljs-keyword">return</span> leftret;<br>      &#125;<br>    btnode*rightret=binarytreefind(root-&gt;right,x);<br>     <span class="hljs-keyword">if</span>(rightret)<span class="hljs-comment">//没走上面的就走下面的，右边找到了</span><br>     &#123;<br>      <span class="hljs-keyword">return</span> rightret;<br>     &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//左边没找到，右边也没找到</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><blockquote><p>用队列实现<br>1.先入根<br>2.在当前节点出来后，再把他的左右孩子带进去，不为空才带进去，这样上一层节点出的时候，带入下一层<br>3.直到队列为空，说明最后一层没有节点，遍历结束</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">binarytreelevelorder</span><span class="hljs-params">(btnode* root)</span><br>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//必须的操作</span><br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-built_in">queue</span> q;<br>queueinit(&amp;q);<span class="hljs-comment">//初始化一个队列</span><br>queuepush(&amp;q, root);<span class="hljs-comment">//入队</span><br><span class="hljs-keyword">while</span> (!queueempty(&amp;q))<span class="hljs-comment">//队不为空就继续操作</span><br>&#123;<br>btnode* front = queuefront(&amp;q);<span class="hljs-comment">//取下队头，避免之后找不到队里面的数据</span><br>queuepop(&amp;q);<span class="hljs-comment">//出队</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, front-&gt;data);<span class="hljs-comment">//打印</span><br><br><span class="hljs-comment">// 孩子带进队列</span><br><span class="hljs-keyword">if</span> (front-&gt;left)<br>queuepush(&amp;q, front-&gt;left);<span class="hljs-comment">//左右孩子不为空就入</span><br><br><span class="hljs-keyword">if</span> (front-&gt;right)<br>queuepush(&amp;q, front-&gt;right);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-comment">//queuedestroy(&amp;q);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h2><blockquote><p>判断满二叉树，可以计算树的高度，再计算树的节点树，是否等于2^h-1,十分容易</p></blockquote><blockquote><p>1.判断是否是完全二叉树(非空节点是连续的)<br>用层序遍历，队列的时候，空也入，null也当作一个元素，遇到空之后，队列里面全是空<br>非完全二叉树，遇到空后，队列里面并非全空</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">bool</span> <span class="hljs-title function_">iscompletebinarytree</span><span class="hljs-params">(btnode*root)</span><br>&#123;<br>    <span class="hljs-built_in">queue</span> q;<br>    queueinit(&amp;q);<br>    queuepush(&amp;q, root);<br>    <span class="hljs-keyword">while</span> (!queueempty(&amp;q))<span class="hljs-comment">//不为空就进入//队头</span><br>    &#123;<br>        btnode* front = queuefront(&amp;q);<br>        <span class="hljs-comment">//空也进</span><br>        queuepop(&amp;q);<br>        <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//遇到了一个NULL元素就跳出去，ci</span><br>        &#123;<br>            <span class="hljs-comment">//为空的花就跳出去</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//front不为空就入左右，左右不管是否为空都入，NULL也是元素</span><br>            queuepush(&amp;q, front-&gt;left);<br>            queuepush(&amp;q, front-&gt;right);<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-comment">//跳出去检查剩下的节点是否全是空,剩下的全是空就是完全二叉树，存在非空，则是非完全二叉树，</span><br>    <span class="hljs-comment">//出剩下的所有节点</span><br>    <span class="hljs-keyword">while</span> (queuesize(&amp;q))<span class="hljs-comment">//null也当作一个元素，直到元素个数完了，就是全是空的</span><br>    &#123;<br>         btnode* front = queuefront(&amp;q);<br>        queuepop(&amp;q);<br>        <span class="hljs-keyword">if</span> (front)<span class="hljs-comment">//遇到了不为空</span><br>        &#123;<br>            queuedestroy(&amp;q);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>    &#125;<br>    queuedestroy(&amp;q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="test-c"><a href="#test-c" class="headerlink" title="test.c"></a>test.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    btnode*root=creatbinarytree();<span class="hljs-comment">//造一个树</span><br>   <span class="hljs-comment">// preorder(root);//前序遍历，根，左子树，右子树</span><br>    <span class="hljs-comment">//用分治，：分而治之，大事化小，小事化了</span><br>    <span class="hljs-comment">//如校长想知道学校有多少人，让10个院报人数，院让专业老师统计人数，老师叫班长，一步一步化小，</span><br>   <span class="hljs-comment">//inorder(root);</span><br>     postorder(root);<br>     <span class="hljs-type">int</span> n1=<span class="hljs-number">0</span>;<br>     binarytreesize2(root, &amp;n1);<span class="hljs-comment">//把n1地址传过去，每次都对这个地址进行操作，就没有销毁的问题了</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n1=%d\n&quot;</span>,n1);<br>     <span class="hljs-type">int</span> n2=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n2=%d\n&quot;</span>,binarytreesize3(root));<br>     <span class="hljs-type">int</span> leafn=<span class="hljs-number">0</span>;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leafn=%d\n&quot;</span>,leafn);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leaf2=%d\n&quot;</span>,binaryleafsize2(root));<br>    <span class="hljs-type">int</span> n3=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;levelk=%d\n&quot;</span>,binarytreelevelsize(root,<span class="hljs-number">3</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;depth=%d\n&quot;</span>,binarytreedepth(root));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言 数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算之按位与</title>
    <link href="/2021/12/17/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <url>/2021/12/17/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><a href="#_2"></a></li><li><ul><li><a href="#_3"></a></li></ul></li><li><a href="#_6">按位与的概念</a></li><li><a href="#1_15">1.判断奇偶性</a></li><li><a href="#25_33">2.保留最后5个数</a></li><li><a href="#2__56">2 的幂</a></li><li><a href="#21_104">2进制数中位1的个数</a></li><li><a href="#_153">二进制表示中质数个计算置位</a></li><li><a href="#_1__221">根据数字二进制下 1 的数目排序</a></li></ul></li></ul><h2 id="按位与的概念"><a href="#按位与的概念" class="headerlink" title="按位与的概念"></a>按位与的概念</h2><blockquote><p>1.按位与，两个都为1则为1，有一个0就是0<br>2.无论是0还是1只要和1与上之后，都保持不变<br>3.无论是0还是1只要和0与上之后，就变成0<br>4.在c语言中，前缀0b代表2进制数，如0b001，前导0可有可无</p></blockquote><h2 id="1-判断奇偶性"><a href="#1-判断奇偶性" class="headerlink" title="1.判断奇偶性"></a>1.判断奇偶性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (c &amp; <span class="hljs-number">0b1</span>)<span class="hljs-comment">//前导0b代表他是2进制数，最后1和任何数按位，都是得最后一个数</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;奇数&quot;</span>);<span class="hljs-comment">//最后一位为1就是奇数</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;偶数&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-保留最后5个数"><a href="#2-保留最后5个数" class="headerlink" title="2.保留最后5个数"></a>2.保留最后5个数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> c = <span class="hljs-number">0b1001000</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, c &amp; <span class="hljs-number">0b11111</span>);<span class="hljs-comment">//和1按为就会保留那些，保留最后5个数</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>消除最后4个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">转化成<span class="hljs-number">16</span>进制方便<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> c = <span class="hljs-number">0b1101011</span>;<br><span class="hljs-comment">//前面都为1，后4个都为0即可</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, c&amp;<span class="hljs-number">0xfffffff0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-的幂"><a href="#2-的幂" class="headerlink" title="2 的幂"></a>2 的幂</h2><blockquote><blockquote><p>2 的幂</p></blockquote><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p><p>如果存在一个整数 x 使得 n &#x3D;&#x3D; 2x ，则认为 n 是 2 的幂次方。</p><p>示例 1：</p><p>输入：n &#x3D; 1 输出：true 解释：20 &#x3D; 1</p><p>示例 2：</p><p>输入：n &#x3D; 16 输出：true 解释：24 &#x3D; 16</p><p>示例 3：</p><p>输入：n &#x3D; 3 输出：false</p><p>示例 4：</p><p>输入：n &#x3D; 4 输出：true</p><p>示例 5：</p><p>输入：n &#x3D; 5 输出：false</p><p>提示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">-<span class="hljs-number">231</span> &lt;<span class="hljs-operator">=</span> n &lt;<span class="hljs-operator">=</span> <span class="hljs-number">231</span> - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>判断是否是2的幂 2的幂一定是10000，有1个1，后面全是0 所以判断条件是x-1为011111，两者与一下全变成了0</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><br><span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span>&amp;&amp;(n&amp;(n<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>;<span class="hljs-comment">//当n大于0才会有2的幂次方，小于等于0都是错的</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2进制数中位1的个数"><a href="#2进制数中位1的个数" class="headerlink" title="2进制数中位1的个数"></a>2进制数中位1的个数</h2><blockquote><blockquote><p>位1的个数</p></blockquote><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p>提示：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">请注意，在某些语言（如 <span class="hljs-keyword">Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</span><br><span class="hljs-keyword"></span>在 <span class="hljs-keyword">Java </span>中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 <span class="hljs-number">3</span> 中，输入表示有符号整数 -<span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p>示例 1：</p><p>输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串<br>00000000000000000000000000001011 中，共有三位为 ‘1’。</p><p>示例 2：</p><p>输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串<br>00000000000000000000000010000000 中，共有一位为 ‘1’。</p><p>示例 3：</p><p>输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串<br>11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><p>提示：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入必须是长度为<span class="hljs-number"> 32 </span>的 二进制串 。<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> &#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<span class="hljs-comment">//消到最后都变成了0</span><br>&#123;<br>    n&amp;=(n<span class="hljs-number">-1</span>);<span class="hljs-comment">//每次都把最高位的1给消掉了，消完之后到了下一个1的位置，执行的次数就是1的个数</span><br>    cnt++;<br>&#125;   <br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二进制表示中质数个计算置位"><a href="#二进制表示中质数个计算置位" class="headerlink" title="二进制表示中质数个计算置位"></a>二进制表示中质数个计算置位</h2><blockquote><blockquote><p>二进制表示中质数个计算置位</p></blockquote><p>给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。</p><p>（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）</p><p>示例 1:</p><p>输入: L &#x3D; 6, R &#x3D; 10 输出: 4 解释: 6 -&gt; 110 (2 个计算置位，2 是质数) 7 -&gt; 111 (3<br>个计算置位，3 是质数) 9 -&gt; 1001 (2 个计算置位，2 是质数) 10-&gt; 1010 (2 个计算置位，2 是质数)</p><p>示例 2:</p><p>输入: L &#x3D; 10, R &#x3D; 15 输出: 5 解释: 10 -&gt; 1010 (2 个计算置位, 2 是质数) 11 -&gt; 1011 (3<br>个计算置位, 3 是质数) 12 -&gt; 1100 (2 个计算置位, 2 是质数) 13 -&gt; 1101 (3 个计算置位, 3 是质数)<br>14 -&gt; 1110 (3 个计算置位, 3 是质数) 15 -&gt; 1111 (4 个计算置位, 4 不是质数)</p><p>注意:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">L, <span class="hljs-built_in">R</span> 是 L &lt;= <span class="hljs-built_in">R</span> 且在 [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>^<span class="hljs-number">6</span>] 中的整数。<br><span class="hljs-built_in">R</span> - L 的最大值为 <span class="hljs-number">10000</span>。<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">numbers</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        x&amp;=(x<span class="hljs-number">-1</span>);<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>||x==<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=(x/i);i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">countPrimeSetBits</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br><span class="hljs-comment">//写一个计算1的个数，写一个判断个数是否为奇数</span><br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i=left;i&lt;=right;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(isprime(numbers(i)))<br>&#123;<br>    n++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> n;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="根据数字二进制下-1-的数目排序"><a href="#根据数字二进制下-1-的数目排序" class="headerlink" title="根据数字二进制下 1 的数目排序"></a>根据数字二进制下 1 的数目排序</h2><blockquote><blockquote><p>根据数字二进制下 1 的数目排序</p></blockquote><p>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。</p><p>如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p><p>示例 1：</p><p>输入：arr &#x3D; [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个<br>1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1<br>的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</p><p>示例 2：</p><p>输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]<br>输出：[1,2,4,8,16,32,64,128,256,512,1024] 解释：数组中所有整数二进制下都只有 1 个 1<br>，所以你需要按照数值大小将它们排序。</p><p>示例 3：</p><p>输入：arr &#x3D; [10000,10000] 输出：[10000,10000]</p><p>示例 4：</p><p>输入：arr &#x3D; [2,3,5,7,11,13,17,19] 输出：[2,3,5,17,7,11,13,19]</p><p>示例 5：</p><p>输入：arr &#x3D; [10,100,1000,10000] 输出：[10,100,10000,1000]</p><p>提示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= arr.length &lt;= <span class="hljs-number">500</span><br><span class="hljs-symbol">0 </span>&lt;= arr[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> &#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<span class="hljs-comment">//消到最后都变成了0</span><br>&#123;<br>    n&amp;=(n<span class="hljs-number">-1</span>);<span class="hljs-comment">//每次都把最高位的1给消掉了，消完之后到了下一个1的位置，执行的次数就是1的个数</span><br>    cnt++;<br>&#125;   <br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span><br>&#123;<br>    <span class="hljs-type">int</span> tmp=*a;<br>    *a=*b;<br>    *b=tmp;<br>&#125;<br><span class="hljs-type">int</span>* <span class="hljs-title function_">sortByBits</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> arrSize, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br><span class="hljs-comment">//先写一个计算1的个数</span><br><span class="hljs-comment">//安1的个数进行排序</span><br><span class="hljs-comment">//已经升序</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span> *cnt = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*arrSize);<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>*returnSize = arrSize;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arrSize; i++)<br>&#123;<br>cnt[i] = hammingWeight(arr[i]);<br>&#125;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;arrSize<span class="hljs-number">-1</span>;i++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;arrSize<span class="hljs-number">-1</span>-i;j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cnt[j]&gt;cnt[j+<span class="hljs-number">1</span>])<br>        &#123;<br>            swap(&amp;arr[j],&amp;arr[j+<span class="hljs-number">1</span>]);<br>            swap(&amp;cnt[j],&amp;cnt[j+<span class="hljs-number">1</span>]);<span class="hljs-comment">//按照1的个数排完序了，现在按大小排</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;arrSize<span class="hljs-number">-1</span>;i++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;arrSize<span class="hljs-number">-1</span>-i;j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cnt[j]==cnt[j+<span class="hljs-number">1</span>]&amp;&amp;arr[j]&gt;arr[j+<span class="hljs-number">1</span>])<br>        &#123;<br>            swap(&amp;arr[j],&amp;arr[j+<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">//按照1的个数排完序了，现在按大小排</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> *ret=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*arrSize);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;arrSize;i++)<br>&#123;<br>    ret[i]=arr[i];<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法初步学习</title>
    <link href="/2021/12/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/12/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#_1"></a></li><li><ul><li><a href="#_2"></a></li><li><ul><li><a href="#_3"></a></li></ul></li><li><a href="#_6">概述</a></li><li><a href="#_11">海盗船</a></li><li><a href="#_44">种花问题</a></li><li><a href="#_101">小行星碰撞</a></li></ul></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>每一步都根据当前的信息做出选择，一担选择，都不会改变（不会反悔）<br>用局部的最优解，达到整体的最优解</p></blockquote><h2 id="海盗船"><a href="#海盗船" class="headerlink" title="海盗船"></a>海盗船</h2><p>海盗船<br>实际问题：一群海盗截获了一艘装满各种金银珠宝和古董的货船，每一件宝物都价值连城一旦打碎就失去了价值。海盗船的载重量为C，每件宝物的重量为Wi，海盗们应该如何把尽可能多的宝物装上船？</p><p>分析，每次选最小的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">2</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">67</span>,<span class="hljs-number">33</span>,<span class="hljs-number">47</span>,<span class="hljs-number">56</span>,<span class="hljs-number">567</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span> &#125;;<br>heapsort(arr, <span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> max = <span class="hljs-number">207</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (sum &gt; max)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>sum += arr[i];<br>n++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a>种花问题</h2><blockquote><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n<br>朵花？能则返回True，不能则返回False。</p><p>注意:</p><p>1、数组内已种好的花不会违反种植规则。 2、输入的数组长度范围为 [1, 20000]。 3、n 是非负整数，且不会超过输入数组的大小。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>```c<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; )<br>&#123;<br><span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-number">1</span>)<span class="hljs-comment">//遇到花就跳两格</span><br>&#123;<br>i += <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//不是花，但是他前面有花且不是第一个，跳1格</span><br>&#123;<br>i += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; i+<span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>)<span class="hljs-comment">//不是花，但他后面有花，且不是最后一个，跳3格</span><br>&#123;<br>i += <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//前后都没花</span><br>&#123;<br>arr[i] = <span class="hljs-number">1</span>;<br>i += <span class="hljs-number">2</span>;<span class="hljs-comment">//跳两格</span><br>count++;<br><span class="hljs-keyword">if</span> (count == n)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote></blockquote><h2 id="小行星碰撞"><a href="#小行星碰撞" class="headerlink" title="小行星碰撞"></a>小行星碰撞</h2><blockquote><p>给定一个整数数组 asteroids，表示在同一行的小行星。</p><p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p><p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><p>示例 1：</p><p>输入：asteroids &#x3D; [5,10,-5] 输出：[5,10] 解释：10 和 -5 碰撞后只剩下 10 。 5 和 10<br>永远不会发生碰撞。</p><p>示例 2：</p><p>输入：asteroids &#x3D; [8,-8] 输出：[] 解释：8 和 -8 碰撞后，两者都发生爆炸。</p><p>示例 3：</p><p>输入：asteroids &#x3D; [10,2,-5] 输出：[10] 解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下<br>10 。</p><p>示例 4：</p><p>输入：asteroids &#x3D; [-2,-1,1,2] 输出：[-2,-1,1,2] 解释：-2 和 -1 向左移动，而 1 和 2<br>向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。</p><p>提示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2</span> &lt;= asteroids<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">104</span><br>-<span class="hljs-number">1000</span> &lt;= asteroids<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">1000</span><br>asteroids<span class="hljs-selector-attr">[i]</span> != <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//正数往右走，负数往左走</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-type">int</span>* <span class="hljs-title function_">asteroidCollision</span><span class="hljs-params">(<span class="hljs-type">int</span>* asteroids, <span class="hljs-type">int</span> asteroidsSize, <span class="hljs-type">int</span>* returnSize)</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> next = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//每次都重左到右扫描一遍</span><br><span class="hljs-keyword">while</span> (next &lt; asteroidsSize)<span class="hljs-comment">// 每次只消一个,这个循环是把所有的都消掉,能够保证两者除0外都挨着</span><br>&#123;<br><span class="hljs-keyword">if</span> (asteroids[prev] * asteroids[next] &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//1.背靠背不能碰撞</span><br><span class="hljs-comment">//如-9 8 32 9</span><br><span class="hljs-comment">//如-9 0 8 9//我们不能够让前后都往后走一步，因为0是有隐患的，我们不走0</span><br><span class="hljs-comment">//prev          next</span><br><span class="hljs-comment">//          prev        next</span><br><span class="hljs-comment">//-9     0      8      9</span><br><span class="hljs-keyword">if</span> (asteroids[prev] &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//前面的往前走，后面的往后走就不符合</span><br>&#123;<br>prev = next;<br>next++;<br><span class="hljs-comment">//背靠背不能再碰了，就进入下一个循环</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">//发生了碰撞,左边大</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(asteroids[prev]) &gt; <span class="hljs-built_in">abs</span>(asteroids[next]))<br>&#123;<br>asteroids[next]=<span class="hljs-number">0</span>;<br>n++;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(asteroids[prev]) &lt; <span class="hljs-built_in">abs</span>(asteroids[next]))<br>&#123;<br>asteroids[prev] = <span class="hljs-number">0</span>;<br>n++;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(asteroids[prev]) == <span class="hljs-built_in">abs</span>(asteroids[next]))<br>&#123;<br>asteroids[next] = <span class="hljs-number">0</span>;<br>asteroids[prev] = <span class="hljs-number">0</span>;<br>n+=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//贪心不贪婪</span><br>&#125;<br><br><span class="hljs-comment">//如果前后相乘为0</span><br><span class="hljs-comment">//0  3,左边的等于0</span><br><span class="hljs-keyword">if</span> (asteroids[prev] == <span class="hljs-number">0</span>)<br>&#123;<br>prev = next;<br>next++;<br>&#125;<br><span class="hljs-comment">//如果前后相乘为0</span><br><span class="hljs-comment">//3  0,右边的等于0</span><br><span class="hljs-keyword">if</span> (asteroids[next] == <span class="hljs-number">0</span>)<span class="hljs-comment">//左边不动</span><br>&#123;<br>next++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//prev  next</span><br><span class="hljs-comment">//7 0 0 4 -2</span><br><span class="hljs-comment">//方向相同,就前进一步</span><br>prev = next;<span class="hljs-comment">//要跨过0</span><br><br>next++;<br>&#125;<br>&#125;<br><span class="hljs-comment">//出来了，next就大于size了</span><br><span class="hljs-keyword">if</span> (next &gt; asteroidsSize)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><br>&#125;<br>*returnSize = asteroidsSize - n;<span class="hljs-comment">//返回剩余的</span><br><span class="hljs-type">int</span> *ret = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*(asteroidsSize - n));<br><span class="hljs-type">int</span> i,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; asteroidsSize; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (asteroids[i])<br>&#123;<br>ret[j++] = asteroids[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的完整概念与堆的深度剖析</title>
    <link href="/2021/12/16/%E6%A0%91%E7%9A%84%E5%AE%8C%E6%95%B4%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%A0%86%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
    <url>/2021/12/16/%E6%A0%91%E7%9A%84%E5%AE%8C%E6%95%B4%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%A0%86%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li><a href="#_1"></a></li><li><ul><li><a href="#_2"></a></li><li><ul><li><a href="#_3"></a></li></ul></li><li><a href="#treec_10">tree.c</a></li><li><a href="#heaph_78">heap.h</a></li><li><a href="#heapc_146">heap.c</a></li><li><a href="#_327">堆的应用</a></li><li><a href="#1topk_329">1.topk问题</a></li><li><a href="#2_398">2.堆排序</a></li></ul></li></ul><blockquote><p>这篇博客会完整的对于树，堆的概念，堆的应用（topk问题，堆排序）进行深度的剖析</p></blockquote><p><img src="https://img-blog.csdnimg.cn/08fe1b95ba6a44c29881850254512ce1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="tree-c"><a href="#tree-c" class="headerlink" title="tree.c"></a>tree.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">`<span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><br><br><br><span class="hljs-comment">//如何表示一个树呢（代码实现如何定义结构）</span><br><span class="hljs-comment">//法1.假设说明了树的度是N（最大是这么多）</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treenode</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treenode</span>*<span class="hljs-title">subs</span>[<span class="hljs-title">N</span>];</span><span class="hljs-comment">//这个数组是一个指针数组，里面存的都是指针，但是有缺陷，问题在于</span><br><span class="hljs-comment">//1.可能会存在不少空间的浪费，如假设只有一个树的度是8，其余的都是0，1，2……浪费了很多空间</span><br><span class="hljs-comment">//万一没有给我们树的度为多少呢，</span><br><br>&#125;;<br><br><br><span class="hljs-comment">//法2；</span><br><span class="hljs-comment">//假设我们已经定义了一个顺序表seqlist出来了，数据类型是</span><br><span class="hljs-comment">//typedef struct treenode* seqdata</span><br><span class="hljs-comment">//这个顺序表里面存的是节点的指针</span><br><br><span class="hljs-comment">//struct treenode</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//int data;</span><br><span class="hljs-comment">//seqlist s;//</span><br><span class="hljs-comment">//&#125;;</span><br><br><br><span class="hljs-comment">//法3.结构数组村粗</span><br><br><span class="hljs-comment">//struct treenode</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//int parenti;</span><br><span class="hljs-comment">//int data;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//&#125;;</span><br><br><br><span class="hljs-comment">//上面的方式各有优缺点，表示树结构的最优方法，  使用左孩子右兄弟表示法</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> datatype;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>*<span class="hljs-title">firstchild</span>;</span><span class="hljs-comment">//第一个孩子节点，    永远指向第一个孩子</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>*<span class="hljs-title">pnextbrother</span>;</span><span class="hljs-comment">//指向下一个兄弟节点  指向孩子右边的兄弟</span><br>datatype data;   <span class="hljs-comment">//节点中的数据域</span><br>&#125;;<br><br><br><span class="hljs-comment">//二叉树</span><br><span class="hljs-comment">//不学习他的增删查改，没有意义</span><br><span class="hljs-comment">//而是去控制一下他的结构（高度，深度）</span><br><span class="hljs-comment">//作用是搜索二叉树：用来进行查找，-》平衡搜索二叉树，（avl树和红黑树，b树）（这些结构才会去学习他的增删查改）</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0366a43f003149a49b8c873dc09c0833.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="heap-h"><a href="#heap-h" class="headerlink" title="heap.h"></a>heap.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><br><br><span class="hljs-comment">//堆是一个完全二叉树</span><br><span class="hljs-comment">//我们已经推导了公式，已知父亲，左为父*2+1，右为父*2+2</span><br><span class="hljs-comment">//已知孩子，父亲为（子-1）/2</span><br><br><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> hpdata;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heap</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">//物理结构就是一个顺序表</span><br>hpdata *a;<br><span class="hljs-type">int</span> size;<br><span class="hljs-type">int</span> capacity;<br>&#125;heap;<br><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapinit</span><span class="hljs-params">(heap* hp)</span>;<br><br><br><span class="hljs-comment">// 销毁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapdestroy</span><span class="hljs-params">(heap* hp)</span>;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heappush</span><span class="hljs-params">(heap *hp, hpdata x)</span>;<br><br><span class="hljs-comment">//删除</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heappop</span><span class="hljs-params">(heap*hp)</span>;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">adjustup</span><span class="hljs-params">(hpdata *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> child)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapprint</span><span class="hljs-params">(heap*hp)</span>;<br><br><br><span class="hljs-comment">//判空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">heapempty</span><span class="hljs-params">(heap*hp)</span>;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">heapsize</span><span class="hljs-params">(heap*hp)</span>;<br><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(hpdata*x, hpdata*y)</span>;<br><br><span class="hljs-comment">//向下调</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">adjustdown</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> parent)</span>;<br></code></pre></td></tr></table></figure><h2 id="heap-c"><a href="#heap-c" class="headerlink" title="heap.c"></a>heap.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;heap.h&quot;</span></span><br><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapinit</span><span class="hljs-params">(heap* hp)</span><br>&#123;<br>assert(hp);<br>hp-&gt;capacity =hp-&gt;size= <span class="hljs-number">0</span>;<br>hp-&gt;a = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 销毁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapdestroy</span><span class="hljs-params">(heap* hp)</span><br>&#123;<br>assert(hp);<br><span class="hljs-built_in">free</span>(hp-&gt;a);<br>hp-&gt;a = <span class="hljs-literal">NULL</span>;<br>hp-&gt;capacity = hp-&gt;size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//向上调整</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">adjustup</span><span class="hljs-params">(hpdata *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> child)</span><span class="hljs-comment">//a就是这数组，n就这个数组右多大</span><br>&#123;<br>assert(a);<br><span class="hljs-type">int</span> parent = (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-comment">//while(parent&gt;=0)</span><br><span class="hljs-keyword">while</span> (child &gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//调到根</span><br>&#123;<br><span class="hljs-keyword">if</span> (a[child] &gt; a[parent])<span class="hljs-comment">//大于就交换</span><br>&#123;<br><span class="hljs-comment">//交换</span><br>hpdata tmp = a[child];<br>a[child] = a[parent];<br>a[parent] = tmp;<br>child = parent;<br>parent = (child - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//小于就停止</span><br>&#125;<br>&#125;<br><br>&#125;<br><br><br><br><br><br><br><br><span class="hljs-comment">//插入</span><br><span class="hljs-comment">//假设是大堆</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heappush</span><span class="hljs-params">(heap *hp, hpdata x)</span><br>&#123;<br>assert(hp);<br><span class="hljs-comment">//满了就要先增容</span><br><span class="hljs-keyword">if</span> (hp-&gt;size == hp-&gt;capacity)<br>&#123;<br><span class="hljs-type">size_t</span> newcapcity = hp-&gt;capacity == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span> : hp-&gt;capacity * <span class="hljs-number">2</span>;<br>hpdata *tmp = (hpdata*)<span class="hljs-built_in">realloc</span>(hp-&gt;a, <span class="hljs-keyword">sizeof</span>(hpdata)*newcapcity);<br><span class="hljs-keyword">if</span> (tmp != <span class="hljs-literal">NULL</span>)<br>&#123;<br>hp-&gt;a = tmp;<br>hp-&gt;capacity = newcapcity;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>perror(<span class="hljs-string">&quot;realloc&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>hp-&gt;a[hp-&gt;size] = x;<br>hp-&gt;size++;<br>adjustup(hp-&gt;a, hp-&gt;size, hp-&gt;size<span class="hljs-number">-1</span>);<br><br><br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapprint</span><span class="hljs-params">(heap*hp)</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; hp-&gt;size; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, hp-&gt;a[i]);<br>&#125;<br>&#125;<br><br><br>```c<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">heapempty</span><span class="hljs-params">(heap*hp)</span><br>&#123;<br>assert(hp);<br><span class="hljs-keyword">return</span> hp-&gt;size == <span class="hljs-number">0</span>;<span class="hljs-comment">//为0就是空的，不为0就不是空的</span><br><br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">heapsize</span><span class="hljs-params">(heap*hp)</span><br>&#123;<br>assert(hp);<br><span class="hljs-keyword">return</span> hp-&gt;size;<br>&#125;<br><span class="hljs-comment">//向上调的时间复杂度是</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//向上调高度次</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">adjustdown</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> parent)</span><br>&#123;<br><span class="hljs-type">int</span> child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (child &lt; n)<span class="hljs-comment">//越界就停止了</span><br>&#123;<br><span class="hljs-keyword">if</span> (child + <span class="hljs-number">1</span> &lt; n&amp;&amp;a[child + <span class="hljs-number">1</span>] &gt; a[child])<span class="hljs-comment">//右孩子也不越界，右孩子大于左孩子，在这里之后，不用管谁的下标的大，统一放到左孩子</span><br>&#123;<br>++child;<span class="hljs-comment">//找大的交换</span><br>&#125;<br><span class="hljs-keyword">if</span> (a[child] &gt; a[parent])<span class="hljs-comment">//孩子大于父亲，就交换</span><br>&#123;<br>swap(&amp;a[child], &amp;a[parent]);<br>parent = child;<br>child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-comment">//再堆里面删除不是随便任意删除什么位置都可以</span><br><span class="hljs-comment">//而是删除堆顶的数据（根），意义是调整堆，找到次小的值（小堆）</span><br><span class="hljs-comment">//向下调整，把他调整成堆，跟左右孩子中小的那个交换</span><br><span class="hljs-comment">//结束条件</span><br><span class="hljs-comment">//1.父亲&lt;=小的那个孩子，则停止</span><br><span class="hljs-comment">//2.调整到叶子（当父亲走到叶子就停止，叶子是没有左孩子，左孩子下标超出数组范围就不存在）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heappop</span><span class="hljs-params">(heap*hp)</span><br>&#123;<br>assert(hp);<br>assert(!heapempty(hp));<span class="hljs-comment">//空了就别删除了</span><br><span class="hljs-comment">//先把堆顶和底部删掉</span><br>swap(&amp;hp-&gt;a[<span class="hljs-number">0</span>], &amp;hp-&gt;a[hp-&gt;size - <span class="hljs-number">1</span>]);<br>hp-&gt;size--;<span class="hljs-comment">//删掉了</span><br><span class="hljs-comment">//交换之后，向下调整，保证不破坏堆,从0开始向下调</span><br>adjustdown(hp-&gt;a, hp-&gt;size, <span class="hljs-number">0</span>);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p>test.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;heap.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a[] = &#123; <span class="hljs-number">70</span>,<span class="hljs-number">56</span>,<span class="hljs-number">30</span>,<span class="hljs-number">25</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>,<span class="hljs-number">75</span> &#125;;<span class="hljs-comment">//用数组去给hp值</span><br>heap HP;<span class="hljs-comment">//定义一个堆</span><br>heapinit(&amp;HP);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]); i++)<br>&#123;<br>heappush(&amp;HP, a[i]);<br>&#125;<br>heapprint(&amp;HP);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><h2 id="1-topk问题"><a href="#1-topk问题" class="headerlink" title="1.topk问题"></a>1.topk问题</h2><blockquote><p>topk问题<br>（就是再n个数里面找到最大的前k个，或者最小的前k个）<br>1.排序：我们最常见的想法就是把所有数据排一遍，然后找到其中最大的k个，但是这样假如说n非常非常大，而k却远小于n，那么就相当于杀鸡用牛刀，这种方法的最有的时间复杂度是O（n*logn）<br>2.我们最优的方法是是先取前k个建立一个小堆，建立小堆之后，顶部的一定是最小的，随后，n-k个入堆，与顶比较，如果比顶部的大，就交换，到最后剩下的 那k个一定就是符合要求的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在N个数找出最大的前K个  or  在N个数找出最小的前K个</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintTopK</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span><br>&#123;<br>heap hp;<br>heapinit(&amp;hp);<br><span class="hljs-comment">// 创建一个K个数的小堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>&#123;<br>heappush(&amp;hp, a[i]);<span class="hljs-comment">//一个一个入堆</span><br>&#125;<br><br><span class="hljs-comment">// 剩下的N-K个数跟堆顶的数据比较，比他大，就替换他进堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i] &gt; heaptop(&amp;hp))<span class="hljs-comment">//比较，大的就入堆</span><br>&#123;<br>heappop(&amp;hp);<span class="hljs-comment">//把顶补的删掉，</span><br>heappush(&amp;hp, a[i]);<span class="hljs-comment">//大的入堆</span><br><span class="hljs-comment">//hp.a[0] = a[i];//把顶部的换成现在大的</span><br><span class="hljs-comment">//adjustdown(hp.a, hp.size, 0);//向下调整</span><br>&#125;<br>&#125;<br><br>heapprint(&amp;hp);<br><br>heapdestroy(&amp;hp);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TestTopk</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">1000000</span>;<br><span class="hljs-type">int</span>* a = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n);<br>srand(time(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>a[i] = rand() % <span class="hljs-number">1000000</span>;<br>&#125;<br><span class="hljs-comment">// 再去设置10个比100w大的数</span><br>a[<span class="hljs-number">5</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">1231</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">2</span>;<br>a[<span class="hljs-number">5355</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">3</span>;<br>a[<span class="hljs-number">51</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">4</span>;<br>a[<span class="hljs-number">15</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">5</span>;<br>a[<span class="hljs-number">2335</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">6</span>;<br>a[<span class="hljs-number">9999</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">7</span>;<br>a[<span class="hljs-number">76</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">8</span>;<br>a[<span class="hljs-number">423</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">9</span>;<br>a[<span class="hljs-number">3144</span>] = <span class="hljs-number">1000000</span> + <span class="hljs-number">10</span>;<br>PrintTopK(a, n, <span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>TestTopk();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2.堆排序"></a>2.堆排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//堆排序</span><br><span class="hljs-comment">//首先先建堆，再应用堆进行排序</span><br><span class="hljs-comment">//升序就建大堆，降序就建小堆</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> n)</span><br>&#123;<br><br><span class="hljs-comment">//法1.</span><br><span class="hljs-comment">// 直接把a构建成堆，直接控制a数组，升序，吧</span><br><span class="hljs-comment">//把a构建成小堆</span><br><span class="hljs-comment">//第一个数先看做堆，后面的数据依次加入堆，然后向上调整，构建堆,调到根就结束了，保证他还是堆</span><br><span class="hljs-comment">//if (n &lt;= 1)//第一个就看成堆</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//return;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//for (int i = 1; i &lt; n; i++)//后面的数加入进去</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//AdjustUp(a,i);</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//法2；</span><br><span class="hljs-comment">//向下调整也可以，保证左子树和右子树都小堆，倒着走最后一个子树进行调整</span><br><span class="hljs-comment">//叶子所在的子树不需要调，所以倒着走的第一个非子节点的子树，就是最后一个节点的父亲，调完之后--，直到根 </span><br><span class="hljs-comment">//前面的调整为后面做了铺垫，前面调整完之后一定是一个堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (n - <span class="hljs-number">1</span><span class="hljs-number">-1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<span class="hljs-comment">//最后一个位置是n-1，</span><br>&#123;<br>AdjustDown(a, n, i);<br>&#125;<br><br><span class="hljs-comment">//排升序建小堆的分析：</span><br><span class="hljs-comment">//1.选出了最小的数放到第一个位置，如何选出次小的位置，只能从第二个位置开始，剩下的数看成一个堆，但是这样的话所有的关系都乱了，只能重新建堆才可以选出次小的堆</span><br><br><span class="hljs-comment">//我们建大堆，最大的数选出来，</span><br><span class="hljs-comment">//最大的数放最后一个位置，交换</span><br><span class="hljs-comment">//如何选出此校的 数，1.把最后一个数不看做堆里面的了，向下调整就可以选出次小的数，依次内推在重复上面过程，，原本有n个数，现在传n-1个数，就不把他当做堆里面的了</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> end = n - <span class="hljs-number">1</span>; end &gt; <span class="hljs-number">0</span>; end--)<br>&#123;<br>Swap(&amp;a[end], &amp;a[<span class="hljs-number">0</span>]);<br>AdjustDown(a, end, <span class="hljs-number">0</span>);<span class="hljs-comment">//向下调整，到根部</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>b树 数据结构 排序算法 算法 c语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超完整素数算法总结归纳</title>
    <link href="/2021/12/06/%E8%B6%85%E5%AE%8C%E6%95%B4%E7%B4%A0%E6%95%B0%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <url>/2021/12/06/%E8%B6%85%E5%AE%8C%E6%95%B4%E7%B4%A0%E6%95%B0%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E7%B4%A0%E6%95%B0%E7%9A%84%E5%88%A4%E5%AE%9A" title="素数的判定">素数的判定</a></p><p><a href="#Eratosthenes%E7%AD%9B%E9%80%89%EF%BC%88%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%EF%BC%89" title="Eratosthenes筛选（素数筛选）">Eratosthenes筛选（素数筛选）</a></p><p><a href="#%E5%9B%A0%E5%AD%90%E6%95%B0%E4%B8%8E%E5%9B%A0%E5%AD%90%E5%92%8C" title="因子数与因子和">因子数与因子和</a></p><p><a href="#%C2%A0%E5%AE%8C%E7%BE%8E%E6%95%B0" title=" 完美数"> 完美数</a></p><p><a href="#n%E7%9A%84%E7%AC%ACk%E4%B8%AA%E5%9B%A0%E5%AD%90" title="n的第k个因子">n的第k个因子</a></p><p><a href="#%E5%88%86%E6%8B%86%E8%B4%A8%E6%95%B0%E5%92%8C" title="分拆质数和">分拆质数和</a></p><p><a href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0" title="分解质因数">分解质因数</a></p><p><a href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%9B%A0%E6%95%B0" title="最接近的因数">最接近的因数</a></p><p><a href="#%C2%A0%E4%B8%91%E6%95%B0" title=" 丑数"> 丑数</a></p><p><a href="#%E7%B4%A0%E6%95%B0%E7%9A%84%E5%88%A4%E5%AE%9A" title="素数的判定">素数的判定</a></p><p><a href="#articleContentId" title="Eratosthenes筛选（素数筛选）">Eratosthenes筛选（素数筛选）</a></p><p><a href="#%E5%9B%A0%E5%AD%90%E6%95%B0%E4%B8%8E%E5%9B%A0%E5%AD%90%E5%92%8C" title="因子数与因子和">因子数与因子和</a></p><p><a href="#%E5%AE%8C%E7%BE%8E%E6%95%B0" title="完美数">完美数</a></p><p><a href="#n%E7%9A%84%E7%AC%ACk%E4%B8%AA%E5%9B%A0%E5%AD%90" title="n的第k个因子">n的第k个因子</a></p><p><a href="#%E5%88%86%E6%8B%86%E8%B4%A8%E6%95%B0%E5%92%8C" title="分拆质数和">分拆质数和</a></p><p><a href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0" title="分解质因数">分解质因数</a></p><p><a href="#%E5%9B%9B%E5%9B%A0%E6%95%B0%C2%A0" title="四因数 ">四因数 </a></p><p><a href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%9B%A0%E6%95%B0" title="最接近的因数">最接近的因数</a></p><p><a href="#%C2%A0%E4%B8%91%E6%95%B0" title=" 丑数"> 丑数</a></p><hr><h1 id="素数的判定"><a href="#素数的判定" class="headerlink" title="素数的判定"></a>素数的判定</h1><blockquote><p>素数的概念是只可以被1和他本身可以整除</p><p>所以我们可以使用试除法，如一个数为n</p><p>（用2-n-1）对n进行试除,但是这样的话时间复杂度是O(N)</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br>int main()<br>&#123;<br>int <span class="hljs-attribute">n</span>=10;<br>int <span class="hljs-attribute">flag</span>=1;<br><span class="hljs-keyword">for</span>(<span class="hljs-attribute">i</span>=2;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(n%<span class="hljs-attribute">i</span>==0)<br>&#123;<br><span class="hljs-attribute">flag</span>=0;<br>break;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">flag</span>=1)<br>&#123;<br>printf(<span class="hljs-string">&quot;是&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>printf(<span class="hljs-string">&quot;否&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样的时间复杂度还不够优化，我们要知道一点如果说一个数是合数的话，那么他的因数一定是小于等于根号n的，如16，因数有4*4，2*8，其因数一定是在根号n的两边的</p><p>所以我们只要对根号n进行试除就可以了，那么时间复杂度就被我们优化到O(sqrt(n))，效率就大大提升了</p><p>同时注意一点</p><p>1.如果我们用如果用sqrt（n）的话，可能会造成会精度丢失，如n&#x3D;15，那么开根号出来就不会是一个整数，造成精度丢失<br>要用的话要加个1e-8，且如果要用到话每次，在循环都要对sqrt进行计算，造成不必要的负担，最好在最前面n&#x3D;sqrt(N+1e-8),进行替换</p><p>2.如果我们想用i*i&lt;&#x3D;n进行计算的话，假如说i的数很大了，那么他们相乘就很有可能会溢出</p><p>，如果想用的话，就最好（long long）i*i,对其进行强制类型转化，尽量不让其溢出</p><p>3.因此我们的最有解是i&lt;&#x3D;n&#x2F;i,这样即保证了时间复杂度，又保证了两边都不会溢出</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br>int main()<br>&#123;<br>int <span class="hljs-attribute">n</span>=10;<br>int <span class="hljs-attribute">flag</span>=1;<br><span class="hljs-keyword">for</span>(<span class="hljs-attribute">i</span>=2;i&lt;=n/i;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(n%<span class="hljs-attribute">i</span>==0)<br>&#123;<br><span class="hljs-attribute">flag</span>=0;<br>break;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">flag</span>=1)<br>&#123;<br>printf(<span class="hljs-string">&quot;是&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>printf(<span class="hljs-string">&quot;否&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Eratosthenes筛选（素数筛选）"><a href="#Eratosthenes筛选（素数筛选）" class="headerlink" title="Eratosthenes筛选（素数筛选）"></a>Eratosthenes筛选（素数筛选）</h1><blockquote><p>我们用一个标记数组f[maxi]，其中f[i]&#x3D;0为素数，否则为非素数，首先我们知道1，和0都不是素数，所以f<strong>[0]&#x3D;1,f[1]&#x3D;1</strong></p><p>1.随后我们在未标记的数里面找最小的数，为2，他不是任何数的的倍数，所以2是素数，此时我们就把所有2的倍数都标记为0；3，6，8，10……2*i</p><p>2.我们再从剩余未标记的数里面找最小的数，为3，他也不是任何数的倍数，所以3是素数，此时我们把所有3的倍数也都标记为0；6，9，12，15，18……3*i</p><p>3.我们再从所有未标记的数里面找最小的数，为5，他也不是任何数的素数，所以5是素数，此时我们把所有5的倍数都标记为0；10，15，20，25……5*i,</p><p>…………以此类推</p></blockquote><blockquote><p> 如果我们要赛选素数的话可以用i&lt;&#x3D;n&#x2F;i</p><p>如果我们要记录所有的素数的话就用i&lt;n,因为用i&lt;&#x3D;n&#x2F;i的话，另外一半的因数就无法被记录进去</p></blockquote><blockquote><p>同时在内层循环的话，我们用i*i，避免对已经标记过的数，重复标记，浪费时间</p><p>如果用2*i,开始的话，如2为素数，那么我们对4，6，8，10…………都已经标记了</p><p>到3的时候又对6 9…………进行标记，6我们已经标记过了，</p><p>而如果为i*i开始的话，3的时候就是9开始,直接跳过已经标记过的数</p></blockquote><h1 id="因子数与因子和"><a href="#因子数与因子和" class="headerlink" title="因子数与因子和"></a>因子数与因子和</h1><blockquote><p>我们当找到了1到根号n间的因子的时候，即当i 是因子的时候，同时n&#x2F;i也为他的因子，如果要记录他所有不同的因子，我们只要规定i！&#x3D;n&#x2F;i即可，即i*i！&#x3D;n，</p><p>因子和就是所有的找到的所有的因子数相加</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include&lt;stdio.h&gt;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=<span class="hljs-number">15</span>;<br><span class="hljs-built_in">int</span> cnt=<span class="hljs-number">0</span>,<span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>;//<span class="hljs-built_in">sum</span>是用来记录所有的因子和，cnt是用来记录有多少个不同的因子<br>for(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>/i;i++)<br>&#123;<br><span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span>%i==<span class="hljs-number">0</span>)<br>&#123;<br><br>cnt++;<br><span class="hljs-built_in">sum</span>+=i;<br><span class="hljs-built_in">if</span>(i*i!=<span class="hljs-built_in">n</span>)//避免同一个因子重复记录<br>&#123;<br>cnt++;<br><span class="hljs-built_in">sum</span>+=<span class="hljs-built_in">n</span>/i;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">sum</span>-=<span class="hljs-built_in">n</span>;//这里是因为要把他本身给删掉了，本身不是他的因数<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完美数"><a href="#完美数" class="headerlink" title="完美数"></a>完美数</h1><blockquote><blockquote><p><a href="https://leetcode-cn.com/problems/perfect-number/" title="完美数">完美数</a></p><p>对于一个 <strong>正整数</strong>，如果它和除了它自身以外的所有 <strong>正因子</strong> 之和相等，我们称它为 「完美数」。</p><p>给定一个 **整数 **<code>n</code>， 如果是完美数，返回 <code>true</code>，否则返回 <code>false</code></p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>num &#x3D; 28<br><strong>输出：</strong>true<br><strong>解释：</strong>28 &#x3D; 1 + 2 + 4 + 7 + 14<br>1, 2, 4, 7, 和 14 是 28 的所有正因子。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>num &#x3D; 6<br><strong>输出：</strong>true</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>num &#x3D; 496<br><strong>输出：</strong>true</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>num &#x3D; 8128<br><strong>输出：</strong>true</p><p><strong>示例 5：</strong></p><p><strong>输入：</strong>num &#x3D; 2<br><strong>输出：</strong>false</p></blockquote></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> checkPerfectNumber(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;<br><span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i*i&lt;=<span class="hljs-built_in">num</span>;i++)<span class="hljs-comment">//如果是i的话会超出去,控制在一半的范围</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span>%i==<span class="hljs-number">0</span>)<br>    &#123;<br>        sum+=i;<span class="hljs-comment">//找sqrt内</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span>%(<span class="hljs-built_in">num</span>/i)==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">num</span>/i!=i)<br>        &#123;<br>            sum+=<span class="hljs-built_in">num</span>/i;<br>        &#125;<br>    &#125;<br>&#125;<br>sum-=<span class="hljs-built_in">num</span>;<br><span class="hljs-keyword">if</span>(sum==<span class="hljs-built_in">num</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="n的第k个因子"><a href="#n的第k个因子" class="headerlink" title="n的第k个因子"></a>n的第k个因子</h1><blockquote><p><a href="https://leetcode-cn.com/problems/the-kth-factor-of-n/" title="n 的第 k 个因子">n 的第 k 个因子</a></p><p>给你两个正整数 <code>n</code> 和 <code>k</code> 。</p><p>如果正整数 <code>i</code> 满足 <code>n % i == 0</code> ，那么我们就说正整数 <code>i</code> 是整数 <code>n</code> 的因子。</p><p>考虑整数 <code>n</code> 的所有因子，将它们 <strong>升序排列</strong> 。请你返回第 <code>k</code> 个因子。如果 <code>n</code> 的因子数少于 <code>k</code> ，请你返回 <strong>-1</strong> 。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>n &#x3D; 12, k &#x3D; 3<br><strong>输出：</strong>3<br><strong>解释：</strong>因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>n &#x3D; 7, k &#x3D; 2<br><strong>输出：</strong>7<br><strong>解释：</strong>因子列表包括 [1, 7] ，第 2 个因子是 7 。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>n &#x3D; 4, k &#x3D; 4<br><strong>输出：</strong>-1<br><strong>解释：</strong>因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>n &#x3D; 1, k &#x3D; 1<br><strong>输出：</strong>1<br><strong>解释：</strong>因子列表包括 [1] ，第 1 个因子为 1 。</p><p><strong>示例 5：</strong></p><p><strong>输入：</strong>n &#x3D; 1000, k &#x3D; 3<br><strong>输出：</strong>4<br><strong>解释：</strong>因子列表包括 [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000] 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= n &lt;= 1000</code></li></ul></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> compare(<span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span>*e1,<span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> *e2)<br>&#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-built_in">int</span>*)e1-*(<span class="hljs-built_in">int</span> *)e2);<br>&#125;<br><br><span class="hljs-built_in">int</span> kthFactor(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> k)&#123;<br><span class="hljs-built_in">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> i,j=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> arr[<span class="hljs-number">1000</span>];<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;&amp;k==<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i*i&lt;=n;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>    &#123;<br>        arr[j++]=i;<br>        <br>        <span class="hljs-keyword">if</span>(i*i!=n)<span class="hljs-comment">//去重复因子</span><br>        &#123;<br>            arr[j++]=n/i;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//把所有因子都找出来了</span><br><span class="hljs-comment">//进行排序</span><br>qsort(arr,j,sizeof(<span class="hljs-built_in">int</span>),compare);<br><span class="hljs-keyword">if</span>(j&lt;k)<span class="hljs-comment">//如果实际的因子数小于需要搜索的数，就返回一个-1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">return</span> arr[k<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分拆质数和"><a href="#分拆质数和" class="headerlink" title="分拆质数和"></a>分拆质数和</h1><blockquote><p>Problem Description<br>把一个偶数拆成两个不同素数的和，有几种拆法呢？</p><p>Input<br>输入包含一些正的偶数，其值不会超过10000，个数不会超过500，若遇0，则结束。</p><p>Output<br>对应每个偶数，输出其拆成不同素数的个数，每个结果占一行。</p><p>Sample Input<br>30 26 0</p><p>Sample Output<br>3 2</p></blockquote><blockquote><p>思路1.首先先把所有10000内的素数给筛选出来</p><p>       2.用一个素数数组</p><p>       3，先枚举素数p,因为两个素数相加可以得到x，所以枚举p在x的一半即可，两者相加只可能在中间值的两边</p><p>4.此时再判定k&#x3D;x-p为质数就自增</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> n 10005</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> isprime[<span class="hljs-number">10005</span>];<br><span class="hljs-built_in">memset</span>(isprime, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(isprime));<br><span class="hljs-type">int</span> i;<br>isprime[<span class="hljs-number">0</span>] = isprime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> prime[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">10005</span> ; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (isprime[i] == <span class="hljs-number">0</span>)<br>&#123;<br>prime[cnt++] = i;<br><span class="hljs-keyword">for</span> (j = i*i; j &lt; <span class="hljs-number">10005</span>; j+=i)<br>&#123;<br>isprime[j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x) &amp;&amp; x)<span class="hljs-comment">//当x为0就停止循环</span><br>&#123;<br><span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//先枚举素数p,因为两个素数相加可以得到x，所以枚举p在x的一半即可，两者相加只可能在中间值的两边</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cnt&amp;&amp;prime[i] &lt;=(x / <span class="hljs-number">2</span>); i++)<br>&#123;<br><span class="hljs-type">int</span> k = x - prime[i];<br><span class="hljs-keyword">if</span> (isprime[k] == <span class="hljs-number">0</span>)<br>&#123;<br>s++;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><blockquote><p>任何一个合数都可以被拆分成所有质数的乘积，</p><p>如8&#x3D;2^2^2,     52&#x3D;2^2*13,被拆分成了质数的乘积的形式，</p><p>所以，如果一个数n可以被2给整除，除完之后n就变成n&#x2F;2，继续和2除，直到把所有的2，除完，接下来再和3，进行整除，如果可以整除，那么就再把所有的3都除掉，如果下一个质数不能被整除，就跳过</p><p>我们也可以提高精度在根号n内筛选质数，最多只会有一个质数大一根号n</p><p>如果在根号n内把所有的质数除干净了，这时候，如果n&gt;1,那么n就会是1个大于根号n的质数</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> i;<br><span class="hljs-built_in">int</span> arr[<span class="hljs-number">10000</span>];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= (n / i); i++)<br>&#123;<br><span class="hljs-keyword">while</span> (n%i == <span class="hljs-number">0</span>)<span class="hljs-comment">//把其中一个质数除干净</span><br>&#123;<br>arr[j++] = i;<span class="hljs-comment">//把那个质数因子存起来</span><br>            n/=i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)<br>&#123;<br>arr[j++] = n;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>好了学完了质数相关的知识，我们开始刷题吧</p></blockquote><h1 id="四因数"><a href="#四因数" class="headerlink" title="四因数"></a>四因数</h1><blockquote><p><a href="https://leetcode-cn.com/problems/four-divisors/" title="四因数">四因数</a></p><p>给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。</p><p>如果数组中不存在满足题意的整数，则返回 <code>0</code> 。</p><p><strong>示例：</strong></p><p><strong>输入：</strong>nums &#x3D; [21,4,7]<br><strong>输出：</strong>32<br><strong>解释：</strong><br>21 有 4 个因数：1, 3, 7, 21<br>4 有 3 个因数：1, 2, 4<br>7 有 2 个因数：1, 7<br>答案仅为 21 的所有因数的和。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> sum(<span class="hljs-built_in">int</span> x)<span class="hljs-comment">//计算因子和的函数</span><br>&#123;<br>    <span class="hljs-built_in">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=(x/i);i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<br>        &#123;<br>            sum+=i;<br>            <span class="hljs-keyword">if</span>(i*i!=x)<br>            &#123;<br>                sum+=(x/i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-built_in">bool</span> fourfactor(<span class="hljs-built_in">int</span> n)<span class="hljs-comment">//判断是否有4个因子的函数</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-built_in">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=(n/i);i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>        &#123;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(i*i!=n)<br>            &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">int</span> sumFourDivisors(<span class="hljs-built_in">int</span>* nums, <span class="hljs-built_in">int</span> numsSize)&#123;<br><span class="hljs-comment">//先对每一个进行拆分是否有4个因数，</span><br><span class="hljs-comment">//拆分完后如果有4个因子</span><br><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> addsum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(fourfactor(nums[i]))<br>    &#123;<br>        addsum+=sum(nums[i]);<span class="hljs-comment">//addsum就把因子和加起来</span><br>        <br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(addsum)<br>&#123;<br>    <span class="hljs-keyword">return</span> addsum;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最接近的因数"><a href="#最接近的因数" class="headerlink" title="最接近的因数"></a>最接近的因数</h1><blockquote><p><a href="https://leetcode-cn.com/problems/closest-divisors/" title="最接近的因数">最接近的因数</a></p><p>给你一个整数 <code>num</code>，请你找出同时满足下面全部要求的两个整数：</p><ul><li>两数乘积等于  <code>num + 1</code> 或 <code>num + 2</code></li><li>以绝对差进行度量，两数大小最接近</li></ul><p>你可以按任意顺序返回这两个整数。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>num &#x3D; 8<br><strong>输出：</strong>[3,3]<br><strong>解释：</strong>对于 num + 1 &#x3D; 9，最接近的两个因数是 3 &amp; 3；对于 num + 2 &#x3D; 10, 最接近的两个因数是 2 &amp; 5，因此返回 3 &amp; 3 。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>num &#x3D; 123<br><strong>输出：</strong>[5,25]</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>num &#x3D; 999<br><strong>输出：</strong>[40,25]</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 10^9</code></li></ul></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">closestDivisors</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span>* returnSize)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//分别对n+1，和n+2进行因数分解，两者间的差值最小，比较的是差值的绝对值</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> *ret = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">2</span>);<br>*returnSize = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> min =<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> j;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (i = num + <span class="hljs-number">1</span>; i &lt;= num + <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= i / j; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (i%j == <span class="hljs-number">0</span>)<span class="hljs-comment">//j是其中的一个因数，这个时候i/j也是其中一个因数</span><br>&#123;<br><br><span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-built_in">abs</span>(j - i / j) || min == <span class="hljs-number">-1</span>)<span class="hljs-comment">//我们初始化m为一个负数，避免对后续产生印象，假如第一次成立的化也能够进入if语句内部</span><br>&#123;<br>                    min = <span class="hljs-built_in">abs</span>(j - i / j);<br>x = j;<br>y = i / j;<br><span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span>)<br>&#123;<br>flag = <span class="hljs-number">0</span>;;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>ret[<span class="hljs-number">0</span>] = x;<br>ret[<span class="hljs-number">1</span>] = y;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><blockquote><p><a href="https://leetcode-cn.com/problems/ugly-number/" title="丑数">丑数</a></p><p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>n &#x3D; 6<br><strong>输出：</strong>true<br><strong>解释：</strong>6 &#x3D; 2 × 3</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>n &#x3D; 8<br><strong>输出：</strong>true<br><strong>解释：</strong>8 &#x3D; 2 × 2 × 2</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>n &#x3D; 14<br><strong>输出：</strong>false<br><strong>解释：</strong>14 不是丑数，因为它包含了另外一个质因数 <code>7</code> 。</p></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs axapta">bool isUgly(<span class="hljs-built_in">int</span> n)<br>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-comment">//分解质因数</span><br><span class="hljs-built_in">int</span> i;<br><span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">2000</span>];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n/i;i++)<br>&#123;<br><span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">str</span>[j++]=i;<br>    n/=i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//此时的n一定是个质数,如果被整除的话，就会n=1，所以整个条件控制的是n&gt;1d</span><br><span class="hljs-built_in">str</span>[j++]=n;<br><span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> m=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;j;k++)<br>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">str</span>[k]==<span class="hljs-number">2</span>||<span class="hljs-built_in">str</span>[k]==<span class="hljs-number">3</span>||<span class="hljs-built_in">str</span>[k]==<span class="hljs-number">5</span>)<br>  &#123;<br>      m++;<span class="hljs-comment">//如果他是这3者其中一个质因数，m自增</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(m==j)<span class="hljs-comment">//如果m和他的所有质因数相同的时，就是都是这3个质因数</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>散列表 数据结构 c++ leetcode 蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异或的高级用法以及LeetCode刷题</title>
    <link href="/2021/12/02/%E5%BC%82%E6%88%96%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8ALeetCode%E5%88%B7%E9%A2%98/"/>
    <url>/2021/12/02/%E5%BC%82%E6%88%96%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8ALeetCode%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.%E5%BC%82%E6%88%96%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D" title="1.异或特性介绍">1.异或特性介绍</a></p><p><a href="#2.%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%C2%A0" title="2.消失的数字 ">2.消失的数字 </a></p><p><a href="#3%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0" title="3数组中数字出现的次数">3数组中数字出现的次数</a></p><p><a href="#4.%C2%A0%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97" title="4. 消失的两个数字">4. 消失的两个数字</a></p><hr><p> </p><h1 id="1-异或特性介绍"><a href="#1-异或特性介绍" class="headerlink" title="1.异或特性介绍"></a>1.异或特性介绍</h1><blockquote><p>异或：在二进制的表示中，两个数异或，同位上的两个数，异或，不同则为1，相同为0</p><p>如4^9</p><p>4二进制表示 0000 0000 0000 0000 0000 0000 0000 0100</p><p>9二进制表示 0000 0000 0000 0000 0000 0000 0000 1001</p><p>两者异或之后的结果是</p><p>                     0000 0000 0000 0000 0000 0000 0000 1101</p></blockquote><blockquote><p> 对于异或这是一个非常重要的知识点，对于算法当中</p><p>异或的特性有，1.交换律，a^b&#x3D;b^a</p><p>2.恒等性，0^a&#x3D;a,即0与任何数异或之后，还是任何数，不改变这个数</p><p>2.归零性，a^a&#x3D;0,即两个相同的数异或之后就变成0，</p><p>2.结合律a^b^a&#x3D;b,两个相同的 数异或之后就没了</p></blockquote><blockquote><p>举个例子</p><p>0^3^1^8^9&#x3D;3^1^8^9</p><p>3^9^7^9^7&#x3D;3</p></blockquote><h1 id="2-消失的数字"><a href="#2-消失的数字" class="headerlink" title="2.消失的数字"></a>2.消失的数字</h1><blockquote><p><a href="https://leetcode-cn.com/problems/missing-number-lcci/" title="消失的数字">消失的数字</a></p><p>数组<code>nums</code>包含从<code>0</code>到<code>n</code>的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？</p><p><strong>注意：</strong>本题相对书上原题稍作改动</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>[3,0,1]<br><strong>输出：</strong>2</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>[9,6,4,2,3,5,7,0,1]<br><strong>输出：</strong>8</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> missing<span class="hljs-constructor">Number(<span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">numsSize</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> arr<span class="hljs-literal">[<span class="hljs-identifier">numsSize</span>]</span>;<br><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=i+<span class="hljs-number">1</span>;<span class="hljs-comment">//先把arr里面赋的是完整的1到n</span><br>&#125;<br><span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    x^=arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<span class="hljs-comment">//0和他们异或之后就是异或1^2^3……^n</span><br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    x^=nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<span class="hljs-comment">//异或之后的1^2^3……^n再和原数组进行异或，之后一样的就都没了，就只剩一个落单的，就是那个消失的数</span><br>&#125;<br><br>return x;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3数组中数字出现的次数"><a href="#3数组中数字出现的次数" class="headerlink" title="3数组中数字出现的次数"></a>3数组中数字出现的次数</h1><blockquote><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums &#x3D; [4,1,4,6]<br><strong>输出：</strong>[1,6] 或 [6,1]</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,2,10,4,1,4,3,3]<br><strong>输出：</strong>[2,10] 或 [10,2]</p><p><strong>限制：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10000</code></li></ul></blockquote><blockquote><p>这题运用到了分组异或的思想</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>/**<br> * Note: The returned array must be malloced, assume caller calls free().<br> */<br>int* singleNumbers(int* nums, int numsSize, int* returnSize)&#123;<br>int ret=<span class="hljs-number">0</span>;<br>int i;<br><span class="hljs-regexp">//</span>假设出现<span class="hljs-number">1</span>次的数是x1和x2<br><span class="hljs-regexp">//</span>把所有数都异或<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    ret^=nums[i];<br>&#125;<br><span class="hljs-regexp">//</span>异或完了就是剩下两个数的异或结果<br><span class="hljs-regexp">//</span>ret=x1^x2<br><span class="hljs-regexp">//</span>下一步就是想办法分离两者<br><span class="hljs-regexp">//</span>找出ret里面第m位为<span class="hljs-number">1</span>的，说明x1和x2的第m位不一样，一个为<span class="hljs-number">1</span>一个为<span class="hljs-number">0</span><br><span class="hljs-regexp">//</span>我们在ret里面不好分离，在原数组里面分离x1和x2<br><span class="hljs-regexp">//</span>分成两组，第m位位<span class="hljs-number">1</span>的位一组<br><span class="hljs-regexp">//</span>         第m位为<span class="hljs-number">0</span>的为一组<br><span class="hljs-regexp">//</span>所以x1，x2一定会分别在这两组里面<br><span class="hljs-regexp">//</span>其他数成对出现在某一组，相同的数，那一位肯定相同，肯定都在同一组<br>int m=<span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>因为是在数组里面找第m位，所以把他弄成<span class="hljs-number">0</span><br><span class="hljs-regexp">//</span>ret一定不为<span class="hljs-number">0</span>，一定有<span class="hljs-number">1</span>这一位<br><span class="hljs-keyword">while</span>(m&lt;<span class="hljs-number">32</span>)<span class="hljs-regexp">//i</span>nt一共有<span class="hljs-number">32</span>位<br>&#123;<br>    <span class="hljs-keyword">if</span>(ret&amp;(<span class="hljs-number">1</span>&lt;&lt;m))<span class="hljs-regexp">//</span>ret与上<span class="hljs-number">1</span>左移m为，如果为<span class="hljs-number">1</span>，就找到了那个第m位<br>    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">else</span><br>    m++;<br>&#125;<br><span class="hljs-regexp">//</span><br>int x1=<span class="hljs-number">0</span>,x2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]&amp;(<span class="hljs-number">1</span>&lt;&lt;m))<br>    &#123;<br>     <span class="hljs-regexp">//</span>为<span class="hljs-number">1</span>的在一组<br>     x1^=nums[i];   <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    x2^=nums[i];<br>    &#125;<br>&#125;<br><br>int* returna=(int*)malloc(sizeof(int)*<span class="hljs-number">2</span>);<br>*returnSize=<span class="hljs-number">2</span>;<br>returna[<span class="hljs-number">0</span>]=x1;<br>returna[<span class="hljs-number">1</span>]=x2;<br>return returna;<br><br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-消失的两个数字"><a href="#4-消失的两个数字" class="headerlink" title="4. 消失的两个数字"></a>4. 消失的两个数字</h1><blockquote><p>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</p><p>以任意顺序返回这两个数字均可。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> <code>[1]</code><br><strong>输出:</strong> [2,3]</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> <code>[2,3]</code><br><strong>输出:</strong> [1,4]</p><p><strong>提示：</strong></p><ul><li><code>nums.length &lt;= 30000</code></li></ul></blockquote><blockquote><p>我们上面介绍了分组异或的思想</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8878987094374c418569920e573696fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">​<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">int</span>* missingTwo(<span class="hljs-built_in">int</span>* nums, <span class="hljs-built_in">int</span> numsSize, <span class="hljs-built_in">int</span>* returnSize)<br>&#123;<br><span class="hljs-built_in">int</span> ret=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> ret1=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=numsSize+<span class="hljs-number">2</span>;i++)<br>&#123;<br>ret^=i;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    ret^=nums[i];<br>&#125;<br><span class="hljs-comment">//此时ret的结果就是剩下两个数异或的结果</span><br><span class="hljs-built_in">int</span> m=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(m&lt;<span class="hljs-number">32</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(ret&amp;(<span class="hljs-number">1</span>&lt;&lt;m))<br>&#123;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>m++;<br>&#125;<br><span class="hljs-built_in">int</span> ret0=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> ret2=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//先分组做原数组的</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]&amp;(<span class="hljs-number">1</span>&lt;&lt;m))<br>    &#123;<br>        ret0^=nums[i];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    ret2^=nums[i];<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=numsSize+<span class="hljs-number">2</span>;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;m))<br>    &#123;<br>        ret0^=i;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    ret2^=i;<br>&#125;<br>*returnSize=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> *retarr=(<span class="hljs-built_in">int</span> *)malloc(sizeof(<span class="hljs-built_in">int</span>)*<span class="hljs-number">2</span>);<br>retarr[<span class="hljs-number">0</span>]=ret0;<br>retarr[<span class="hljs-number">1</span>]=ret2;<br><span class="hljs-keyword">return</span> retarr;<br><br>&#125;<br>​<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划 算法 排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列精华总结</title>
    <link href="/2021/12/01/%E9%98%9F%E5%88%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/01/%E9%98%9F%E5%88%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>队列遵循的原则是先进先出</p><p>打印的数无论按什么时间出都是一样的</p></blockquote><blockquote><p> queue.h</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> queuedata;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">queuenode</span><br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">queuenode</span>*next;<br>queuedata data;<br>&#125;qnode;<br><br><br><span class="hljs-comment">//定义一个结构体，需要有一个头节点，和尾节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">queue</span><br>&#123;<br>qnode*head;<br>qnode*tail;<br><br>&#125;queue;<br><br><span class="hljs-comment">//我们需要初始化一下</span><br><span class="hljs-comment">//我们可以需要用带哨兵位的头，这个主要是解决二级指针的问题</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queueinit</span><span class="hljs-params">(queue* pq)</span></span>;<br><br><span class="hljs-comment">//销毁,动态开辟必备，否则内存泄露</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queuedestroy</span><span class="hljs-params">(queue*pq)</span></span>;<br><br><span class="hljs-comment">//他的push是在队尾入，出是在队头出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queuepush</span><span class="hljs-params">(queue*pq, queuedata x)</span></span>;<br><br><span class="hljs-comment">//队头出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queuepop</span><span class="hljs-params">(queue*pq)</span></span>;<br><br><span class="hljs-comment">//取的是队头的数据</span><br><span class="hljs-function">queuedata  <span class="hljs-title">queuefront</span><span class="hljs-params">(queue*pq)</span></span>;<br><span class="hljs-comment">//取队尾的数据</span><br><span class="hljs-function">queuedata <span class="hljs-title">queueback</span><span class="hljs-params">(queue*pq)</span></span>;<br><span class="hljs-comment">//计算有多少个数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queuesize</span><span class="hljs-params">(queue*pq)</span></span>;<br><br><span class="hljs-comment">//对这个队列进行判空 </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">queueempty</span><span class="hljs-params">(queue*pq)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>queue.c</p></blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs xl">#define _CRT_SECURE_NO_WARNINGS <span class="hljs-number">1</span><br>#include<span class="hljs-string">&quot;queue.h&quot;</span><br>void queueinit(queue* pq)<span class="hljs-comment">//传过来的是结构体的指针，所以我们传一级就可以了</span><br>&#123;<br>assert(pq);<br><span class="hljs-function"><span class="hljs-title">pq</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span>=pq-&gt;</span>tail=NULL;<span class="hljs-comment">//都初始化为空//但我们在单链表中不加tail这个尾巴节点，</span><br>                       <span class="hljs-comment">//因为tail可以解决尾插，但是解决不了尾删,就很麻烦</span><br>&#125;<br><br><span class="hljs-comment">//队尾入</span><br>void queuepush(queue*pq, queuedata x)<br>&#123;<br>assert(pq);<br><span class="hljs-comment">//我们要入数据，一开始tail和head的都是空的</span><br>qnode*newnode = (qnode*)malloc(sizeof(qnode));<br><span class="hljs-keyword">if</span> (newnode == NULL)<br>&#123;<br>perror(<span class="hljs-string">&quot;malloc&quot;</span>);<br>return;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">newnode</span>-&gt;</span><span class="hljs-keyword">data</span> = x;<br><span class="hljs-function"><span class="hljs-title">newnode</span>-&gt;</span>next = NULL;<br><span class="hljs-function"><span class="hljs-title">if</span> (pq-&gt;</span>tail == NULL)<span class="hljs-comment">//假如说尾巴也是空，就没办法把newnode插进去，也就是说还没有节点，</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">pq</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span> = pq-&gt;</span>tail = newnode;<span class="hljs-comment">//那么他们就是指向的是同一个，所以这个newnode既是头也是尾</span><br>&#125;<br><span class="hljs-comment">//否则，我们就插入一个节点，就链接一个节点，将tail指向他</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">pq</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tail</span>-&gt;</span>next = newnode;<span class="hljs-comment">//把尾巴的next指向他，进行链接，头一直不变，尾巴在变多</span><br><span class="hljs-function"><span class="hljs-title">pq</span>-&gt;</span>tail= newnode;<span class="hljs-comment">//</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//队头出，相当于头删</span><br>void queuepop(queue*pq)<br>&#123;<br>assert(pq);<span class="hljs-comment">//指针不为空</span><br><span class="hljs-function"><span class="hljs-title">assert</span>(pq-&gt;</span>head);<span class="hljs-comment">//链表为空就错了</span><br><span class="hljs-comment">//一个节点</span><br><span class="hljs-function"><span class="hljs-title">if</span> (pq-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span>next == NULL)<span class="hljs-comment">//即只有一个节点</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">free</span>(pq-&gt;</span>head);<br><span class="hljs-function"><span class="hljs-title">pq</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span> = pq-&gt;</span>head = NULL;<span class="hljs-comment">//释放掉之后，把他们都置空</span><br>&#125;<br><span class="hljs-comment">//多个节点</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">qnode</span>*next = pq-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span>next;<span class="hljs-comment">//要保存住下一个节点，否则就找不到他了</span><br><span class="hljs-function"><span class="hljs-title">free</span>(pq-&gt;</span>head);<span class="hljs-comment">//head不用置空</span><br><span class="hljs-function"><span class="hljs-title">pq</span>-&gt;</span>head = next;<span class="hljs-comment">//head要指向新的节点</span><br><span class="hljs-comment">//假如到最后都删除完了，tail就变成一个野指针</span><br>&#125;<br>&#125;<br><br>bool queueempty(queue*pq)<br>&#123;<br>assert(pq);<br><span class="hljs-function"><span class="hljs-title">return</span> pq-&gt;</span>head == NULL;<span class="hljs-comment">//假如说他为空就是真，就是没有节点了，假如说他不为空就为假，用来后面打印判断用</span><br>&#125;<br><br><span class="hljs-comment">//取队头的数据</span><br>queuedata  queuefront(queue*pq)<br>&#123;<br>assert(pq);<br><span class="hljs-function"><span class="hljs-title">assert</span>(pq-&gt;</span>head);<span class="hljs-comment">//头也不能为空</span><br><span class="hljs-function"><span class="hljs-title">return</span> pq-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span><span class="hljs-keyword">data</span>;<br>&#125;<br><br><span class="hljs-comment">//取队尾的数据</span><br>queuedata  queueback(queue*pq)<br>&#123;<br>assert(pq);<br><span class="hljs-function"><span class="hljs-title">assert</span>(pq-&gt;</span>head);<span class="hljs-comment">//头也不能为空</span><br><span class="hljs-function"><span class="hljs-title">return</span> pq-&gt;</span><span class="hljs-function"><span class="hljs-title">tail</span>-&gt;</span><span class="hljs-keyword">data</span>;<br>&#125;<br><br>int queuesize(queue*pq)<br>&#123;<br>assert(pq);<br>int sz = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">qnode</span>*cur = pq-&gt;</span>head;<br><span class="hljs-keyword">while</span> (cur)<span class="hljs-comment">//不为空才是队的，假如说是不等于tail的话就会少算一个</span><br>&#123;<br>++sz;<br><span class="hljs-function"><span class="hljs-title">cur</span> = cur-&gt;</span>next;<br><br>&#125;<br>return sz;<br>&#125;<br><br>void queuedestroy(queue*pq)<br>&#123;<br>assert(pq);<br><span class="hljs-function"><span class="hljs-title">qnode</span>*cur = pq-&gt;</span>head;<br><span class="hljs-keyword">while</span> (cur)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">qnode</span>*next = cur-&gt;</span>next;<span class="hljs-comment">//要找到cur的下一个，否则就找不到下一个节点的 位置了</span><br><span class="hljs-comment">//再free掉</span><br>free(cur);<br>cur = next;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">pq</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span> = pq-&gt;</span>tail = NULL;<span class="hljs-comment">//删除完后，再把head和tail置成空</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>test.c</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> _CRT_SECURE_NO_WARNINGS <span class="hljs-number">1</span><br><span class="hljs-selector-id">#include</span>&quot;queue<span class="hljs-selector-class">.h</span>&quot;<br><br>int <span class="hljs-selector-tag">main</span>()<br>&#123;<br>queue <span class="hljs-selector-tag">q</span>;<br><span class="hljs-built_in">queueinit</span>(&amp;q);<br><span class="hljs-built_in">queuepush</span>(&amp;q, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">queuepush</span>(&amp;q, <span class="hljs-number">2</span>);<br><br><span class="hljs-built_in">queuepush</span>(&amp;q, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">queuepush</span>(&amp;q, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">queuepush</span>(&amp;q, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">queuepush</span>(&amp;q, <span class="hljs-number">6</span>);<br>while (!queueempty(&amp;q))<span class="hljs-comment">//用我们写的函数来作为循环判断的条件，而不用自己写的东西，保证准确性</span><br>&#123;<br><span class="hljs-built_in">printf</span>(&quot;%d &quot;, queuefront(&amp;q));<br><span class="hljs-comment">//再删掉对头的数据</span><br><span class="hljs-built_in">queuepop</span>(&amp;q);<br>&#125;<br><span class="hljs-built_in">queuedestroy</span>(&amp;q);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表 数据结构 leetcode 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>细数排序（1）</title>
    <link href="/2021/11/30/%E7%BB%86%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%881%EF%BC%89/"/>
    <url>/2021/11/30/%E7%BB%86%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>插入排序</p><p><img src="https://img-blog.csdnimg.cn/3169f596cb4c48f4a994dfc274768592.gif"></p><p><img src="https://img-blog.csdnimg.cn/9cff6f63df2d48679e9ac667d6e182f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> end = i;<br><span class="hljs-type">int</span> tmp = arr[end + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (tmp &lt; arr[end])<br>&#123;<br>arr[end + <span class="hljs-number">1</span>] = arr[end];<br>end--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>        &#125;<br>arr[end+<span class="hljs-number">1</span>] = tmp;<span class="hljs-comment">//因为走到了要求的数的前一个位置，那么他的后一位就是我们要插入的位置</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>希尔排序</p><p><img src="https://img-blog.csdnimg.cn/7519e8d0c5874a7eb02f796fc3c3d505.gif"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 时间复杂度是O(N*logN);</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//为了应对假如说使用插入排序的时候，那个数过于无序，如我们对一个逆序的数组，将他排序成顺序的，</span><br><span class="hljs-comment">//一个一个的排时间复杂度过于大，太浪费了</span><br><span class="hljs-comment">//所以我们可以使用中间间隔多的为一组进行排序，尽量把大的数字放到后面去，小的数字放到前面去，做到尽量有序</span><br><span class="hljs-comment">//当间隔为1的时候就是直接插入排序</span><br><span class="hljs-type">int</span> gap = n;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">1</span>)<br>&#123;<br>gap = gap / <span class="hljs-number">2</span>;<span class="hljs-comment">//如果gap是%2的话，最后gap会变成1，就是直接插入排序</span><br><span class="hljs-comment">//假如我们是gap=gap/3的话，最后可能就不能变成1变成直接插入排序了,希尔排序内部的算法可以类比，直接插入排序，只不过把原来的1变成了gap</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - gap; i++)<br>&#123;<br><span class="hljs-type">int</span> end = i;<br><span class="hljs-type">int</span> tmp = arr[end + gap];<br><span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (tmp &lt; arr[end])<br>&#123;<br>arr[end + gap] = arr[end];<br>end -= gap;<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>arr[end + gap] = tmp;<br>&#125;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>选择排序</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>, end = n - <span class="hljs-number">1</span>;<span class="hljs-comment">//</span><br><span class="hljs-keyword">while</span> (begin &lt; end)<span class="hljs-comment">//begin和end分别从两边开始走，begin一方找到的是最小的那些数，end一方找到的是最大的一些数，当两者相遇或者刚好走到挨着的时候，就排序完成了</span><br>&#123;<br><span class="hljs-type">int</span> max=begin, min=begin;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin; i &lt;= end; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[i] &lt; arr[begin])<br>&#123;<br>min = i;<span class="hljs-comment">//把最小的下标存到min里面</span><br>&#125;<br><span class="hljs-keyword">if</span> (arr[i] &gt; arr[begin])<br>&#123;<br>max = i;<span class="hljs-comment">//把最大的下标存到max里面</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(&amp;arr[begin], &amp;arr[min]);<span class="hljs-comment">//处理完后把找到的最小下标和begin进行交换</span><br><span class="hljs-comment">//假如说第一个就是最大的，那交换之后，最大的就和最小的交换了</span><br><span class="hljs-keyword">if</span>(begin==maxi)<br>&#123;<br>maxi=mini;<br>&#125;<br><span class="hljs-built_in">swap</span>(&amp;arr[end], &amp;arr[max]);<span class="hljs-comment">//把最大下标和end进行交换</span><br>begin++;<br>end--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速排序</p><p><img src="https://img-blog.csdnimg.cn/8501d2b6bf7c4c918d250711ab4c04f6.gif"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (left &gt;= right)<span class="hljs-comment">//当left&gt;right就算是不存在，=就是只有一个值，都是不用排</span><br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> begin = left, end = right;<br><span class="hljs-type">int</span> pivot = begin;<span class="hljs-comment">//把左边做一个坑</span><br><span class="hljs-type">int</span> key = arr[begin];<span class="hljs-comment">//把左边的数作为关键字，保存起来</span><br><span class="hljs-comment">//一趟的排序</span><br><span class="hljs-keyword">while</span> (begin &lt; end)<span class="hljs-comment">//左边做坑则右边先动</span><br>&#123;<br><span class="hljs-comment">//右边找小，放到左边</span><br><br><span class="hljs-keyword">while</span> (begin &lt; end&amp;&amp;arr[end] &gt;= key)<span class="hljs-comment">//大于就--，小于才停下来//同时end走的必须是在begin右边，因为begin左边都是以及处理过的，所以end要大于begin</span><br>&#123;<br>--end;<br>&#125;<br><span class="hljs-comment">//找到的小的，放到左边，从而自己形成了新的坑位</span><br>arr[pivot] = arr[end];<br>pivot = end;<br><span class="hljs-comment">//现在去找大</span><br><span class="hljs-keyword">while</span> (begin&lt;end &amp;&amp;arr[begin] &lt;= key)<span class="hljs-comment">//始终保证begin&lt;end的条件</span><br>&#123;<br>++begin;<br>&#125;<br><span class="hljs-comment">//大的放到左边的坑，自己形成新的坑位</span><br>arr[pivot] = arr[begin];<br>pivot = begin;<br>&#125;<br>pivot = begin;<span class="hljs-comment">//到达了中间的位置</span><br>arr[pivot] = key;<br><span class="hljs-comment">//[在left，right]</span><br><span class="hljs-comment">//每次调用这函数都被分成3部分</span><br><span class="hljs-comment">//[left,pivot-1],pivot,[pivot+1,right]//始终被分成了这三个部分，pivot是已经有序的了</span><br><span class="hljs-comment">//只要让左子区间和右子区间有序，我们就有序了，我们就用到了分治递归的思想</span><br><span class="hljs-built_in">quicksort</span>(arr, left, pivot - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">quicksort</span>(arr, pivot + <span class="hljs-number">1</span>, right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法 链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法零基础——大数四则运算</title>
    <link href="/2021/11/30/%E7%AE%97%E6%B3%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%A4%A7%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/"/>
    <url>/2021/11/30/%E7%AE%97%E6%B3%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%A4%A7%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0" title="字符串相加">字符串相加</a></p><p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98" title="字符串相乘">字符串相乘</a></p><p><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C" title="二进制求和">二进制求和</a></p><p><a href="#%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E6%95%B0" title="千位分隔数">千位分隔数</a></p><hr><p>我们知道无论任何类型都有数字的最大范围，所以我们如果想要对于任何两个数都能够进行</p><p>四则运算，那么我们就可以运用一个字符串进行运算</p><h1 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h1><blockquote><p><a href="https://leetcode-cn.com/problems/add-strings/" title="字符串相加">字符串相加</a></p><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>num1 &#x3D; “11”, num2 &#x3D; “123”<br><strong>输出：</strong>“134”</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>num1 &#x3D; “456”, num2 &#x3D; “77”<br><strong>输出：</strong>“533”</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>num1 &#x3D; “0”, num2 &#x3D; “0”<br><strong>输出：</strong>“0”</p></blockquote><blockquote><p>我们想要对字符串进行运算，所以我们要对字符串进行反转</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len/<span class="hljs-number">2</span>;i++)<br>    &#123;<br>        <span class="hljs-type">char</span> c=s[i];<br>        s[i]=s[len<span class="hljs-number">-1</span>-i];<br>        s[len<span class="hljs-number">-1</span>-i]=c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">addStrings</span><span class="hljs-params">(<span class="hljs-type">char</span> * num1, <span class="hljs-type">char</span> * num2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i,n1,n2,now,cap;<br>cap=<span class="hljs-number">0</span>;<span class="hljs-comment">//cap用来计算进位的，逢10进1，所以cap只有0或1</span><br><span class="hljs-type">int</span> len1=<span class="hljs-built_in">strlen</span>(num1);<span class="hljs-comment">//计算num1的长度</span><br><span class="hljs-type">int</span> len2=<span class="hljs-built_in">strlen</span>(num2);<span class="hljs-comment">//计算num2的长度</span><br><span class="hljs-built_in">reverse</span>(num1);<br><span class="hljs-built_in">reverse</span>(num2);<br><span class="hljs-type">int</span> max=len1&gt;len2?len1:len2;<span class="hljs-comment">//两个数相加，最大的可能长度就是，两者最大长度+1，要不然就是两者的最大值</span><br><span class="hljs-type">char</span> *c=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>)*(max+<span class="hljs-number">2</span>));<span class="hljs-comment">//我们把加后的数字存储到c里面，由于字符串的结束标志是‘\0’，所以我们开辟的时候多开辟一点</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;max;i++)<br>&#123;<br>    n1=i&lt;len1?num1[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<span class="hljs-comment">//i&lt;len1的话，数字都是可以的，到len的话num1后就没有数字了，</span><br>    n2=i&lt;len2?num2[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<span class="hljs-comment">//同理</span><br>    <span class="hljs-type">int</span> now=n1+n2+cap;<span class="hljs-comment">//now就是还没进位的数，每个位置数有可能是个两位数</span><br>    cap=now/<span class="hljs-number">10</span>;<span class="hljs-comment">//cap处理进位</span><br>    c[i]=(now%<span class="hljs-number">10</span>)+<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//%10就是现在的数+‘0’就是个字符了</span><br><br>&#125;<br><span class="hljs-keyword">if</span>(cap)<br>&#123;<br>    c[i]=<span class="hljs-string">&#x27;1&#x27;</span>;<span class="hljs-comment">//如果cap处理进位后变成了1，那么最高位进1</span><br>    max++;<span class="hljs-comment">//同时长度增长</span><br>&#125;<br>c[max]=<span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//最后要把最后一位变成‘\0’作为字符串的结束标志，与他反转无关，字符串结束就要加个‘\0’</span><br><span class="hljs-built_in">reverse</span>(c);<span class="hljs-comment">//最后再把c给转过来</span><br><span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h1><blockquote><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> num1 &#x3D; “2”, num2 &#x3D; “3”<br><strong>输出:</strong> “6”</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> num1 &#x3D; “123”, num2 &#x3D; “456”<br><strong>输出:</strong> “56088”</p><p><strong>说明：</strong></p><ol><li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li><li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li><li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li><li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len/<span class="hljs-number">2</span>;i++)<br>    &#123;<br>        <span class="hljs-type">char</span> tmp=s[i];<br>        s[i]=s[len<span class="hljs-number">-1</span>-i];<br>        s[len<span class="hljs-number">-1</span>-i]=tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">char</span> * num1, <span class="hljs-type">char</span> * num2)</span></span>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-type">int</span> len1=<span class="hljs-built_in">strlen</span>(num1);<br><span class="hljs-type">int</span> len2=<span class="hljs-built_in">strlen</span>(num2);<br><span class="hljs-type">int</span> len=len1+len2;<span class="hljs-comment">//字符串相乘的长度，最大是两个长度相加</span><br><span class="hljs-type">int</span> *mul=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*(len+<span class="hljs-number">5</span>));<span class="hljs-comment">//我们开辟一个相乘后的字符串数组，长度要多开辟一点，避免最后数组越界,多出来的部分我们可以在后面进行处理</span><br><span class="hljs-type">char</span>*ret=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>)*(len+<span class="hljs-number">5</span>));<br><span class="hljs-built_in">memset</span>(mul,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*(len+<span class="hljs-number">5</span>));<span class="hljs-comment">//再memset里面，我们最好用sizeof(int)*计算数组的长度，而不用sizeof(mul),</span><br><span class="hljs-built_in">reverse</span>(num1);<br><span class="hljs-built_in">reverse</span>(num2);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len1;i++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;len2;j++)<br>    &#123;<br>        mul[i+j]+=(num1[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*(num2[j]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//根据竖式计算，第i位和第j位的数相乘会再第i+j位上，同时i+j位会有多个数字运算</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<span class="hljs-comment">//因为mul我们多开辟了空间，所以他的长度可以到len而不越界</span><br>&#123;<br>    mul[i+<span class="hljs-number">1</span>]+=mul[i]/<span class="hljs-number">10</span>;<span class="hljs-comment">//第i+1位需要进位，是前一位/10出来的</span><br>    mul[i]%=<span class="hljs-number">10</span>;<span class="hljs-comment">//每一位需要%10，才得出了真实的每一位</span><br>&#125;<br><span class="hljs-comment">//由于我们不知道相乘后的长度，所以我们要处理反转后的前导0</span><br><span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">1</span>&amp;&amp;mul[len<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)<span class="hljs-comment">//当len-1位是0是长度减减1</span><br>&#123;<br>    len--;<br>&#125;<br><span class="hljs-comment">//最后把数字转化成一个字符串</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>&#123;<br>    ret[i]=mul[i]+<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//数字+‘0’就变成了一个字符</span><br>&#125;<br>ret[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//把最后一位赋值为‘\0’，作为字符串的结束标志</span><br><span class="hljs-built_in">reverse</span>(ret);<span class="hljs-comment">//把ret反转后就是运算后的结果</span><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h1><blockquote><p><a href="https://leetcode-cn.com/problems/add-binary/" title="二进制求和">二进制求和</a></p><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> a &#x3D; “11”, b &#x3D; “1”<br><strong>输出:</strong> “100”</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> a &#x3D; “1010”, b &#x3D; “1011”<br><strong>输出:</strong> “10101”</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len/<span class="hljs-number">2</span>;i++)<br>    &#123;<br>        <span class="hljs-type">char</span> tmp=s[i];<br>        s[i]=s[len<span class="hljs-number">-1</span>-i];<br>        s[len<span class="hljs-number">-1</span>-i]=tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">addBinary</span><span class="hljs-params">(<span class="hljs-type">char</span> * a, <span class="hljs-type">char</span> * b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> lena=<span class="hljs-built_in">strlen</span>(a);<br><span class="hljs-type">int</span> lenb=<span class="hljs-built_in">strlen</span>(b);<br><span class="hljs-type">int</span> maxlen=lena&gt;lenb?lena:lenb;<br><span class="hljs-built_in">reverse</span>(a);<br><span class="hljs-built_in">reverse</span>(b);<br><span class="hljs-type">char</span> *ret=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>)*(maxlen+<span class="hljs-number">2</span>));<br><span class="hljs-type">int</span> av,bv,now,cap=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxlen;i++)<br>&#123;<br>av=(i&lt;lena)?(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>):<span class="hljs-number">0</span>;<br>bv=(i&lt;lenb)?(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>):<span class="hljs-number">0</span>;<br>now=av+bv+cap;<br>cap=now/<span class="hljs-number">2</span>;<br>ret[i]=now%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(cap)<br>&#123;<br>    ret[i]=<span class="hljs-string">&#x27;1&#x27;</span>;<br>maxlen++;<br>&#125;<br>ret[maxlen]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-built_in">reverse</span>(ret);<br><span class="hljs-keyword">return</span> ret;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="千位分隔数"><a href="#千位分隔数" class="headerlink" title="千位分隔数"></a>千位分隔数</h1><blockquote><p><a href="https://leetcode-cn.com/problems/thousand-separator/" title="千位分隔数">千位分隔数</a></p><p>给你一个整数 <code>n</code>，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>n &#x3D; 987<br><strong>输出：</strong>“987”</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>n &#x3D; 1234<br><strong>输出：</strong>“1.234”</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>n &#x3D; 123456789<br><strong>输出：</strong>“123.456.789”</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>n &#x3D; 0<br><strong>输出：</strong>“0”</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>*n)</span><span class="hljs-comment">//逆序</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len/<span class="hljs-number">2</span>;i++)<br>&#123;<br>    <span class="hljs-type">char</span> tmp=n[i];<br>    n[i]=n[len<span class="hljs-number">-1</span>-i];<br>    n[len<span class="hljs-number">-1</span>-i]=tmp;<br>&#125;<br><br><span class="hljs-keyword">return</span> n;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">thousandSeparator</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//首先先求出n是几位数</span><br>    <span class="hljs-comment">//将n转化为一个字符串</span><br>    <span class="hljs-comment">//记录字符串的长度</span><br>    <span class="hljs-comment">//把n逆序</span><br>    <span class="hljs-comment">//每三位就加个点，同时后面的位数往后挪，len++，要注意的是，加点之后，数组i对应的就变化了</span><br>，要对这个点进行处理<br>    <span class="hljs-comment">//最后再逆序</span><br>    <span class="hljs-type">int</span> x=n;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-comment">//当他为0的情况下，在计算长度时候不会进入计算，所以要单独拿出来写</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n)<br>    &#123;<br>        n/=<span class="hljs-number">10</span>;<br>        len++;<span class="hljs-comment">//记录他的长度</span><br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>*num=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>)*(len+(len<span class="hljs-number">-1</span>)/<span class="hljs-number">3</span>+<span class="hljs-number">4</span>));<span class="hljs-comment">//(len-1)是为了避免假如最后也是3位而多大的点，同时+4是为了让他不越界</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x)<br>        &#123;<br>        num[i]=x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>        x/=<span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br> num[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//&#x27;\0&#x27;作为字符串结束的标志，必须要写，不然是不合法的</span><br>    <br><span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<span class="hljs-comment">//因为每次加一个点，则num对应的下标所对应的元素就会发生变化</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len-k;i++)<span class="hljs-comment">//-k是为了保证每次移动他的下标对应的值不发生变换</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>&amp;&amp;i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//</span><br>    &#123;<br>        <br>        <span class="hljs-type">int</span> end=len;<br>        <span class="hljs-keyword">while</span>(end&gt;=i+k)<span class="hljs-comment">//每次加点后i包含了点，所以也要往后挪</span><br>        &#123;<br>            num[end+<span class="hljs-number">1</span>]=num[end];<span class="hljs-comment">//遇到了就往后挪，空出位置给‘.’</span><br>            end--;<br>        &#125;<br>        len++;<br>       num[i+k]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>       k++;<span class="hljs-comment">//要先给i+k赋值才能++，否则i+k的值就变了</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">reverse</span>(num);<br><span class="hljs-keyword">return</span> num;<br>    &#125;<br>    <br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法 链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法零基础——计数数组</title>
    <link href="/2021/11/26/%E7%AE%97%E6%B3%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%AE%A1%E6%95%B0%E6%95%B0%E7%BB%84/"/>
    <url>/2021/11/26/%E7%AE%97%E6%B3%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%AE%A1%E6%95%B0%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E5%BC%95%E8%A8%80%EF%BC%88%E8%AE%A1%E6%95%B0%E6%B3%95%E4%B8%8E%E8%AE%A1%E6%95%B0%E6%95%B0%E7%BB%84%EF%BC%89" title="引言（计数法与计数数组）">引言（计数法与计数数组）</a></p><p><a href="#%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C" title="唯一元素的和">唯一元素的和</a></p><p><a href="#%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97" title="找到所有数组中消失的数字">找到所有数组中消失的数字</a></p><p><a href="#%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE" title="好数对的数目">好数对的数目</a></p><p><a href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%90%8C" title="检查是否所有字符出现次数相同">检查是否所有字符出现次数相同</a></p><p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6" title="字符串中的第一个唯一字符">字符串中的第一个唯一字符</a></p><hr><h1 id="引言（计数法与计数数组）"><a href="#引言（计数法与计数数组）" class="headerlink" title="引言（计数法与计数数组）"></a>引言（计数法与计数数组）</h1><p>我们经常用一个奇数元素来统计元素出现的次数</p><p>如我们统计智商超过163的有多少人，就可以用一个计数法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> func(<span class="hljs-keyword">int</span> *iq, <span class="hljs-keyword">int</span> size) &#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(i<span class="hljs-string">q[i]</span> &gt; <span class="hljs-number">163</span>) &#123;<br>            ++cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们想知道iq的分布呢，那么我们就可以使用一个计数数组，我们可以把iq的值映射到计数数组的下标，其所对应的值就是这个元素出现的次数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *iq, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> IQMax)</span> </span>&#123;                <span class="hljs-comment">// (1）*iq就是他数组元素，size就是这个元素的长度，iqmax就是智商的上限</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> *cnt = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>( <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (IQMax+<span class="hljs-number">1</span>) ); <span class="hljs-comment">// (2)弄一个计数的数组，其最大值为iqmax+1，因为他要映射到数组的下标</span><br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (IQMax+<span class="hljs-number">1</span>));             <span class="hljs-comment">// (3)对他进行初始化赋值为0，后续进行操作</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>         ++cnt[ iq[i] ];                                 <span class="hljs-comment">// (4)//把iq的值赋给cnt的下标，后期对cnt进行遍历就可以了</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;                                          <span class="hljs-comment">// (5)</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="唯一元素的和"><a href="#唯一元素的和" class="headerlink" title="唯一元素的和"></a>唯一元素的和</h1><blockquote><p><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/" title="唯一元素的和">唯一元素的和</a></p><p>给你一个整数数组 <code>nums</code> 。数组中唯一元素是那些只出现 <strong>恰好一次</strong> 的元素。</p><p>请你返回 <code>nums</code> 中唯一元素的 <strong>和</strong> 。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,2,3,2]<br><strong>输出：</strong>4<br><strong>解释：</strong>唯一元素为 [1,3] ，和为 4 。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,1,1,1,1]<br><strong>输出：</strong>0<br><strong>解释：</strong>没有唯一元素，和为 0 。</p><p><strong>示例 3 ：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,2,3,4,5]<br><strong>输出：</strong>15<br><strong>解释：</strong>唯一元素为 [1,2,3,4,5] ，和为 15 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> sumOfUnique(<span class="hljs-built_in">int</span>* nums, <span class="hljs-built_in">int</span> numsSize)<br>&#123;<br><span class="hljs-built_in">int</span> cnt[<span class="hljs-number">101</span>];<span class="hljs-comment">//由于nums[i]的上限就是100，所以把他计数数组的下标定义的最大值为101，</span><br>memset(cnt,<span class="hljs-number">0</span>,sizeof(cnt));<span class="hljs-comment">//把他赋为0</span><br><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    ++cnt[nums[i]];<span class="hljs-comment">//对计数数组进行统计</span><br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">101</span>;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cnt[i]==<span class="hljs-number">1</span>)<span class="hljs-comment">//假如只出现一次，就把他的下标加起来</span><br>    &#123;<br>        <span class="hljs-keyword">sum</span>+=i;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a>找到所有数组中消失的数字</h1><blockquote><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" title="找到所有数组中消失的数字">找到所有数组中消失的数字</a></p><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums &#x3D; [4,3,2,7,8,2,3,1]<br><strong>输出：</strong>[5,6]</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,1]<br><strong>输出：</strong>[2]</p><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li></ul></blockquote><blockquote><p>有n个元素的数组原本里面的元素应该是1到n ，我们需要找到这其中没出现的元素</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">int</span>* find<span class="hljs-constructor">DisappearedNumbers(<span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">numsSize</span>, <span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">returnSize</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> cnt<span class="hljs-literal">[<span class="hljs-identifier">numsSize</span>+<span class="hljs-number">1</span>]</span>;<span class="hljs-comment">//定义计数数组，最大元素应当映射到n，所以就+1</span><br>memset(cnt,<span class="hljs-number">0</span>,sizeof(cnt));<span class="hljs-comment">//对他初始化为0，之后对计数数组填充后，找到那个出现次数为0的即可</span><br><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    cnt<span class="hljs-literal">[<span class="hljs-identifier">nums</span>[<span class="hljs-identifier">i</span>]</span>]++;<br>&#125;<br><span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;numsSize+<span class="hljs-number">1</span>;i++)<span class="hljs-comment">//因为i=0，0也只出现0次，但 题目要求我们是从1开始，所以i从1开始</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(cnt<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>==<span class="hljs-number">0</span>)<br>    &#123;<br>        j++;<span class="hljs-comment">//因为我们要malloc出来一个数组来接收那些只出现一次的元素，所以要计算那个数组里面有多少个元素</span><br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> *ret=(<span class="hljs-built_in">int</span> *)malloc(sizeof(<span class="hljs-built_in">int</span>)*j);<br><span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;numsSize+<span class="hljs-number">1</span>;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cnt<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>==<span class="hljs-number">0</span>)<br>    &#123;<br>        ret<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span>=i;<span class="hljs-comment">//把只出现过一次的赋给ret</span><br>    &#125;<br>&#125;<br>*returnSize=j;<br>return ret;<span class="hljs-comment">//返回那个元素的数组</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="好数对的数目"><a href="#好数对的数目" class="headerlink" title="好数对的数目"></a>好数对的数目</h1><blockquote><p><a href="https://leetcode-cn.com/problems/number-of-good-pairs/" title="好数对的数目">好数对的数目</a></p><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> &#x3D;&#x3D; <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p><p>返回好数对的数目。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,2,3,1,1,3]<br><strong>输出：</strong>4<br><strong>解释：</strong>有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,1,1,1]<br><strong>输出：</strong>6<br><strong>解释：</strong>数组中的每组数字都是好数对</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,2,3]<br><strong>输出：</strong>0</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><blockquote><p>假如一个元素出现3次，他的对数是3，加个元素出现4次，他的对数是6 ，那么我们就可以用一个计数数组来接收，假如他计数数组的值大于1，那么他的对数就是Cn2，</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> consist(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)//计数这个大于<span class="hljs-number">1</span>的数的对数<br>&#123;<br>    <span class="hljs-type">int</span> sum1=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum2=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum;<br><span class="hljs-type">int</span> i=n;<br><span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br>    sum1*=j;<br>&#125;<br><span class="hljs-keyword">while</span>(m<span class="hljs-comment">--)</span><br>&#123;<br>    sum2*=i;<br>    i<span class="hljs-comment">--;</span><br>&#125;<br>sum=sum2/sum1;<br><span class="hljs-keyword">return</span> sum;<br><br>&#125;<br><br><br><br><span class="hljs-type">int</span> numIdenticalPairs(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)<br>&#123;<br>    <span class="hljs-type">int</span> n=numsSize;<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">101</span>];<br>memset(cnt,<span class="hljs-number">0</span>,sizeof(cnt));<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>    ++cnt[nums[i]];<br><br>&#125;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">101</span>;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cnt[i]!=<span class="hljs-number">0</span>&amp;&amp;cnt[i]!=<span class="hljs-number">1</span>)<br>    &#123;<br>sum+=consist(cnt[i],<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="检查是否所有字符出现次数相同"><a href="#检查是否所有字符出现次数相同" class="headerlink" title="检查是否所有字符出现次数相同"></a>检查是否所有字符出现次数相同</h1><blockquote><p><a href="https://leetcode-cn.com/problems/check-if-all-characters-have-equal-number-of-occurrences/" title="检查是否所有字符出现次数相同">检查是否所有字符出现次数相同</a></p><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>好</strong> 字符串，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p><p>如果 <code>s</code> 中出现过的 <strong>所有</strong> 字符的出现次数 <strong>相同</strong> ，那么我们称字符串 <code>s</code> 是 <strong>好</strong> 字符串。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>s &#x3D; “abacbc”<br><strong>输出：</strong>true<br><strong>解释：</strong>s 中出现过的字符为 ‘a’，’b’ 和 ‘c’ 。s 中所有字符均出现 2 次。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>s &#x3D; “aaabb”<br><strong>输出：</strong>false<br><strong>解释：</strong>s 中出现过的字符为 ‘a’ 和 ‘b’ 。<br>‘a’ 出现了 3 次，’b’ 出现了 2 次，两者出现次数不同。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 只包含小写英文字母。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">areOccurrencesEqual</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>];<span class="hljs-comment">//因为里面每个元素都是小写字母</span><br><span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cnt));<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s);<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>&#123;<br>    ++cnt[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-comment">//-‘a’，假如‘a’-‘a’=0；，字母也就映射到了下标</span><br>&#125;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cnt[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]!=cnt[s[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>])<span class="hljs-comment">//出现的次数用s[i]来因数，假如前后对应出现的次数不相同就是错的，前后总能把所有元素进行比对完</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a>字符串中的第一个唯一字符</h1><blockquote><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" title="字符串中的第一个唯一字符">字符串中的第一个唯一字符</a></p><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例：</strong></p><p>s &#x3D; “leetcode”<br>返回 0</p><p>s &#x3D; “loveleetcode”<br>返回 2</p></blockquote><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">int</span> firstUniqChar(char * s)<br>&#123;<br>    <span class="hljs-keyword">int</span> len=<span class="hljs-keyword">strlen</span>(s)<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">cnt</span>[<span class="hljs-number">26</span>]<span class="hljs-comment">;</span><br><span class="hljs-keyword">memset</span>(<span class="hljs-keyword">cnt</span>,<span class="hljs-number">0</span>,sizeof(<span class="hljs-keyword">cnt</span>))<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;len;i++)</span><br>&#123;<br>    ++<span class="hljs-keyword">cnt</span>[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;len;i++)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">cnt</span>[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> i<span class="hljs-comment">;//遇到第一个只出现一次的就返回</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><span class="hljs-comment">;//循环的都没找到就返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法 链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2021/11/25/%E6%A0%88/"/>
    <url>/2021/11/25/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>栈：一种特殊的线性表，其只允许在固定的一段进行插入和删除元素，进行插入和删除元素的一端叫做栈顶，另一端叫做栈底，栈中的元素遵守着先进后出的原则</p></blockquote><blockquote><p> stack.h</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> stdata;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>stdata* a;<span class="hljs-comment">//动态开辟</span><br><span class="hljs-comment">//如果使用stdata a[max],就相当于一个静态表，不够灵活</span><br><span class="hljs-type">int</span> top;<span class="hljs-comment">//栈顶</span><br><span class="hljs-type">int</span> capacity;<span class="hljs-comment">//记录容量</span><br>&#125;st;<br><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stackinit</span><span class="hljs-params">(st *ps)</span></span>;<br><span class="hljs-comment">//销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stackdestroy</span><span class="hljs-params">(st*ps)</span></span>;<br><br><span class="hljs-comment">//对容量进行检查</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stackcheckcapacity</span><span class="hljs-params">(st*ps)</span></span>;<br><br><span class="hljs-comment">//插入,因为所有的操作都是在栈顶进行操作,所以就不用区分是尾插还是头插</span><br><span class="hljs-comment">//入栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stackpush</span><span class="hljs-params">(st*ps,stdata x)</span></span>;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-comment">//出栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stackpop</span><span class="hljs-params">(st *ps)</span></span>;<br><span class="hljs-comment">//返回栈顶的元素</span><br><span class="hljs-function">stdata <span class="hljs-title">stacktop</span><span class="hljs-params">(st*ps)</span></span>;<br><span class="hljs-comment">//栈里面元素的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stacksize</span><span class="hljs-params">(st *ps)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">stackempty</span><span class="hljs-params">(st*ps)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p> stack.c</p></blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs xl">#define _CRT_SECURE_NO_WARNINGS <span class="hljs-number">1</span><br>#include<span class="hljs-string">&quot;stack.h&quot;</span><br><br><br><span class="hljs-comment">//初始化</span><br>void stackinit(st *ps)<br>&#123;<br>assert(ps);<span class="hljs-comment">//我们初始化一个指针，他肯定不能是空的</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a = malloc(sizeof(stdata)*<span class="hljs-number">4</span>);<span class="hljs-comment">//一开始初始化的时候可以就给a一定的空间，方便后面使用，假如一开始是空的话，还有进行判断比较麻烦</span><br><span class="hljs-comment">//malloc完都要进行判断检查</span><br><span class="hljs-function"><span class="hljs-title">if</span> (ps-&gt;</span>a == NULL)<br>&#123;<br>perror(<span class="hljs-string">&quot;malllc&quot;</span>);<br>return;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>capacity = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>top=<span class="hljs-number">0</span>;<span class="hljs-comment">//top从头开始，指向最后一个数据</span><br><span class="hljs-comment">//假如一开始把top置为0，在push的时候，就把top索引赋值，再把top进行加加</span><br>&#125;<br><br>void stackcheckcapacity(st*ps)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (ps-&gt;</span><span class="hljs-function"><span class="hljs-title">top</span> == ps-&gt;</span>capacity)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">int</span> newcapacity = ps-&gt;</span><span class="hljs-function"><span class="hljs-title">capacity</span> == 0 ? 4 : 2 * ps-&gt;</span>capacity;<br><span class="hljs-comment">//增容是对数组进行，所以不可以使用结构体</span><br><span class="hljs-function"><span class="hljs-title">stdata</span>*tmp = (stdata*)realloc(ps-&gt;</span>a, sizeof(st)*newcapacity * <span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (tmp == NULL)<br>&#123;<br>perror(<span class="hljs-string">&quot;realllc&quot;</span>);<br>return;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a = tmp;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>capacity = newcapacity;<br>&#125;<br>&#125; <br>&#125;<br><br><br><br>void stackpush(st*ps,stdata x)<br>&#123;<br>stackcheckcapacity(ps);<br><span class="hljs-comment">//同样我们也要对容量进行检查</span><br>assert(ps);<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[ps-&gt;</span>top] = x;<span class="hljs-comment">//top一开始是0，所以是从0开始加</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>top++;<span class="hljs-comment">//++后top都是指向最后一个元素的后一个位置</span><br>&#125;<br><br><span class="hljs-comment">//删除</span><br>void stackpop(st*ps)<br>&#123;<br>assert(ps);<br><span class="hljs-comment">//如果栈空了，调用pop就直接报错，直接终止</span><br><span class="hljs-function"><span class="hljs-title">assert</span>(ps-&gt;</span>top &gt; <span class="hljs-number">0</span>);<br><span class="hljs-comment">//直接把top--一下就可以了</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>top--;<br><span class="hljs-comment">//这时候top就指向前一元素</span><br>&#125;<br><br><span class="hljs-comment">//销毁</span><br>void stackdestroy(st*ps)<br>&#123;<br><span class="hljs-comment">//也要对他进行一个断言</span><br>assert(ps);<br><span class="hljs-function"><span class="hljs-title">free</span>(ps-&gt;</span>a);<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a = NULL;<br><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">top</span>=ps-&gt;</span>capacity = <span class="hljs-number">0</span>;<br><br>&#125;<br><span class="hljs-comment">//返回栈顶的元素</span><br>stdata stacktop(st*ps)<br>&#123;<br>assert(ps);<br><span class="hljs-function"><span class="hljs-title">assert</span>(ps-&gt;</span>top &gt; <span class="hljs-number">0</span>);<br><span class="hljs-comment">//假如说top在0的位置，也就是第一个位置，减一就是错误的</span><br><span class="hljs-comment">//由于top是指向栈顶的下一个元素，那么返回栈顶,就是top的前一个</span><br><span class="hljs-function"><span class="hljs-title">return</span> ps-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[ps-&gt;</span>top - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">//记录栈里面一共有多少个元素</span><br>int stacksize(st*ps)<br>&#123;<br>assert(ps);<span class="hljs-comment">//我们也要对栈进行断言，不可以为空</span><br><span class="hljs-function"><span class="hljs-title">return</span> ps-&gt;</span>top;<span class="hljs-comment">//由于top是从0开始的，所以他指向的是最后一个元素的下一个，而top的值也就是元素的个数</span><br>&#125;<br><br><span class="hljs-comment">//判断栈是否为空</span><br>bool stackempty(st*ps)<br>&#123;<br>assert(ps);<br><span class="hljs-function"><span class="hljs-title">return</span> ps-&gt;</span>top == <span class="hljs-number">0</span>;<span class="hljs-comment">//因为我们一开始设置的top是为0.所以当top值为0的时候，他就是空的，</span><br>                    <span class="hljs-comment">//假如top一开始设定的是-1，那么当top为-1时他就是空的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>test.c</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> _CRT_SECURE_NO_WARNINGS <span class="hljs-number">1</span><br><span class="hljs-selector-id">#include</span>&quot;stack<span class="hljs-selector-class">.h</span>&quot;<br>int <span class="hljs-selector-tag">main</span>()<br>&#123;<br>st stack;<br><span class="hljs-built_in">stackinit</span>(&amp;stack);<br><span class="hljs-built_in">stackpush</span>(&amp;stack, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">stackpush</span>(&amp;stack, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">stackpush</span>(&amp;stack, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">stackpush</span>(&amp;stack, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">stackpush</span>(&amp;stack, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">stackpush</span>(&amp;stack, <span class="hljs-number">6</span>);<br><span class="hljs-comment">//因为栈是先进后出，所以每次出的都是从栈顶出来</span><br>while (!stackempty(&amp;stack))<br>&#123;<br><span class="hljs-built_in">printf</span>(&quot;%d &quot;, stacktop(&amp;stack));<br><span class="hljs-comment">//打印完一个，就出一个</span><br><span class="hljs-built_in">stackpop</span>(&amp;stack);<br><br>&#125;<br><span class="hljs-built_in">stackdestroy</span>(&amp;stack);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划 算法 排序算法 数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形链表</title>
    <link href="/2021/11/25/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/11/25/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%C2%A0%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" title=" 环形链表"> 环形链表</a></p><p><a href="#%E2%80%98%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82" title="‘环形链表2">‘环形链表2</a></p><hr><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><blockquote><p> </p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6afd2de8b1b0edaa7be926d674f0135b.png"></p><p><strong>输入：</strong>head &#x3D; [3,2,0,-4], pos &#x3D; 1<br><strong>输出：</strong>true<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p><p><strong>示例 2：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/76d22e9d59c83d78a7b3b6fba397dac6.png"></p><p><strong>输入：</strong>head &#x3D; [1,2], pos &#x3D; 0<br><strong>输出：</strong>true<br><strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</p><p><strong>示例 3：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/46089240455f4acd580687181f3f8f43.png"></p><p><strong>输入：</strong>head &#x3D; [1], pos &#x3D; -1<br><strong>输出：</strong>false<br><strong>解释：</strong>链表中没有环。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul></blockquote><blockquote><p>1.slow一次走一步，fast一次走两步，假如说slow和fast间的距离是n</p><p>每走一次，就变成n-1，每次走一步都减一，到最后一定会追上的</p><p>2.假如说slow一次走一步，fast一次走三步，假如说slow和fast间的距离是n</p><p>，每走一步，就变成n-2，如果n为偶数，一定会追及，如果n为奇数，最后是-1</p><p>，fast就反超了slow，假设环的长度为c，这现在两者间的距离为c-1，同理假设c-1为偶数就会追上，为奇数就不会追上</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f93d5412873d478287d8b2afbeccc415.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_ invoke__">hasCycle</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> *head) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>*slow=head;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>*fast=head;<br><span class="hljs-title function_ invoke__">while</span>(fast&amp;&amp;fast<span class="hljs-punctuation">-&gt;</span>next)<span class="hljs-comment">//同中间节点一样</span><br>&#123;<br>    fast=fast<span class="hljs-punctuation">-&gt;</span>next<span class="hljs-punctuation">-&gt;</span>next;<br>    slow=slow<span class="hljs-punctuation">-&gt;</span>next;<br>    <span class="hljs-title function_ invoke__">if</span>(fast==slow)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="环形链表-2"><a href="#环形链表-2" class="headerlink" title=".环形链表 2"></a>.环形链表 2</h1><blockquote><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" title="环形链表 II">环形链表 II</a></p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c010a3dc6e112b8105462312e52ec237.png"></p><p><strong>输入：</strong>head &#x3D; [3,2,0,-4], pos &#x3D; 1<br><strong>输出：</strong>返回索引为 1 的链表节点<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p><p><strong>示例 2：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f340baa076dcffcd5dd05175f468a2b.png"></p><p><strong>输入：</strong>head &#x3D; [1,2], pos &#x3D; 0<br><strong>输出：</strong>返回索引为 0 的链表节点<br><strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</p><p><strong>示例 3：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a4c4ff526dd1eb9edcb168fc929c0ed0.png"></p><p><strong>输入：</strong>head &#x3D; [1], pos &#x3D; -1<br><strong>输出：</strong>返回 null<br><strong>解释：</strong>链表中没有环。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/0cad5b67f7e547858728fc319a1d0dd4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> </p><p> </p><p> </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> * struct ListNode &#123;<br> *     int val;<br> *     struct ListNode *next;<br> * &#125;;<br> */<br>struct ListNode <span class="hljs-number">*de</span>tectCycle(struct ListNode *head) &#123;<br>    struct ListNode*<span class="hljs-attribute">slow</span>=head;<br>    struct ListNode<span class="hljs-number">*fa</span><span class="hljs-attribute">st</span>=head;<br>    struct ListNode*<span class="hljs-attribute">mid</span>=<span class="hljs-literal">NULL</span>;<br>    struct ListNode*<span class="hljs-attribute">init</span>=head;<br>    <span class="hljs-keyword">while</span>(fast&amp;&amp;fast-&gt;next)<br>    &#123;<br>        <span class="hljs-attribute">fast</span>=fast-&gt;next-&gt;next;<br>        <span class="hljs-attribute">slow</span>=slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">fast</span>==slow)<br>        &#123;<br>            <span class="hljs-attribute">mid</span>=fast;//mid在环里面，而init在环外面，相遇的节点就是进入的节点<br>            <span class="hljs-keyword">while</span>(mid!=init)<br>            &#123;<br>                <span class="hljs-attribute">mid</span>=mid-&gt;next;<br>                <span class="hljs-attribute">init</span>=init-&gt;next;<br> <br>            &#125;<br>            return mid;<br>        &#125;<br>    &#125;<br>    <br>    return <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构 链表 数据结构 leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序表力扣题</title>
    <link href="/2021/11/25/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8A%9B%E6%89%A3%E9%A2%98/"/>
    <url>/2021/11/25/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8A%9B%E6%89%A3%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%C2%A0" title="移除元素 ">移除元素 </a></p><p><a href="#%C2%A0%E6%B3%95%E4%B8%80%EF%BC%8C%E6%9A%B4%E5%8A%9B%E8%A6%86%E7%9B%96" title=" 法一，暴力覆盖"> 法一，暴力覆盖</a></p><p><a href="#%E6%B3%95%E4%BA%8C%EF%BC%8C%E6%95%B0%E7%BB%84%E6%8E%A5%E6%94%B6" title="法二，数组接收">法二，数组接收</a></p><p><a href="#%C2%A0%E6%B3%953%E5%8F%8C%E6%8C%87%E9%92%88%E5%88%A4%E6%96%AD" title=" 法3双指针判断"> 法3双指针判断</a></p><p><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84" title="合并两个有序数组">合并两个有序数组</a></p><p><a href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%C2%A0" title="移除元素 ">移除元素 </a></p><p><a href="#%C2%A0%E6%B3%95%E4%B8%80%EF%BC%8C%E6%9A%B4%E5%8A%9B%E8%A6%86%E7%9B%96" title=" 法一，暴力覆盖"> 法一，暴力覆盖</a></p><hr><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><blockquote><p>给你一个数组 <code>nums</code>和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="原地">原地</a></strong> 移除所有数值等于 <code>val</code>的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="原地 ">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>&#x2F;&#x2F; <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len &#x3D; removeElement(nums, val);</p><p>&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 <strong>该长度范围内</strong> 的所有元素。<br>for (int i &#x3D; 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums &#x3D; [3,2,2,3], val &#x3D; 3<br><strong>输出：</strong>2, nums &#x3D; [2,2]<br><strong>解释：</strong>函数应该返回新的长度 <strong>2</strong>, 并且 nums  中的前两个元素均为 <strong>2</strong>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br><strong>输出：</strong>5, nums &#x3D; [0,1,4,0,3]<br><strong>解释：</strong>函数应该返回新的长度 <strong><code>5</code></strong>, 并且 nums 中的前五个元素为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>3</code></strong>, <strong><code>0</code></strong>, <strong>4</strong>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><p>通过次数519,054提交次数870,623</p></blockquote><blockquote><p>暴力题解，时间复杂度是O（n2）</p></blockquote><h2 id="法一，暴力覆盖"><a href="#法一，暴力覆盖" class="headerlink" title="法一，暴力覆盖"></a>法一，暴力覆盖</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">numsSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span>&#123;<br><span class="hljs-built_in">int</span> len=numsSize;<br><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>==<span class="hljs-keyword">val</span>)/当nums的元素和<span class="hljs-keyword">val</span>一致时<br>    &#123;<br>        <br>        <span class="hljs-built_in">int</span> start=i+<span class="hljs-number">1</span>;/把这个元素消掉，就把这个元素给覆盖掉<br>        <span class="hljs-keyword">while</span>(start&lt;numsSize)<span class="hljs-comment">//当start的值到numssize时就停止</span><br>        &#123;<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">start</span>-<span class="hljs-number">1</span>]</span>=nums<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>;<span class="hljs-comment">//前一个的值等于后一个的值</span><br>            start++;<br>        &#125;<br>        len--;<span class="hljs-comment">//每执行一次，就把len--，最终返回的就是len的值</span><br>    &#125;<br>&#125;<br>return len;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="法二，数组接收"><a href="#法二，数组接收" class="headerlink" title="法二，数组接收"></a>法二，数组接收</h2><blockquote><p>用一个新的数组来接收，当nums值不等于val的时候，nums的值赋给那个新的数组，同时新的数组的下标再自增 ，最后的返回的长度就是用一个count来计数，返回count</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">numsSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> arr<span class="hljs-literal">[<span class="hljs-identifier">numsSize</span>+<span class="hljs-number">1</span>]</span>;<span class="hljs-comment">//我们一开始要把arr的长度赋为numssize+1，因为假如说nums为空，也就是说numssize的值为0，arr就是一个无长度的数组，是错误的</span><br>    memset(arr,<span class="hljs-number">0</span>,sizeof(arr));<br>    <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>!=<span class="hljs-keyword">val</span>)<span class="hljs-comment">//当nums里面的值和val不一样时，就把nums的值赋给arr来接收</span><br>        &#123;<br>            arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>=nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>            j++;<br>            count++;<span class="hljs-comment">//同时count++，最终返回count</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;count;i++)<br>    &#123;<br>        nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<span class="hljs-comment">//最后在把arr的值赋给nums，因为要返回的是nums</span><br>    &#125;<br>    return count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="法3双指针判断"><a href="#法3双指针判断" class="headerlink" title="法3双指针判断"></a>法3双指针判断</h2><p><img src="https://img-blog.csdnimg.cn/fc7bc490e32448839f41276d143ca6b3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><blockquote></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">numsSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br><span class="hljs-built_in">int</span> src=<span class="hljs-number">0</span>,dst=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">src</span>]</span>!=<span class="hljs-keyword">val</span>)<br>    &#123;<br>        nums<span class="hljs-literal">[<span class="hljs-identifier">dst</span>]</span>=nums<span class="hljs-literal">[<span class="hljs-identifier">src</span>]</span>;<br>        dst++;<br>        src++;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        src++;<br>    &#125;<br>&#125;<br>return dst;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><blockquote><p> </p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code>  和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code>  到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br><strong>输出：</strong>[1,2,2,3,5,6]<br><strong>解释：</strong>需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,<em><strong>3</strong></em>,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br><strong>输出：</strong>[1]<br><strong>解释：</strong>需要合并 [1] 和 [] 。<br>合并结果是 [1] 。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br><strong>输出：</strong>[1]<br><strong>解释：</strong>需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/8d2d254d5f3540de8e799a62887649ea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> merge(<span class="hljs-type">int</span>* nums1, <span class="hljs-type">int</span> nums1Size, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>* nums2, <span class="hljs-type">int</span> nums2Size, <span class="hljs-type">int</span> n)&#123;<br><br><span class="hljs-type">int</span> end=m+n<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> end1=m<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> end2=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(end1&gt;=<span class="hljs-number">0</span>&amp;&amp;end2&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(nums1[end1]&gt;nums2[end2])<br>    &#123;<br>        nums1[<span class="hljs-keyword">end</span>]=nums1[end1];<br>        end1<span class="hljs-comment">--;</span><br>        <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        nums1[<span class="hljs-keyword">end</span>]=nums2[end2];<br>        end2<span class="hljs-comment">--;</span><br>        <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(end2&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>    nums1[<span class="hljs-keyword">end</span>]=nums2[end2];<br>        end2<span class="hljs-comment">--;</span><br>        <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构 链表 数据结构 leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序表</title>
    <link href="/2021/11/21/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <url>/2021/11/21/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>静态顺序表</p><p>test.c</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//顺序表是物理地址连续的存储单元，一次存储数据元素的线性结构，在数组上实现数据增删查改</span><br><span class="hljs-comment">//顺序表一般可以分为</span><br><span class="hljs-comment">//1.静态的顺序表：使用定长数组存储</span><br><span class="hljs-comment">//2.动态的顺序表，使用动态开辟的数组进行存储</span><br><br><span class="hljs-comment">//1.连续的物理空间存储——数组</span><br><span class="hljs-comment">//2.数据必须是从头开始，依次存储，一个一个存</span><br><br><span class="hljs-comment">//静态的顺序表，给少了不够用，够多了浪费，不能灵活利用</span><br><span class="hljs-selector-id">#include</span>&quot;seqlist<span class="hljs-selector-class">.h</span>&quot;<br><br>void <span class="hljs-built_in">testseqlist</span>()<br>&#123;<br>SL s;<br><span class="hljs-built_in">seqlistinit</span>(&amp;s);<span class="hljs-comment">//要把实参的地址传给形参</span><br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">11</span>);<br><br>&#125;<br>int <span class="hljs-selector-tag">main</span>()<br>&#123;<br><span class="hljs-built_in">testseqlist</span>();<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>seqlist.c</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">#include<span class="hljs-string">&quot;seqlist.h&quot;</span><br>void seqlistinit(SL* ps)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">memset</span>(ps-&gt;</span>a, <span class="hljs-number">0</span>, sizeof(seqdata)*n);<span class="hljs-comment">//对数组初始化为0</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz = <span class="hljs-number">0</span>;<br>&#125;<br><br>void seqlistpushback(SL*ps, seqdata x)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (ps-&gt;</span>sz &gt;= n)<br>&#123;<br>printf(<span class="hljs-string">&quot;seqlist is full\n&quot;</span>);<br>return;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[ps-&gt;</span>sz] = x;<span class="hljs-comment">//尾插在sz下一个位置的下标</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz++;<br><span class="hljs-comment">//sz可能会超过数组的最大范围，会越界</span><br>&#125;<br></code></pre></td></tr></table></figure><p>seqlist.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> n 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> seqdata;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">seqlist</span><br>&#123;<br>seqdata a[n];<br><span class="hljs-type">int</span> sz;<br>&#125;SL;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testseqlist</span><span class="hljs-params">()</span></span>;<br><br><br><span class="hljs-comment">//初始化一个数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistinit</span><span class="hljs-params">(SL* ps)</span></span>;<br><br><span class="hljs-comment">//尾插</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistpushback</span><span class="hljs-params">(SL*ps, seqdata x)</span></span>;<br></code></pre></td></tr></table></figure><p>动态版顺序表</p><p><img src="https://img-blog.csdnimg.cn/1e929af5f87846c7b12430459ce08f5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> <img src="https://img-blog.csdnimg.cn/3e796fe61a754bdab33e810604b0cf0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>seqlist.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> n 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> seqdata;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">seqlist</span><br>&#123;<br>seqdata *a;<span class="hljs-comment">//指向动态开辟的数组</span><br><span class="hljs-type">int</span> sz;<span class="hljs-comment">//有效数据的个数</span><br><span class="hljs-type">int</span> capacity;<span class="hljs-comment">//记录容量</span><br>&#125;SL;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testseqlist</span><span class="hljs-params">()</span></span>;<br><br><br><span class="hljs-comment">//初始化一个数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistinit</span><span class="hljs-params">(SL* ps)</span></span>;<br><br><span class="hljs-comment">//尾插</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistpushback</span><span class="hljs-params">(SL*ps, seqdata x)</span></span>;<br><br><span class="hljs-comment">//打印</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistprint</span><span class="hljs-params">(SL*ps)</span></span>;<br><br><span class="hljs-comment">//头插</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistpushfront</span><span class="hljs-params">(SL *ps, seqdata x)</span></span>;<br><span class="hljs-comment">//检查容量是否充足</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistcheckcapacity</span><span class="hljs-params">(SL*ps)</span></span>;<br><br><span class="hljs-comment">//尾删</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistpopback</span><span class="hljs-params">(SL*ps)</span></span>;<br><br><span class="hljs-comment">//头删</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistpopfront</span><span class="hljs-params">(SL*ps)</span></span>;<br><br><span class="hljs-comment">//中间插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistinsert</span><span class="hljs-params">(SL*ps, <span class="hljs-type">int</span> pos, seqdata x)</span></span>;<br><br><span class="hljs-comment">//中间删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlisterase</span><span class="hljs-params">(SL*ps, <span class="hljs-type">int</span> pos)</span></span>;<br><br><span class="hljs-comment">//销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistdestroy</span><span class="hljs-params">(SL*ps)</span></span>;<br><br><span class="hljs-comment">//查</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistfind</span><span class="hljs-params">(SL *ps, seqdata x)</span></span>;<br><br><span class="hljs-comment">//修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqlistmodify</span><span class="hljs-params">(SL *ps,<span class="hljs-type">int</span> pos, seqdata x)</span></span>;<br></code></pre></td></tr></table></figure><p>seqlist.c</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs xl">#include<span class="hljs-string">&quot;seqlist.h&quot;</span><br>void seqlistinit(SL* ps)<span class="hljs-comment">//对顺序表进行初始化</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a = NULL;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>capacity = <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//尾插</span><br>void seqlistpushback(SL*ps, seqdata x)<br>&#123;<br>seqlistcheckcapacity(ps);<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[ps-&gt;</span>sz] = x;<span class="hljs-comment">//尾插在sz下一个位置的下标</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz++;<br><span class="hljs-comment">//sz可能会超过数组的最大范围，会越界</span><br>&#125;<br><br><br><span class="hljs-comment">//打印</span><br>void seqlistprint(SL*ps)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">for</span> (int i = 0; i &lt; ps-&gt;</span>sz; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%d &quot;, ps-&gt;</span>a[i]);<br>&#125;<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//头插</span><br>void seqlistpushfront(SL *ps, seqdata x)<span class="hljs-comment">//同样面临一个增容的问题，但每次都写增容的代码很麻烦，所以我们可以写一个</span><br>&#123;<br>seqlistcheckcapacity(ps);<br><span class="hljs-function"><span class="hljs-title">int</span> end = ps-&gt;</span>sz - <span class="hljs-number">1</span>;<br><span class="hljs-comment">//循环while的写法</span><br><span class="hljs-comment">//1.初始条件</span><br><span class="hljs-comment">//2.结束条件</span><br><span class="hljs-comment">//3.迭代过程</span><br><span class="hljs-comment">//头插就是每一位都往后挪,第一个位置空了出来</span><br><br><span class="hljs-keyword">while</span> (end &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//我们想的结束的条件，而循环写的是继续的条件</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[end + 1] = ps-&gt;</span>a[end];<br>end--;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a[<span class="hljs-number">0</span>] = x;<span class="hljs-comment">//把第一个元素插入</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz++;<br><br>&#125;<br><br><span class="hljs-comment">//搞出一个函数原来检查容量是否充足，如果不足就要增容</span><br>void seqlistcheckcapacity(SL*ps)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (ps-&gt;</span><span class="hljs-function"><span class="hljs-title">sz</span> == ps-&gt;</span>capacity)<span class="hljs-comment">//有效数据对于最大容量，那么我们就要进行扩容</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">int</span> newcapacity = ps-&gt;</span><span class="hljs-function"><span class="hljs-title">capacity</span> == 0 ? 4 : ps-&gt;</span>capacity * <span class="hljs-number">2</span>;<span class="hljs-comment">//一开始sz为0，capacity也为0，所以当等于时有两种情况，</span><br><span class="hljs-comment">//1.为开辟空间</span><br><span class="hljs-comment">//2.sz到达了capabilities的容量</span><br><span class="hljs-comment">//如果一开始的capaci的初值为0，就把capacity改为4，否则就把他扩容两倍</span><br><span class="hljs-comment">//我们一般扩2倍，扩一倍浪费时间，扩3倍浪费空间</span><br><span class="hljs-function"><span class="hljs-title">seqdata</span> *tmp = (seqdata*)realloc(ps-&gt;</span>a, newcapacity * <span class="hljs-number">2</span> * sizeof(seqdata));<br><span class="hljs-keyword">if</span> (tmp == NULL)<br>&#123;<br>printf(<span class="hljs-string">&quot;realloc failur&quot;</span>);<br>return;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a = tmp;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>capacity = newcapacity;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//尾删</span><br>void seqlistpopback(SL*ps)<br>&#123;<br><span class="hljs-comment">//假如说sz为0就不用删除了</span><br><span class="hljs-comment">//但是如果想用粗暴的方法</span><br><span class="hljs-comment">//断言，如果大于0就继续删除，等于0的化就会报错</span><br><span class="hljs-function"><span class="hljs-title">assert</span>(ps-&gt;</span>sz&gt;<span class="hljs-number">0</span>);<br><span class="hljs-comment">//由sz来标识有多少个有效数据</span><br><span class="hljs-comment">//直接把sz--，把有效数据减少就行了</span><br><span class="hljs-comment">//如果我们把最后一个数据置为0，再sz--，不合适，因为可能最后一个元素本来就是一个0，或者他并不是int类型，是一个double类型的变量</span><br><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz--;<br>&#125;<br><span class="hljs-comment">//头删</span><br>void seqlistpopfront(SL*ps)<br>&#123;<br><span class="hljs-comment">//同时也要预防头没有数据了</span><br><span class="hljs-function"><span class="hljs-title">assert</span>(ps-&gt;</span>sz &gt; <span class="hljs-number">0</span>);<br>int start = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//前一个都用后一个来覆盖</span><br><span class="hljs-function"><span class="hljs-title">while</span> (start &lt; ps-&gt;</span>sz)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[start - 1] = ps-&gt;</span>a[start];<span class="hljs-comment">//start下标最多到sz-1的位置</span><br>start++;<br>&#125;<br><span class="hljs-comment">//头部数据删除完之后</span><br><span class="hljs-comment">//同样sz也要减</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz--;<br>&#125;<br><br>void seqlistinsert(SL*ps, int pos, seqdata x)<br>&#123;<br><span class="hljs-comment">//pos只能再sz有效数据里面进行选择</span><br><span class="hljs-function"><span class="hljs-title">assert</span>(pos &lt; ps-&gt;</span>sz);<br>seqlistcheckcapacity(ps);<br><span class="hljs-function"><span class="hljs-title">int</span> end = ps-&gt;</span>sz - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (end&gt;=pos)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[end + 1] = ps-&gt;</span>a[end];<br>end--;<br>&#125;<br><span class="hljs-comment">//直到end挪到小于pos就终止了</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a[pos] = x;<span class="hljs-comment">//pos是数组的下标</span><br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz++;<br>&#125;<br><br>void seqlisterase(SL*ps, int pos)<br>&#123;<br><span class="hljs-comment">//一次把后面的数据往前挪</span><br><span class="hljs-comment">//把pos的位置给覆盖掉</span><br><span class="hljs-function"><span class="hljs-title">assert</span>(pos &lt; ps-&gt;</span>sz);<br>int start = pos + <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-title">while</span> (start &lt; ps-&gt;</span>sz)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">a</span>[start-1] = ps-&gt;</span>a[start];<br>start++;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>sz--;<br>&#125;<br><br><br>void seqlistdestroy(SL*ps)<span class="hljs-comment">//malloc出来的空间不销毁就会内存泄露</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">free</span>(ps-&gt;</span>a);<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a = NULL;<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sz</span> = ps-&gt;</span>capacity = <span class="hljs-number">0</span>;<br>&#125;<br><br>void seqlistfind(SL *ps, seqdata x)<span class="hljs-comment">//如果有序的化就可以使用二分查找</span><br>&#123;<br><span class="hljs-comment">//假如是有序的化，就可以用二分查找，但他并不是有序的</span><br><span class="hljs-comment">//那么我们就用暴力解法</span><br>int i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; ps-&gt;</span>sz; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (ps-&gt;</span>a[i] == x)<br>&#123;<br>return i;<span class="hljs-comment">//返回x的下标</span><br>&#125;<br>&#125;<br>return -<span class="hljs-number">1</span>;<span class="hljs-comment">//如果找到的化就返回下标，每找到就返回-1，因为数组里面的下标不可能是-1</span><br>&#125;<br><br>void seqlistmodify(SL *ps, int pos, seqdata x)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">assert</span>(pos &lt; ps-&gt;</span>sz);<br><span class="hljs-function"><span class="hljs-title">ps</span>-&gt;</span>a[pos] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p> test.c</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//顺序表是物理地址连续的存储单元，一次存储数据元素的线性结构，在数组上实现数据增删查改</span><br><span class="hljs-comment">//顺序表一般可以分为</span><br><span class="hljs-comment">//1.静态的顺序表：使用定长数组存储</span><br><span class="hljs-comment">//2.动态的顺序表，使用动态开辟的数组进行存储</span><br><br><span class="hljs-comment">//1.连续的物理空间存储——数组</span><br><span class="hljs-comment">//2.数据必须是从头开始，依次存储，一个一个存</span><br><br><span class="hljs-comment">//静态的顺序表，给少了不够用，够多了浪费，不能灵活利用</span><br><span class="hljs-selector-id">#include</span>&quot;seqlist<span class="hljs-selector-class">.h</span>&quot;<br><br>void <span class="hljs-built_in">testseqlist</span>()<br>&#123;<br>SL s;<br><span class="hljs-built_in">seqlistinit</span>(&amp;s);<span class="hljs-comment">//要把实参的地址传给形参</span><br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">5</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">7</span>);   <br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">8</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">seqlistpushback</span>(&amp;s, <span class="hljs-number">11</span>);<br><span class="hljs-built_in">seqlistpushfront</span>(&amp;s, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">seqlistpushfront</span>(&amp;s, -<span class="hljs-number">1</span>);<br><span class="hljs-built_in">seqlistpopfront</span>(&amp;s);<br><span class="hljs-built_in">seqlistpopback</span>(&amp;s);<br><span class="hljs-built_in">seqlistinsert</span>(&amp;s, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">//0数组的下标</span><br><span class="hljs-built_in">seqlisterase</span>(&amp;s, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">seqlistprint</span>(&amp;s);<br><span class="hljs-built_in">seqlistdestroy</span>(&amp;s);<br><br>&#125;<br>int <span class="hljs-selector-tag">main</span>()<br>&#123;<br><span class="hljs-built_in">testseqlist</span>();<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>随后我会上传一些顺序表的oj</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法 链表 数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存函数</title>
    <link href="/2021/11/20/%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0/"/>
    <url>/2021/11/20/%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>memmove可以处理内存重叠的问题，<br>memcpy不可以处理内存重叠的问题，<br>memcmp比较内存的大小<br>memset,<br>int main()<br>{<!-- --><br>    int arr[10] &#x3D; { 1,2,3,4,5,6,7,8,9,10 };<br>    &#x2F;&#x2F;              1,2,1,2,3,4,5,8,9,10<br>    int arr1[10] &#x3D; { 0 };<br>    memcpy(arr1, arr, 20);<br>    memmove(arr + 2, arr, 20);<br>    float arr2[] &#x3D; { 1.0,2.0,3.0,4.0,5.0 };<br>    float arr3[] &#x3D; { 1.0,3.0 };<br>    int ret &#x3D; memcmp(arr2, arr3, 8);&#x2F;&#x2F;只比较前4个字节，和strcmp的返回值是一样的，<br>    int a[10] &#x3D; { 0 };&#x2F;&#x2F;把a的前20个字节全部设置成1,一个int是，设置的是字节，而不是数，是以字节为单位来设置内存<br>    memset(a, 1, 20);<br>    return 0;<br>}</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法 链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟着英雄学算法--矩阵</title>
    <link href="/2021/11/20/%E8%B7%9F%E7%9D%80%E8%8B%B1%E9%9B%84%E5%AD%A6%E7%AE%97%E6%B3%95--%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/11/20/%E8%B7%9F%E7%9D%80%E8%8B%B1%E9%9B%84%E5%AD%A6%E7%AE%97%E6%B3%95--%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.%E5%8A%9B%E6%89%A3%E9%A2%98%E5%88%86%E6%9E%90" title="1.力扣题分析">1.力扣题分析</a></p><p><a href="#2.%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F" title="2.最富有客户的资产总量">2.最富有客户的资产总量</a></p><p><a href="#3.%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5%C2%A0" title="3.转置矩阵 ">3.转置矩阵 </a></p><p><a href="#4.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F" title="4.旋转图像">4.旋转图像</a></p><p><a href="#5.%E5%9B%9E%E6%97%8B%E7%9F%A9%E9%98%B5%EF%BC%88%E6%96%B9%E9%98%B5%EF%BC%89" title="5.回旋矩阵（方阵）">5.回旋矩阵（方阵）</a></p><hr><h1 id="矩阵力扣题讲解"><a href="#矩阵力扣题讲解" class="headerlink" title="矩阵力扣题讲解"></a>矩阵力扣题讲解</h1><blockquote><p>二进制二维数组image水平反转在取反</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span>** flip<span class="hljs-constructor">AndInvertImage(<span class="hljs-params">int</span><span class="hljs-operator">**</span> <span class="hljs-params">image</span>, <span class="hljs-params">int</span> <span class="hljs-params">imageSize</span>, <span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">imageColSize</span>, <span class="hljs-params">int</span><span class="hljs-operator">*</span> <span class="hljs-params">returnSize</span>, <span class="hljs-params">int</span><span class="hljs-operator">**</span> <span class="hljs-params">returnColumnSizes</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> i, j, col;<br>    <span class="hljs-built_in">int</span> **ret = (<span class="hljs-built_in">int</span> **)malloc( sizeof(<span class="hljs-built_in">int</span> *)<span class="hljs-operator"> * </span>imageSize );        <span class="hljs-comment">// (1)</span><br>    *returnColumnSizes = (<span class="hljs-built_in">int</span> *)malloc( sizeof(<span class="hljs-built_in">int</span>)<span class="hljs-operator"> * </span>imageSize );  <span class="hljs-comment">// (2)</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; imageSize; ++i) &#123;<br>        col = imageColSize<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;                                      <span class="hljs-comment">// (3)</span><br>        ret<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = (<span class="hljs-built_in">int</span> *)malloc( sizeof(<span class="hljs-built_in">int</span>)<span class="hljs-operator"> * </span>col );                <span class="hljs-comment">// (4)</span><br>        (*returnColumnSizes)<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = col;                              <span class="hljs-comment">// (5)</span><br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            ret<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = <span class="hljs-number">1</span> - image<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[ <span class="hljs-identifier">col</span>-<span class="hljs-number">1</span>-<span class="hljs-identifier">j</span> ]</span>;                    <span class="hljs-comment">// (6)</span><br>        &#125;<br>    &#125;<br>    *returnSize = imageSize;                                        <span class="hljs-comment">// (7)</span><br>    return ret;                                                     <span class="hljs-comment">// (8)</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>image是传过来二维数组，</p><p>imagesize是传过来的二维数组的行数，</p><p>imagecolsize是传过来二维数组每行的列数</p><p>returnSize是传回去二维数组的行数</p><p>returnColumnSizes是传回去二维数组每行的列数</p><p>返回的时候要malloc一个二维数组来接收</p><p>同时每行也要malloc处每行的元素个数（最后malloc完二维数组后，就对每个一维数组进行malloc）</p></blockquote><h1 id="1-最富有客户的资产总量"><a href="#1-最富有客户的资产总量" class="headerlink" title="1.最富有客户的资产总量"></a>1.最富有客户的资产总量</h1><blockquote><p>给你一个 <code>m x n</code> 的整数网格 <code>accounts</code> ，其中 <code>accounts[i][j]</code> 是第 <code>i​​​​​​​​​​​​</code> 位客户在第 <code>j</code> 家银行托管的资产数量。返回最富有客户所拥有的 <strong>资产总量</strong> 。</p><p>客户的 <strong>资产总量</strong> 就是他们在各家银行托管的资产数量之和。最富有客户就是 <strong>资产总量</strong> 最大的客户。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>accounts &#x3D; [[1,2,3],[3,2,1]]<br><strong>输出：</strong>6<br><strong>解释：</strong><br><code>第 1 位客户的资产总量 = 1 + 2 + 3 = 6 第 2 位客户的资产总量 = 3 + 2 + 1 = 6</code> 两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>accounts &#x3D; [[1,5],[7,3],[3,5]]<br><strong>输出：</strong>10<br><strong>解释：</strong><br><code>第 1 位客户的资产总量</code> &#x3D; 6<br><code>第 2 位客户的资产总量</code> &#x3D; 10<br><code>第 3 位客户的资产总量</code> &#x3D; 8<br>第 2 位客户是最富有的，资产总量是 10</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>accounts &#x3D; [[2,8,7],[7,1,3],[1,9,5]]<br><strong>输出：</strong>17</p></blockquote><blockquote><p>思路：求出每行的和，再将每行和进行比较，求出最大值进行返回</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumWealth</span><span class="hljs-params">(<span class="hljs-type">int</span>** accounts, <span class="hljs-type">int</span> accountsSize, <span class="hljs-type">int</span>* accountsColSize)</span></span>&#123;<br><span class="hljs-type">int</span> i,j,col;<br><span class="hljs-type">int</span> arr[accountsSize];<span class="hljs-comment">//用一个arr数组来接收每行和</span><br><span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,accountsSize*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));同时要对他初始化为<span class="hljs-number">0</span><br><br><span class="hljs-type">int</span> max;<span class="hljs-comment">//定义max为最终最大返回值</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;accountsSize;i++)<br>&#123;<br>    <br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;accountsColSize[i];j++)<br>    &#123;<br>        arr[i]+=accounts[i][j];<br>    &#125; <br>&#125;<br>max=arr[<span class="hljs-number">0</span>];<span class="hljs-comment">//max赋初值第一个元素</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;accountsSize;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(max&lt;arr[i])<br>    &#123;<br>        max=arr[i];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> max;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h1><blockquote><p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p><p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e96c03d3c525760097b7571029c8e3dc.png"></p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br><strong>输出：</strong>[[1,4,7],[2,5,8],[3,6,9]]</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6]]<br><strong>输出：</strong>[[1,4],[2,5],[3,6]]</p></blockquote><blockquote><p> 思路：对角线互换，行变列，列变行</p></blockquote><blockquote><p> 1.returnsize返回的是转置后返回的二维数组的行数；</p><p>2.*returnColumnSizes是返回的二维数组的每行的列数</p><p>3.返回的二维数组必须自己malloc出来，同时返回的二维数组每一行的元素也要自己malloc出来，</p></blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs smali">/**<br> * Return an<span class="hljs-built_in"> array </span>of arrays of size *returnSize.<br> * The sizes of the arrays are returned as *returnColumnSizes array.<br> * Note: Both returned<span class="hljs-built_in"> array </span>and *columnSizes<span class="hljs-built_in"> array </span>must be malloced, assume caller calls free().<br> */<br>int** transpose(int** matrix,<span class="hljs-built_in"> int </span>matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes)<br>&#123;<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>i,j,col;    <br>col=matrixColSize[0];//<span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>**ret=(int **)malloc(sizeof(int*)*col);      //ret的行数是matrix的列数<br>*returnColumnSizes=(int*)malloc(sizeof(int)*col);//*returnColumnSize返回的每行的个数是原二维数组的列数<br>*returnSize=col;      //返回的行数是原来的列数                        <br>for(i=0;i&lt;col;i++)      <br>&#123;          <br>    (*returnColumnSizes)[i]=matrixSize;//返回每行的列数是原来的行数<br>    ret[i]=(int *)malloc(sizeof(int)*matrixSize);<br>&#125;<br>for(i=0;i&lt;matrixSize;i++)<br>&#123;    <br>    for(j=0;j&lt;col;j++)<br>    &#123;<br>        ret[j][i]=matrix[i][j];<br>    &#125;<br>&#125;<span class="hljs-built_in"></span><br><span class="hljs-built_in">return </span>ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><blockquote><p>给定一个 _n _× <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title=" 原地"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b91170c7fe691e12d5d5bd0ee2cc8593.png"></p><p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br><strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]</p><p><strong>示例 2：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/542ac7221f126af4d2bedfd36a562db1.png"></p><p><strong>输入：</strong>matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>matrix &#x3D; [[1]]<br><strong>输出：</strong>[[1]]</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>matrix &#x3D; [[1,2],[3,4]]<br><strong>输出：</strong>[[3,1],[4,2]]</p></blockquote><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">void</span> rotate(<span class="hljs-type">int</span>** <span class="hljs-type">matrix</span>, <span class="hljs-type">int</span> matrixSize, <span class="hljs-type">int</span>* matrixColSize)&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">col</span>;<br><span class="hljs-type">int</span> arr[matrixSize][matrixSize];<span class="hljs-comment">//开辟一个arr二维数组，长度是matrixsize</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;matrixSize;i++)<br>&#123;<br>    <span class="hljs-built_in">col</span>=matrixColSize[i];       <span class="hljs-comment">//col是每行的列数</span><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">col</span>;j++)<br>&#123;<br>    arr[j][<span class="hljs-built_in">col</span>-<span class="hljs-number">1</span>-i]=<span class="hljs-type">matrix</span>[i][j];<span class="hljs-comment">//因为是对matrix的i和j的遍历，所以matrix是[i][j],</span><br>                                   arr是规律是arr[j][<span class="hljs-built_in">col</span>-<span class="hljs-number">1</span>-i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;matrixSize;i++)<br>&#123;<br>    <span class="hljs-built_in">col</span>=matrixColSize[i];<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">col</span>;j++)<br>    &#123;<br>        <span class="hljs-type">matrix</span>[i][j]=arr[i][j];<span class="hljs-comment">//arr是已经旋转之后的数组，同时因为要旋转，所以要对原来的数组进行改变，把arr赋给matrix</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">matrix</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="回旋矩阵"><a href="#回旋矩阵" class="headerlink" title="回旋矩阵"></a>回旋矩阵</h1><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> i, j;<br><span class="hljs-built_in">int</span> m = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>;<br><br><span class="hljs-built_in">int</span> ret[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>memset(ret, <span class="hljs-number">0</span>, sizeof(ret));用memset内存函数对ret初始化为<span class="hljs-number">0</span><br><br><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>;<br>for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span> / <span class="hljs-number">2</span>; i++)<br>&#123;<br><br>//向右<br>for (j = i; j &lt; m - i; j++)<br>&#123;<br>ret[i][j] = <span class="hljs-built_in">count</span>++;<br>&#125;<br>//向下<br>for (j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">n</span> - i; j++)<br>&#123;<br>ret[j][m - <span class="hljs-number">1</span> - i] = <span class="hljs-built_in">count</span>++;<br>&#125;<br>for (j = m - <span class="hljs-number">2</span> - i; j &gt;= i; j--)<br>&#123;<br>ret[<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span> - i][j] = <span class="hljs-built_in">count</span>++;<br>&#125;<br>for (j = <span class="hljs-built_in">n</span> - <span class="hljs-number">2</span> - i; j &gt; i; j--)<br><br>&#123;<br><br>ret[j][i] = <span class="hljs-built_in">count</span>++;<br>&#125;<br><span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)//假如<span class="hljs-built_in">n</span>是奇数的话，中间还要填一个数<br>&#123;<br>ret[<span class="hljs-built_in">n</span> / <span class="hljs-number">2</span>][m / <span class="hljs-number">2</span>] = <span class="hljs-built_in">n</span> * m;<br>&#125;<br><br>&#125;<br><br>for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++)<br>&#123;<br>for (j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br>printf(<span class="hljs-string">&quot;%d &quot;</span>, ret[i][j]);<br>&#125;<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法 链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分支与循环</title>
    <link href="/2021/11/18/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/"/>
    <url>/2021/11/18/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0" title="找最大公约数">找最大公约数</a></p><p><a href="#%E6%B3%951" title="法1">法1</a></p><p><a href="#%E6%B3%952" title="法2">法2</a></p><p><a href="#%E6%B1%82%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0" title="求最小公倍数">求最小公倍数</a></p><p><a href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E7%B4%A0%E6%95%B0" title="判断是否是素数">判断是否是素数</a></p><p><a href="#%E6%B3%951" title="法1">法1</a></p><p><a href="#%E6%B3%952" title="法2">法2</a></p><p><a href="#%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2" title="模拟用户登录界面">模拟用户登录界面</a></p><p><a href="#%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%C2%A0" title="找两个数的最大公约数 ">找两个数的最大公约数 </a></p><p><a href="#%E6%B3%951" title="法1">法1</a></p><p><a href="#%C2%A0%E6%B3%952%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0" title=" 法2辗转相除法求最大公约数"> 法2辗转相除法求最大公约数</a></p><p><a href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E7%B4%A0%E6%95%B0" title="判断一个数是否是素数">判断一个数是否是素数</a></p><p><a href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%99%BB%E5%85%A5%E7%95%8C%E9%9D%A2" title="模拟实现用户输入密码登入界面">模拟实现用户输入密码登入界面</a></p><hr><h1 id="找两个数的最大公约数"><a href="#找两个数的最大公约数" class="headerlink" title="找两个数的最大公约数"></a>找两个数的最大公约数</h1><h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl"><br><span class="hljs-keyword">int</span> main()<br>&#123;<br><span class="hljs-keyword">int</span> m, n;<br>scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);<br><span class="hljs-keyword">int</span> ret = m &lt; n ? m : n;<span class="hljs-regexp">//</span>求得到m和n中较小的那个数<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (m%ret == <span class="hljs-number">0</span> &amp;&amp; n%ret == <span class="hljs-number">0</span>)//从m与n的最小值中开始减，减到<span class="hljs-keyword">if</span>成立<br>&#123;<br><span class="hljs-keyword">break</span>;<span class="hljs-regexp">//</span>当ret同时能够被m和n整除时，ret就是最大公约数<br>&#125;<br>ret--;<br>&#125;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ret);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="法2辗转相除法求最大公约数"><a href="#法2辗转相除法求最大公约数" class="headerlink" title="法2辗转相除法求最大公约数"></a>法2辗转相除法求最大公约数</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl"><br><span class="hljs-keyword">int</span> main()<br>&#123;<br><span class="hljs-keyword">int</span> m, n;<br>scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);<span class="hljs-regexp">//</span>假设输入<span class="hljs-number">24</span> <span class="hljs-number">18</span>，ret=<span class="hljs-number">24</span>%18=<span class="hljs-number">6</span>,将n的值赋给m，m=<span class="hljs-number">18</span>，ret的值赋给n,ret=<span class="hljs-number">6</span>，<span class="hljs-number">18</span>%6=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>就停下来此时n的值就是最大公约数，若输入的是<span class="hljs-number">18</span>，<span class="hljs-number">24</span>，<span class="hljs-number">18</span>/%24=<span class="hljs-number">18</span>，也会把两者进行交换<br><span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (ret = m % n)//ret为<span class="hljs-number">0</span>就停下来了，<br>&#123;<br>m = n;<br>n = ret;<br>&#125;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 最小公倍数<br>可以把两个数相乘除以他们的最大公约数</p></blockquote><h1 id="判断一个数是否是素数"><a href="#判断一个数是否是素数" class="headerlink" title="判断一个数是否是素数"></a>判断一个数是否是素数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num,i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; num; i++)<span class="hljs-comment">//从2到num-1对num进行试除，一旦除成功就跳出去</span><br>&#123;<br><span class="hljs-keyword">if</span> (num%i == <span class="hljs-number">0</span>)<br>&#123;<br>flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;是素数&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不是素数&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>但我们还有更高效率的方法<br>要找一个数的因数如16&#x3D;2*8，4*4，如果有因数，则在根号16前面至少会有一个因数，所以不用全部进行试除</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(num); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (num%i == <span class="hljs-number">0</span>)<br>&#123;<br>flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;是素数&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模拟实现用户输入密码登入界面"><a href="#模拟实现用户输入密码登入界面" class="headerlink" title="模拟实现用户输入密码登入界面"></a>模拟实现用户输入密码登入界面</h1><p>用户只有3次输入密码的机会，三次都错误就退出界面 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> password[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>假设密码是<span class="hljs-number">123456</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入密码\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, password);<br>对字符串进行判断相等，用<span class="hljs-function">strcmp</span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(strcmp(password, <span class="hljs-string">&quot;123456&quot;</span>) == <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;登录成功\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)<span class="hljs-comment">//i最后自增到3&lt;3不成立就不执行了，往下i=3,3次都失败了</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 登录失败,退出程序\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划 算法 排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟着英雄学算法2数列</title>
    <link href="/2021/11/16/%E8%B7%9F%E7%9D%80%E8%8B%B1%E9%9B%84%E5%AD%A6%E7%AE%97%E6%B3%952%E6%95%B0%E5%88%97/"/>
    <url>/2021/11/16/%E8%B7%9F%E7%9D%80%E8%8B%B1%E9%9B%84%E5%AD%A6%E7%AE%97%E6%B3%952%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>求斐波那契数列 </p></blockquote><blockquote><p>我们使用一般的递归会造成栈溢出</p><p>那么我们就可以使用一个数组来接收这个数</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> f[<span class="hljs-number">31</span>];                     <span class="hljs-comment">// (1)</span><br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;            <span class="hljs-comment">// (2)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;  <span class="hljs-comment">// (3)</span><br>        f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>];    <span class="hljs-comment">// (4)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n];                   <span class="hljs-comment">// (5)</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" title="第 N 个泰波那契数">第 N 个泰波那契数</a></p><p>泰波那契序列 Tn 定义如下： </p><p>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 Tn+3 &#x3D; Tn + Tn+1 + Tn+2</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>n &#x3D; 4<br><strong>输出：</strong>4<br><strong>解释：</strong><br>T_3 &#x3D; 0 + 1 + 1 &#x3D; 2<br>T_4 &#x3D; 1 + 1 + 2 &#x3D; 4</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>n &#x3D; 25<br><strong>输出：</strong>1389537</p></blockquote><p> </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> tribonacci(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>[<span class="hljs-number">38</span>];//用一个数组来接收那些值<br><span class="hljs-built_in">t</span>[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>,<span class="hljs-built_in">t</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,<span class="hljs-built_in">t</span>[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> i=<span class="hljs-number">3</span>;<br>for(i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-built_in">n</span>;i++)<br><span class="hljs-built_in">t</span>[i]=<span class="hljs-built_in">t</span>[i-<span class="hljs-number">1</span>]+<span class="hljs-built_in">t</span>[i-<span class="hljs-number">2</span>]+<span class="hljs-built_in">t</span>[i-<span class="hljs-number">3</span>];<br>return <span class="hljs-built_in">t</span>[<span class="hljs-built_in">n</span>];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://leetcode-cn.com/problems/monotonic-array/" title="单调数列">单调数列</a></p><p>如果数组是单调递增或单调递减的，那么它是_单调的_。</p><p>如果对于所有 <code>i &lt;= j</code>，<code>A[i] &lt;= A[j]</code>，那么数组 <code>A</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>A[i]&gt; = A[j]</code>，那么数组 <code>A</code> 是单调递减的。</p><p>当给定的数组 <code>A</code> 是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>[1,2,2,3]<br><strong>输出：</strong>true</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>[6,5,4,4]<br><strong>输出：</strong>true</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>[1,3,2]<br><strong>输出：</strong>false</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>[1,2,4,5]<br><strong>输出：</strong>true</p><p><strong>示例 5：</strong></p><p><strong>输入：</strong>[1,1,1]<br><strong>输出：</strong>true</p></blockquote><blockquote><p>思路：非单调的数列，即中间的数大于两边的，或小于两边的</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMonotonic</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span></span>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//设置一个flag标识符</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>((nums[i]&gt;nums[i<span class="hljs-number">-1</span>]&amp;&amp;nums[i]&lt;nums[i+<span class="hljs-number">1</span>])||(nums[i]&lt;nums[i+<span class="hljs-number">1</span>]&amp;&amp;nums[i]&lt;nums[i<span class="hljs-number">-1</span>]))<br>&#123;<br>    flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论 动态规划 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表的中间结点</title>
    <link href="/2021/11/16/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
    <url>/2021/11/16/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</p><p>示例 2：</p><p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p><p>提示：</p><p>    给定链表的结点数介于 1 和 100 之间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">https://leetcode-cn.com/problems/middle-of-the-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/ee1dab6516df433ea1a19d0200b4f562.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">ListNode</span>* <span class="hljs-built_in">middleNode</span>(struct ListNode* head)&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">ListNode</span>* fast=head;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">ListNode</span>*<span class="hljs-type">slow</span>=<span class="hljs-type">head</span>;<br><span class="hljs-keyword">while</span>(fast!=<span class="hljs-built_in">NULL</span>&amp;&amp;fast-&gt;next!=<span class="hljs-built_in">NULL</span>)<span class="hljs-comment">//继续的条件，fast，fast-&gt;next有一个为空就停下来了 </span><br>&#123;<br>    fast=fast-&gt;next-&gt;next;<br>    slow=slow-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表 数据结构 leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法零基础100讲》(第1讲) 幂和对数</title>
    <link href="/2021/11/15/%E3%80%8A%E7%AE%97%E6%B3%95%E9%9B%B6%E5%9F%BA%E7%A1%80100%E8%AE%B2%E3%80%8B(%E7%AC%AC1%E8%AE%B2)%20%E5%B9%82%E5%92%8C%E5%AF%B9%E6%95%B0/"/>
    <url>/2021/11/15/%E3%80%8A%E7%AE%97%E6%B3%95%E9%9B%B6%E5%9F%BA%E7%A1%80100%E8%AE%B2%E3%80%8B(%E7%AC%AC1%E8%AE%B2)%20%E5%B9%82%E5%92%8C%E5%AF%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>跟着英雄学算法打卡第一天</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                          <span class="hljs-comment">// (1)</span><br>    &#125;<br>    <span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>)(<span class="hljs-built_in">log2</span>(n) / <span class="hljs-built_in">log2</span>(<span class="hljs-number">4</span>) + <span class="hljs-number">1e-8</span>);   <span class="hljs-comment">// (2)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(n - <span class="hljs-built_in">pow</span>(<span class="hljs-number">4</span>, x)) &lt; <span class="hljs-number">1e-8</span>;         <span class="hljs-comment">// (3)</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>bool类型是用来判断真假的，true为1，false为0</p></blockquote><blockquote><p>1.n&#x3D;0为特殊情况</p><p>2.换底公式，并且加上一个精度，避免精度缺失导致取整错误</p><p>3.浮点数的相等判定</p></blockquote><blockquote><p> 对数和幂</p><p>若判断一个数是否为4的对数 n&#x3D;4^x</p><p>即x&#x3D;log4(n);可以使用fabs来判断，由于fabs是判断小数的绝对值，如果两数相等，</p><p>则fabs(a-b)&lt;1e-8;即小于一个无穷小，a和b两个数相等</p><p>换底公式中用2为底和以10为底的更好计算</p></blockquote><p>力扣题</p><blockquote><p><a href="https://leetcode-cn.com/problems/power-of-two/" title=". 2 的幂">. 2 的幂</a></p><p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>x</code> 使得 <code>n == 2x</code> ，则认为 <code>n</code> 是 2 的幂次方。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>n &#x3D; 1<br><strong>输出：</strong>true<br><strong>解释：</strong>20 &#x3D; 1</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>n &#x3D; 16<br><strong>输出：</strong>true<br><strong>解释：</strong>24 &#x3D; 16</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>n &#x3D; 3<br><strong>输出：</strong>false</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>n &#x3D; 4<br><strong>输出：</strong>true</p><p><strong>示例 5：</strong></p><p><strong>输入：</strong>n &#x3D; 5<br><strong>输出：</strong>false</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br><br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-type">int</span> x=(<span class="hljs-type">int</span>)(<span class="hljs-built_in">log2</span>(n)+<span class="hljs-number">1e-8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(n-<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,x))&lt;<span class="hljs-number">1e-8</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3的幂次方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-type">int</span> x=(<span class="hljs-type">int</span>)(<span class="hljs-built_in">log2</span>(n)/<span class="hljs-built_in">log2</span>(<span class="hljs-number">3</span>)+<span class="hljs-number">1e-8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(n-<span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,x))&lt;<span class="hljs-number">1e-8</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串排序</title>
    <link href="/2021/11/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/11/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>本题要求编写程序，读入5个字符串，按由小到大的顺序输出。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入为由空格分隔的5个非空字符串，每个字符串不包括空格、制表符、换行符等空白字符，长度小于80。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照以下格式输出排序后的结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">After sorted:<br>每行一个字符串<br></code></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">red yellow <span class="hljs-keyword">blue </span><span class="hljs-keyword">black </span>white<br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">After sorted:<br><span class="hljs-keyword">black</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">blue</span><br><span class="hljs-keyword"></span>red<br>white<br>yellow<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>对于字符串排序我们有两种方法，一种是使用数组的方法，利用二维数组</p><p>一种是使用指针的方法，利用指针数组</p></blockquote><p> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">char</span> str[<span class="hljs-number">6</span>][<span class="hljs-number">80</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">80</span>];<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//相当于一个冒泡排序</span><br>    &#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>-i;j++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(str[j],str[j+<span class="hljs-number">1</span>])&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//比较大小，使用strcmp来比较大于0就是前一个字符串大，就要对两者进行交换</span><br>    &#123;<br><span class="hljs-built_in">strcpy</span>(s,str[j]);<span class="hljs-comment">//字符串的交换不能使用=，因为字符串名是其首元素地址，所以我们应该定义一个字符数组，使用strcpy拷贝交换</span><br>    <span class="hljs-built_in">strcpy</span>(str[j],str[j+<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">strcpy</span>(str[j+<span class="hljs-number">1</span>],s);<br>    &#125;<br>&#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After sorted:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找指定字符</title>
    <link href="/2021/11/15/%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6/"/>
    <url>/2021/11/15/%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>本题要求编写程序，从给定字符串中查找某指定的字符。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入的第一行是一个待查找的字符。第二行是一个以回车结束的非空字符串（不超过80个字符）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果找到，在一行内按照格式“index &#x3D; 下标”输出该字符在字符串中所对应的最大下标（下标从0开始）；否则输出”Not Found”。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">m</span><br><span class="hljs-attribute">programming</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Not Found</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>输入一个字符串时可能在最后有多个空格才打回车，但是scanf是默认到空格就结束读取，空格后就被放进输入缓冲区了被后面的来读取 ，那么我们可以使用%[^\n]就是遇到回车才会停止输入</p></blockquote><blockquote><p>我们知道 ：scanf() 遇到空格结束输入</p><p>可以用 scanf(“%[^\n], str”) 输入一行数据包括空格，直到遇到换行符 ’ \n ’</p><p>scanf(“%*[^\n]“);&#x2F;&#x2F;清理输入缓冲区中第一个\n之前的所有字符<br>scanf(“%*c”); &#x2F;&#x2F;清理输入缓冲区中第一个字符，也就是上次遗留下的\n<br>scanf(“%*[^\n]%*c”)是把这两句放在一起</p></blockquote><blockquote><p>思路：使用m对数组进行遍历</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c);<br><span class="hljs-comment">//清空输入缓冲区</span><br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">81</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %[^\n]s&quot;</span>,str);<span class="hljs-comment">//输入空格也会继续读取</span><br>    <span class="hljs-type">int</span> index=<span class="hljs-number">-1</span>;<span class="hljs-comment">//先将index赋值为-1</span><br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>    &#123;<br><span class="hljs-keyword">if</span>(str[i]==c)<span class="hljs-comment">//找到了，接收的最大的i</span><br>&#123;<br>index=i;<br>&#125;<br>    &#125;<br>   <span class="hljs-keyword">if</span>(index&gt;=<span class="hljs-number">0</span>)<span class="hljs-comment">//因为肯在第一个元素就找到了，所以index要大于等于0</span><br>   &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index = %d&quot;</span>,index);<br>   &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index==<span class="hljs-number">-1</span>)<span class="hljs-comment">//-1就是没有找到</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Found&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查验身份证</title>
    <link href="/2021/11/15/%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/"/>
    <url>/2021/11/15/%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：</p><p>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值<code>Z</code>；最后按照以下关系对应<code>Z</code>值与校验码<code>M</code>的值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Z</span>：<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">M</span>：<span class="hljs-number">1</span> <span class="hljs-number">0</span> X <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出<code>All passed</code>。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-number">4</span><br><span class="hljs-number">320124198808240056</span><br><span class="hljs-number">12010</span><span class="hljs-keyword">X</span><span class="hljs-number">198901011234</span><br><span class="hljs-number">110108196711301866</span><br><span class="hljs-number">37070419881216001</span><span class="hljs-keyword">X</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-number">12010</span><span class="hljs-keyword">X</span><span class="hljs-number">198901011234</span><br><span class="hljs-number">110108196711301866</span><br><span class="hljs-number">37070419881216001</span><span class="hljs-keyword">X</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>320124198808240056<br>110108196711301862<br></code></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">All</span> passed<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>首先介绍一个知识点：1：‘9’-‘0’&#x3D;9，一个字符减去‘0’，即可得到他数字的大小</p><p>2：对字符串进行多次输入可以使用二维数组如 char[10][20]即有10行字符串，每行字符串最大大小为20的个字节</p><p>3.同样我们也可以用一个标识符count为1，但最后一个数字对应不同时就把count置为0</p><p>全非0即all passed</p></blockquote><p> </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, i, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> z;<br>    <span class="hljs-type">char</span> dui[<span class="hljs-number">17</span>] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span> &#125;;<br><span class="hljs-comment">//因为x并非是一个数字，所以就不能用整形数组，就应该用一个字符数组</span><br><br>    <span class="hljs-type">int</span> qz[<span class="hljs-number">17</span>] = &#123; <span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> id[<span class="hljs-number">100</span>][<span class="hljs-number">19</span>];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, id[i]);<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>            sum=<span class="hljs-number">0</span>;<br>            z=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">18</span>; k++)<br>&#123;<br><br>sum += (id[i][k] - <span class="hljs-string">&#x27;0&#x27;</span>) * qz[k];<br><span class="hljs-comment">//(id[i][k] - &#x27;0&#x27;)计算每个字符的大小为int型</span><br>&#125;<br><br><br> z = sum % <span class="hljs-number">11</span>;<br><span class="hljs-keyword">if</span> (dui[z] != id[i][<span class="hljs-number">17</span>])<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, id[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>count = <span class="hljs-number">0</span>;<br>&#125;<br><br><br>&#125;<br><span class="hljs-keyword">if</span> (count)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;All passed&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.判断上三角矩阵</title>
    <link href="/2021/11/15/1.%E5%88%A4%E6%96%AD%E4%B8%8A%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/11/15/1.%E5%88%A4%E6%96%AD%E4%B8%8A%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>上三角矩阵指主对角线以下的元素都为0的矩阵；主对角线为从矩阵的左上角至右下角的连线。</p><p>本题要求编写程序，判断一个给定的方阵是否上三角矩阵。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数T，为待测矩阵的个数。接下来给出T个矩阵的信息：每个矩阵信息的第一行给出一个不超过10的正整数n。随后n行，每行给出n个整数，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个矩阵的判断结果占一行。如果输入的矩阵是上三角矩阵，输出“YES”，否则输出“NO”。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">3<br>3<br>1<span class="hljs-number"> 2 </span>3<br>0<span class="hljs-number"> 4 </span>5<br>0<span class="hljs-number"> 0 </span>6<br>2<br>1 0<br>-8 2<br>3<br>1<span class="hljs-number"> 2 </span>3<br>1<span class="hljs-number"> 4 </span>5<br>0 -1 6<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">NO</span><br><span class="hljs-keyword">NO</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>思路一：上三角矩阵即对角线以下全为0；若i为行，j为列，则在i&gt;y的坐标中数字全应该为0</p><p>那么我们在进入每次循环时就可以用一个标记点flag初始为1，</p><p>用到反证法：只要遇到非0就把flag置成0，然后break出去</p><p>接收1.时可用数组来接收flag的值，循环遍历flag的数组，1为yes，0为no</p><p>接收2.if（flag）不为0则yes，反之亦然</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr1[<span class="hljs-number">15</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>&#123;<br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (i &gt; j&amp;&amp;arr[i][j] != <span class="hljs-number">0</span>)<br>&#123;<br>flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag)<br>&#123;<br>arr1[k] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>arr1[k]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr1[i] == <span class="hljs-number">1</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路2：我们可以计算下三角0的个数，如果符合就yes，反之则no</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span> m;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;arr[i][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">0</span>)<br>&#123;<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> sum = (m * (m - <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (sum == count)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵 线性代数 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣刷题—链表反转</title>
    <link href="/2021/11/11/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E2%80%94%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <url>/2021/11/11/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E2%80%94%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>法一：反转指针</p><p> <img src="https://img-blog.csdnimg.cn/5dd8faedc01748d3b179436a05b3348c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/**<br> * Definition for singly-linked list.<br> * struct ListNode &#123;<br> *     int val<span class="hljs-comment">;</span><br> *     struct ListNode *next<span class="hljs-comment">;</span><br> * &#125;<span class="hljs-comment">;</span><br> */<br><br><br>struct ListNode* reverseList(struct ListNode* head)&#123;<br>if(head<span class="hljs-operator">=</span><span class="hljs-operator">=</span>NULL)<br>return NULL<span class="hljs-comment">;</span><br><br>struct ListNode*n1<span class="hljs-operator">=</span>NULL<span class="hljs-comment">;//n1作为返回的头节点</span><br>struct ListNode*n2<span class="hljs-operator">=</span>head<span class="hljs-comment">;</span><br>struct ListNode*n3<span class="hljs-operator">=</span>n2-&gt;next<span class="hljs-comment">;//记录头节点的下一个节点，避免转过去之后找不到后面的节点</span><br><br><br>    while(n2)//n2是反转的主角，所以n2到空才可以，迭代过程<br>    &#123;<br>        n2-&gt;next<span class="hljs-operator">=</span>n1<span class="hljs-comment">;</span><br>        n1<span class="hljs-operator">=</span>n2<span class="hljs-comment">;</span><br>        n2<span class="hljs-operator">=</span>n3<span class="hljs-comment">;</span><br>        if(n3)<br>        n3<span class="hljs-operator">=</span>n3-&gt;next<span class="hljs-comment">;</span><br>    &#125;<br>    return n1<span class="hljs-comment">;</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p> 法二：头插法</p><p><img src="https://img-blog.csdnimg.cn/52732fec0b1e44ebacf281f1cda66c46.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/**<br> * Definition for singly-linked list.<br> * struct ListNode &#123;<br> *     int val<span class="hljs-comment">;</span><br> *     struct ListNode *next<span class="hljs-comment">;</span><br> * &#125;<span class="hljs-comment">;</span><br> */<br><br><br>struct ListNode* reverseList(struct ListNode* head)&#123;<br>if(head<span class="hljs-operator">=</span><span class="hljs-operator">=</span>NULL)<br>return NULL<span class="hljs-comment">;</span><br>struct ListNode*cur<span class="hljs-operator">=</span>head<span class="hljs-comment">;</span><br>struct ListNode*newnode<span class="hljs-operator">=</span>NULL<span class="hljs-comment">;</span><br>struct ListNode*next<span class="hljs-operator">=</span>cur-&gt;next<span class="hljs-comment">;</span><br>while(cur)<br>&#123;<br>    cur-&gt;next<span class="hljs-operator">=</span>newnode<span class="hljs-comment">;</span><br>    newnode<span class="hljs-operator">=</span>cur<span class="hljs-comment">;</span><br>    cur<span class="hljs-operator">=</span>next<span class="hljs-comment">;</span><br>    if(next)<br>    next<span class="hljs-operator">=</span>next-&gt;next<span class="hljs-comment">;</span><br><br>&#125;<br>return newnode<span class="hljs-comment">;</span><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>list 链表 leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带头双向循环链表</title>
    <link href="/2021/11/10/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/11/10/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>我们以及学习了无头单链表，可以发现它有点麻烦</p><p>1.单链表不能从后面往前</p><p>2.找不到它的前驱（上一个地址）</p><p>（尾插，尾删，中插，中删）都要找到它的前一个节点</p><p>3.没有带头的节点：要用二级指针进行传参，不用改变传过来指针</p></blockquote><blockquote><p>那么我们可以介绍一下带头双向循环链表的好处</p><p>1.带头节点的好处</p><p>：不存储有效数据，带哨兵位的头节点不存入链表的长度，使得尾插更加方便，每次都在头后进行连接</p><p>2.双向的好处</p><p>：方便找到他的前一个节点</p><p>3.循环的好处</p><p>：头指向尾，尾指向头，头的前一个节点就是尾，方便找尾节点</p></blockquote><p><img src="https://img-blog.csdnimg.cn/402c5d758d074fe88281fac06beda41b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>  <img src="https://img-blog.csdnimg.cn/8f2d7e25bfc249bbb8cc13457455acd3.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> list.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> listdata;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span><br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>*prev;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>*next;<br>listdata data;<br>&#125;listnode;<br><br><span class="hljs-comment">//初始化链表的哨兵位的头节点</span><br><span class="hljs-function">listnode* <span class="hljs-title">listinit</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//实现尾插</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listpushback</span><span class="hljs-params">(listnode*phead, listdata x)</span></span>;<br><br><span class="hljs-comment">//实现打印，头节点不打印</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listprint</span><span class="hljs-params">(listnode*phead)</span></span>;<br><br><span class="hljs-comment">//头插</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listpushfront</span><span class="hljs-params">(listnode* phead, listdata x)</span></span>;<br><br><span class="hljs-comment">//头删</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listpopfront</span><span class="hljs-params">(listnode*phead)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listpopback</span><span class="hljs-params">(listnode*phead)</span></span>;<br><br><span class="hljs-function">listnode* <span class="hljs-title">listfind</span><span class="hljs-params">(listnode*phead,listdata x)</span></span>;<br><br><span class="hljs-comment">//中间加入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listinsert</span><span class="hljs-params">(listnode*phead, listdata x)</span></span>;<br><span class="hljs-comment">//中间删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listerase</span><span class="hljs-params">(listnode*pos)</span></span>;<br><span class="hljs-comment">//销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listdestroy</span><span class="hljs-params">(listnode*phead)</span></span>;<br></code></pre></td></tr></table></figure><p>list.c </p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs zephir">#define _CRT_SECURE_NO_WARNINGS <span class="hljs-number">1</span><br>#include<span class="hljs-string">&quot;list.h&quot;</span><br><span class="hljs-comment">//首先要先开辟节点</span><br>listnode* buynode(listdata x)<br>&#123;<br>listnode*newnode = (listnode*)malloc(sizeof(listnode));<br>newnode-&gt;next = NULL;<br>newnode -&gt;prev = NULL;<br>newnode-&gt;data = x;<br><span class="hljs-keyword">return</span> newnode;<br>&#125;<br><br><br><span class="hljs-comment">//初始化带哨兵位的头节点</span><br>listnode* listinit()<br>&#123;<br><span class="hljs-comment">//初始化头节点</span><br>listnode*phead = buynode(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//因为是循环链表，所以且是头节点</span><br>头的前面和后面都是指向自己<br>    phead-&gt;next = phead;<br>phead-&gt;prev = phead;<br><span class="hljs-keyword">return</span> phead;<br>&#125;<br><br><br><br><span class="hljs-comment">//实现尾插，和有无节点都无关都可以用这代码</span><br>void listpushback(listnode*phead, listdata x)<br>&#123;<br><span class="hljs-comment">//因为定义了双向链表</span><br><span class="hljs-comment">//所以用头指针的prev就能找到尾节点</span><br>listnode*tail = phead-&gt;prev;<br>listnode*newnode = buynode(x);<br>tail-&gt;next = newnode;<br>newnode-&gt;prev = tail;<br>newnode-&gt;next = phead;<br>phead-&gt;prev = newnode;<br><span class="hljs-comment">//利用中间插入的代码也可以实现尾插，传入头的地址，在头的前面插入就是尾插</span><br><span class="hljs-comment">/*listinsert(phead,x);*/</span><br>&#125;<br><br><br><br><span class="hljs-comment">//打印</span><br>void listprint(listnode*phead)<br>&#123;<br><span class="hljs-comment">// 头不打印</span><br><span class="hljs-comment">//加入断言就方便如果有错误就好找一点</span><br>assert(phead);<span class="hljs-comment">//断言pheaed不可能为空指针，假设传参错误就会报错</span><br>listnode*cur = phead-&gt;next;<br><span class="hljs-keyword">while</span> (cur != phead)<br>&#123;<br>printf(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);<br>cur = cur-&gt;next;<br>&#125;<br>printf(<span class="hljs-string">&quot;NULL&quot;</span>);<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>&#125;<br><br><br><br><span class="hljs-comment">//头插</span><br><br>void listpushfront(listnode* phead, listdata x)<br>&#123;<br>listnode*newnode = buynode(x);<br>listnode*first = phead-&gt;next;<br>phead-&gt;next = newnode;<br>newnode-&gt;prev = phead;<br>newnode-&gt;next = first;<br>first-&gt;prev = newnode;<br><span class="hljs-comment">//使用中间插入的也可以实现头插，但应传入的是第一个节点的值，在第一个节点前面实现头插</span><br><span class="hljs-comment">/*listinsert(phead-&gt;next,x);*/</span><br>&#125;<br><br><br><br><br><span class="hljs-comment">//头删</span><br><br>void listpopfront(listnode*phead)<br>&#123;<br><span class="hljs-comment">//这个做法和有几个节点没有关系，如果只有一个节点的话，next就指向头节点，没有节点的话，就指向自己</span><br>listnode*first = phead-&gt;next;<br>listnode*second = first-&gt;next;<br><span class="hljs-comment">//要先完成节点的链接才可以把头节点给free掉</span><br>phead-&gt;next = second;<br>second-&gt;prev = phead;<br>free(first);<br>first = NULL;<br><span class="hljs-comment">//使用中间删除的代码也可以实现头删，也要找到头后面第一个节点，把这个节点给删除掉</span><br><span class="hljs-comment">/*listerase(phead-&gt;next);*/</span><br>&#125;<br><br><br><br><span class="hljs-comment">//尾删</span><br>void listpopback(listnode*phead)<br>&#123;<br>listnode*tail = phead-&gt;prev;<br>listnode*prev = tail-&gt;prev;<br>phead-&gt;prev = prev;<br>prev-&gt;next = phead;<br>free(tail);<br>tail = NULL;<br><span class="hljs-comment">//使用中间删除的代码实现，找到它前一个节点，并把它删除掉</span><br><span class="hljs-comment">/*listerase(phead-&gt;prev);*/</span><br>&#125;<br><br><br><br><span class="hljs-comment">//查找某一个节点</span><br>listnode* listfind(listnode*phead,listdata x)<br>&#123;<br><span class="hljs-comment">//要找某个节点</span><br>assert(phead);<br>listnode*cur = phead-&gt;next;<br><span class="hljs-keyword">while</span> (cur != phead)<br>&#123;<br><span class="hljs-keyword">if</span> (cur-&gt;data == x)<br>&#123;<br><span class="hljs-keyword">return</span> cur;<br>&#125;<br>cur = cur-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> NULL;<br>&#125;<br><br><br><br><span class="hljs-comment">//在pos的前面插入</span><br>void listinsert(listnode*pos, listdata x)<br>&#123;<br><span class="hljs-comment">//加个断言</span><br>assert(pos);<br>listnode*newnode = buynode(x);<br>listnode*prev = pos-&gt;prev;<br>prev-&gt;next = newnode;<br>newnode-&gt;prev = prev;<br>newnode-&gt;next = pos;<br>pos -&gt; prev = newnode;<br>&#125;<br><br><br><br><br><span class="hljs-comment">//中间删除</span><br>void listerase(listnode*pos)<br>&#123;<br>assert(pos);<br>listnode*next = pos-&gt;next;<br>listnode*prev = pos-&gt;prev;<br>prev-&gt;next = next;<br>next-&gt;prev = prev;<br>free(pos);<br>pos = NULL;<br>&#125;<br><br><br><span class="hljs-comment">//销毁</span><br>void listdestroy(listnode*phead)<br>&#123;<br>assert(phead);<br>listnode*cur = phead-&gt;next;<br><span class="hljs-keyword">while</span> (cur != phead)<br>&#123;<br><span class="hljs-comment">//定义一个指针指向下一个，否则就找不到下一个节点了</span><br>listnode*next = cur-&gt;next;<br>free(cur);<br>cur =next;<br>&#125;<br>phead = NULL;<span class="hljs-comment">//都得干掉，</span><br>&#125;<br></code></pre></td></tr></table></figure><p>test.c </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-comment">#include&quot;list.h&quot;</span><br><br><br><span class="hljs-regexp">//</span>带头双向循环链表，最有用的链表结构，任意位置插入删除都是O（<span class="hljs-number">1</span>），<br><span class="hljs-regexp">//</span>查找还是O(N);但是查找的时候有更有的算法<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.平衡搜索树（AVL树和红黑树）<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>.哈希表<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>.B树 B ＋树系列<br><span class="hljs-regexp">//</span>跳表，布隆过滤器，位图<br><br><br><br><br><span class="hljs-regexp">//</span>但是我们其实只需要用insert 和erase就可以完成各种操作<br>void testlist()<br>&#123;<br><span class="hljs-regexp">//</span>我们要创建一个带头双向循环链表<br><span class="hljs-regexp">//</span>即尾指向头，头指向尾，一个节点可以找到前后两个节点<br><span class="hljs-regexp">//</span>首先就要初始化一个哨兵位的头节点<br><br>listnode*plist = listinit();<br>listpushback(plist, <span class="hljs-number">1</span>);<br>listpushback(plist, <span class="hljs-number">2</span>);<br>listpushback(plist, <span class="hljs-number">3</span>);<br>listpushback(plist, <span class="hljs-number">4</span>);<br>listpushback(plist, <span class="hljs-number">5</span>);<br>listpopfront(plist);<br>listprint(plist);<br> listpopback(plist);<br>listpushfront(plist,<span class="hljs-number">0</span>);<br>listnode* pos=listfind(plist,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (pos)<br>&#123;<br><span class="hljs-regexp">//</span>查找附带着修改的作用，找的同时可以对他进行修改<br>pos-&gt;data = <span class="hljs-number">30</span>;<br>printf(<span class="hljs-string">&quot;find\n&quot;</span>);<br>listprint(plist);<br>&#125;<br><span class="hljs-regexp">//</span>想在<span class="hljs-number">3</span>的前面插入一个<span class="hljs-number">300</span><br>listinsert(pos, <span class="hljs-number">300</span>);<br><span class="hljs-regexp">//</span>把pos的位置给删掉<br>listerase(pos);<br>listinsert(pos, <span class="hljs-number">40</span>);<br>listprint(plist);<br>listdestroy(plist);<br>&#125;<br><br><br><br><br><br><br>int main()<br>&#123;<br>testlist();<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 我以及将代码上传到我的gitee上面去了</p><p><a href="https://gitee.com/jiang-wan-zevin/code/tree/master/%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" title="​​​​​​​wcode: 代码收集 - Gitee.com">wcode: 代码收集 - Gitee.com</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表 数据结构 list 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见练习题</title>
    <link href="/2021/11/08/%E5%B8%B8%E8%A7%81%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2021/11/08/%E5%B8%B8%E8%A7%81%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" title="1.二分查找">1.二分查找</a></p><p><a href="#2.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%88%E7%8E%B0" title="2.字符串呈现">2.字符串呈现</a></p><hr><p>​​​​​​​</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>（前提是这个数组有序）</p><p>时间复杂度为O(logn)</p><blockquote><p>我们要在一个数组里面查找一个数，如果用循环遍历的话，那么就要一个一个查找，效率很低</p><p>那么我们就介绍一个效率高的算法，二分查找，或折半查找</p></blockquote><p><img src="https://img-blog.csdnimg.cn/dd764b3d3d18490197f5b8951f4cbc09.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_16,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><span class="hljs-built_in">int</span> sz = sizeof(arr) / sizeof(arr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">int</span> k = <span class="hljs-number">17</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = sz - <span class="hljs-number">1</span>;<br>while (<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>)<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-built_in">if</span> (arr[<span class="hljs-built_in">mid</span>] &lt; k)<br>&#123;<br><span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>&#125;<br>else <span class="hljs-built_in">if</span> (arr[<span class="hljs-built_in">mid</span>] &gt; k)<br>&#123;<br><span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>&#125;<br>else<br>&#123;<br>printf(<span class="hljs-string">&quot;找到了 %d&quot;</span>, <span class="hljs-built_in">mid</span>);<br>break;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &gt; <span class="hljs-built_in">right</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;找不到&quot;</span>);<br>&#125;<br><br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><span class="hljs-built_in">int</span> sz = sizeof(arr) / sizeof(arr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">int</span> k = <span class="hljs-number">17</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = sz - <span class="hljs-number">1</span>;<br>while (<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>)<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-built_in">if</span> (arr[<span class="hljs-built_in">mid</span>] &lt; k)<br>&#123;<br><span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>&#125;<br>else <span class="hljs-built_in">if</span> (arr[<span class="hljs-built_in">mid</span>] &gt; k)<br>&#123;<br><span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>&#125;<br>else<br>&#123;<br>printf(<span class="hljs-string">&quot;找到了 %d&quot;</span>, <span class="hljs-built_in">mid</span>);<br>break;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &gt; <span class="hljs-built_in">right</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;找不到&quot;</span>);<br>&#125;<br><br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d75f5663cdc54391923d9623b0eb92c0.png"></p><h1 id="2-字符串从两边向中间汇聚"><a href="#2-字符串从两边向中间汇聚" class="headerlink" title="2.字符串从两边向中间汇聚"></a>2.字符串从两边向中间汇聚</h1><blockquote><p>我们同时介绍一下sleep函数，于system函数</p><p>Sleep函数是Windows系统给的，在windows.h的头文件里面，可以给程序一点延迟输出，单位是毫秒，Sleep（x），x为多少毫秒</p><p>system函数，执行 dos(windows系统) 或 shell(<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=Linux" title="Linux">Linux</a>&#x2F;Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。</p><p>常见的有system（pause）暂停程序</p><p>system（cls）为清空屏幕</p></blockquote><blockquote><p> 用一个str1来接收str里的字符串</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span><span class="hljs-comment">//</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;hello  world&quot;</span>;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> right = <span class="hljs-built_in">strlen</span>(str)- <span class="hljs-number">1</span>;<br><span class="hljs-comment">//可以用两个数组</span><br><span class="hljs-comment">//一个放原字符串，另一个放拷贝的过程</span><br><span class="hljs-comment">//#################</span><br><span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;############&quot;</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right)<span class="hljs-comment">//但是太快了，要让他慢一点</span><br>&#123;<br>str1[left] = str[left];<br>str1[right] = str[right];<br>left++;<br>right--;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str1);<br><span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<span class="hljs-comment">//睡眠函数，单位是毫秒</span><br><span class="hljs-comment">//system这个函数是用来执行系统命令的</span><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-comment">//清理函数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单链表完整版</title>
    <link href="/2021/11/04/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%8C%E6%95%B4%E7%89%88/"/>
    <url>/2021/11/04/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%8C%E6%95%B4%E7%89%88/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>实现单链表的头插头删，尾插尾删，中间插入，中间删除，查找</p><p>slist.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> slistdate;<span class="hljs-comment">//对int重命名，只会方便把int改成double或其他数据类型</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span><br>&#123;<br>slistdate date;<span class="hljs-comment">//</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span>*next;<span class="hljs-comment">//指针地址，指向下一个节点</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span> slistnode;<span class="hljs-comment">//方便写</span><br><br><span class="hljs-comment">//可能会改变链表的头指针就传二级指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpushback</span><span class="hljs-params">(slistnode**pphead, slistdate x)</span></span>;<span class="hljs-comment">//尾插</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpushfront</span><span class="hljs-params">(slistnode**pphead, slistdate x)</span></span>;<span class="hljs-comment">//头插</span><br><span class="hljs-comment">//不会改变链表的头指针，就传一级指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistprint</span><span class="hljs-params">(slistnode*phead)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpopback</span><span class="hljs-params">(slistnode**pphead)</span></span>;<span class="hljs-comment">//尾删</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpopfront</span><span class="hljs-params">(slistnode**pphead)</span></span>;<span class="hljs-comment">//头删</span><br><br><span class="hljs-function">slistnode* <span class="hljs-title">slistnodefind</span><span class="hljs-params">(slistnode*pphead, slistdate x)</span></span>;<span class="hljs-comment">//找某一个节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistinsert</span><span class="hljs-params">(slistnode**pphead, slistnode* pos,slistdate x)</span></span>;<span class="hljs-comment">//插入一个节点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slisterase</span><span class="hljs-params">(slistnode**pphead, slistnode* pos, slistdate x)</span></span>;<br></code></pre></td></tr></table></figure><p>slist.c </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-comment">#include&quot;slist.h&quot;</span><br><br><br>void slistprint(slistnode*phead)<br>&#123;<br>slistnode*cur = phead;<br><span class="hljs-keyword">while</span> (cur != NULL)<span class="hljs-regexp">//</span>遍历是cur不等于空就往下走，走到尾部还不等于空，走到下一个节点，是空的<br>&#123;<br>printf(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, cur-&gt;date);<br>cur = cur-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span>cur指向下一个指针<br>&#125;<br>printf(<span class="hljs-string">&quot;NULL\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-regexp">//</span>开辟节点做的事情很多次，所以直接用一个函数去做开辟节点的事情就可以了<br><br>slistnode*buynode(slistdate x)<br>&#123;<br>slistnode*newnode = (slistnode*)malloc(sizeof(slistnode));<span class="hljs-regexp">//</span> 要尾插就要动态开辟一个节点出来<br>newnode-&gt;date = x;<span class="hljs-regexp">//</span>将newnode初始化<br>newnode-&gt;<span class="hljs-keyword">next</span> = NULL;<span class="hljs-regexp">//</span>把<span class="hljs-keyword">next</span>赋值为空<br>return newnode;<br>&#125;<br><br><br>void slistpushback(slistnode**pphead, slistdate x)<br>&#123;<br>slistnode*newnode = buynode(x);<br><span class="hljs-regexp">//</span>那么我们这个时候要找尾<br><span class="hljs-regexp">//</span>找到尾节点的指针<br><span class="hljs-keyword">if</span> (*pphead == NULL)<br>&#123;<br>*pphead = newnode;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>slistnode*tail = *pphead;<span class="hljs-regexp">//</span>我们要让tail走到尾部去，而非走到空<br><span class="hljs-keyword">while</span> (tail-&gt;<span class="hljs-keyword">next</span> != NULL)<br>&#123;<br>tail = tail-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<span class="hljs-regexp">//</span>找到了尾节点,链接新节点<br>tail-&gt;<span class="hljs-keyword">next</span>=newnode;<br>&#125;<br>&#125;<br><br><br>void slistpushfront(slistnode**pphead, slistdate x)<br>&#123;<br><span class="hljs-regexp">//</span>头插<br><span class="hljs-regexp">//</span>也要malloc出来一个节点<br>slistnode*newnode = buynode(x);<br>newnode-&gt;<span class="hljs-keyword">next</span> = *pphead;<span class="hljs-regexp">//</span>指向头节点，随后要让phead存第一个节点的地址<br>*pphead = newnode;<span class="hljs-regexp">//</span>phead存入newnode地址，phead作为头节点，就把newnode当作了头节点<br>&#125;<br><br><br><br><br><span class="hljs-regexp">//</span>尾删要分<span class="hljs-number">3</span>种情况分析<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.没有节点<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>.一个节点<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>.多个节点<br>void slistpopback(slistnode**pphead)<span class="hljs-regexp">//</span>尾删<br>&#123;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.想删除就找到那个节点，free掉就可以了，因为都是malloc出来的<br><span class="hljs-regexp">//</span>但是，如果将tail找到了那个尾节点，直接free掉，那么前一个节点的指针就会变成野指针，它的指针仍有存在值，但是没有指向的目标，<br><span class="hljs-regexp">//</span>因此，我们要找到它的前一个节点，再定义一个prev，作为尾节点找到最后一个节点，他的前一个节点<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.没有节点,即*pphead没有指向，就直接返回不用删除<br><span class="hljs-keyword">if</span> (*pphead == NULL)<br>&#123;<br>return;<br>&#125;<br><span class="hljs-regexp">//</span>只有一个节点<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*pphead)-&gt;<span class="hljs-keyword">next</span> == NULL)<span class="hljs-regexp">//</span>由于*和-&gt;的优先级相同，所以为了不报错，就应该把*pphead用括号包含<br>&#123;<br><span class="hljs-regexp">//</span>直接free掉<span class="hljs-number">8</span><br>free(*pphead);<br>*pphead = NULL;<span class="hljs-regexp">//</span>再将*pphead置成空指针，防止它变成野指针<br>&#125;<br><span class="hljs-regexp">//</span>有多个节点<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-regexp">//</span>先定义tail用来找尾，prev找尾前一个节点<br>slistnode*tail = *pphead;<br>slistnode*prev = NULL;<span class="hljs-regexp">//</span>prev置成空指针<br><span class="hljs-regexp">//</span>找尾节点<br><span class="hljs-keyword">while</span> (tail-&gt;<span class="hljs-keyword">next</span> != NULL)<br>&#123;<br>prev = tail;<br>tail = tail-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br><span class="hljs-regexp">//</span>此时prev就是尾节点<br>free(tail);<br>prev-&gt;<span class="hljs-keyword">next</span> = NULL;<br>&#125;<br>&#125;<br><br><br>void slistpopfront(slistnode**pphead)<span class="hljs-regexp">//</span>头删<br>&#123;<br><span class="hljs-regexp">//</span>先保存它下一个指针，<span class="hljs-keyword">next</span><br>slistnode*<span class="hljs-keyword">next</span> = (*pphead)-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span><span class="hljs-keyword">next</span>保存第二个节点的地址，之后将其作为第一个节点<br><span class="hljs-regexp">//</span>删除头节点<br>free(*pphead);<br>*pphead = <span class="hljs-keyword">next</span>;<br>&#125;<br><br>slistnode* slistnodefind(slistnode*pphead, slistdate x)<span class="hljs-regexp">//</span>找某一个节点<br>&#123;<br>slistnode*cur = pphead;<br><span class="hljs-keyword">while</span> (cur)<br>&#123;<br><span class="hljs-keyword">if</span> (cur-&gt;date == x)<span class="hljs-regexp">//</span>找到了要找的数据<br>&#123;<br>return cur;<span class="hljs-regexp">//</span>就把cur的数据返回<br>&#125;<br>cur = cur-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br>return NULL;<span class="hljs-regexp">//</span>找节点，节点是slistnode*的数据，因此返回值也应该要是slistnode*来接收，没找到，就返回空指针<br>&#125;<br><br>void slistinsert(slistnode**pphead, slistnode* pos, slistdate x)<span class="hljs-regexp">//</span>插入一个节点<span class="hljs-regexp">//</span>插入一个节点<br>&#123;<br><span class="hljs-regexp">//</span>要插入一个节点，首先就是要先malloc一个节点<br><span class="hljs-regexp">//</span>有头插的可能如果pos指向第一个节点，又要插入一个节点，就相当于头插，<br><span class="hljs-keyword">if</span> (pos == *pphead)<br>&#123;<br>slistpushfront(pphead, <span class="hljs-number">30</span>);<br>&#125;<br><br>slistnode *newnode = buynode(<span class="hljs-number">30</span>);<br><span class="hljs-regexp">//</span>pos的前一个节点的<span class="hljs-keyword">next</span>指向newnode，newnode—&gt;<span class="hljs-keyword">next</span>=pos<br><span class="hljs-regexp">//</span>要用一个prev来找到pos的前一个<br>slistnode*prev = *pphead;<br><span class="hljs-keyword">while</span> (prev-&gt;<span class="hljs-keyword">next</span> != pos)<br>&#123;<br>prev = prev-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br><span class="hljs-regexp">//</span>找到了<br>prev-&gt;<span class="hljs-keyword">next</span> = newnode;<br>newnode-&gt;<span class="hljs-keyword">next</span> = pos;<br>&#125;<br><br><span class="hljs-regexp">//</span>删除pos处的位置，要让前一个指向后一个，<br>void slisterase(slistnode**pphead, slistnode* pos, slistdate x)<br>&#123;<br>slistnode* prev = *pphead;<br><span class="hljs-regexp">//</span>假如pos是在头部,那么就找不到它的前一个<br><br><span class="hljs-keyword">if</span> (pos == *pphead)<br>&#123;<br><span class="hljs-regexp">//</span>相当于头删<br>slistpopfront(pphead);<br> &#125;<br><span class="hljs-regexp">//</span>也要找到前一个，前一个的<span class="hljs-keyword">next</span>指向后一个<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">while</span> (prev-&gt;<span class="hljs-keyword">next</span> != pos)<br>&#123;<br>prev = prev-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br>prev-&gt;<span class="hljs-keyword">next</span> = pos-&gt;<span class="hljs-keyword">next</span>;<br>free(pos);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>test.c </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-comment">#include&quot;slist.h&quot;</span><br><span class="hljs-regexp">//</span>链表的概念及结构<br><span class="hljs-regexp">//</span>链表是一种物理存储结构上非连续，非顺序的存储结构，数据元素的逻辑结构是通过链表中的指针来链接<br><br><br>void testslist()<br>&#123;<br>slistnode*plist = NULL;<span class="hljs-regexp">//</span>一开始定义一个指针，但啥都没有，所以先赋值空指针，作为头节点，存入第一个节点的地址<br>slistpushback(&amp;plist, <span class="hljs-number">1</span>);<span class="hljs-regexp">//</span>尾插<span class="hljs-regexp">//</span>也要传地址才可以，实参传给形参，形参是实参的临时拷贝<br>slistpushback(&amp;plist, <span class="hljs-number">2</span>);<br>slistpushback(&amp;plist, <span class="hljs-number">3</span>);<br>slistpushback(&amp;plist, <span class="hljs-number">4</span>);<br>slistpushfront(&amp;plist, <span class="hljs-number">0</span>);<span class="hljs-regexp">//</span>头插<br>slistpopback(&amp;plist);<br>slistpopfront(&amp;plist);<span class="hljs-regexp">//</span>头删<br>slistnodefind(plist, <span class="hljs-number">3</span>);<span class="hljs-regexp">//</span>找某一个节点<br>slistnode*pos = slistnodefind(plist, <span class="hljs-number">3</span>);<span class="hljs-regexp">//</span>把要插入到位置找出来，pos就是现在指向的位置<br><span class="hljs-keyword">if</span> (pos)<span class="hljs-regexp">//</span>pos不等于空才会进入这个里面<br>&#123;<br>slistinsert(&amp;plist, pos, <span class="hljs-number">32</span>);<span class="hljs-regexp">//</span>在pos指向的位置插入数据为<span class="hljs-number">30</span>的节点<br>&#125;<br>slistnode*p = slistnodefind(plist, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (p)<br>&#123;<br>slisterase(&amp;plist, p, <span class="hljs-number">2</span>);<br>&#125;<br><br>slistprint(plist);<br>&#125;<br>int main()<br>&#123;<br><span class="hljs-regexp">//</span>需要定义一个指针指向头部<br>testslist();<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表 数据结构 c++ 后端 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之链表2</title>
    <link href="/2021/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A82/"/>
    <url>/2021/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A82/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>实现链表的头插</p><p>test.c</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;slist.h&quot;</span></span><br><span class="hljs-comment">//链表的概念及结构</span><br><span class="hljs-comment">//链表是一种物理存储结构上非连续，非顺序的存储结构，数据元素的逻辑结构是通过链表中的指针来链接</span><br><br><br>void testslist()<br><span class="hljs-punctuation">&#123;</span><br>slistnode*<span class="hljs-attr">plist</span> <span class="hljs-operator">=</span> NULL<span class="hljs-punctuation">;</span><span class="hljs-comment">//一开始定义一个指针，但啥都没有，所以先赋值空指针，作为头节点，存入第一个节点的地址</span><br>slistpushback(<span class="hljs-variable">&amp;plist</span>, <span class="hljs-number">1</span>)<span class="hljs-punctuation">;</span><span class="hljs-comment">//尾插//也要传地址才可以，实参传给形参，形参是实参的临时拷贝</span><br>slistpushback(<span class="hljs-variable">&amp;plist</span>, <span class="hljs-number">2</span>)<span class="hljs-punctuation">;</span><br>slistpushback(<span class="hljs-variable">&amp;plist</span>, <span class="hljs-number">3</span>)<span class="hljs-punctuation">;</span><br>slistpushback(<span class="hljs-variable">&amp;plist</span>, <span class="hljs-number">4</span>)<span class="hljs-punctuation">;</span><br>slistpushfront(<span class="hljs-variable">&amp;plist</span>, <span class="hljs-number">0</span>)<span class="hljs-punctuation">;</span><span class="hljs-comment">//头插</span><br>slistpopback(<span class="hljs-variable">&amp;plist</span>)<span class="hljs-punctuation">;</span><br>slistpopfront(<span class="hljs-variable">&amp;plist</span>)<span class="hljs-punctuation">;</span><span class="hljs-comment">//头删</span><br>slistprint(plist)<span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br>int main()<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-comment">//需要定义一个指针指向头部</span><br>testslist()<span class="hljs-punctuation">;</span><br><br>return <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>slist.c </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-comment">#include&quot;slist.h&quot;</span><br><br><br>void slistprint(slistnode*phead)<br>&#123;<br>slistnode*cur = phead;<br><span class="hljs-keyword">while</span> (cur != NULL)<span class="hljs-regexp">//</span>遍历是cur不等于空就往下走，走到尾部还不等于空，走到下一个节点，是空的<br>&#123;<br>printf(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, cur-&gt;date);<br>cur = cur-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span>cur指向下一个指针<br>&#125;<br>printf(<span class="hljs-string">&quot;NULL\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-regexp">//</span>开辟节点做的事情很多次，所以直接用一个函数去做开辟节点的事情就可以了<br><br>slistnode*buynode(slistdate x)<br>&#123;<br>slistnode*newnode = (slistnode*)malloc(sizeof(slistnode));<span class="hljs-regexp">//</span> 要尾插就要动态开辟一个节点出来<br>newnode-&gt;date = x;<span class="hljs-regexp">//</span>将newnode初始化<br>newnode-&gt;<span class="hljs-keyword">next</span> = NULL;<span class="hljs-regexp">//</span>把<span class="hljs-keyword">next</span>赋值为空<br>return newnode;<br>&#125;<br><br><br>void slistpushback(slistnode**pphead, slistdate x)<br>&#123;<br>slistnode*newnode = buynode(x);<br><span class="hljs-regexp">//</span>那么我们这个时候要找尾<br><span class="hljs-regexp">//</span>找到尾节点的指针<br><span class="hljs-keyword">if</span> (*pphead == NULL)<br>&#123;<br>*pphead = newnode;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>slistnode*tail = *pphead;<span class="hljs-regexp">//</span>我们要让tail走到尾部去，而非走到空<br><span class="hljs-keyword">while</span> (tail-&gt;<span class="hljs-keyword">next</span> != NULL)<br>&#123;<br>tail = tail-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<span class="hljs-regexp">//</span>找到了尾节点,链接新节点<br>tail-&gt;<span class="hljs-keyword">next</span>=newnode;<br>&#125;<br>&#125;<br><br><br>void slistpushfront(slistnode**pphead, slistdate x)<br>&#123;<br><span class="hljs-regexp">//</span>头插<br><span class="hljs-regexp">//</span>也要malloc出来一个节点<br>slistnode*newnode = buynode(x);<br>newnode-&gt;<span class="hljs-keyword">next</span> = *pphead;<span class="hljs-regexp">//</span>指向头节点，随后要让phead存第一个节点的地址<br>*pphead = newnode;<span class="hljs-regexp">//</span>phead存入newnode地址，phead作为头节点，就把newnode当作了头节点<br>&#125;<br><br><br><br><br><span class="hljs-regexp">//</span>尾删要分<span class="hljs-number">3</span>种情况分析<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.没有节点<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>.一个节点<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>.多个节点<br>void slistpopback(slistnode**pphead)<span class="hljs-regexp">//</span>尾删<br>&#123;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.想删除就找到那个节点，free掉就可以了，因为都是malloc出来的<br><span class="hljs-regexp">//</span>但是，如果将tail找到了那个尾节点，直接free掉，那么前一个节点的指针就会变成野指针，它的指针仍有存在值，但是没有指向的目标，<br><span class="hljs-regexp">//</span>因此，我们要找到它的前一个节点，再定义一个prev，作为尾节点找到最后一个节点，他的前一个节点<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.没有节点,即*pphead没有指向，就直接返回不用删除<br><span class="hljs-keyword">if</span> (*pphead == NULL)<br>&#123;<br>return;<br>&#125;<br><span class="hljs-regexp">//</span>只有一个节点<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*pphead)-&gt;<span class="hljs-keyword">next</span> == NULL)<span class="hljs-regexp">//</span>由于*和-&gt;的优先级相同，所以为了不报错，就应该把*pphead用括号包含<br>&#123;<br><span class="hljs-regexp">//</span>直接free掉<span class="hljs-number">8</span><br>free(*pphead);<br>*pphead = NULL;<span class="hljs-regexp">//</span>再将*pphead置成空指针，防止它变成野指针<br>&#125;<br><span class="hljs-regexp">//</span>有多个节点<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-regexp">//</span>先定义tail用来找尾，prev找尾前一个节点<br>slistnode*tail = *pphead;<br>slistnode*prev = NULL;<span class="hljs-regexp">//</span>prev置成空指针<br><span class="hljs-regexp">//</span>找尾节点<br><span class="hljs-keyword">while</span> (tail-&gt;<span class="hljs-keyword">next</span> != NULL)<br>&#123;<br>prev = tail;<br>tail = tail-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br><span class="hljs-regexp">//</span>此时prev就是尾节点<br>free(tail);<br>prev-&gt;<span class="hljs-keyword">next</span> = NULL;<br>&#125;<br>&#125;<br><br><br>void slistpopfront(slistnode**pphead)<span class="hljs-regexp">//</span>头删<br>&#123;<br><span class="hljs-regexp">//</span>先保存它下一个指针，<span class="hljs-keyword">next</span><br>slistnode*<span class="hljs-keyword">next</span> = (*pphead)-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span><span class="hljs-keyword">next</span>保存第二个节点的地址，之后将其作为第一个节点<br><span class="hljs-regexp">//</span>删除头节点<br>free(*pphead);<br>*pphead = <span class="hljs-keyword">next</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>slist.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> slistdate;<span class="hljs-comment">//对int重命名，只会方便把int改成double或其他数据类型</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span><br>&#123;<br>slistdate date;<span class="hljs-comment">//</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span>*next;<span class="hljs-comment">//指针地址，指向下一个节点</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span> slistnode;<span class="hljs-comment">//方便写</span><br><br><span class="hljs-comment">//可能会改变链表的头指针就传二级指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpushback</span><span class="hljs-params">(slistnode**pphead, slistdate x)</span></span>;<span class="hljs-comment">//尾插</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpushfront</span><span class="hljs-params">(slistnode**pphead, slistdate x)</span></span>;<span class="hljs-comment">//头插</span><br><span class="hljs-comment">//不会改变链表的头指针，就传一级指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistprint</span><span class="hljs-params">(slistnode*phead)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpopback</span><span class="hljs-params">(slistnode**pphead)</span></span>;<span class="hljs-comment">//尾删</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpopfront</span><span class="hljs-params">(slistnode**pphead)</span></span>;<span class="hljs-comment">//头删</span><br></code></pre></td></tr></table></figure><p>1.头插实现</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe">void slistpushfront(slistnode**pphead, slistdate x)<br>&#123;<br><span class="hljs-comment">//头插</span><br><span class="hljs-comment">//也要malloc出来一个节点</span><br>slistnode*<span class="hljs-keyword">new</span><span class="hljs-type">node</span> = buynode(x);<br><span class="hljs-keyword">new</span><span class="hljs-type">node</span>-&gt;next = *pphead;<span class="hljs-comment">//指向头节点，随后要让phead存第一个节点的地址</span><br>*pphead = <span class="hljs-keyword">new</span><span class="hljs-type">node</span>;<span class="hljs-comment">//phead存入newnode地址，phead作为头节点，就把newnode当作了头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/966ee2f44da7485997bb3ae0e43a8742.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>2.头删</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">void slistpopfront(slistnode**pphead)<span class="hljs-regexp">//</span>头删<br>&#123;<br><span class="hljs-regexp">//</span>先保存它下一个指针，<span class="hljs-keyword">next</span><br>slistnode*<span class="hljs-keyword">next</span> = (*pphead)-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span><span class="hljs-keyword">next</span>保存第二个节点的地址，之后将其作为第一个节点<br><span class="hljs-regexp">//</span>删除头节点<br>free(*pphead);<br>*pphead = <span class="hljs-keyword">next</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>4.尾删</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>尾删要分<span class="hljs-number">3</span>种情况分析<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.没有节点<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>.一个节点<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>.多个节点<br>void slistpopback(slistnode**pphead)<span class="hljs-regexp">//</span>尾删<br>&#123;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.想删除就找到那个节点，free掉就可以了，因为都是malloc出来的<br><span class="hljs-regexp">//</span>但是，如果将tail找到了那个尾节点，直接free掉，那么前一个节点的指针就会变成野指针，它的指针仍有存在值，但是没有指向的目标，<br><span class="hljs-regexp">//</span>因此，我们要找到它的前一个节点，再定义一个prev，作为尾节点找到最后一个节点，他的前一个节点<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.没有节点,即*pphead没有指向，就直接返回不用删除<br><span class="hljs-keyword">if</span> (*pphead == NULL)<br>&#123;<br>return;<br>&#125;<br><span class="hljs-regexp">//</span>只有一个节点<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*pphead)-&gt;<span class="hljs-keyword">next</span> == NULL)<span class="hljs-regexp">//</span>由于*和-&gt;的优先级相同，所以为了不报错，就应该把*pphead用括号包含<br>&#123;<br><span class="hljs-regexp">//</span>直接free掉<span class="hljs-number">8</span><br>free(*pphead);<br>*pphead = NULL;<span class="hljs-regexp">//</span>再将*pphead置成空指针，防止它变成野指针<br>&#125;<br><span class="hljs-regexp">//</span>有多个节点<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-regexp">//</span>先定义tail用来找尾，prev找尾前一个节点<br>slistnode*tail = *pphead;<br>slistnode*prev = NULL;<span class="hljs-regexp">//</span>prev置成空指针<br><span class="hljs-regexp">//</span>找尾节点<br><span class="hljs-keyword">while</span> (tail-&gt;<span class="hljs-keyword">next</span> != NULL)<br>&#123;<br>prev = tail;<br>tail = tail-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br><span class="hljs-regexp">//</span>此时prev就是尾节点<br>free(tail);<br>prev-&gt;<span class="hljs-keyword">next</span> = NULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表 list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小练习</title>
    <link href="/2021/11/01/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/11/01/%E5%B0%8F%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C%C2%A0" title="求整数段和 ">求整数段和 </a></p><p><a href="#%E9%99%8D%E4%BB%B7%E6%8F%90%E9%86%92%E6%9C%BA%E5%99%A8%E4%BA%BA" title="降价提醒机器人">降价提醒机器人</a></p><p><a href="#%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87" title="调和平均">调和平均</a></p><p><a href="#%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0%C2%A0" title="水仙花数 ">水仙花数 </a></p><p><a href="#%C2%A0%E8%BE%93%E5%87%BA%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AD%97%E7%AC%A6%E9%98%B5%E5%88%97%C2%A0" title=" 输出三角形字符阵列 "> 输出三角形字符阵列 </a></p><h1 id="求整数段和"><a href="#求整数段和" class="headerlink" title="**求整数段和 **"></a>**求整数段和 **</h1><blockquote><p>给定两个整数A和B，输出从A到B的所有整数以及这些数的和。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出2个整数A和B，其中−100≤A≤B≤100，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按<code>Sum = X</code>的格式输出全部数字的和<code>X</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-3 8</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">   -3   -2   -1   <span class="hljs-number"> 0 </span>   1<br>   <span class="hljs-number"> 2 </span>  <span class="hljs-number"> 3 </span>  <span class="hljs-number"> 4 </span>  <span class="hljs-number"> 5 </span>   6<br>   <span class="hljs-number"> 7 </span>   8<br>Sum = 30<br></code></pre></td></tr></table></figure><p> </p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-keyword">int</span> main()<br>&#123;<br><span class="hljs-keyword">int</span> Sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> A,B;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br>scanf(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;A,&amp;B);<br><span class="hljs-keyword">for</span>(i=A;i&lt;=B;i++)<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>,i);<br>count++;<br><span class="hljs-keyword">if</span>(count%5==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>Sum+=i;<br>&#125;<br>    <span class="hljs-keyword">if</span>(count%5!=<span class="hljs-number">0</span>)<br>    &#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Sum = %d\n&quot;</span>,Sum);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/becda3920a7440eebc5211dbaf23c77e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_13,color_FFFFFF,t_70,g_se,x_16"></p><p> <img src="https://img-blog.csdnimg.cn/a3adcf6616ce4c66869f6a9753110c53.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_13,color_FFFFFF,t_70,g_se,x_16"></p><p> </p><h1 id="降价提醒机器人"><a href="#降价提醒机器人" class="headerlink" title="降价提醒机器人"></a>降价提醒机器人</h1><blockquote><p>小 T 想买一个玩具很久了，但价格有些高，他打算等便宜些再买。但天天盯着购物网站很麻烦，请你帮小 T 写一个降价提醒机器人，当玩具的当前价格比他设定的价格便宜时发出提醒。</p><h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行是两个正整数 N 和 M (1≤N≤100,0≤M≤1000)，表示有 N 条价格记录，小 T 设置的价格为 M。</p><p>接下来 N 行，每行有一个实数 Pi​（−1000.0&lt;Pi​&lt;1000.0），表示一条价格记录。</p><h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一条比设定价格 M 便宜的价格记录 <code>P</code>，在一行中输出 <code>On Sale! P</code>，其中 <code>P</code> 输出到小数点后 1 位。</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">99</span><br><span class="hljs-number">98.0</span><br><span class="hljs-number">97.0</span><br><span class="hljs-number">100.2</span><br><span class="hljs-number">98.9</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">On</span> Sale! <span class="hljs-number">98</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">On</span> Sale! <span class="hljs-number">97</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">On</span> Sale! <span class="hljs-number">98</span>.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></blockquote><p> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f %f&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">float</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f&quot;</span>,&amp;p);<br>        <span class="hljs-keyword">if</span>(p&lt;m)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;On Sale! %.1f\n&quot;</span>,p);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/1306f3597a1e48268996dbd2ab3d72f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_9,color_FFFFFF,t_70,g_se,x_16"></p><p> </p><h1 id="调和平均"><a href="#调和平均" class="headerlink" title="调和平均"></a>调和平均</h1><blockquote><p>调和平均</p><p>N 个正数的<strong>算数平均</strong>是这些数的和除以 N，它们的<strong>调和平均</strong>是它们倒数的算数平均的倒数。本题就请你计算给定的一系列正数的调和平均值。</p><h3 id="输入格式：-2"><a href="#输入格式：-2" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 N (≤1000)；第 2 行给出 N 个正数，都在区间 [0.1,100] 内。</p><h3 id="输出格式：-2"><a href="#输出格式：-2" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出给定数列的调和平均值，输出小数点后2位。</p><h3 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span><br><span class="hljs-attribute">10</span> <span class="hljs-number">15</span> <span class="hljs-number">12</span>.<span class="hljs-number">7</span> <span class="hljs-number">0</span>.<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">13</span> <span class="hljs-number">1</span> <span class="hljs-number">15</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">61</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> b=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> s=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f&quot;</span>,&amp;b);<br>        s+=<span class="hljs-number">1.0</span>/b;<br>    &#125;<br>    <span class="hljs-type">float</span> ave=s/n;<br>    <span class="hljs-type">float</span> l=<span class="hljs-number">1.0</span>/ave;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7e6b69ab034b40d0be937541ec484ace.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h1><blockquote><p>水仙花数 </p><p>水仙花数是指一个N位正整数（N≥3），它的每个位上的数字的N次幂之和等于它本身。例如：153&#x3D;13+53+33。 本题要求编写程序,计算所有N位水仙花数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中给出一个正整数N（3≤N≤7）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按递增顺序输出所有N位水仙花数，每个数字占一行。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">153<br>370<br>371<br>407<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,n<span class="hljs-number">-1</span>);i&lt;<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,n);i++)<br>    &#123;<br>        j=i;<br>        <span class="hljs-keyword">while</span>(j!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> a=j%<span class="hljs-number">10</span>;<br>            j/=<span class="hljs-number">10</span>;<br>            s+=<span class="hljs-built_in">pow</span>(a,n);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s==i)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>        &#125;<br>        s=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/639d4b1522924bebb2b5bf66a5da120c.png"></p><h1 id="输出三角形字符阵列"><a href="#输出三角形字符阵列" class="headerlink" title="输出三角形字符阵列"></a>输出三角形字符阵列</h1><blockquote><p> 输出三角形字符阵列 </p><p>本题要求编写程序，输出n行由大写字母A开始构成的三角形字符阵列。</p><h3 id="输入格式：-3"><a href="#输入格式：-3" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个正整数n（1≤n&lt;7）。</p><h3 id="输出格式：-3"><a href="#输出格式：-3" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出n行由大写字母A开始构成的三角形字符阵列。格式见输出样例，其中每个字母后面都有一个空格。</p><h3 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span> <span class="hljs-variable">B</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span> <br><span class="hljs-built_in">E</span> <span class="hljs-variable">F</span> <span class="hljs-variable">G</span> <br><span class="hljs-variable">H</span> <span class="hljs-built_in">I</span> <br><span class="hljs-variable">J</span> <br></code></pre></td></tr></table></figure><p> </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;A&#x27;</span>;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n-i;j++)<br>        &#123;<br><br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,a++);<br>        <br>        &#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3d9ca1bbac5a4c07ab06ae18d9b05d7f.png"></p>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之链表（1）</title>
    <link href="/2021/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%EF%BC%881%EF%BC%89/"/>
    <url>/2021/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p> </p><p>1。实现链表的尾插</p><p>图形结构示意图 </p><p><img src="https://img-blog.csdnimg.cn/85560f3690104801a8b0e7304d3e10a6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><blockquote><p> slist.h </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> slistdate;<span class="hljs-comment">//对int重命名，只会方便把int改成double或其他数据类型</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span><br>&#123;<br>slistdate date;<span class="hljs-comment">//</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span>*next;<span class="hljs-comment">//指针地址，指向下一个节点</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">slistnode</span> slistnode;<span class="hljs-comment">//方便写</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistpushback</span><span class="hljs-params">(slistnode**pphead, slistdate x)</span></span>;<span class="hljs-comment">//尾插</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slistprint</span><span class="hljs-params">(slistnode*phead)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>slist.c </p></blockquote><p> </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-comment">#include&quot;slist.h&quot;</span><br><br><br>void slistprint(slistnode*phead)<br>&#123;<br>slistnode*cur = phead;<br><span class="hljs-keyword">while</span> (cur != NULL)<span class="hljs-regexp">//</span>遍历是cur不等于空就往下走，走到尾部还不等于空，走到下一个节点，是空的<br>&#123;<br>printf(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, cur-&gt;date);<br>cur = cur-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span>cur指向下一个指针<br>&#125;<br>printf(<span class="hljs-string">&quot;NULL\n&quot;</span>);<br>&#125;<br><br><br>void slistpushback(slistnode**pphead, slistdate x)<br>&#123;<br>slistnode*newnode = (slistnode*)malloc(sizeof(slistnode));<span class="hljs-regexp">//</span> 要尾插就要动态开辟一个节点出来<br>newnode-&gt;date = x;<span class="hljs-regexp">//</span>将newnode初始化<br>newnode-&gt;<span class="hljs-keyword">next</span> = NULL;<span class="hljs-regexp">//</span>把<span class="hljs-keyword">next</span>赋值为空<br><span class="hljs-regexp">//</span>那么我们这个时候要找尾<br><span class="hljs-regexp">//</span>找到尾节点的指针<br><span class="hljs-keyword">if</span> (*pphead == NULL)<br>&#123;<br>*pphead = newnode;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>slistnode*tail = *pphead;<span class="hljs-regexp">//</span>我们要让tail走到尾部去，而非走到空<br><span class="hljs-keyword">while</span> (tail-&gt;<span class="hljs-keyword">next</span> != NULL)<br>&#123;<br>tail = tail-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<span class="hljs-regexp">//</span>找到了尾节点,链接新节点<br>tail-&gt;<span class="hljs-keyword">next</span>=newnode;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> </p><blockquote><p>text.c </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;slist.h&quot;</span></span><br><span class="hljs-comment">//链表的概念及结构</span><br><span class="hljs-comment">//链表是一种物理存储结构上非连续，非顺序的存储结构，数据元素的逻辑结构是通过链表中的指针来链接</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testslist</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>slistnode*plist = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//一开始定义一个指针，但啥都没有，所以先赋值空指针</span><br><span class="hljs-built_in">slistpushback</span>(&amp;plist, <span class="hljs-number">1</span>);<span class="hljs-comment">//尾插//也要传地址才可以，实参传给形参，形参是实参的临时拷贝</span><br><span class="hljs-built_in">slistpushback</span>(&amp;plist, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">slistpushback</span>(&amp;plist, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">slistpushback</span>(&amp;plist, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">slistprint</span>(plist);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//需要定义一个指针指向头部</span><br><span class="hljs-built_in">testslist</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8b9424689321487fba0bd8ef8c1dfc1d.png"></p>]]></content>
    
    
    <categories>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵相关练习</title>
    <link href="/2021/10/31/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/10/31/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%8A%A0" title="矩阵相加">矩阵相加</a></p><p><a href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98" title="矩阵相乘">矩阵相乘</a></p><p><a href="#%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC90%C2%B0" title="矩阵顺时针旋转90°">矩阵顺时针旋转90°</a></p><hr><h1 id="1-矩阵相加"><a href="#1-矩阵相加" class="headerlink" title="1.矩阵相加"></a>1.矩阵相加</h1><p>分析</p><p><img src="https://img-blog.csdnimg.cn/95122a564e4d4a618f55696e0d162ebf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs prolog">int main()<br>&#123;<br>int a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125; &#125;;<br>int b[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">6</span>&#125; &#125;;<br>int c[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>int i, j;<br>for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br>c[i][j] = a[i][j] + b[i][j];<br>&#125;<br><br>&#125;<br>for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br>printf(<span class="hljs-string">&quot;%-4d&quot;</span>, c[i][j]);<br>&#125;<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h1><p>分析</p><p><img src="https://img-blog.csdnimg.cn/cc70a71e5de94590a7a899ee430a55c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs prolog">int main()<br>&#123;<br>int a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125; &#125;;<br>int b[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125; &#125;;<br>int c[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>int i, j, k;<br>for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>&#123;<br>for (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++)<br>&#123;<br>c[i][j] += a[i][k] * b[k][j];<br>&#125;<br>&#125;<br>&#125;<br>for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>for (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>&#123;<br>printf(<span class="hljs-string">&quot;%-5d&quot;</span>, c[i][j]);<br>&#125;<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/b389c60e133b4311aff9a60bc2fd03c1.png"></p><h1 id="矩阵实现顺时针旋转90°"><a href="#矩阵实现顺时针旋转90°" class="headerlink" title="矩阵实现顺时针旋转90°"></a>矩阵实现顺时针旋转90°</h1><blockquote><p><a href="https://leetcode-cn.com/problems/rotate-image/" title=". 旋转图像">. 旋转图像</a></p><p>给定一个 _n _× <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title=" 原地"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8f15a422ce89857db5159bab83b7aec0.png"></p><p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br><strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]</p><p><strong>示例 2：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1fea7be501ecdd1cee949a479a802828.png"></p><p><strong>输入：</strong>matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>matrix &#x3D; [[1]]<br><strong>输出：</strong>[[1]]</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>matrix &#x3D; [[1,2],[3,4]]<br><strong>输出：</strong>[[3,1],[4,2]]</p></blockquote><p> 分析</p><p><img src="https://img-blog.csdnimg.cn/162f4e87e93d4e14813fc8fa8529ece4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_17,color_FFFFFF,t_70,g_se,x_16"></p><p> </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">int main()<br>&#123;<br>int arr[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>int i = <span class="hljs-number">0</span>;<br>int <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span>;<br>int n;<br><span class="hljs-keyword">scanf(&quot;%d&quot;, </span>&amp;n);<br>for (i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; n; i++)</span><br>&#123;<br>for (<span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; n; j++)</span><br>&#123;<br><span class="hljs-keyword">scanf(&quot;%d&quot;, </span>&amp;arr[i][<span class="hljs-keyword">j]);</span><br><span class="hljs-keyword"></span>&#125;<br>&#125;<br>int <span class="hljs-keyword">b[10][10] </span>= &#123; <span class="hljs-number">0</span> &#125;;<br>for (i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; n; i++)</span><br>&#123;<br>for (<span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; n; j++)</span><br>&#123;<br> <span class="hljs-keyword">b[i][j] </span>= arr[i][<span class="hljs-keyword">j];</span><br><span class="hljs-keyword"></span>&#125;<br>&#125;<br>for(i=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;n;i++)</span><br><br>&#123;<br>for (<span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; n; j++)</span><br>&#123;<br><br>arr[<span class="hljs-keyword">j][n </span>- <span class="hljs-number">1</span> - i]=<span class="hljs-keyword">b[i][j];</span><br><span class="hljs-keyword"></span><br><br>&#125;<br>&#125;<br><br><br>for (i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; n; i++)</span><br>&#123;<br>for (<span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; n; j++)</span><br>&#123;<br>printf(<span class="hljs-string">&quot;%d &quot;</span>, arr[i][<span class="hljs-keyword">j]);</span><br><span class="hljs-keyword"></span>&#125;<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> </p><p><img src="https://img-blog.csdnimg.cn/7e5a975e34b54aefbac6bd0186b2642a.png"></p><p> </p><p>同理若逆时针旋转思想也是类似的，有兴趣的可以去做做逆时针旋转90°</p>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端 矩阵 算法 线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用字符串函数</title>
    <link href="/2021/10/30/%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <url>/2021/10/30/%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">长度不受限的字符串</a></p><p><a href="#strlen">strlen</a></p><p><a href="#strcpy">strcpy</a></p><p><a href="#strcpy%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcpy模拟实现</a></p><p><a href="#strcat">strcat</a></p><p><a href="#strcat%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcat模拟实现</a></p><p><a href="#strcmp">strcmp</a></p><p><a href="#strcmp%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">strcmp模拟实现</a></p><p><a href="#%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">长度受限的字符串函数</a></p><p><a href="#strncpy">strncpy</a></p><p><a href="#strncat">strncat</a></p><p><a href="#strncmp">strncmp</a></p><p><a href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">其他类型的字符串函数</a></p><p><a href="#strstr">strstr</a></p><p><a href="#strtok">strtok</a></p><p><a href="#strerror">strerror</a></p><hr><h1 id="长度不受限的字符串函数"><a href="#长度不受限的字符串函数" class="headerlink" title="长度不受限的字符串函数"></a>长度不受限的字符串函数</h1><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><blockquote><p>size_t strlen（char *str)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//strlen，记到\0为止</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> arr1[] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span> &#125;;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(arr1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, len);<span class="hljs-comment">//len是一个随机数,因为一直往后不知道什么时候会找到\0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> strlen 的返回值为size_t无符号数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;abc&quot;</span>) - <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;abcdef&quot;</span>) &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//3-6=-3,正常情况下是小于0，但无符号数-无符号数=无符号数，因此，-3是一个无符号数,最高位就不认为是符号位了</span><br><span class="hljs-comment">//是一个非常大的数，1000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="hljs-comment">//                  1111 1111 1111 1111 1111 1111 1111 1101</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;abc&quot;</span>) - <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;abcdef&quot;</span>));<span class="hljs-comment">//无符号数把补码最高位1不认为是符号位，打印了出来</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><blockquote><p>strcpy<br>注意事项<br>1.源字符串必须以\0结束，<br>2.同时会将字符串拷贝到目标空间里面去<br>3.目标空间必须足够大，来存放源字符串，否者程序就会崩溃<br>4.目标空间必须可变，源字符串必须不可变<br>4.arr1的字符大于arr2，arr1后面的也会消失</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;#########&quot;</span>;<br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;abcde&quot;</span>;<span class="hljs-comment">//这是一个常量字符串，不可被改变，p指向的是字符串首元素地址，h的地址</span><br><span class="hljs-comment">//arr=&quot;hello&quot;这是错误的</span><br><span class="hljs-built_in">strcpy</span>(arr, p);<span class="hljs-comment">//把p里面的内容拷贝到arr里面，同时arr后面内容也会消失，等同于一个p</span><br><span class="hljs-type">char</span> arr1[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> arr2[<span class="hljs-number">20</span>]=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<span class="hljs-comment">//没有遇到\0，会一直找，就是一个随机值</span><br><span class="hljs-built_in">strcpy</span>(arr1, arr2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, arr1);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strcpy的模拟实现"><a href="#strcpy的模拟实现" class="headerlink" title="strcpy的模拟实现"></a>strcpy的模拟实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">mystrcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span></span><br><span class="hljs-function"><span class="hljs-comment">//const修饰*src的内容就不能改变了,这里可以用char*来接收返回值，也可以用void</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (*dest++ = *src++)<span class="hljs-comment">//*dest++到\0的时候就不会继续循环了</span><br>&#123;<br>;<br>&#125;<br><span class="hljs-keyword">return</span> *dest;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-built_in">mystrcpy</span>(arr, p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, arr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h2><blockquote><p>strcat<br>把源字符串接到目标字符串的后面<br>源字符串必须以\0结尾<br>\0会被覆盖<br>会将源字符串的\0拷贝到目标空间里面去<br>目标空间必须足够大<br>目标空间必须可变</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr1[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;hello &quot;</span>;<br><span class="hljs-type">char</span> arr2[] = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-built_in">strcat</span>(arr1, arr2);<span class="hljs-comment">//把world追加到arr1的后面</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, arr1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-built_in">strcat</span>(arr, arr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, arr);<span class="hljs-comment">//无法在自己的后面追加自己，\0被覆盖了，不断重复的追加,找不到结束的\0了</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟实现strcat"><a href="#模拟实现strcat" class="headerlink" title="模拟实现strcat"></a>模拟实现strcat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">mystrcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">char</span> *src)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">while</span> (*dest)<br> &#123;<br>dest++ ;<br> &#125;<span class="hljs-comment">//首先要先让dest指向\0处，指向\0为0就是假就不会继续循环了</span><br><span class="hljs-comment">//arr1拷贝到arr里面去</span><br><span class="hljs-keyword">while</span> (*dest++ = *src++)<br>&#123;<br>;<br>&#125;<br><span class="hljs-keyword">return</span> *dest;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot; hacb &quot;</span>;<br><span class="hljs-type">char</span> arr1[] = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-built_in">mystrcat</span>(arr, arr1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, arr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-type">char</span> *q = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-keyword">if</span> (p &gt; q)<span class="hljs-comment">//p和q比的地址</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;anc&quot;</span>&gt;<span class="hljs-string">&quot;cbcd&quot;</span>)<span class="hljs-comment">//表达式分别是a和c的地址</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;abbb&quot;</span>, <span class="hljs-string">&quot;abf&quot;</span>);<span class="hljs-comment">//b&lt;c,返回&lt;0</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ret);<span class="hljs-comment">//</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟实现strcmp"><a href="#模拟实现strcmp" class="headerlink" title="模拟实现strcmp"></a>模拟实现strcmp</h3><blockquote><p>strcmp字符串比较函数<br>比较的是字符串的大小，（ascll）<br>int strcmp(const char *p1,const char *p2)<br>如果p1的那个字符大于p2的那个字符，就会返回&gt;0，从左到右比较 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mystrcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(s1&amp;&amp;s2);<span class="hljs-comment">//断言s1，s2不是空指针</span><br><span class="hljs-keyword">while</span> (*s1 == *s2)<br>&#123;<br><span class="hljs-keyword">if</span> (*s1 == <span class="hljs-string">&#x27;\0&#x27;</span>||*s2==<span class="hljs-string">&#x27;\0&#x27;</span>)<span class="hljs-comment">//当发现其中有一个等于\0就返回0</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>s1++;<br>s2++;<br>&#125;<br><span class="hljs-keyword">if</span> (*s1 &gt; *s2)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> *s1 - *s2;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> *q = <span class="hljs-string">&quot;abbb&quot;</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">mystrcmp</span>(p, q);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ret);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="长度受限的字符串函数"><a href="#长度受限的字符串函数" class="headerlink" title="长度受限的字符串函数"></a>长度受限的字符串函数</h1><h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr1[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> arr2[] = <span class="hljs-string">&quot;qwer&quot;</span>;<br><span class="hljs-comment">//strncpy(arr1, arr2, 2);//把arr2的前两个拷贝到arr1里面//qwcdef</span><br><span class="hljs-comment">//strcpy(arr1, arr2);</span><br><span class="hljs-built_in">strncpy</span>(arr1, arr2, <span class="hljs-number">6</span>);<span class="hljs-comment">//arr2拷贝过去\0也会被拷贝过去，arr2的字符小于6，但也只会拷贝arr2所有元素加\0</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, arr1);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strncat"><a href="#strncat" class="headerlink" title="strncat"></a>strncat</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr1[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;hello &quot;</span>;<br><span class="hljs-type">char</span> arr2[] = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-comment">//strncat(arr1, arr2, 2);//在arr后面2个元素</span><br><span class="hljs-built_in">strncat</span>(arr1, arr2, <span class="hljs-number">10</span>);<span class="hljs-comment">//hello world\0,即使数多余arr2，也只会追加一个</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, arr1);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> *q = <span class="hljs-string">&quot;abcqwert&quot;</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">strncmp</span>(p, q, <span class="hljs-number">4</span>);<span class="hljs-comment">//选前四个进行一一比较</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ret);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他的一些字符串函数"><a href="#其他的一些字符串函数" class="headerlink" title="其他的一些字符串函数"></a>其他的一些字符串函数</h1><h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h2><blockquote><p>char *strstr(const char *str1,const char* str2)<br>如果找到了就会返回str2在str1中首地址，否则返回空指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr1[] = <span class="hljs-string">&quot;abcdefabcdef&quot;</span>;<br><span class="hljs-type">char</span> arr2[] = <span class="hljs-string">&quot;bcd&quot;</span>;<br><span class="hljs-type">char</span> *ret = <span class="hljs-built_in">strstr</span>(arr1, arr2);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找不到&quot;</span>);<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟实现strstr"><a href="#模拟实现strstr" class="headerlink" title="模拟实现strstr"></a>模拟实现strstr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#inlcude<span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">mystrstr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(str1&amp;&amp;str2);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1 = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//s1来移动判断是否有和str2有相同元素</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2 = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//s2如果能走到\0就找到了</span><br><span class="hljs-type">char</span> *cp = str1;<span class="hljs-comment">//cp来记录如果s1走下去没有，cp就往下走一位</span><br><span class="hljs-keyword">while</span> (*cp)<br>&#123;<br>s1 = cp;<span class="hljs-comment">//s1从cp的位置的位置开始走</span><br>s2 = str2;<span class="hljs-comment">//s2从str2的首元素位置开始走</span><br><span class="hljs-keyword">while</span> (*s1&amp;&amp;*s2 &amp;&amp; (*s1 == *s2))<span class="hljs-comment">//*s1走到\0或者*s2走到\0就不继续循环了，</span><br>&#123;<br><span class="hljs-comment">//*s1和*s2相等的话，就开始循环，循环到*s1或者*s其中一方到\0就跳出循环</span><br>s1++;<br>s2++;<br>&#125;<br><span class="hljs-keyword">if</span> (*s2 == <span class="hljs-string">&#x27;\0&#x27;</span>)<span class="hljs-comment">//如果*s到达\0，就代表找到了，</span><br>&#123;<br><span class="hljs-keyword">return</span> cp;<br>&#125;<br>cp++;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr1[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> arr2[] = <span class="hljs-string">&quot;cde&quot;</span>;<br><span class="hljs-type">char</span> *ret = <span class="hljs-built_in">mystrstr</span>(arr1, arr2);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找不到&quot;</span>);<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h2><blockquote><p>strtok(char *str,const char*sep)<br>1990.02.19&#x2F;&#x2F;..就是分隔符号的集合<br>sep参数是一个字符串，定义了用作分隔符的字符集合<br>第一个参数指定一个字符串，他包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记<br>strtok函数找到str中的下一个标记，并将其用\0结尾，返回一个指向这个标记的指针首元素地址，<br>strtok函数的第一个参数部位NULL，函数找到str中第一个标记，strtok函数保存他在字符串中的位置<br>strtok函数第一个参数为NULL，函数将同一个字符串被保存的位置开始，查找下一个标记，<br>如果不存在更多的标记，则返回NULL指针 </p></blockquote><blockquote></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;1990.02.20&quot;</span>;<br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;..&quot;</span>;<br><span class="hljs-type">char</span> tmp[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">strcpy</span>(tmp, arr);<span class="hljs-comment">//tmp中拷贝了arr的元素</span><br><span class="hljs-type">char</span>* ret = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//在没有考虑好要赋什么值的时候将其置为空指针</span><br>ret=<span class="hljs-built_in">strtok</span>(tmp, p);<span class="hljs-comment">//tmp到第一个分隔符停止补上\0</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, ret);<br> ret = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, p);<span class="hljs-comment">//此后每次使用第一个位置都是NULL</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, ret);<br> ret = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, ret);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;1990.02.20&quot;</span>;<br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;..&quot;</span>;<br><span class="hljs-type">char</span> tmp[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">strcpy</span>(tmp, arr);<br><span class="hljs-type">char</span> *ret = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (ret = <span class="hljs-built_in">strtok</span>(tmp, p); ret != <span class="hljs-literal">NULL</span>; ret = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, p))<span class="hljs-comment">//ret比到最后就变成空指针，不是空指针就不会继续循环</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,ret);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h2><blockquote><p>strerror&#x2F;&#x2F;把错误码翻译成对应的错误信息<br>char *strerror(int errnum)<br>errno是一个全局的错误码<br>要包含头文件<br>#include&lt;&gt;<br>使用库函数的时候，有可能会调用库函数失败的时候，都会设置一个错误码， int errno </p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-keyword">int</span> main()<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, strerror(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, strerror(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, strerror(<span class="hljs-number">2</span>));<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, strerror(<span class="hljs-number">3</span>));<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, strerror(<span class="hljs-number">4</span>));<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, strerror(<span class="hljs-number">5</span>));<br>FILE * pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span> (pf == NULL)<br>&#123;<br>perror(<span class="hljs-string">&quot;%s&quot;</span>,strerror(errno));<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>fclose(pf);<br>pf = NULL;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只会我会将代码上传到我的gitee仓库上</p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言 开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言程序的预处理</title>
    <link href="/2021/10/27/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <url>/2021/10/27/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="程序的翻译环境"><a href="#程序的翻译环境" class="headerlink" title="程序的翻译环境"></a>程序的翻译环境</h2><h2 id="程序的执行环境"><a href="#程序的执行环境" class="headerlink" title="程序的执行环境"></a>程序的执行环境</h2><h2 id="详解C语言程序的编译-链接"><a href="#详解C语言程序的编译-链接" class="headerlink" title="详解C语言程序的编译+链接"></a>详解C语言程序的编译+链接</h2><h2 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>预处理指令#define</p><h2 id="宏和函数的对比"><a href="#宏和函数的对比" class="headerlink" title="宏和函数的对比"></a>宏和函数的对比</h2><h2 id="预处理操作符-和-的介绍"><a href="#预处理操作符-和-的介绍" class="headerlink" title="预处理操作符#和##的介绍"></a>预处理操作符#和##的介绍</h2><h2 id="命令定义"><a href="#命令定义" class="headerlink" title="命令定义"></a>命令定义</h2><h2 id="预处理指令-include"><a href="#预处理指令-include" class="headerlink" title="预处理指令#include"></a>预处理指令#include</h2><p> </p><h2 id="程序的翻译环境-1"><a href="#程序的翻译环境-1" class="headerlink" title="程序的翻译环境"></a>程序的翻译环境</h2><blockquote><p>程序的翻译环境和执行环境<br>在任何c的实现中都存在两种不同的环境<br>1.翻译环境就是在这环境中源代码被转换为可执行的机器指令<br>2.执行环境就是实际执行代码</p></blockquote><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>程序的执行环境</p><blockquote><p>3.运行环境<br>1）.程序必须载入内存中，在有操作系统的环境中，这一般由操作系统完成，<br>在独立的环境中，程序的载入必须由手工安排，也可能通过可执行代码置入只读内存来完成(嵌入式）<br>2）.程序的执行便开始，接着调用main函数<br>3）.开始执行程序代码，这时候程序将使用一个运行时的堆栈（栈帧）(并不包括堆)，在使用完后就将他的地址回收，存储函数的局部变量和返回地址，<br>程序同时也可以使用静态（static）内存，存储与静态内存中的变量在程序的整个执行过程一直保存他们的值。<br>4）.终止程序，正常终止main函数，也可能意外终止</p></blockquote><h2 id="详解C语言程序的编译-链接-1"><a href="#详解C语言程序的编译-链接-1" class="headerlink" title="详解C语言程序的编译+链接"></a>详解C语言程序的编译+链接</h2><p><img src="https://img-blog.csdnimg.cn/339854a9fc374988aaf63d1fb8c9e4aa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>预定义符号</p><blockquote><p>__FILE__打印当前文件所在的路径</p><p>__LINE__打印当前代码所在函数</p><p>__DATE__打印当前日期</p><p>__TIME__打印当前时间</p></blockquote><p><img src="https://img-blog.csdnimg.cn/91629671b1664f63aa05ca24ee70a684.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/7ac7a77847f143f895a77e3959270c03.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="预处理指令-define"><a href="#预处理指令-define" class="headerlink" title="预处理指令#define"></a>预处理指令#define</h2><blockquote><p>define定义符号，可以提升代码的可读性</p><p>不仅可以定义数字，也可以定义代码，关键字，或者符号，</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ret register<span class="hljs-comment">//用ret来替换registr</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> do_forever for( ; ;)<span class="hljs-comment">//死循环</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x int*</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ret <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    do_forever;<br>    <span class="hljs-type">int</span> a = m;<span class="hljs-comment">//100</span><br>    x p=&amp;a;<span class="hljs-comment">//p为int*的指针变量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> x int *</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> * INT<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>x a,b;<br>INT c,d;<br><span class="hljs-comment">//其中只有b不是指针</span><br><span class="hljs-comment">//因为define只完成代码的替换，替换成了int* a,b//a是指针，b不是指针</span><br><span class="hljs-comment">//而typedef是对类型的重命名，</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>宏和函数的对比</p><blockquote><p>define 定义宏，同样是完成替换<br>#define机制包括一个规定，把常数替换到文本中，这种实现形式就叫做宏，或定义宏，<br>参数左括号必须与函数名紧邻，若中间又有空格，就会被解释为stuff中的成员,不可吝啬括号</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//不可以吝啬括号</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> square(x) x*x<span class="hljs-comment">//建议把x加个括号（x），将其当做一个整体，括号很重要</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double(x) (x)+(x)<span class="hljs-comment">//将之当成一个整体才可以</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> doubl(x) ((x)+(x))</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">square</span>(<span class="hljs-number">3</span>));<span class="hljs-comment">//会被替换成printf（&quot;%d&quot;,3*3）;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">square</span>(<span class="hljs-number">3</span> + <span class="hljs-number">1</span>));<span class="hljs-comment">//7!=16,会被替换，宏的参数是完成替换的，不是计算的，不经过任何计算直接传过去</span><br><span class="hljs-comment">//会被替换成printf(&quot;%d&quot;,3+1*3+1))//7</span><br><span class="hljs-comment">//加括号就变成了（3+1）*（3+1）</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">10</span> * <span class="hljs-built_in">double</span>(<span class="hljs-number">4</span>));<span class="hljs-comment">//这样写也是有问题的，会被替换成10*（4）+（4）=44</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">10</span> * <span class="hljs-built_in">doubl</span>(<span class="hljs-number">4</span>));<span class="hljs-comment">//这样就可以了;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>再调用宏的时候，首先对参数进行检查，是否有define定义的符号<br>宏不能递归，而函数可以<br>当预处理时，字符串常量不能被替换，如printf（“”）里的不被替换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">max</span>(<span class="hljs-number">101</span>, m);<span class="hljs-comment">//宏替换，</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;m=%d&quot;</span>, m);<span class="hljs-comment">//括号里面的m不被替换</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>预处理操作符#和##的介绍</p><blockquote><p>#可以把参数插入到字符串中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(x) printf(<span class="hljs-string">&quot;the value of &quot;</span> #x <span class="hljs-string">&quot; is %d\n&quot;</span>,x)<span class="hljs-comment">//#x会变成x对于的内容所对于的字符串&quot;a&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello&quot;</span><span class="hljs-string">&quot;world\n&quot;</span>);<span class="hljs-comment">//结果是一样的，</span><br><span class="hljs-comment">//写3个printf()有点冗余，</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">print</span>(a);<br><span class="hljs-comment">//the value of a is 10</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">print</span>(b);<br><span class="hljs-comment">//the value of b is 20</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">print</span>(c);<br><span class="hljs-comment">//the value of b is 30</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>##可以把两个符号合成一个符号，两个符号连在一起</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> cd(x,y) x##y</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> c = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">cd</span>(c, <span class="hljs-number">120</span>));<span class="hljs-comment">//替换成100120</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>带副作用的宏参数 </p><blockquote><p>首先介绍一下什么是副作用</p><p>int a&#x3D;1;<br>int b&#x3D;a+1;&#x2F;&#x2F;b&#x3D;2,a&#x3D;1，没有副作用<br>int b&#x3D;++a&#x2F;&#x2F;b&#x3D;2,而a&#x3D;2这里的a就是有副作用，</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) (x)&gt;(y)?(x):(y)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">max</span>(a++, b++);<br><span class="hljs-comment">//int c = (a++) &gt; (b++) ? (a++) : (b++);替换</span><br><span class="hljs-comment">//5&gt;8不成立，执行完判断语句，a和b就加1，a=6，b=9，则执行b++,但b++是先使用在++</span><br>    <span class="hljs-comment">//c=9，执行完后b=10</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, c);<span class="hljs-comment">//9</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>宏和函数的对比</p><blockquote><p>1.宏比函数在程序的规模上和速度上更胜一筹<br>2.更为重要的是，函数在定义上有数据类型限制，若定义int型数据，则double型数据就无法传参，而宏与类型无关，</p><p>3.命名规定，宏名全部大写，函数名不全部大写（不成文的规定）</p></blockquote><p>命令定义</p><blockquote><p>#undef移除一个宏定义</p><p>#if 加常量表达式，为0为真往下面执行</p><p>#endif为#if的结束标志</p><p>#ifdef 如果定义了就执行下面的代码</p><p>#ifndef 如果没定义就执行下面的代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">undef</span><span class="hljs-comment">//移除一个宏定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = m;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> m<span class="hljs-comment">//把定义的m取消掉</span></span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<span class="hljs-comment">//a就没有值</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//#if 加常量表达式（非0未真就往下执行，直到#endif停止）</span><br><span class="hljs-comment">//#endif为#if的结束标志</span><br><span class="hljs-comment">//#if 0//相当于把下面的代码给注释掉，</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print 1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 1-2<span class="hljs-comment">//1为真就执行，0就为假不执行，非0为真</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> print<span class="hljs-comment">//print为1为真就往下执行下面的代码</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe &quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 1==1<span class="hljs-comment">//判断成立，就往下执行，从多分支只选择一个，选择完下面就不执行跳到#endif去</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hh&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> 1 == 2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//判断是否被定义的写法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> test<span class="hljs-comment">//如果test被定义了，下面参与执行，给个0也可以</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> hh<span class="hljs-comment">//如果hh不定义，下面参与编译</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hehe&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><p>预处理指令#include</p><blockquote><p>文件包含<br>1.&lt;&gt;直接去库函数的头文件所在的目录下查找<br>2.””形式的包含文件，(1).在自己写的代码底下所在的目录去查找，(2).如果1找不到，就在库函数的头文件目录下查找</p><p>嵌套文件包含<br>一个头文件被重复包含两次，有点啰嗦<br>#pragma once&#x2F;&#x2F;头文件只包含一次,不管自己写了多少此，加上这句都只用一次<br>头文件中的ifndef,define ,endif是用来防止文件被多次包含</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【1024程序员节福利！！！】牛客网小练习</title>
    <link href="/2021/10/24/%E3%80%901024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82%E7%A6%8F%E5%88%A9%EF%BC%81%EF%BC%81%EF%BC%81%E3%80%91%E7%89%9B%E5%AE%A2%E7%BD%91%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/10/24/%E3%80%901024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82%E7%A6%8F%E5%88%A9%EF%BC%81%EF%BC%81%EF%BC%81%E3%80%91%E7%89%9B%E5%AE%A2%E7%BD%91%E5%B0%8F%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定秒数 seconds ，把秒转化成小时、分钟和秒。</p><p>数据范围： </p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>一行，包括一个整数，即给定的秒数。</p><h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><p>一行，包含三个整数，依次为输入整数对应的小时数、分钟数和秒数（可能为零），中间用一个空格隔开。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><p>3661</p><p>复制输出：</p><p>1 1 1</p><p>输入</p><p>    9000</p><p>复制输出</p><p>  2  30  0</p><p>输入</p><p>   60</p><p>复制输出</p><p> 0  1  0 </p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    <span class="hljs-keyword">int</span> seconds;<br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;seconds);<br>    <span class="hljs-keyword">int</span> hour,minute,second;<br>    <br>    hour=seconds/<span class="hljs-number">3600</span>;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,hour);<br>    <br>    <br>    second=seconds%60;<br>    <span class="hljs-keyword">if</span>(seconds&gt;<span class="hljs-number">3600</span>)<br>    &#123;<br>seconds-=<span class="hljs-number">3600</span>*hour;<br>        minute=seconds/<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,minute);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,seconds/<span class="hljs-number">60</span>);<br>    &#125;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,second);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果示例</p><p> <img src="https://img-blog.csdnimg.cn/e34409b0fe7f488fbb8d330811d46621.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/b951858e288247deb734f9a5eb2853d3.png"></p><p> <img src="https://img-blog.csdnimg.cn/ce91c2bde87b481ea81cb2bdbd5929e6.png"></p><blockquote><p>BC29 2的n次方计算</p><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>不使用累计乘法的基础上，通过移位运算（&lt;&lt;）实现2的n次方的计算。</p><p>数据范围： </p><h3 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h3><p>一行输入整数n（0 &lt;&#x3D; n &lt; 31）。</p><h3 id="输出描述：-1"><a href="#输出描述：-1" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出对应的2的n次方的结果。</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><p>2</p><p>复制输出：</p><p>4</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">1</span>&lt;&lt;n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 左移动操作符</p></blockquote><blockquote><p>BC7 缩短二进制</p><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>我们处理的整数通常用十进制表示，在计算机内存中是以二进制补码形式存储，但通常二进制表示的整数比较长，为了便于在程序设计过程中理解和处理数据，通常采用八进制和十六<a href="https://www.baidu.com/s?wd=16%E8%BF%9B%E5%88%B6&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" title="进制">进制</a>，缩短了<a href="https://www.baidu.com/s?wd=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" title="二进制补码表示的整数">二进制补码表示的整数</a>，但保持了<a href="https://www.baidu.com/s?wd=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" title="二进制数">二进制数</a>的表达特点。请输出十进制整数1234对应的八进制和十六进制。</p><h3 id="输入描述：-2"><a href="#输入描述：-2" class="headerlink" title="输入描述："></a>输入描述：</h3><p>无</p><h3 id="输出描述：-2"><a href="#输出描述：-2" class="headerlink" title="输出描述："></a>输出描述：</h3><p>十进制整数1234对应的八进制和十六进制（字母大写），用空格分开，并且要求，在八进制前显示前导0，在十六进制数前显示前导0X<strong>。</strong></p><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>printf可以使用使用格式控制串“%o”、“%X”分别输出八进制整数和十六进制整数，并使用修饰符“#”控制前导显示</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1234</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#o %#X&quot;</span>,a,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>#o和#x可以打印出八进制前到0，16进制前导0x</p></blockquote><blockquote><p>BC20 kiki算数</p><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>问题：KiKi今年5岁了，已经能够认识100以内的非负整数，并且并且能够进行 100 以内的非负整数的加法计算。不过，BoBo老师发现KiKi在进行大于等于100的正整数的计算时，规则如下：</p><p>1.       只保留该数的最后两位，例如：对KiKi来说1234等价于34；</p><p>2.       如果计算结果大于等于 100， 那么KIKI也仅保留计算结果的最后两位，如果此两位中十位为0，则只保留个位。</p><p>例如：45+80 &#x3D; 25</p><p>要求给定非负整数 a和 b，模拟KiKi的运算规则计算出 a+b 的值。</p><h3 id="输入描述：-3"><a href="#输入描述：-3" class="headerlink" title="输入描述："></a>输入描述：</h3><p>一行，输入两个非负整数a和b，用一个空格分隔。（0 &lt;&#x3D; a,b&lt;&#x3D; 231-1）。</p><h3 id="输出描述：-3"><a href="#输出描述：-3" class="headerlink" title="输出描述："></a>输出描述：</h3><p>针对每组输入，输出按照KiKi的运算规则计算出 a+b 的值。</p><h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><p>45 80</p><p>复制输出：</p><p>25</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    scanf(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-keyword">if</span>(a+b&lt;<span class="hljs-number">100</span>)<br>    &#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>((a+b)/<span class="hljs-number">10</span>%10==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(a+b)%10);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(a+b)%100);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/62e9d506812749739b6150a1886b50d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_18,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
    <categories>
      
      <category>1024程序员节</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关键字</title>
    <link href="/2021/10/22/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/10/22/%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#static" title="static">static</a></p><p><a href="#extern" title="extern">extern</a></p><p><a href="#define%20%E5%AE%8F" title="define 宏">define 宏</a></p><hr><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>可用在局部变量 全局变量 函数</p><p>1.局部变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()<span class="hljs-comment">//进函数a生命周期开始</span></span><br>&#123;<br> <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">//a局部变量，再进来a还是1，循环往复</span><br>a++;<span class="hljs-comment">//2</span><br>printf(<span class="hljs-string">&quot;%d&quot;</span>, a);<span class="hljs-comment">//2222222222</span><br>&#125;<span class="hljs-comment">//出函数a就销毁了还给操作系统</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>)<br>&#123;<br>test();<br>i++;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br>    c += <span class="hljs-number">1</span>;<br>    b += <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> (a + b + c);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>, <span class="hljs-built_in">sum</span>(a)); <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p> a是main函数里开辟的局部变量，c是sum里面的局部变量，在出sum中就会销毁，而b是被static修饰的静态变量，不会因为出sum就销毁，</p></blockquote><blockquote><p> static修饰局部变量，改变了变量的储存类型，所以这个变量就失去了局部变量的特性，（栈区-&gt;静态区）使得静态的局部变量出了自己的作用域也不会销毁，相当于改变了他的生命周期</p></blockquote><table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td>a</td><td>b</td><td>c</td></tr><tr><td>0</td><td>2</td><td>5</td><td>1</td></tr><tr><td>1</td><td>2</td><td>7</td><td>1</td></tr><tr><td>2</td><td>2</td><td>9</td><td>1</td></tr><tr><td>3</td><td>2</td><td>11</td><td>1</td></tr><tr><td>4</td><td>2</td><td>13</td><td>1</td></tr></tbody></table><blockquote><p>结果是8 10 12 14 16 </p></blockquote><p> </p><p> </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span><br>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">//上一次出的时候a没有销毁，可以根据结果推测，每一次调用test函数使用的a是上一次留下的，</span><br>a++;<span class="hljs-comment">//2</span><br>printf(<span class="hljs-string">&quot;%d&quot;</span>, a);<span class="hljs-comment">//234567891011</span><br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>)<br>&#123;<br>test();<br>i++;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> </p><blockquote><p> 在另一个文件定义的变量不能直接使用，要声明<br>extern int g;&#x2F;&#x2F;使用之前声明，extern是一个关键字，专门用来声名外部符号的 </p></blockquote><blockquote><p>static修饰全局变量，<br> 一个全局变量在整个过程的其他文件内部使用，是因为全局变量具有外部链接属性，当一个全局变量被static修饰的时候，整个变量<br>当一个全局变量被static修饰的时候，整个变量就变成了内部链接属性，使得全局变量只能在自己所在的源文件内部使用，其他文件不能用，<br>static int g &#x3D; 10; </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">在另一个文件定义的变量不能直接使用，要声明<br>test.c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g;<span class="hljs-comment">//使用之前声明，extern是一个关键字，专门用来声名外部符号的</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, g);<span class="hljs-comment">//10</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>g是main.c另一个文件中定义的全局变量<br><span class="hljs-type">int</span> g=<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p> 同理修饰函数和修饰全局变量也是一样的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">add</span>(a, b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//test.c里面的</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="define定义宏"><a href="#define定义宏" class="headerlink" title="define定义宏"></a>define定义宏</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//定义宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> add(a,b)((x)+(y))</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">add</span>(a, b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发语言 后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔</title>
    <link href="/2021/10/18/%E9%9A%8F%E7%AC%94/"/>
    <url>/2021/10/18/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>目录</strong></p><p><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9" title="注意点">注意点</a></p><p><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" title="局部变量与全局变量">局部变量与全局变量</a></p><p><a href="#%E6%95%B0%E7%BB%84" title="数组">数组</a></p><p><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98" title="练习题">练习题</a></p><p><a href="#%E9%A2%981" title="题1">题1</a></p><p><a href="#%E6%B3%951" title="法1">法1</a></p><p><a href="#%E6%B3%952" title="法2">法2</a></p><p><a href="#%E6%B3%953" title="法3">法3</a></p><p><a href="#%E9%A2%982" title="题2">题2</a></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><p>1</p><blockquote><p>在{}的代码块里面定义的变量就叫局部变量，一个局部变量必须要初始化否则就是一个随机值</p><p>脱离代码块的就叫全局变量，倘若局部变量与全局变量冲突时以局部变量为主，若全局变量为初始化，默认为0</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<span class="hljs-comment">//全局变量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<span class="hljs-comment">//局部变量</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> a=<span class="hljs-number">20</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<span class="hljs-comment">//打出的是局部变量10而非20；</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<span class="hljs-comment">//0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[n];<span class="hljs-comment">//[]里面不可以是个未知变量，应该是一个常量</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *arr=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//使用动态开辟的数组</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>练习题</p><p>题1</p><p>法1</p><blockquote><p>本题要求编写程序计算某年某月某日是该年中的第几天。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中按照格式“yyyy&#x2F;mm&#x2F;dd”（即“年&#x2F;月&#x2F;日”）给出日期。注意：闰年的判别条件是该年年份能被4整除但不能被100整除、或者能被400整除。闰年的2月有29天。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行输出日期是该年中的第几天。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2009</span>/<span class="hljs-number">03</span>/<span class="hljs-number">02</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">61<br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2000</span>/<span class="hljs-number">03</span>/<span class="hljs-number">02</span><br></code></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">62<br></code></pre></td></tr></table></figure><p> </p></blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br>int main()<br>&#123;<br>int day;<br>int year, month, date;<br>scanf(&quot;%d/%d/%d&quot;, &amp;year, &amp;month, &amp;date);<br>if ((year %<span class="hljs-number"> 4 </span>==<span class="hljs-number"> 0 </span>&amp;&amp; year %<span class="hljs-number"> 100 </span>!= 0) || year %<span class="hljs-number"> 400 </span>== 0)<br>&#123;<br>if (month &gt;= 3)<br>&#123;<br>if (month == 3)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 4)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 5)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 6)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 7)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 8)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 9)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 10)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 11)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 12)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br><br>&#125;<br>else<br>&#123;<br>if (month == 1)<br>&#123;<br>day = date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 2)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>&#125;<br>&#125;<br>else<br>&#123;<br>if (month == 1)<br>&#123;<br>day = date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 2)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 3)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 4)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 5)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 6)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 7)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 8)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 9)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 10)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 11)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br>if (month == 12)<br>&#123;<br>day =<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 28 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+<span class="hljs-number"> 31 </span>+<span class="hljs-number"> 30 </span>+ date;<br>printf(&quot;%d&quot;, day);<br>&#125;<br><br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>法2</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include&lt;stdio.h&gt;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">year</span>, m, d, <span class="hljs-built_in">date</span>;<br><span class="hljs-built_in">int</span> arr1[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br><span class="hljs-built_in">int</span> arr2[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> ret=<span class="hljs-number">0</span>;<br>scanf(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;<span class="hljs-built_in">year</span>, &amp;m, &amp;d);<br><span class="hljs-built_in">if</span> ((<span class="hljs-built_in">year</span> % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">year</span> % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || <span class="hljs-built_in">year</span> % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)<br>&#123;<br>for (i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>&#123;<br>ret += arr2[i];<br>&#125;<br><span class="hljs-built_in">date</span> = ret + d;<br>&#125;<br>else<br>&#123;<br>for (i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>&#123;<br>ret += arr1[i];<br>&#125;<br><span class="hljs-built_in">date</span> = ret + d;<br>&#125;<br>printf(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">date</span>);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>法3</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include&lt;stdio.<span class="hljs-property">h</span>&gt;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>()<br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-built_in">year</span>, <span class="hljs-built_in">month</span>, <span class="hljs-built_in">day</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;<br><span class="hljs-title function_">scanf</span>(<span class="hljs-string">&quot;%d/%d/%d&quot;</span>, &amp;<span class="hljs-built_in">year</span>, &amp;<span class="hljs-built_in">month</span>, &amp;<span class="hljs-built_in">day</span>);<br><span class="hljs-title function_">switch</span> (<span class="hljs-built_in">month</span>)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: sum = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: sum = <span class="hljs-number">31</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: sum = <span class="hljs-number">59</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: sum = <span class="hljs-number">90</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: sum = <span class="hljs-number">120</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: sum = <span class="hljs-number">151</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: sum = <span class="hljs-number">181</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: sum = <span class="hljs-number">212</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: sum = <span class="hljs-number">243</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: sum = <span class="hljs-number">273</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: sum = <span class="hljs-number">304</span>; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: sum = <span class="hljs-number">334</span>; <span class="hljs-keyword">break</span>;<br>&#125;<br>sum += <span class="hljs-built_in">day</span>;<br><span class="hljs-keyword">if</span> ((<span class="hljs-built_in">year</span> % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">year</span> % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || <span class="hljs-built_in">year</span> % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)<br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">month</span> &gt; <span class="hljs-number">2</span>)<br>sum++;<br><span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我认为还可以用递归做，但我实力有限暂时没想出来 ,如果有人可以做出了欢迎在评论去留言</p><p>题2</p><blockquote><p>某电视台的娱乐节目有个表演评审环节，每次安排两位艺人表演，他们的胜负由观众投票和 3 名评委投票两部分共同决定。规则为：如果一位艺人的观众票数高，且得到至少 1 名评委的认可，该艺人就胜出；或艺人的观众票数低，但得到全部评委的认可，也可以胜出。节目保证投票的观众人数为奇数，所以不存在平票的情况。本题就请你用程序判断谁是赢家。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出 2 个不超过 1000 的正整数 Pa 和 Pb，分别是艺人 a 和艺人 b 得到的观众票数。题目保证这两个数字不相等。随后第二行给出 3 名评委的投票结果。数字 0 代表投票给 a，数字 1 代表投票给 b，其间以一个空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按以下格式输出赢家：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">The</span> winner is x: <span class="hljs-built_in">P1</span> + <span class="hljs-built_in">P2</span><br></code></pre></td></tr></table></figure><p>其中 <code>x</code> 是代表赢家的字母，<code>P1</code> 是赢家得到的观众票数，<code>P2</code> 是赢家得到的评委票数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">327 </span><span class="hljs-number">129</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> winner is a: <span class="hljs-number">327</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-keyword">int</span> main()<br>&#123;<br><span class="hljs-keyword">int</span> Pa, Pb;<br>scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;Pa, &amp;Pb);<br><span class="hljs-keyword">int</span> n1, n2, n3;<br>scanf(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n1, &amp;n2, &amp;n3);<br><span class="hljs-keyword">int</span> count = n1 + n2 + n3;<br><span class="hljs-keyword">int</span> sh;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;The winner is b: %d + %d&quot;</span>, Pb, count);<br>&#125;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;The winner is a: %d + %d&quot;</span>, Pa, count);<br>&#125;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>)<br>&#123;<br>sh = <span class="hljs-number">3</span> - count;<br><span class="hljs-keyword">if</span> ((Pa + sh) &gt;= (Pb + count))<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;The winner is a: %d + %d&quot;</span>, Pa, sh);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;The winner is b: %d + %d&quot;</span>, Pb, count);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">2</span>)<br>&#123;<br>sh = <span class="hljs-number">3</span> - count;<br><span class="hljs-keyword">if</span> ((Pa + sh) &gt;= (Pb + count))<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;The winner is a: %d + %d&quot;</span>, Pa, sh);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;The winner is b: %d + %d&quot;</span>, Pb, count);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java php c++ c#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件</title>
    <link href="/2021/10/18/%E6%96%87%E4%BB%B6/"/>
    <url>/2021/10/18/%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a><strong>文件</strong></h1><p> </p><h1 id="文件的详细介绍"><a href="#文件的详细介绍" class="headerlink" title="文件的详细介绍"></a><strong>文件的详细介绍</strong></h1><p>引子</p><blockquote><p> 文件.在我们前面学习通讯录时，程序运行起来时，可以给通讯录增删查改，但此时数据是存放在内存中，当程序退出时，通讯录的数据就消失了。<br>就很难受，为了使得数据持久化，我们就应该把数据存放在磁盘文件，存放到数据库等方式，磁盘上关机了重启还会在，使数据持久化，因此就需要用到文件</p></blockquote><p><strong>目录</strong></p><p><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">文件的详细介绍</a></p><p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6">什么是文件</a></p><p><a href="#%E6%96%87%E4%BB%B6%E5%90%8D">文件名</a></p><p><a href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88">文件指针</a></p><p><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8">文件的使用</a></p><p><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD">文件的打开与关闭</a></p><p><a href="#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%EF%BC%88%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%89">顺序读写（流的概念）</a></p><p><a href="#fputc">fputc</a></p><p><a href="#fgetc">fgetc</a></p><p><a href="#fputs%20fgets">fputs fgets</a></p><p><a href="#fprintf%EF%BC%8Cfscanf%EF%BC%8Csscanf,sprintf">fprintf，fscanf，sscanf,sprintf</a></p><p><a href="#fwrite%20fread%C2%A0">fwrite fread </a></p><p><a href="#%C2%A0%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96"> 文件的随机读取</a></p><p><a href="#fseek%20ftell%20rewind">fseek ftell rewind</a></p><p><a href="#%C2%A0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E6%9D%9F%E7%9A%84%E5%88%A4%E5%AE%9A"> 文件读取结束的判定</a></p><p><a href="#feof%20ferror">feof ferror</a></p><p><a href="#%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA">文件缓冲区</a></p><hr><h1 id="1-什么是文件"><a href="#1-什么是文件" class="headerlink" title="1 什么是文件"></a>1 什么是文件</h1><blockquote><p>在磁盘上所有的东西都是文件，c盘包括桌面的，<br>但一般在程序设计时，分两种：程序文件和数据文件（从文件的功能进行分类的）<br>程序文件有源程序文件.c，目标文件.obj，可执行文件.exe<br>数据文件，我们写的数据</p></blockquote><h1 id="2-文件名"><a href="#2-文件名" class="headerlink" title="2.文件名"></a>2.文件名</h1><blockquote><p>文件名，一个文件有唯一的文件标识。便于用户使用和识别（绝对路径）<br>文件名包含3个部分：文件路径+文件名主干+文件名后缀<br>如c:\code\test.txt,其中c:\code\是路径名，test叫文件主干名，.txt叫文件的后缀2</p></blockquote><h1 id="3-文件指针"><a href="#3-文件指针" class="headerlink" title="3.文件指针"></a>3.文件指针</h1><blockquote><p>4.文件指针（文件的打开与关闭）<br>每个被使用的文件都开辟了一个相应的文件信息区，用于存放文件的相关信息，<br>（如文件的名字，文件状态及文件当前的位置）这些信息都保持在一个结构体变量中，该结构体类型名叫FILE<br>一般用FILE型指针来维护FILE结构的变量，这样使用起来更加方便<br>FILE* pf,pf是指向FILE型的变量，可以使用pf来指向某个文件信息区，通过文件信息区中的信息就可以访问该文件，即可以通过文件指针变量找到与他相关的文件，</p></blockquote><h1 id="4-文件的使用"><a href="#4-文件的使用" class="headerlink" title="4.文件的使用"></a>4.文件的使用</h1><blockquote><p>文件在读写之前首先要打开文件fopen，在文件使用完之后要关闭文件fclose,fopen返回失败会返回一个空指针，因此每次使用都要判断</p><p>其中fopen原型是FILE * _fopen_(const char * path, const char * mode);</p><p>const char * path是使用的路径，即要在哪个文件中使用</p><p>const char * mode是fopen的打开形式</p><p>常见的模式有”r“，（read）以只读方式打开文件，该文件必须存在。</p><p>”w“（write）打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失;若文件不存在则创建该文件。</p><p>wb是只写打开或新建一个二进制文件，只允许写数据。</p></blockquote><p>例如</p><h2 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h2><p>1.0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FILE *pf=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;tst.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);*<span class="hljs-comment">///&quot;test.dat&quot;是文件名，&quot;w&quot;是打开方式(以写的形式进行创建)（只写）“w”为了 输出数据，打开一个文件，如果指定文件不存在，就新建一个（在此文件中开辟）</span><br>     <span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//写文件</span><br><span class="hljs-comment">//关闭文件（不想要了）</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//可类比动态内存开辟，补不置成空指针就会报错</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FILE *pf=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;D:\\2021\\class\\test.7\\test.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<span class="hljs-comment">//如果文件并不是在此文件下创建的化，同样也不会运行成功，但使用绝对路径是可以的</span><br><span class="hljs-comment">//,单斜杠情况下会将后面理解为转义字符,因此都要使用双斜杠,用于将\打印出来</span><br><br><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//写文件</span><br><span class="hljs-comment">//关闭文件（不想要了）</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><br>FILE *pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;tst.dat&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-comment">//以读的方式打开</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//写文件</span><br><span class="hljs-comment">//关闭文件（不想要了）</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//可类比动态内存开辟，</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件的顺序读写"><a href="#文件的顺序读写" class="headerlink" title="文件的顺序读写"></a>文件的顺序读写</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><blockquote><p>：流，高度抽象的概念，，我们写的程序有时想放屏幕，硬盘，u盘，光盘，网络，程序要操作各种硬件，也就需要各种的读写方式，因此在程序与硬件中抽象出流这个层次<br>我们只有把数据放到流里面去，写文件可以理解为文件流，<br>c语言程序运行起来，就默认打开了3个流<br>stdin-标准输入流–键盘，  stdout标准输出流–屏幕， stderr–标准错误流–屏幕，类型都是FILE*的</p><p> 使用哪个流就在哪个流输出输入</p></blockquote><p>代码2.0</p><h3 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h3><blockquote><p><strong>int fputc(int char, FILE *stream)</strong>把参数 <strong>char</strong> 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FILE *pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<span class="hljs-comment">//以w的形式打开，即使原来有内容也会清空掉，</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//写文件</span><br><span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;b&#x27;</span>, pf);<span class="hljs-comment">//文件字符输入，</span><br><span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;i&#x27;</span>, pf);<br><span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;t&#x27;</span>, pf);<span class="hljs-comment">//便会向test.dat文件中输入bit</span><br><span class="hljs-comment">// 关闭文件</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.1 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;c&#x27;</span>, stdout);<span class="hljs-comment">//便在屏幕上打印了c这字符</span><br><span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;b&#x27;</span>, stdout);<br><span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;a&#x27;</span>, stdout);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 2.2.</p><h3 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc"></a>fgetc</h3><blockquote><p><strong>int fgetc(FILE *stream)</strong> 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-regexp">//</span>文本中输入abcdef<br>int main()<br>&#123;<br>FILE *pf = fopen(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-regexp">//</span>以w的形式打开，即使原来有内容也会清空掉，<br><span class="hljs-keyword">if</span> (pf == NULL)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>return <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-regexp">//</span>读文件,fgetc从文件首字符中一个一个读取<br><span class="hljs-regexp">//i</span>nt ret=fgetc(pf);<span class="hljs-regexp">//</span>从文件流里面读一个字符，可以从文件，也可以从标准输入流中，文件字符输入，如果读取正常，会返回此字符的ascll值，如果读取失败，会返回EOF(-<span class="hljs-number">1</span>)<br><span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;%c&quot;</span>, ret);<br><span class="hljs-regexp">//</span>ret = fgetc(pf);<br><span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;%c&quot;</span>, ret);<span class="hljs-regexp">//</span>读取的都是test.dat<br><br>int ret = fgetc(stdin);<span class="hljs-regexp">//</span>从标准屏幕输入流里面读一个字符，可以从文件，也可以从标准输入流中，文件字符输入，如果读取正常，会返回此字符的ascll值，如果读取失败，会返回EOF(-<span class="hljs-number">1</span>)<br>printf(<span class="hljs-string">&quot;%c&quot;</span>, ret);<br>ret = fgetc(stdin);<br>printf(<span class="hljs-string">&quot;%c&quot;</span>, ret);<span class="hljs-regexp">//</span>读取的都是test.dat，文件结束就会输出EOF为-<span class="hljs-number">1</span><br><br><br>fclose(pf);<br>pf = NULL;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fgets-fputs"><a href="#fgets-fputs" class="headerlink" title="fgets fputs"></a>fgets fputs</h3><blockquote><p>char *fgets(char *str, int n, FILE *stream)从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p></blockquote><blockquote><p><strong>int fputs(const char *str, FILE *stream)</strong> 把字符串写入到指定的流 stream 中，但不包括空字符 </p></blockquote><blockquote><p>我们不仅可以一个字符一个字符的输入与输出，</p><p>我们也可以一行一行的输入与输出</p><p>可以用到fgets，fputs</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FILE*pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<span class="hljs-comment">//以写的形式打开</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//写文件-按行写</span><br><span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;abcdef\n&quot;</span>,pf);<span class="hljs-comment">//s-string写字符串打个\n就可以换行,pf是要写的文件流</span><br><span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;ghijk\n&quot;</span>, pf);<br><br><br><span class="hljs-comment">//用完关闭文件</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>FILE*pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-comment">//以读的形式打开</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//读文件-按行读</span><br><span class="hljs-built_in">fgets</span>(arr, <span class="hljs-number">4</span>, pf);<span class="hljs-comment">//fgets(const char*string,const int n,const stream),n是可以读的最大字符，但多了一个\0n要+1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr);<span class="hljs-comment">//读完从c后开始读</span><br><span class="hljs-built_in">fgets</span>(arr, <span class="hljs-number">4</span>, pf);<span class="hljs-comment">//最多读3个</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, arr);<br><span class="hljs-comment">//用完关闭文件</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fprintf，fscanf，sscanf-sprintf"><a href="#fprintf，fscanf，sscanf-sprintf" class="headerlink" title="fprintf，fscanf，sscanf,sprintf"></a>fprintf，fscanf，sscanf,sprintf</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>&lt;stdio.h</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span><br>&#123;<br><span class="hljs-type">char</span> age[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">float</span> f;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span> a = &#123; <span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">5.5f</span> &#125;;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span> tmp = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">//sprintf是把格式化的数据转化成字符串，</span><br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s %d %f&quot;</span>, a.age, a.a, a.f);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><span class="hljs-comment">//从buf这个字符串中还原出一个结构体</span><br><span class="hljs-comment">//从字符串中读出格式化的数据</span><br><span class="hljs-built_in">sscanf</span>(buf, <span class="hljs-string">&quot;%s %d %f&quot;</span>, tmp.age, &amp;tmp.a, &amp;tmp.f);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d %f&quot;</span>, tmp.age, tmp.a, tmp.f);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><blockquote><p>fprintf（FILE *stream, const char *format，……)除去前面的流，后都和printf一样，</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">a</span><br>&#123;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> num;<br><span class="hljs-type">float</span> sc;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">a</span> s = &#123; <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5.5f</span> &#125;;<br>FILE* pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">fprintf</span>(pf, <span class="hljs-string">&quot;%s %d %f&quot;</span>, s.arr, s.num, s.sc);<span class="hljs-comment">//格式化输出，写入pf文件流，</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>fscanf同scanf多了前面的流</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> main()<br>&#123;<br>struct a s = &#123; <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5.5</span> &#125;;<br>FILE* pf = fopen(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span> (pf == NULL)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>fscanf(pf, <span class="hljs-string">&quot;%s %d %f&quot;</span>, s.arr, &amp;(s.num), &amp;(s.sc));<span class="hljs-regexp">//</span>格式化输出，写入pf文件流<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s %d %f&quot;</span>, s.arr, s.num, s.sc);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fwrite-fread"><a href="#fwrite-fread" class="headerlink" title="fwrite fread"></a>fwrite fread</h3><blockquote><p>fwrite二进制输出 <strong>(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong></p><p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中</p><p>size这是要被写入的每个元素的大小，以字节为单位</p><p><strong>nmemb</strong> -- 这是元素的个数，每个元素的大小为 size 字节</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">a</span> s = &#123; <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5.5</span> &#125;;<br>FILE* pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">fwrite</span>(&amp;s, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> a), <span class="hljs-number">1</span>, pf);<span class="hljs-comment">//二进制输出，写入pf文件流</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> </p><p>与fwrite等同二进制输出</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">a</span> s = &#123; <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5.5</span> &#125;;<br>FILE* pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">fread</span>(&amp;s, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> a), <span class="hljs-number">1</span>, pf);<span class="hljs-comment">//二进制输入，读出pf文件流</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d %f&quot;</span>, s.arr, s.num, s.sc);<br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件的随机读取"><a href="#文件的随机读取" class="headerlink" title="文件的随机读取"></a>文件的随机读取</h2><h3 id="fseek-ftell-rewind"><a href="#fseek-ftell-rewind" class="headerlink" title="fseek ftell rewind"></a>fseek ftell rewind</h3><blockquote><p>文件的随机读取文件的随机读写，根据文件指针的位置和偏移量来定位文件指针<br>fseek（file stream,long offset,int origin）&#x2F;&#x2F;offset偏移量，oringin起始位置，<br>origin有三种状态，SEEK_CUR(从当前位置开始偏移），</p><p>SEEK_END(从文件末尾开始偏移)只能偏移负数，</p><p>SEEK_SET(从文件开头开始偏移</p></blockquote><blockquote><p> 文件随机读取的函数有rewind,让文件指针重新回到起始地址</p><p>ftell判断此时文件指针对于起始位置的偏移量</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> main()<br>&#123; <br>FILE *pf=fopen(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span> (pf == NULL)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>&#125;<br>//顺序读写，从头开始<br><span class="hljs-keyword">int</span> ch = fgetc(pf);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br><br>fseek(pf, <span class="hljs-number">2</span>, SEEK_CUR);<span class="hljs-regexp">//</span>偏移的单位是字节，从当前位置向后偏移两个字节<br>ch = fgetc(pf);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>ch = fgetc(pf);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br><span class="hljs-keyword">int</span> ret = ftell(pf);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ret);<br><span class="hljs-regexp">//</span>让文件指针回到起始位置用rewind（）<br>rewind(pf);<span class="hljs-regexp">//</span>回到起始位置<br><span class="hljs-keyword">int</span> d = ftell(pf);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p> 数据文件与二进制文件</p><blockquote><p>数据文件被称为二进制文件或二进制文件，<br>1000可以把内存中的数据转化为ascll值存储，文本文件，也可以以二进制存储就叫二进制文件 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10000</span>;<span class="hljs-comment">//00002710小端存储会是10 27 00 00</span><br>FILE* pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fopen&quot;</span>);<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-built_in">fwrite</span>(&amp;a, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-number">1</span>, pf);<br><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件读取结束的判定"><a href="#文件读取结束的判定" class="headerlink" title="文件读取结束的判定"></a>文件读取结束的判定</h2><blockquote><p>文件读取结束的判定<br>fgetc函数在读取结束的时候，会返回eof，正常读取的是很好，返回的是读取的字符的ascll值<br>fgets函数在读取结束是，会返回null，正常读取的时候 ，返回的是字符串；<br> fread在读取结束时，返回的是实际读取到的完整元素的个数，如果发现读取到的完整元素的个数小于指定的元素的个数，这就是最后一次读取，<br>判断文件结束的原因的函数是feof </p><p>ferror判断文件结束的原因是出现错误</p></blockquote><blockquote><p>写一个代码把text.txt 文件拷贝一份，生成text2.txt </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FILE *pfd = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;text.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span> (pfd == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>FILE *pw = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;text2.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-keyword">if</span> (pw == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">fclose</span>(pfd);<br>pfd = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//把第一个文件关掉，当第一个文件返回失败才会</span><br>&#125;<br><span class="hljs-comment">//文件打开成功</span><br><span class="hljs-comment">//读写文件</span><br><br><span class="hljs-type">int</span> ch = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((ch = <span class="hljs-built_in">fgetc</span>(pfd)) != EOF)<span class="hljs-comment">//一个字符一个字符的输入直到eof</span><br>&#123;<br><span class="hljs-comment">//写文件</span><br><span class="hljs-built_in">fputc</span>(ch, pw);<br>pw = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">feof</span>(pfd))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;遇到文件结束标志，文件正常结束&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ferror</span>(pfd))<span class="hljs-comment">//判断是否遇到错误</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件读取失败结束&quot;</span>);<br><br>&#125;<br><span class="hljs-built_in">fclose</span>(pfd);<br><br>pfd=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">fclose</span>(pw)<br>pw=<span class="hljs-literal">NULL</span>;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">enum</span> &#123; size = <span class="hljs-number">5</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> a[size] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>FILE *pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<span class="hljs-comment">//必须用二进制模式</span><br><span class="hljs-built_in">fwrite</span>(a, <span class="hljs-keyword">sizeof</span> *a, size, pf);<span class="hljs-comment">//写double的数组</span><br><span class="hljs-built_in">fclose</span>(pf);<br><span class="hljs-type">double</span> b[size];<br>pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">size_t</span> ret_code = <span class="hljs-built_in">fread</span>(b, <span class="hljs-keyword">sizeof</span>*b, size, pf);<span class="hljs-comment">//读double的数组</span><br><span class="hljs-keyword">if</span> (ret_code == size)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;arry read succseefully,contents&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; size; n++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, b[n]);<br><span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">feof</span>(pf))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error reading test.bin:unexpected end of file&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ferror</span>(pf))<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error reading test.bin&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h2><blockquote><p>文件缓冲区<br>从内存中向硬盘输出数据，会先送到内存中的缓冲区，装满之后才会送到硬盘上，<br>如果硬盘向计算机读取数据，则硬盘文件中读取数据集输入到内存缓冲区，充满后<br>再从缓冲区逐个将数据送到程序数据区，</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/96867a2f04bc4961a2c3c0b81c59cafc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FILE *pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;test.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;abcde&quot;</span>, pf);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;睡眠10秒-已经写数据，打开test.txt文件，文件没有内容\n&quot;</span>);<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;刷新缓冲区\n&quot;</span>);<br><span class="hljs-built_in">fflush</span>(pf);<span class="hljs-comment">//刷新缓冲区，才将输出缓冲区的数据写到文件（磁盘）</span><br>    <span class="hljs-comment">//fflush在高端vs上不能使用</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;再睡眠10秒，打开test.txt文件，有内容了&quot;</span>);<br><br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-comment">//缓冲区里的数据</span><br><span class="hljs-built_in">fclose</span>(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>再学习完文件后，我们就可以将通讯录进行优化</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言 数据库 c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言相关练习学习有感2</title>
    <link href="/2021/10/15/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F2/"/>
    <url>/2021/10/15/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="c语言相关练习学习有感2"><a href="#c语言相关练习学习有感2" class="headerlink" title="c语言相关练习学习有感2"></a>c语言相关练习学习有感2</h3><ol><li></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> a = <span class="hljs-number">0</span>, ch;<br><span class="hljs-keyword">while</span> ((ch = <span class="hljs-built_in">getchar</span>()) != <span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-comment">//当getchar输入的不是一个回车时就会进入到while函数里面，</span><br>&#123;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &amp;&amp; (ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>))<br>ch = ch - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;A&#x27;</span>;<br>a++;<br><span class="hljs-built_in">putchar</span>(ch);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/e0b21bc64ef14a359f40fd1a6dfbc37c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> 2.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//i</span>nt main()<br><span class="hljs-regexp">//</span>&#123;<span class="hljs-regexp">//</span>以下哪个选项一定可以将 flag 的第二个 bit 位置 <span class="hljs-number">0</span>，且其它 bit 位不变<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span>int flag = <span class="hljs-number">15</span>;<span class="hljs-regexp">//</span><span class="hljs-number">15</span>是个正数原反补码相同<br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-number">15</span>的二进制表示<span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1111</span><br><span class="hljs-regexp">//</span>int a=flag &amp;= ~<span class="hljs-number">2</span>;<span class="hljs-regexp">//</span>&amp;按位与有个二进制数，两<span class="hljs-number">1</span>为<span class="hljs-number">1</span>，有<span class="hljs-number">0</span>则<span class="hljs-number">0</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-number">2</span> 的二进制表示<span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>结果为        <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span>,第<span class="hljs-number">2</span>个比特位不变，其他都变，不符合<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span>int b=flag != <span class="hljs-number">2</span>;<span class="hljs-regexp">//</span>!=,==是逻辑操作符，成立为<span class="hljs-number">1</span>，不成立为<span class="hljs-number">0</span>，<span class="hljs-number">15</span>！=<span class="hljs-number">2</span>成立，答案为<span class="hljs-number">1</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>         <br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>         <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>只有第一个不变其他<span class="hljs-number">3</span>位都变<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span>int c=flag ^= <span class="hljs-number">2</span>;<span class="hljs-regexp">//</span>^=是按位异或即两<span class="hljs-number">1</span>为<span class="hljs-number">0</span>，有<span class="hljs-number">0</span>则<span class="hljs-number">1</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1111</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>结果为<br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1101</span>符合题目要求<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span>int d=flag &gt;&gt;= <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>&gt;&gt;=二进制向右移动两位，左边补符号位，正数补<span class="hljs-number">0</span>，负数补<span class="hljs-number">1</span>，若是向左移动，右边都是补<span class="hljs-number">0</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1111</span><br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br><span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<span class="hljs-regexp">//</span><span class="hljs-number">13</span><br><span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;%d\n&quot;</span>, b);<span class="hljs-regexp">//</span><span class="hljs-number">1</span><br><span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;%d\n&quot;</span>, c);<span class="hljs-regexp">//</span><span class="hljs-number">15</span><br><span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;%d\n&quot;</span>, d);<span class="hljs-regexp">//</span><span class="hljs-number">3</span><br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span>return <span class="hljs-number">0</span>;<br><span class="hljs-regexp">//</span>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">int main()<br>&#123;<br>int x = <span class="hljs-number">1</span>;<span class="hljs-regexp">//</span><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span>语句是先执行再判断<br><span class="hljs-regexp">//</span><br><span class="hljs-keyword">do</span> &#123;<br>printf(<span class="hljs-string">&quot;%2d\n&quot;</span>, x++);<span class="hljs-regexp">//</span>x++右置++，先使用再++,打印<span class="hljs-number">1</span>，加加后得<span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">while</span> (x--);<span class="hljs-regexp">//</span>同理先使用再--，<span class="hljs-keyword">while</span>（<span class="hljs-number">2</span>）成立--得<span class="hljs-number">1</span>进入循环，死循环<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">int</span> <span class="hljs-string">main()</span><br>&#123;<br><span class="hljs-string">int</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-number">-3</span><span class="hljs-string">;//</span>        <span class="hljs-number">1000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0011</span><br><span class="hljs-string">//反码</span>               <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1100</span><br><span class="hljs-string">//补码</span>               <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1101</span><br><span class="hljs-string">unsigned</span> <span class="hljs-string">int</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;//b位无符号整形0000</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0010</span><br><span class="hljs-string">long</span> <span class="hljs-string">c</span> <span class="hljs-string">=</span> <span class="hljs-string">a</span> <span class="hljs-string">+</span> <span class="hljs-string">b;//长整形</span> <span class="hljs-string">电脑使用补码进行相加减</span><br><span class="hljs-string">//</span>                   <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0010</span><br><span class="hljs-string">//</span>                   <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1101</span><br><span class="hljs-string">//</span>                   <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111</span><br><span class="hljs-string">printf(&quot;%u\n&quot;</span>, <span class="hljs-string">c);//%u是打印无符号整形数，即即使是负数也将其认为是无符号整形数</span>,<span class="hljs-string">以十进制数表示</span><br><span class="hljs-string">//4294967295</span><br><span class="hljs-string">return</span> <span class="hljs-number">0</span><span class="hljs-string">;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li></li></ol><blockquote><p>7-1 真睡还是装睡 (15 分)</p><p>你永远叫不醒一个装睡的人 —— 但是通过分析一个人的呼吸频率和脉搏，你可以发现谁在装睡！医生告诉我们，正常人睡眠时的呼吸频率是每分钟15-20次，脉搏是每分钟50-70次。下面给定一个人的呼吸频率与脉搏，请你判断他是真睡还是装睡（即至少一项指标不在正常睡眠范围内）。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>在一行中输入空格隔开的两个整数，分别表示一个人的呼吸频率和脉搏（均为不超过100的正整数）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果判定此人真睡，则输出 <code>T</code>，否则为装睡，输出 <code>F</code>。</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例 1:"></a>输入样例 1:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">18 </span><span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例 1:"></a>输出样例 1:</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">T</span><br></code></pre></td></tr></table></figure><p>结尾无空行</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> breath, pulse;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;breath, &amp;pulse);<br><span class="hljs-keyword">if</span> (breath &gt;= <span class="hljs-number">15</span> &amp;&amp; breath &lt;= <span class="hljs-number">20</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (pulse &gt;= <span class="hljs-number">50</span> &amp;&amp; pulse &lt;= <span class="hljs-number">70</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;T&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>(<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;F&quot;</span>));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;F&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果 </p><p><img src="https://img-blog.csdnimg.cn/9343602636cb47b7ab5e43b4c6c39f3a.png"></p><p> </p><ol start="6"><li></li></ol><blockquote><p>题述：有一个有序数字序列，从小到大排序，将一个新输入的数插入到序列中，保证插入新数后，序列仍然是升序。</p><p>🍳 输入描述：</p><p>    第一行输入一个整数(0≤N≤50)。</p><p>    第二行输入N个升序排列的整数，输入用空格分隔的N个整数。</p><p>    第三行输入想要进行插入的一个整数。</p><p>🍳 输出描述：</p><p>    输出为一行，N+1个有序排列的整数。</p><p>💨 示例：</p><p>输入：<br>    5<br>    1 6 9 22 30<br>    8<br>输出：<br>    1 6 8 9 22 30<br>————————————————<br>版权声明：本文为CSDN博主「跳动的bit」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wh128341/article/details/120677309">https://blog.csdn.net/wh128341/article/details/120677309</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sort_up</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*e1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*e2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (*(<span class="hljs-type">int</span>*)e1 - *(<span class="hljs-type">int</span>*)e2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-type">int</span> arr[<span class="hljs-number">51</span>];<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>&#125;<br><br><span class="hljs-type">int</span> input;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>arr[n] = input;<br><span class="hljs-built_in">qsort</span>(arr, n + <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]), sort_up);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://img-blog.csdnimg.cn/dcced5a2edd94afa8d017ece639401fd.png"></p>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c语言相关练习理解</title>
    <link href="/2021/10/13/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E7%90%86%E8%A7%A3/"/>
    <url>/2021/10/13/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="c语言相关练习学习有感"><a href="#c语言相关练习学习有感" class="headerlink" title="c语言相关练习学习有感"></a>c语言相关练习学习有感</h1><p>本文是我从csdn上一博主上看到 练习以及一些感悟</p><p> 原题可以去看这个作者的<a href="https://blog.csdn.net/wh128341/article/details/118378330" title="C语言入门必做踩坑题《篇一》_wh128341的博客-CSDN博客">C语言入门必做踩坑题《篇一》_wh128341的博客-CSDN博客</a></p><p>1.递归题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//全局变量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>count++;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret=<span class="hljs-built_in">fib</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ret);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a04bdfb9c338419a8d530bbcd6fe0685.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> 2.栈返回问题，以及全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>a += <span class="hljs-number">2</span>;<span class="hljs-comment">//此处对a的变化并不会改变a的值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<span class="hljs-comment">//返回栈空间的值，离开函数，内存销毁，</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<span class="hljs-comment">//a仍然是1，全局变量</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 3.全局变量的初始化及数据存储，sizeof的使用与比较</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-string">int</span> <span class="hljs-string">i;//i作为全局变量，未初始化，都是0；signed型</span><br><br><span class="hljs-string">int</span> <span class="hljs-string">main()</span><br>&#123;<br><span class="hljs-string">i--;//-1</span><br><span class="hljs-string">if</span> <span class="hljs-string">(i</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">sizeof(i))//sizeof(i)</span> <span class="hljs-string">中计算的结果是unsigned型，</span><br>              <span class="hljs-string">//而此时的i却是一个signed型，两者进行比较，i强制类型转化为unsigned型</span>,<span class="hljs-string">i为-1.</span><br>              <span class="hljs-string">//-1源码1000</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001</span><br>              <span class="hljs-string">//反码1111</span> <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1110</span><br>              <span class="hljs-string">//补码1111</span> <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111</span><span class="hljs-string">&gt;远大于4</span><br>&#123;<br><span class="hljs-string">printf(&quot;&gt;&quot;);//因此结果是&gt;</span><br>&#125;<br><span class="hljs-string">else</span><br>&#123;<br><span class="hljs-string">printf(&quot;&lt;&quot;);</span><br>&#125;<br><span class="hljs-string">return</span> <span class="hljs-number">0</span><span class="hljs-string">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4.数据存储，强制类型转换（有符号在char类型时就强制类型转换成int），数据截断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a = <span class="hljs-number">200</span>;<span class="hljs-comment">//unsigned char 无符号整形，范围是0-256，而signed char 范围是在-127~128</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b = <span class="hljs-number">100</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = <span class="hljs-number">0</span>;<br>c = a + b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, a + b, c);<span class="hljs-comment">//a+b有符号参与就会整形提升a整数原反补相同</span><br><span class="hljs-comment">//00000000 00000000 00000000 11001000 a</span><br><span class="hljs-comment">//00000000 00000000 00000000 01100100 b</span><br><span class="hljs-comment">//00000000 00000000 00000001 00101100 c,结果是300</span><br><span class="hljs-comment">//而c是char类型的，会发生截断8位00101100 结果是44</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.二维数组，强制类型转换，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">5</span>] = &#123; &#123;<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-comment">//</span><br><span class="hljs-type">int</span> *ptr1 = (<span class="hljs-type">int</span>*)(&amp;arr + <span class="hljs-number">1</span>);<span class="hljs-comment">//arr是数组指针，里面存放的指针，强制类型转化为整形指针，</span><br>                             <span class="hljs-comment">//每个元素是int型，&amp;arr取出的是整数数组，&amp;arr+1取到了1后的地址，</span><br><br><span class="hljs-type">int</span> *ptr2 = (<span class="hljs-type">int</span>*)(*(arr + <span class="hljs-number">1</span>));<span class="hljs-comment">//arr除在sizeof内部，和&amp;arr之外，其数组名都是首元素地址，而二维数组的首元素地址是首行的地址</span><br><span class="hljs-comment">//arr+1得到的是第二行的地址，*（arr+1），对第二行进行解引用，得到的是第二行全部的元素，同时又强制转化位（int*）得到的是第二行第一个元素</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>, *(ptr1 - <span class="hljs-number">1</span>), *(ptr2 - <span class="hljs-number">1</span>));<span class="hljs-comment">//*(ptr1 - 1)得到的是1，*(ptr2 - 1)得到的是6</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.强制类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)(&amp;a + <span class="hljs-number">1</span>);<span class="hljs-comment">//&amp;a取出的是a整个数组，&amp;a+1指向1后面的地址，同时强制类型转化位（int*）类型</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d&quot;</span>, *(a + <span class="hljs-number">1</span>), *(ptr - <span class="hljs-number">1</span>));<span class="hljs-comment">//a是首元素地址，a+1是4的地址解引用得到4，ptr-1得到1的地址，解引用得到1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.联合体.大小计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">un</span><span class="hljs-comment">//计算联合体大小</span><br><span class="hljs-comment">//1.联合体大小至少是最大成员的大小，2.联合体内也有内存对齐，</span><br><span class="hljs-comment">//3.当最大对其数非最大对齐数的整数倍时，就要对齐到最大对其数的整数倍</span><br><span class="hljs-comment">//每个元素都从0对齐数开始，取最大值</span><br><br>&#123;<br><span class="hljs-type">short</span> a[<span class="hljs-number">7</span>];<span class="hljs-comment">//最大对齐数为2，2*7=14,！=4的整数倍，故对其数为16，大小为16个字节</span><br><span class="hljs-type">int</span> n;<span class="hljs-comment">//最大对齐数为4</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">union</span> un));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.联合体数据存储.存储方式，大小端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">un</span><br>&#123;<br><span class="hljs-type">short</span> k;<br><span class="hljs-type">char</span> i[<span class="hljs-number">2</span>];<br>&#125;*s, a;<span class="hljs-comment">//*s为指针型，a是变量</span><br>s = &amp;a;<br>s-&gt;i[<span class="hljs-number">0</span>] = <span class="hljs-number">0x39</span>;<span class="hljs-comment">//i[0]是16进制数</span><br>s-&gt;i[<span class="hljs-number">1</span>] = <span class="hljs-number">0x38</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %x\n&quot;</span>,a.k, a.k);<span class="hljs-comment">//vs里面是小端存储，低数据存在内存低地址（从左向右）0x3839</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>9.无符号型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">7</span>;<span class="hljs-comment">//unsigned char 范围为0-255，而signed char 范围为-127到128</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-number">3</span>)<span class="hljs-comment">//unsigned char 做减法并不会变成负数，7~4~1~254~直到i=0时循环停止，j一直加</span><br>&#123;<br>++j;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, j);<span class="hljs-comment">//173</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>r语言 html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>柔性数组</title>
    <link href="/2021/10/13/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
    <url>/2021/10/13/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h3><p>c语言并没有柔性数组这个概念，但他又是实际存在的，结构体中最后一个成员是数组，且未规定内存大小，即可理解为柔性数组</p><blockquote><p>柔性数组的特点<br>1.结构体中柔性数组的成员前面至少有一个其他成员<br>2.sizeof计算结构体大小是不包含柔性数组的内存<br>3.包含柔性数组成员的结构应用malloc进行开辟内存空间，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小</p></blockquote><p>1. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> arr[];<span class="hljs-comment">//大小未知，有的写成int arr[0]也是可以的</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>此时arr就是一个柔性数组</p><ol start="2"><li></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> S<br>&#123;<br><span class="hljs-built_in">int</span> a;<br><span class="hljs-built_in">int</span> arr[];<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>printf(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-keyword">sizeof</span>(s));<span class="hljs-comment">//计算柔性数组的大小，是不包含柔性数组的，只计算它前面的变量</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行的结果是</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>也就是不包括柔性数组的大小，只有他前面成员的大小 </p><p>2.柔性数组应该用malloc进行开辟空间，而不是直接对其进行赋值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> S<br>&#123;<br><span class="hljs-built_in">int</span> a;<br><span class="hljs-built_in">int</span> arr[];<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-keyword">struct</span> S s=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//用malloc函数进行分配,正常不会这样使用</span><br><br>printf(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-keyword">sizeof</span>(s));<span class="hljs-comment">//计算柔性数组的大小，是不包含柔性数组的，只计算它前面的变量</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 正确的使用应该是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> arr[];<span class="hljs-comment">//大小未知，有的写成int arr[0]也是可以的</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>* ptr = (<span class="hljs-keyword">struct</span> S*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> S) + <span class="hljs-number">10</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//10*sizeof(int)给数组的，后面的大小可以通过realloc进行改变</span><br>ptr-&gt;a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>ptr-&gt;arr[i] = i;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>* ps = (<span class="hljs-keyword">struct</span> S*)<span class="hljs-built_in">realloc</span>(ptr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> S) + <span class="hljs-number">20</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">NULL</span>)<br>&#123;<br>ptr = ps;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ptr-&gt;arr);<br><span class="hljs-built_in">free</span>(ptr);<br>ptr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能会有人认为将结构体中的数组改为指针也可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> *arr;<span class="hljs-comment">//在栈上开辟</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span>* ps = (<span class="hljs-keyword">struct</span> s*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> s));<br><span class="hljs-keyword">if</span> (ps == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//先对ps这个指针判断空指针</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>ps-&gt;a = <span class="hljs-number">10</span>;<br>ps-&gt;arr = (<span class="hljs-keyword">struct</span> s*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-number">10</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)));<br><span class="hljs-keyword">if</span> (ps-&gt;arr == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//arr也是一个指针，所以也要判断是否是空针</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>ps-&gt;arr[i] = i;<span class="hljs-comment">//达到和之前一样的效果</span><br>&#125;<br><span class="hljs-comment">//增加</span><br><span class="hljs-type">int</span>*ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(ps-&gt;arr, <span class="hljs-number">20</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">if</span> (ptr != <span class="hljs-literal">NULL</span>)<br>&#123;<br>ps-&gt;arr = ptr;<br>&#125;<br><span class="hljs-comment">//使用</span><br><br><span class="hljs-comment">//释放,ps,和arr都是被malloc开辟出来，要先free指针空间，再free，ps的空间</span><br><span class="hljs-built_in">free</span>(ps-&gt;arr);<br>ps-&gt;arr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">free</span>(ps);<br>ps = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//但是这是有不足的地方，这不是柔性数组，进行了两次malloc同时就会对应两次free，malloc开辟次数越多，内存碎片也越多，内存利用率也就降低了，内存局部性原理，每次使用都是在他周边范围使用</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但实际上他malloc开辟了两次空间，留了过多的内存碎片，使得内存的利用率降低，</p><p>优势.方便开辟。方便释放</p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html c语言 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态内存开辟3</title>
    <link href="/2021/10/11/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F3/"/>
    <url>/2021/10/11/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="动态内存开辟相关试题"><a href="#动态内存开辟相关试题" class="headerlink" title="动态内存开辟相关试题"></a>动态内存开辟相关试题</h2><p>我们此次会介绍关于动态内存开辟的一些试题，错误点，以及原因 </p><ol><li></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-type">char</span>* p)</span><span class="hljs-comment">//p也是空指针</span></span><br><span class="hljs-function"></span>&#123;<br>p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//在堆上开辟100个字节的空间，将这100个字节的起始地址交给了p，p便不再是空指针，但p只是个形式参数，</span><br><span class="hljs-comment">//出了函数便销毁了，使得malloc开辟的空间再也找不到了，内存泄露了</span><br><span class="hljs-comment">//内存泄露未free释放掉导致strcpy也无法执行，什么都没有</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* str = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">getmemory</span>(str);<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;hello world&quot;</span>);<span class="hljs-comment">//回来后str还是空指针，拷贝不成功</span><br><span class="hljs-built_in">printf</span>(str);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> str是一个变量，str传给getmemory函数，是值传递，<br>所以getmemory函数的形参p是str的一份临时拷贝，在其内部动态申请空间的地址，存放在p中，<br>不会影响外边的str，所以当getmemory返回后，str仍然是个空指针，所以strcpy会失败<br>当getmemory函数返回后，形参p销毁i，使得动态开辟的100个字节存在内存泄露</p></blockquote><p>修改1. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-type">char</span>* p)</span><span class="hljs-comment">//p也是空指针</span></span><br><span class="hljs-function"></span>&#123;<br>p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">return</span> p;<span class="hljs-comment">//p的类型是char*，所以getmemory中接收了malloc开辟的空间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* str = <span class="hljs-literal">NULL</span>;<br>str=<span class="hljs-built_in">getmemory</span>(str);<span class="hljs-comment">//str接收了p里面的地址</span><br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(str);<span class="hljs-comment">//str就是一个字符指针因此str这样是可以用的</span><br><span class="hljs-built_in">free</span>(str);<span class="hljs-comment">//使用完进行释放</span><br>str = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//再将其制成空指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改2.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-type">char</span>** p)</span><span class="hljs-comment">//char**二级指针进行接收</span></span><br><span class="hljs-function"></span>&#123;<br>*p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//p是&amp;str，*p是str，</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* str = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">getmemory</span>(&amp;str);<span class="hljs-comment">//想让他改变这个str，就将str的地址传过去，str是个指针，&amp;str是个二级指针</span><br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">printf</span>(str);<br><span class="hljs-built_in">free</span>(str);<br>str = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例2.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>*<span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//返回栈空间地址的问题，出返回就销毁了，而堆上开辟的空间出函数是不销毁的</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> p[] = <span class="hljs-string">&quot;hello world&quot;</span>;<span class="hljs-comment">//p是一个局部的数组，进入函数生命周期开始，出函数生命周期结束销毁释放，</span><br><span class="hljs-keyword">return</span> p;<span class="hljs-comment">//p也是一个指针，所以返回类型是char*，p返回的是hello world的起始地址</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>str = <span class="hljs-built_in">getmemory</span>();<span class="hljs-comment">//str存的是h首元素地址，接收后那个空间就还给操作系统了</span><br><span class="hljs-built_in">printf</span>(str);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>getmemory函数内部创建的数组是在栈区开辟的<br>出了函数，p数组的空间就返回给了操作系统<br>返回的地址是没有实际意义，如果通过返回的地址，去访问内存就是非法访问内存的<br>char*getmemory(void)&#x2F;&#x2F;返回栈空间地址的问题，出返回就销毁了，而堆上开辟的空间出函数是不销毁的</p></blockquote><blockquote><p>此类问题可以归结为返回栈空间的内容，一律是错误的</p></blockquote><p>同类题如1，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>*<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//同样是在栈区开辟的问题</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span>(&amp;x);<span class="hljs-comment">//返回的是没有意义的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同类题2.</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">int</span>*f2(<span class="hljs-type">void</span>)<br>&#123;<br><span class="hljs-type">int</span>* <span class="hljs-keyword">ptr</span>;//归结为野指针<br>*<span class="hljs-keyword">ptr</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">ptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例3.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getmemory</span><span class="hljs-params">(<span class="hljs-type">char</span>**p, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>*p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* str = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">getmemory</span>(&amp;str, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-built_in">printf</span>(str);<span class="hljs-comment">//用完没有释放掉</span><br><span class="hljs-built_in">free</span>(str);<br>str = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例4.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* str = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-built_in">free</span>(str);<span class="hljs-comment">//改错题应在free后将str置为空指针，而不是将free放到if语句后面</span><br><span class="hljs-keyword">if</span> (str != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-built_in">printf</span>(str);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时介绍一下内存中的空间</p><p><img src="https://img-blog.csdnimg.cn/5111efd59cd540f0b8cc8b7023deab22.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++ r语言 算法 排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言实现动态内存分配2</title>
    <link href="/2021/10/08/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D2/"/>
    <url>/2021/10/08/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="c语言实现动态内存分配——错误开辟"><a href="#c语言实现动态内存分配——错误开辟" class="headerlink" title="c语言实现动态内存分配——错误开辟"></a>c语言实现动态内存分配——错误开辟</h2><p><strong>目录</strong></p><p>动态内存的错误开辟<br>1.对null指针的解引用<br>2.对动态开辟空间的越界访问</p><p>3.使用free释放未动态开辟的空间</p><p>4.使用free释放动态空间的一部分</p><p>5对同一快动态开辟的空间进行多次释放</p><p>6.动态开辟的空间忘记释放- 内存泄露-严重</p><blockquote><p>1.对null指针的解引用</p></blockquote><p> 上代码</p><blockquote><p>malloc在使用时必须要先判断是否为空指针，才能使用，使用完一定要释放</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100000</span>);<span class="hljs-comment">//括号内为字节数</span><br><span class="hljs-comment">//未对malloc函数返回值进行判断是否为空指针，直接进行使用</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>*(p + i) = i;<span class="hljs-comment">//均为空指针</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.对动态开辟空间的越界访问</p></blockquote><blockquote><p> malloc中一个有40个字节的空间</p><p>但循环语句中进行了160个字节超过范围</p><p>越界访问不合理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">if</span> (p = <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//越界访问</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++)<br>&#123;<br>*p++ = i;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>3.使用free释放未动态开辟的空间</p></blockquote><blockquote><p>使用时搞混了，只有malloc,calloc,realloc在堆区开辟的空间才可以用free释放，</p><p>而arr在栈区开辟的非动态空间不可以用free释放</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//在栈区开辟</span><br><span class="hljs-type">int</span>*p = arr;<br><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//使用free释放非动态开辟的空间</span><br>p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>4.使用free释放动态空间的一部分</p></blockquote><blockquote><p>free释放的应从开辟空间起始地址进行释放</p><p>而不能是空间中的地址 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>*p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">if</span> (p = <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>*p++ = i;<span class="hljs-comment">//p最初指向0位置，后指向5位置</span><br>&#125;<br><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//释放了5后面的空间，不符合，可使p回到最初的地址，对其进行free</span><br>p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>5.对同一动态开辟的空间进行多次释放</p></blockquote><blockquote><p>对一个开辟的空间只可以释放一次</p><p>若多次释放</p><p>则应该在每次释放后将p置为空指针 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>*p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//使用....</span><br><span class="hljs-comment">//释放....</span><br><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//</span><br>p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//使用</span><br><span class="hljs-comment">//释放</span><br><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//多次释放不符合，但可以在每次使用完free 后对其制成空指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>6.动态开辟的空间忘记释放- 内存泄露-严重</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//只有p可以找到这个空间，离开函数时，他作为局部变量的生命周期到了，销毁</span><br><span class="hljs-comment">//但是p销毁了，malloc开辟的空间不会销毁，</span><br><span class="hljs-comment">//回收的情况:1.主动释放free</span><br><span class="hljs-comment">//2.程序结束,main函数结束，</span><br><span class="hljs-comment">//malloc</span><br><span class="hljs-keyword">if</span> (p = <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//使用，忘记释放，返回，无人记得这个空间，内存泄露</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-comment">//....</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是动态开辟常见的一些错误</p><p>若想初步了解动态内存开辟的知识，可以翻看本人的</p><p><a href="https://blog.csdn.net/m0_61567378/article/details/120595150" title="c语言中动态内存管理（1）_m0_61567378的博客-CSDN博客">c语言中动态内存管理（1）_m0_61567378的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言 r语言 c++ c# 开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言实现通讯录（动态版）</title>
    <link href="/2021/10/06/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%EF%BC%88%E5%8A%A8%E6%80%81%E7%89%88%EF%BC%89/"/>
    <url>/2021/10/06/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%EF%BC%88%E5%8A%A8%E6%80%81%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>上回我们已经介绍了静态版的通讯录，但这种版本会使内存浪费，不够灵活</p><p>因此我们此次将对其进行优化</p><blockquote><p>.动态增长的版本<br>1-&gt;初始化后能存放3个人的信息<br>2-&gt;当我们空间存放满的时候，我们增加两个信息<br>3.3+2+2….每次都扩容2</p></blockquote><p> contact.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-comment">//结构体在contact和test里面都要用，所以放在这里定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_name 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_sex 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_tele 12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_addr 30</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> default 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> insz 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">peoinfo</span><span class="hljs-comment">//一个人的信息</span><br>&#123;<br><span class="hljs-type">char</span> name[max_name];<span class="hljs-comment">//[]里面的改麻烦，所以在上面定义</span><br><span class="hljs-type">char</span> sex[max_sex];<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">char</span> tele[max_tele];<br><span class="hljs-type">char</span> addr[max_addr];<br><br>&#125;peoinfo;<span class="hljs-comment">//重新起个名字就叫peoinfo</span><br><br><br><span class="hljs-comment">//动态版本</span><br><span class="hljs-comment">//起初3个，放满3个要增容，同时还要添加容量capacity</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">contact</span><span class="hljs-comment">//再重新定义一下，多个人的信息</span><br>&#123;<br>peoinfo *data;<span class="hljs-comment">//指向动态内存申请的空间，原来存放联系人的信息</span><br><span class="hljs-type">int</span> sz;<span class="hljs-comment">//记录当前通讯录中有多少人的信息，即有效信息的个数</span><br><span class="hljs-type">int</span> capacity;<span class="hljs-comment">//记录当前通讯录最大的容量</span><br>&#125;contact;<br><span class="hljs-comment">//初始化通讯录</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initcontact</span><span class="hljs-params">(contact* pc)</span></span>;<br><span class="hljs-comment">//增加联系人的信息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addcontact</span><span class="hljs-params">(contact* pc)</span></span>;<br><span class="hljs-comment">//打印显示联系人的信息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printcontact</span><span class="hljs-params">(<span class="hljs-type">const</span> contact* pc)</span></span>;<br><span class="hljs-comment">//删除联系人的信息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delcontact</span><span class="hljs-params">(contact*pc)</span></span>;<br><span class="hljs-comment">//查找</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchcontact</span><span class="hljs-params">(contact*pc)</span></span>;<br><span class="hljs-comment">//修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifycontact</span><span class="hljs-params">(contact*pc)</span></span>;<br><span class="hljs-comment">//销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroycontact</span><span class="hljs-params">(contact* pc)</span></span>;<br></code></pre></td></tr></table></figure><p>其中最主要的，增加容量，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>动态版本<br><span class="hljs-regexp">//</span>起初<span class="hljs-number">3</span>个，放满<span class="hljs-number">3</span>个要增容，同时还要添加容量capacity<br>typedef struct contact<span class="hljs-regexp">//</span>再重新定义一下，多个人的信息<br>&#123;<br>peoinfo *data;<span class="hljs-regexp">//</span>指向动态内存申请的空间，原来存放联系人的信息<br>int sz;<span class="hljs-regexp">//</span>记录当前通讯录中有多少人的信息，即有效信息的个数<br>int capacity;<span class="hljs-regexp">//</span>记录当前通讯录最大的容量<br>&#125;contact;<br></code></pre></td></tr></table></figure><p>主函数 test.c</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs awk">void menu()<br>&#123;<br>printf(<span class="hljs-string">&quot;******************************\n&quot;</span>);<br>printf(<span class="hljs-string">&quot;***1,add     2,dele***********\n&quot;</span>);<br>printf(<span class="hljs-string">&quot;***3,search  4,modify*********\n&quot;</span>);<br>printf(<span class="hljs-string">&quot;***5,sort    6,print**********\n&quot;</span>);<br>printf(<span class="hljs-string">&quot;************0,exit************\n&quot;</span>);<br>&#125;<br>enum option<span class="hljs-regexp">//</span>使用枚举让case中更加显而易见<br>&#123;<br><span class="hljs-keyword">exit</span>,<br>add,<br>dele,<br>search,<br>modify,<br>sort,<br>print<br>&#125;;<br>int main()<br>&#123;<br><span class="hljs-regexp">//</span>使用增删查改，多样化实现，可以使用菜单<br>int input;<br><span class="hljs-regexp">//</span>创建通讯录<br><span class="hljs-regexp">//</span>peoinfo data[max];<span class="hljs-regexp">//</span>每次使用peoinfo都要加struct比较麻烦<br><span class="hljs-regexp">//i</span>nt sz = <span class="hljs-number">0</span>;可以将两者结合，使用一个结构体变量<br>contact con;<br><span class="hljs-regexp">//</span>初始化通讯录的函数<br><span class="hljs-regexp">//</span> 给data申请一块连续的空间，在堆空间上<br><span class="hljs-regexp">//</span>sz=<span class="hljs-number">0</span>，capacity初始化为当前最大容量<br>initcontact(&amp;con);<span class="hljs-regexp">//</span>会改变应该要传递地址<br><br><span class="hljs-keyword">do</span><br>&#123;<br>menu();<br>printf(<span class="hljs-string">&quot;请选择&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>switch (input)<br>&#123;<br>case add:<br><span class="hljs-regexp">//</span>增加人的信息，总得知道当前通讯录有几个信息，要知道通讯录中当前总共有几个元素<br>addcontact(&amp;con);<span class="hljs-regexp">//</span>会改变con用传地址<br><span class="hljs-keyword">break</span>;<br>case dele:<br>delcontact(&amp;con);<span class="hljs-regexp">//</span>也会改变通讯录，因此传地址<br><span class="hljs-keyword">break</span>;<br>case search:<br>searchcontact(&amp;con);<br><span class="hljs-keyword">break</span>;<br>case modify:<br>modifycontact(&amp;con);<br><span class="hljs-keyword">break</span>;<br>case sort:<br><span class="hljs-keyword">break</span>;<br>case print:<br>printcontact(&amp;con);<span class="hljs-regexp">//</span>把通讯录里面相关信息打印出来不会改变,但是传地址效率更高<br><span class="hljs-keyword">break</span>;<br>case <span class="hljs-keyword">exit</span>:<br>destroycontact(&amp;con);<br>printf(<span class="hljs-string">&quot;退出通讯录&quot;</span>);<span class="hljs-regexp">//</span>离开时要释放空间，销毁通讯录<br><span class="hljs-keyword">break</span>;<br>default;<br>printf(<span class="hljs-string">&quot;选择错误&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (input);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在初始化阶段，进行动态更改，其中只有addcontact，exit，initcontact需要修改，变成动态版本</p></blockquote><p>contact.c</p><blockquote><p>对data进行初始化，将变量均初始化为0，也可以calloc进行</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">void</span> initcontact(contact* pc)<br>&#123;<br>//pc-&gt;sz = <span class="hljs-number">0</span>;<br>memset()内存设置，把<span class="hljs-class"><span class="hljs-keyword">data</span>数组中每一个字节初始化为0</span><br>//memset(pc-&gt;<span class="hljs-class"><span class="hljs-keyword">data</span>, 0, sizeof(<span class="hljs-title">pc</span>-&gt;<span class="hljs-title">data</span>));//<span class="hljs-keyword">data</span>数组名计算的是整个数组的大小</span><br>pc -&gt; <span class="hljs-class"><span class="hljs-keyword">data</span> = (<span class="hljs-title">peoinfo</span>*)malloc(<span class="hljs-title">default</span> * <span class="hljs-title">sizeof</span>(<span class="hljs-title">peoinfo</span>));//也可用calloc直接初始化为0</span><br><span class="hljs-keyword">if</span> (pc-&gt;<span class="hljs-class"><span class="hljs-keyword">data</span> == <span class="hljs-type">NULL</span>)</span><br>&#123;<br>printf(<span class="hljs-string">&quot;错误&quot;</span>);<br>&#125;<br>pc-&gt;sz = <span class="hljs-number">0</span>;<br>pc-&gt;capacity = <span class="hljs-keyword">default</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>增加时要考虑此时的sz是否达到了规定容量，达到就要对其进行增容，进行动态增长</p></blockquote><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xl">void addcontact(contact* pc)<br>&#123;<br><span class="hljs-comment">//考虑增容</span><br><span class="hljs-function"><span class="hljs-title">if</span> (pc-&gt;</span><span class="hljs-function"><span class="hljs-title">sz</span> == pc-&gt;</span>capacity)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">peoinfo</span>* ptr=(peoinfo*)realloc(pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>, (pc-&gt;</span>capacity + insz) * sizeof(peoinfo));<span class="hljs-comment">//增加两个元素新的大小</span><br><span class="hljs-keyword">if</span> (ptr != NULL)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span><span class="hljs-keyword">data</span> = ptr;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>capacity += insz;<br>printf(<span class="hljs-string">&quot;增容成功\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>printf(<span class="hljs-string">&quot;增加失败\n&quot;</span>);<br>return;<br>&#125;<br>&#125;<br><span class="hljs-comment">//增加一个人的信息</span><br><span class="hljs-comment">//把新的元素放到数组下表为sz的位置上去，只是一个元素</span><br>printf(<span class="hljs-string">&quot;请输入一个人的名字&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].<span class="hljs-keyword">name</span>);<br>printf(<span class="hljs-string">&quot;请输入年龄&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%d&quot;, &amp;(pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].age));<br>printf(<span class="hljs-string">&quot;请输入性别&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].sex);<br>printf(<span class="hljs-string">&quot;请输入电话&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].tele);<br>printf(<span class="hljs-string">&quot;请输入地址&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].addr);<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>sz++;<br>printf(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其余都与静态一致</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs xl">void printcontact(const contact* pc)<br>&#123;<br><br><span class="hljs-comment">//有sz个元素</span><br>int i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//打印标题，再打应数据</span><br>printf(<span class="hljs-string">&quot;%-20s %-5s %-5s %-12s %-20s\n&quot;</span>, <span class="hljs-string">&quot;名字&quot;</span>,<span class="hljs-string">&quot;年龄&quot;</span>,<span class="hljs-string">&quot;性别&quot;</span>,<span class="hljs-string">&quot;电话&quot;</span>,<span class="hljs-string">&quot;地址&quot;</span>);<span class="hljs-comment">//左对齐，打印字</span><br><span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; pc-&gt;</span>sz; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%-20s %-5d %-5s %-12s %-20s\n&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].<span class="hljs-keyword">name</span>, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].age, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].sex, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].tele, pc-&gt;</span><span class="hljs-keyword">data</span>[i].addr);<br>&#125;<br>&#125;<br><br>static int findbyname(contact*pc, char <span class="hljs-keyword">name</span>[])<span class="hljs-comment">//不想给别人看到，用来修饰函数，其他源文件用不到</span><br>&#123;<br><span class="hljs-comment">//遍历数组</span><br>int i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; pc-&gt;</span>sz; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span>(strcmp(pc-&gt;</span><span class="hljs-keyword">data</span>[i].<span class="hljs-keyword">name</span>,<span class="hljs-keyword">name</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//说明两个名字相等，即找到了</span><br>return i;<br>&#125;<br>return -<span class="hljs-number">1</span>;<span class="hljs-comment">//找不到的情况</span><br>&#125;<br><br>void delcontact(contact*pc)<br>&#123;<br>char <span class="hljs-keyword">name</span>[max_name];<br><span class="hljs-comment">//通讯录为空不能删除</span><br><span class="hljs-function"><span class="hljs-title">if</span> (pc-&gt;</span>sz == <span class="hljs-number">0</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;通讯录为空，无需删除\n&quot;</span>);<br>return;<span class="hljs-comment">//直接返回</span><br>&#125;<br>printf(<span class="hljs-string">&quot;请输入要删除人的名字&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-keyword">name</span>);<br><span class="hljs-comment">//删除的第一步是查找要删除的人，因此要把查找的功能独立的拎出来写</span><br>int pos=findbyname(pc, <span class="hljs-keyword">name</span>);<span class="hljs-comment">//通过名字查找,sz对应的数大于0，因此当pos=-1时，就没找到</span><br><br><span class="hljs-comment">//告诉有或没有</span><br><span class="hljs-keyword">if</span> (pos == -<span class="hljs-number">1</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;要删除的人不存在&quot;</span>);<br>return;<span class="hljs-comment">//不能继续往下走</span><br>&#125;<br><span class="hljs-comment">//存在即删除123456</span><br><span class="hljs-comment">//若要把3的位置删掉，只要把后面的每个元素都往前挪一个位置即可，3便不见了成12456，把下表为i+1的元素赋给i，后面变依次i++；</span><br>int i;<br><span class="hljs-function"><span class="hljs-title">for</span> (i = pos; i &lt; pc-&gt;</span>sz-<span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i] = pc-&gt;</span><span class="hljs-keyword">data</span>[i + <span class="hljs-number">1</span>];<span class="hljs-comment">//把i的位置变成i+1，但到sz时，后面是被一个空白所覆盖，因此没有必要，sz-1即可</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>sz--;<span class="hljs-comment">//删除前几个元素，也剪掉也没有了</span><br>printf(<span class="hljs-string">&quot;删除成功&quot;</span>);<br><br>&#125;<br><span class="hljs-comment">//查找</span><br>void searchcontact(contact*pc)<br>&#123;<br>char <span class="hljs-keyword">name</span>[max_name];<br>printf(<span class="hljs-string">&quot;请输入要查找人的名字&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-keyword">name</span>);<br>int pos = findbyname(pc, <span class="hljs-keyword">name</span>);<span class="hljs-comment">//通过名字查找,sz对应的数大于0，因此当pos=-1时，就没找到</span><br><br><span class="hljs-comment">//告诉有或没有</span><br><span class="hljs-keyword">if</span> (pos == -<span class="hljs-number">1</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;要查找的人不存在&quot;</span>);<br>return;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%-20s %-5d %-5s %-12s %-20s\n&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].<span class="hljs-keyword">name</span>, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].age, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].sex, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].tele, pc-&gt;</span><span class="hljs-keyword">data</span>[pos].addr);<br>&#125;<br><br>&#125;<br><br>void modifycontact(contact*pc)<br>&#123;<br><span class="hljs-comment">//首先是查找</span><br>char <span class="hljs-keyword">name</span>[max_name];<br>printf(<span class="hljs-string">&quot;请输入要修改人的名字&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-keyword">name</span>);<br>int pos = findbyname(pc, <span class="hljs-keyword">name</span>);<span class="hljs-comment">//通过名字查找,sz对应的数大于0，因此当pos=-1时，就没找到</span><br><br><span class="hljs-comment">//告诉有或没有</span><br><span class="hljs-keyword">if</span> (pos == -<span class="hljs-number">1</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;要修改的人不存在&quot;</span>); <br>return;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>printf(<span class="hljs-string">&quot;请输入一个人的名字&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-keyword">data</span>[pos].<span class="hljs-keyword">name</span>);<br>printf(<span class="hljs-string">&quot;请输入年龄&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%d&quot;, &amp;(pc-&gt;</span><span class="hljs-keyword">data</span>[pos].age));<br>printf(<span class="hljs-string">&quot;请输入性别&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-keyword">data</span>[pos].sex);<br>printf(<span class="hljs-string">&quot;请输入电话&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-keyword">data</span>[pos].tele);<br>printf(<span class="hljs-string">&quot;请输入地址&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-keyword">data</span>[pos].addr);<br><br>printf(<span class="hljs-string">&quot;修改成功&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中在退出时要对重新进行销毁</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xl">void destroycontact(contact* pc)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">free</span>(pc-&gt;</span><span class="hljs-keyword">data</span>);<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span><span class="hljs-keyword">data</span> = NULL;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>sz = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>capacity = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想了解动态内存，可查看本人的<a href="https://blog.csdn.net/m0_61567378/article/details/120595150" title="c语言中动态内存管理（1）_m0_61567378的博客-CSDN博客">c语言中动态内存管理（1）_m0_61567378的博客-CSDN博客</a></p><p>静态版通讯录</p><p><a href="https://blog.csdn.net/m0_61567378/article/details/120592969" title="c语言实现通讯录（静态）_m0_61567378的博客-CSDN博客">c语言实现通讯录（静态）_m0_61567378的博客-CSDN博客</a></p><p>本人会持续对动态内存进行更新</p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言中动态内存管理（1）</title>
    <link href="/2021/10/03/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/"/>
    <url>/2021/10/03/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>1.为什么会存在动态内存分配</p><p>如</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int arr[<span class="hljs-number">1000</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>1.像这样建立一个数组，一开始建立了这么大一个空间，可能会造成空间浪费，无法一次性用完</p><p>2.静态空间开辟的大小比较固定</p><p>3.对于空间的使用，只有我们在运行程序的时候才知道</p><p>-&gt;因此我们就需要动态内存开辟了</p></blockquote><p>2. 要学习动态内存开辟，就要了解内存中的三个区</p><p><img src="https://img-blog.csdnimg.cn/2e04a160b34f496b8b4abe2ecbfa6723.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>这些函数都包含在：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p> 3.（1）malloc的使用</p></blockquote><p>malloc函数的定义</p><blockquote><p>void* malloc(size_t size)</p></blockquote><blockquote><p>返回一个无类型的指针，括号中包含的是开辟的字节数</p><p>开辟不成功会返回一个空指针</p></blockquote><p>上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//int arr[10];</span><br><span class="hljs-type">int</span>*p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//开辟10个整形空间,有可能会开辟失败</span><br><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc error&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//可以使用</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>*(p + i)=i;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p[i]);<br>&#125;<br><span class="hljs-comment">//回收空间用free</span><br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//用完把他做成空指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>3.（2）.calloc的使用</p></blockquote><blockquote><p>calloc函数的定义</p><p>void* calloc(size_t num,size_t size)</p></blockquote><blockquote><p>num是开辟的是元素的个数</p><p>size为每个元素的长度，单位是字节，1个元素多大</p><p>会将里面的元素都初始化为0</p></blockquote><p>上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*int *p = (int *)malloc(40);*/</span><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//会初始化为0，但参数不一样，其他都一样</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *(p + i));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>3.3realloc的使用</p></blockquote><blockquote><p>realloc函数的定义</p><p>void*realloc(void* ptr,size_t size)</p></blockquote><blockquote><p>p要增加的地址，逗号后面是新的大小，而非增加的大小，返回的是void*，指向的是重新调整之后的内存块<br>ptr为要调整的内存地址<br>size为调整之后的大小</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*int *p = (int *)malloc(40);*/</span><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//会初始化为0，但参数不一样，其他都一样</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *(p + i));<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (ptr != <span class="hljs-literal">NULL</span>)<br><br><br>&#123;<br>p = ptr;<br>&#125;<br><br><span class="hljs-built_in">free</span>(p);<br>p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>realloc实现会出现两种情况</p><p><img src="https://img-blog.csdnimg.cn/36e62c3c88ea447d90d7a62c9debbd77.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGf5oy9fg==,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言 c#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言实现通讯录（静态）</title>
    <link href="/2021/10/03/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89/"/>
    <url>/2021/10/03/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%AE%AF%E5%BD%95%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="c语言实现通讯录（静态）"><a href="#c语言实现通讯录（静态）" class="headerlink" title="c语言实现通讯录（静态）"></a>c语言实现通讯录（静态）</h2><p>本人第一次写博客，如有不好的地方，请见谅</p><p><strong>目录</strong></p><p>实现通讯录，</p><p>1.存放1000人的信息<br>2, 每个人的信息包含（名字，年龄，性别，电话，地址）,结构体<br>3，增加人的信息<br>4，删除人的信息<br>5，修改人的信息<br>6，查找指定人的信息<br>7，排序人的信息</p><p> 后续会发布动态版的通讯录</p><blockquote><p>开始实现通讯录</p></blockquote><p>首先要先初始化信息，可在头文件里面实现</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">typedef struct peoinfo<span class="hljs-comment">//一个人的信息</span><br>&#123;<br>char name<span class="hljs-selector-attr">[max_name]</span>;<span class="hljs-comment">//[]里面的改麻烦，所以在上面定义</span><br>char sex<span class="hljs-selector-attr">[max_sex]</span>;<br>int age;<br>char tele<span class="hljs-selector-attr">[max_tele]</span>;<br>char addr<span class="hljs-selector-attr">[max_addr]</span>;<br><br>&#125;peoinfo;<span class="hljs-comment">//重新起个名字就叫peoinfo</span><br></code></pre></td></tr></table></figure><p>同时在上方定义一些变量，以便后续修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_name 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_sex 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_tele 12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_addr 30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max 1000</span><br></code></pre></td></tr></table></figure><blockquote><p>菜单的实现，与用户进行交互</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;******************************\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;***1,add     2,dele***********\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;***3,search  4,modify*********\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;***5,sort    6,print**********\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;************0,exit************\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可使用枚举对这些量进行实现，在case语句中显得更加直观</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">enum option<span class="hljs-regexp">//</span>使用枚举让case中更加显而易见<br>&#123;<br><span class="hljs-keyword">exit</span>,<br>add,<br>dele,<br>search,<br>modify,<br>sort,<br>print<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>主函数</strong></p><blockquote><p>选择为0，会打印退出通讯录</p><p>选择在1-6中会调用相关的函数，并对函数进行实现</p><p>若选择不为0-6范围内，则会提示选择错误，请重新输入一个数</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs awk">int main()<br>&#123;<br><span class="hljs-regexp">//</span>使用增删查改，多样化实现，可以使用菜单<br>int input;<br><span class="hljs-regexp">//</span>创建通讯录<br><span class="hljs-regexp">//</span>peoinfo data[max];<span class="hljs-regexp">//</span>每次使用peoinfo都要加struct比较麻烦<br><span class="hljs-regexp">//i</span>nt sz = <span class="hljs-number">0</span>;可以将两者结合，使用一个结构体变量<br>contact con;<br><span class="hljs-regexp">//</span>初始化通讯录的函数<br>initcontact(&amp;con);<span class="hljs-regexp">//</span>会改变应该要传递地址<br><br><span class="hljs-keyword">do</span><br>&#123;<br>menu();<br>printf(<span class="hljs-string">&quot;请选择&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>switch (input)<br>&#123;<br>case add:<br><span class="hljs-regexp">//</span>增加人的信息，总得知道当前通讯录有几个信息，要知道通讯录中当前总共有几个元素<br>addcontact(&amp;con);<span class="hljs-regexp">//</span>会改变con用传地址<br><span class="hljs-keyword">break</span>;<br>case dele:<br>delcontact(&amp;con);<span class="hljs-regexp">//</span>也会改变通讯录，因此传地址<br><span class="hljs-keyword">break</span>;<br>case search:<br>searchcontact(&amp;con);<br><span class="hljs-keyword">break</span>;<br>case modify:<br>modifycontact(&amp;con);<br><span class="hljs-keyword">break</span>;<br>case sort:<br><span class="hljs-keyword">break</span>;<br>case print:<br>printcontact(&amp;con);<span class="hljs-regexp">//</span>把通讯录里面相关信息打印出来不会改变,但是传地址效率更高<br><span class="hljs-keyword">break</span>;<br>case <span class="hljs-keyword">exit</span>:<br>printf(<span class="hljs-string">&quot;退出通讯录&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>default:<br>printf(<span class="hljs-string">&quot;选择错误&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (input);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对其中进行实现</p><p>1.实现通讯录多个人的信息，放在contact.h里面</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">contact</span><span class="hljs-comment">//再重新定义一下，多个人的信息</span><br>&#123;<br>peoinfo data[max];<span class="hljs-comment">//可以存放添加进来的人的信息</span><br><span class="hljs-type">int</span> sz;<span class="hljs-comment">//记录当前通讯录中有多少人的信息，即有效信息的个数</span><br>&#125;contact;<br></code></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">contact.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>均在这里面对函数进行实现</p><p>2.初始化通讯录</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">void initcontact(contact* pc)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>sz = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//memset()内存设置，把data数组中每一个字节初始化为0</span><br><span class="hljs-function"><span class="hljs-title">memset</span>(pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>, 0, sizeof(pc-&gt;</span><span class="hljs-keyword">data</span>));<span class="hljs-comment">//data数组名计算的是整个数组的大小</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3.增加通讯录人的信息</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xl">void addcontact(contact* pc)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (pc-&gt;</span>sz == max)<br>&#123;<br>printf(<span class="hljs-string">&quot;通讯录已满，无法添加&quot;</span>);<br>return;<span class="hljs-comment">//void无返回值，但是又要结束这个函数，写个return即可</span><br>&#125;<br><span class="hljs-comment">//增加一个人的信息</span><br><span class="hljs-comment">//把新的元素放到数组下表为sz的位置上去，只是一个元素</span><br>printf(<span class="hljs-string">&quot;请输入一个人的名字&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].<span class="hljs-keyword">name</span>);<br>printf(<span class="hljs-string">&quot;请输入年龄&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%d&quot;, &amp;(pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].age));<br>printf(<span class="hljs-string">&quot;请输入性别&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].sex);<br>printf(<span class="hljs-string">&quot;请输入电话&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].tele);<br>printf(<span class="hljs-string">&quot;请输入地址&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">scanf</span>(&quot;%s&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pc-&gt;</span>sz].addr);<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>sz++;<br>printf(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.打印人的信息</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xl">void printcontact(const contact* pc)<br>&#123;<br><br><span class="hljs-comment">//有sz个元素</span><br>int i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//打印标题，再打应数据</span><br>printf(<span class="hljs-string">&quot;%-20s %-5s %-5s %-12s %-20s\n&quot;</span>, <span class="hljs-string">&quot;名字&quot;</span>,<span class="hljs-string">&quot;年龄&quot;</span>,<span class="hljs-string">&quot;性别&quot;</span>,<span class="hljs-string">&quot;电话&quot;</span>,<span class="hljs-string">&quot;地址&quot;</span>);<span class="hljs-comment">//左对齐，打印字</span><br><span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; pc-&gt;</span>sz; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%-20s %-5d %-5s %-12s %-20s\n&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].<span class="hljs-keyword">name</span>, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].age, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].sex, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i].tele, pc-&gt;</span><span class="hljs-keyword">data</span>[i].addr);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.删除人的信息</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int findbyname(contact*pc, char <span class="hljs-keyword">name</span>[])<span class="hljs-comment">//不想给别人看到，用来修饰函数，其他源文件用不到</span><br>&#123;<br><span class="hljs-comment">//遍历数组</span><br>int i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; pc-&gt;</span>sz; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span>(strcmp(pc-&gt;</span><span class="hljs-keyword">data</span>[i].<span class="hljs-keyword">name</span>,<span class="hljs-keyword">name</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//说明两个名字相等，即找到了</span><br>return i;<br>&#125;<br>return -<span class="hljs-number">1</span>;<span class="hljs-comment">//找不到的情况</span><br>&#125;<br><br>void delcontact(contact*pc)<br>&#123;<br>char <span class="hljs-keyword">name</span>[max_name];<br><span class="hljs-comment">//通讯录为空不能删除</span><br><span class="hljs-function"><span class="hljs-title">if</span> (pc-&gt;</span>sz == <span class="hljs-number">0</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;通讯录为空，无需删除\n&quot;</span>);<br>return;<span class="hljs-comment">//直接返回</span><br>&#125;<br>printf(<span class="hljs-string">&quot;请输入要删除人的名字&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-keyword">name</span>);<br><span class="hljs-comment">//删除的第一步是查找要删除的人，因此要把查找的功能独立的拎出来写</span><br>int pos=findbyname(pc, <span class="hljs-keyword">name</span>);<span class="hljs-comment">//通过名字查找,sz对应的数大于0，因此当pos=-1时，就没找到</span><br><br><span class="hljs-comment">//告诉有或没有</span><br><span class="hljs-keyword">if</span> (pos == -<span class="hljs-number">1</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;要删除的人不存在&quot;</span>);<br>return;<span class="hljs-comment">//不能继续往下走</span><br>&#125;<br><span class="hljs-comment">//存在即删除123456</span><br><span class="hljs-comment">//若要把3的位置删掉，只要把后面的每个元素都往前挪一个位置即可，3便不见了成12456，把下表为i+1的元素赋给i，后面变依次i++；</span><br>int i;<br><span class="hljs-function"><span class="hljs-title">for</span> (i = pos; i &lt; pc-&gt;</span>sz-<span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[i] = pc-&gt;</span><span class="hljs-keyword">data</span>[i + <span class="hljs-number">1</span>];<span class="hljs-comment">//把i的位置变成i+1，但到sz时，后面是被一个空白所覆盖，因此没有必要，sz-1即可</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">pc</span>-&gt;</span>sz--;<span class="hljs-comment">//删除前几个元素，也剪掉也没有了</span><br>printf(<span class="hljs-string">&quot;删除成功&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>5.查找人的信息</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">void searchcontact(contact*pc)<br>&#123;<br>char <span class="hljs-keyword">name</span>[max_name];<br>printf(<span class="hljs-string">&quot;请输入要查找人的名字&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-keyword">name</span>);<br>int pos = findbyname(pc, <span class="hljs-keyword">name</span>);<span class="hljs-comment">//通过名字查找,sz对应的数大于0，因此当pos=-1时，就没找到</span><br><br><span class="hljs-comment">//告诉有或没有</span><br><span class="hljs-keyword">if</span> (pos == -<span class="hljs-number">1</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;要查找的人不存在&quot;</span>);<br>return;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%-20s %-5d %-5s %-12s %-20s\n&quot;, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].<span class="hljs-keyword">name</span>, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].age, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].sex, pc-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[pos].tele, pc-&gt;</span><span class="hljs-keyword">data</span>[pos].addr);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>6.修改人的信息</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs perl">void modifycontact(contact*pc)<br>&#123;<br><span class="hljs-regexp">//</span>首先是查找<br>char name[max_name];<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;请输入要修改人的名字&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, name);<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span> = findbyname(pc, name);<span class="hljs-regexp">//</span>通过名字查找,sz对应的数大于<span class="hljs-number">0</span>，因此当<span class="hljs-keyword">pos</span>=-<span class="hljs-number">1</span>时，就没找到<br><br>//告诉有或没有<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">pos</span> == -<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;要修改的人不存在&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;请输入一个人的名字&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, pc-&gt;data[<span class="hljs-keyword">pos</span>].name);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;请输入年龄&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(pc-&gt;data[<span class="hljs-keyword">pos</span>].age));<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;请输入性别&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, pc-&gt;data[<span class="hljs-keyword">pos</span>].sex);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;请输入电话&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, pc-&gt;data[<span class="hljs-keyword">pos</span>].tele);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;请输入地址&quot;</span>);<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>, pc-&gt;data[<span class="hljs-keyword">pos</span>].addr);<br><br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;修改成功&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>r语言 c语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
